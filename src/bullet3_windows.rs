/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const b3Vector3DataName: &'static [u8; 19usize] = b"b3Vector3FloatData\0";
pub const b3Point2PointConstraintDataName: &'static [u8; 33usize] =
    b"b3Point2PointConstraintFloatData\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std_conditional_type<_Ty2> = _Ty2;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
    pub _base: std_false_type,
}
pub type std__Disjunction_t = std_disjunction;
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_Statetype> {
    pub _Myoff: std_streamoff,
    pub _Fpos: fpos_t,
    pub _Mystate: _Statetype,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Statetype>>,
}
pub type std_streampos = std_fpos<_Mbstatet>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Char_traits {
    pub _address: u8,
}
pub type std__Char_traits_char_type<_Elem> = _Elem;
pub type std__Char_traits_int_type<_Int_type> = _Int_type;
pub type std__Char_traits_pos_type = std_streampos;
pub type std__Char_traits_off_type = std_streamoff;
pub type std__Char_traits_state_type = _Mbstatet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Container_base0 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Iterator_base0 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Container_proxy {
    pub _Mycont: *const std__Container_base12,
    pub _Myfirstiter: *mut std__Iterator_base12,
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Container_base12 {
    pub _Myproxy: *mut std__Container_proxy,
}
extern "C" {
    #[link_name = "\u{1}?_Orphan_all@_Container_base12@std@@QEAAXXZ"]
    pub fn std__Container_base12__Orphan_all(this: *mut std__Container_base12);
}
extern "C" {
    #[link_name = "\u{1}?_Swap_all@_Container_base12@std@@QEAAXAEAU12@@Z"]
    pub fn std__Container_base12__Swap_all(
        this: *mut std__Container_base12,
        arg1: *mut std__Container_base12,
    );
}
impl std__Container_base12 {
    #[inline]
    pub unsafe fn _Orphan_all(&mut self) {
        std__Container_base12__Orphan_all(self)
    }
    #[inline]
    pub unsafe fn _Swap_all(&mut self, arg1: *mut std__Container_base12) {
        std__Container_base12__Swap_all(self, arg1)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Iterator_base12 {
    pub _Myproxy: *mut std__Container_proxy,
    pub _Mynextiter: *mut std__Iterator_base12,
}
pub type std__Container_base = std__Container_base0;
pub type std__Iterator_base = std__Iterator_base0;
pub type std__Compressed_pair__Mybase<_Ty1> = _Ty1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Iterator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_RanIt> {
    pub current: _RanIt,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RanIt>>,
}
pub type std_reverse_iterator_iterator_category = std_iterator_traits;
pub type std_reverse_iterator_value_type = std_iterator_traits;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_RanIt> = _RanIt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std__Rebind_alloc_t = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__Not_user_specialized = ::std::os::raw::c_void;
pub type std_allocator_value_type<_Ty> = _Ty;
pub type std_allocator_pointer<_Ty> = *mut _Ty;
pub type std_allocator_const_pointer<_Ty> = *const _Ty;
pub type std_allocator_reference<_Ty> = *mut _Ty;
pub type std_allocator_const_reference<_Ty> = *const _Ty;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
pub struct std__String_const_iterator {
    pub _Ptr: std__String_const_iterator_pointer,
}
pub type std__String_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_const_iterator_value_type = [u8; 0usize];
pub type std__String_const_iterator_difference_type = [u8; 0usize];
pub type std__String_const_iterator_pointer = [u8; 0usize];
pub type std__String_const_iterator_reference = *const std__String_const_iterator_value_type;
pub type std__String_const_iterator__Unchecked_type = std__String_const_iterator_pointer;
#[repr(C)]
pub struct std__String_iterator {
    pub _base: std__String_const_iterator,
}
pub type std__String_iterator__Mybase = std__String_const_iterator;
pub type std__String_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_iterator_value_type = [u8; 0usize];
pub type std__String_iterator_difference_type = [u8; 0usize];
pub type std__String_iterator_pointer = [u8; 0usize];
pub type std__String_iterator_reference = *mut std__String_iterator_value_type;
pub type std__String_iterator__Unchecked_type = std__String_iterator_pointer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__String_base_types {
    pub _address: u8,
}
pub type std__String_base_types__Alty = std__Rebind_alloc_t;
pub type std__String_base_types__Alty_traits = std_allocator_traits;
pub type std__String_base_types__Val_types = std_conditional_t;
#[repr(C)]
pub struct std__String_val {
    pub _Bx: std__String_val__Bxty,
    pub _Mysize: std__String_val_size_type,
    pub _Myres: std__String_val_size_type,
}
pub type std__String_val_value_type = [u8; 0usize];
pub type std__String_val_size_type = [u8; 0usize];
pub type std__String_val_difference_type = [u8; 0usize];
pub type std__String_val_pointer = [u8; 0usize];
pub type std__String_val_const_pointer = [u8; 0usize];
pub type std__String_val_reference = *mut std__String_val_value_type;
pub type std__String_val_const_reference = *const std__String_val_value_type;
pub const std__String_val__BUF_SIZE: std__String_val__bindgen_ty_1 = 0;
pub type std__String_val__bindgen_ty_1 = i32;
pub const std__String_val__ALLOC_MASK: std__String_val__bindgen_ty_2 = 0;
pub type std__String_val__bindgen_ty_2 = i32;
#[repr(C)]
pub struct std__String_val__Bxty {
    pub _Buf: __BindgenUnionField<*mut std__String_val_value_type>,
    pub _Ptr: __BindgenUnionField<std__String_val_pointer>,
    pub _Alias: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct std__String_alloc {
    pub _Mypair: u8,
}
pub type std__String_alloc__Alty = [u8; 0usize];
pub type std__String_alloc__Alty_traits = [u8; 0usize];
pub type std__String_alloc__Alproxy = std__Rebind_alloc_t;
pub type std__String_alloc__Alproxy_traits = std_allocator_traits;
pub type std__String_alloc__Val_types = [u8; 0usize];
pub type std__String_alloc__Mydata_t = std__String_val;
pub type std__String_alloc__Bxty = [u8; 0usize];
pub type std__String_alloc_value_type = [u8; 0usize];
pub type std__String_alloc_size_type = [u8; 0usize];
pub type std__String_alloc_difference_type = [u8; 0usize];
pub type std__String_alloc_pointer = [u8; 0usize];
pub type std__String_alloc_const_pointer = [u8; 0usize];
pub type std__String_alloc_reference = *mut std__String_alloc_value_type;
pub type std__String_alloc_const_reference = *const std__String_alloc_value_type;
pub type std__String_alloc_iterator = std__String_iterator;
pub type std__String_alloc_const_iterator = std__String_const_iterator;
pub const std__String_alloc__BUF_SIZE: std__String_alloc__bindgen_ty_1 = 0;
pub type std__String_alloc__bindgen_ty_1 = i32;
pub const std__String_alloc__ALLOC_MASK: std__String_alloc__bindgen_ty_2 = 0;
pub type std__String_alloc__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_string {
    pub _base: std__String_alloc,
}
pub type std_basic_string__Mybase = std__String_alloc;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_allocator_type<_Alloc> = _Alloc;
pub type std_basic_string__Alty = std_basic_string__Mybase;
pub type std_basic_string__Alty_traits = std_basic_string__Mybase;
pub type std_basic_string__Mydata_t = std_basic_string__Mybase;
pub type std_basic_string_value_type = std_basic_string__Mybase;
pub type std_basic_string_size_type = std_basic_string__Mybase;
pub type std_basic_string_difference_type = std_basic_string__Mybase;
pub type std_basic_string_pointer = std_basic_string__Mybase;
pub type std_basic_string_const_pointer = std_basic_string__Mybase;
pub type std_basic_string_reference = *mut std_basic_string_value_type;
pub type std_basic_string_const_reference = *const std_basic_string_value_type;
pub type std_basic_string_iterator = std_basic_string__Mybase;
pub type std_basic_string_const_iterator = std_basic_string__Mybase;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string__Use_memcpy_move = std_bool_constant;
pub type std_basic_string__Is_elem_cptr = std__Disjunction_t;
pub type std_string = std_basic_string;
extern "C" {
    pub fn b3EnterProfileZone(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn b3LeaveProfileZone();
}
#[repr(C)]
#[derive(Debug)]
pub struct b3ProfileZone {
    pub _address: u8,
}
pub type b3PrintfFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3WarningMessageFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3ErrorMessageFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3EnterProfileZoneFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3LeaveProfileZoneFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    /// The developer can route b3Printf output using their own implementation
    pub fn b3SetCustomPrintfFunc(printfFunc: b3PrintfFunc);
}
extern "C" {
    pub fn b3SetCustomWarningMessageFunc(warningMsgFunc: b3WarningMessageFunc);
}
extern "C" {
    pub fn b3SetCustomErrorMessageFunc(errorMsgFunc: b3ErrorMessageFunc);
}
extern "C" {
    /// Set custom profile zone functions (zones can be nested)
    pub fn b3SetCustomEnterProfileZoneFunc(enterFunc: b3EnterProfileZoneFunc);
}
extern "C" {
    pub fn b3SetCustomLeaveProfileZoneFunc(leaveFunc: b3LeaveProfileZoneFunc);
}
extern "C" {
    /// Don't use those internal functions directly, use the b3Printf or b3SetCustomPrintfFunc instead (or warning/error version)
    pub fn b3OutputPrintfVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn b3OutputWarningMessageVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn b3OutputErrorMessageVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
pub type __m128 = [f32; 4usize];
pub type b3Scalar = f32;
pub type b3SimdFloat4 = __m128;
/// rudimentary class to provide type info
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedObject {
    pub m_objectType: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?b3AlignedAllocInternal@@YAPEAX_KH@Z"]
    pub fn b3AlignedAllocInternal(
        size: usize,
        alignment: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?b3AlignedFreeInternal@@YAXPEAX@Z"]
    pub fn b3AlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
}
pub type b3AlignedAllocFunc = ::std::option::Option<
    unsafe extern "C" fn(size: usize, alignment: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void,
>;
pub type b3AlignedFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
pub type b3AllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type b3FreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// The developer can let all Bullet memory allocations go through a custom memory allocator, using b3AlignedAllocSetCustom
    #[link_name = "\u{1}?b3AlignedAllocSetCustom@@YAXP6APEAX_K@ZP6AXPEAX@Z@Z"]
    pub fn b3AlignedAllocSetCustom(allocFunc: b3AllocFunc, freeFunc: b3FreeFunc);
}
extern "C" {
    /// If the developer has already an custom aligned allocator, then b3AlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
    #[link_name = "\u{1}?b3AlignedAllocSetCustomAligned@@YAXP6APEAX_KH@ZP6AXPEAX@Z@Z"]
    pub fn b3AlignedAllocSetCustomAligned(
        allocFunc: b3AlignedAllocFunc,
        freeFunc: b3AlignedFreeFunc,
    );
}
pub type b3AlignedAllocator_self_type = u8;
pub type b3AlignedAllocator_const_pointer<T> = *const T;
pub type b3AlignedAllocator_const_reference<T> = *const T;
pub type b3AlignedAllocator_pointer<T> = *mut T;
pub type b3AlignedAllocator_reference<T> = *mut T;
pub type b3AlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedAllocator_rebind {
    pub _address: u8,
}
pub type b3AlignedAllocator_rebind_other = u8;
/// The b3AlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct b3AlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedObjectArray_less {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}b3vMzeroMask"]
    pub static mut b3vMzeroMask: __m128;
}
extern "C" {
    #[link_name = "\u{1}b3v1110"]
    pub static mut b3v1110: __m128;
}
extern "C" {
    #[link_name = "\u{1}b3vHalf"]
    pub static mut b3vHalf: __m128;
}
extern "C" {
    #[link_name = "\u{1}b3v1_5"]
    pub static mut b3v1_5: __m128;
}
/// @brief b3Vector3 can be used to represent 3D points and vectors.
/// It has an un-used w component to suit 16-byte alignment when b3Vector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
/// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Vector3 {
    pub __bindgen_anon_1: b3Vector3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Vector3__bindgen_ty_1 {
    pub mVec128: b3SimdFloat4,
    pub m_floats: [f32; 4usize],
    pub __bindgen_anon_1: b3Vector3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Vector4 {
    pub _base: b3Vector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3FloatData {
    pub m_floats: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3DoubleData {
    pub m_floats: [f64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3QuadWord {
    pub __bindgen_anon_1: b3QuadWord__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3QuadWord__bindgen_ty_1 {
    pub mVec128: b3SimdFloat4,
    pub m_floats: [b3Scalar; 4usize],
    pub __bindgen_anon_1: b3QuadWord__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3QuadWord__bindgen_ty_1__bindgen_ty_1 {
    pub x: b3Scalar,
    pub y: b3Scalar,
    pub z: b3Scalar,
    pub w: b3Scalar,
}
extern "C" {
    #[link_name = "\u{1}b3vOnes"]
    pub static mut b3vOnes: __m128;
}
extern "C" {
    #[link_name = "\u{1}b3vQInv"]
    pub static mut b3vQInv: b3SimdFloat4;
}
extern "C" {
    #[link_name = "\u{1}b3vPPPM"]
    pub static mut b3vPPPM: b3SimdFloat4;
}
/// @brief The b3Quaternion implements quaternion to perform linear algebra rotations in combination with b3Matrix3x3, b3Vector3 and b3Transform.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Quaternion {
    pub _base: b3QuadWord,
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    #[link_name = "\u{1}b3vMPPP"]
    pub static mut b3vMPPP: __m128;
}
extern "C" {
    #[link_name = "\u{1}b3v1000"]
    pub static mut b3v1000: b3SimdFloat4;
}
extern "C" {
    #[link_name = "\u{1}b3v0100"]
    pub static mut b3v0100: b3SimdFloat4;
}
extern "C" {
    #[link_name = "\u{1}b3v0010"]
    pub static mut b3v0010: b3SimdFloat4;
}
/// @brief The b3Matrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with b3Quaternion, b3Transform and b3Vector3.
/// Make sure to only include a pure orthogonal matrix without scaling.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Matrix3x3 {
    /// Data storage for the matrix, each vector is a row of the matrix
    pub m_el: [b3Vector3; 3usize],
}
extern "C" {
    /// @brief Return the determinant of the matrix
    #[link_name = "\u{1}?determinant@b3Matrix3x3@@QEBAMXZ"]
    pub fn b3Matrix3x3_determinant(this: *const b3Matrix3x3) -> b3Scalar;
}
extern "C" {
    /// @brief Return the adjoint of the matrix
    #[link_name = "\u{1}?adjoint@b3Matrix3x3@@QEBA?AV1@XZ"]
    pub fn b3Matrix3x3_adjoint(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the matrix with all values non negative
    #[link_name = "\u{1}?absolute@b3Matrix3x3@@QEBA?AV1@XZ"]
    pub fn b3Matrix3x3_absolute(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the transpose of the matrix
    #[link_name = "\u{1}?transpose@b3Matrix3x3@@QEBA?AV1@XZ"]
    pub fn b3Matrix3x3_transpose(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the inverse of the matrix
    #[link_name = "\u{1}?inverse@b3Matrix3x3@@QEBA?AV1@XZ"]
    pub fn b3Matrix3x3_inverse(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?transposeTimes@b3Matrix3x3@@QEBA?AV1@AEBV1@@Z"]
    pub fn b3Matrix3x3_transposeTimes(
        this: *const b3Matrix3x3,
        m: *const b3Matrix3x3,
    ) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?timesTranspose@b3Matrix3x3@@QEBA?AV1@AEBV1@@Z"]
    pub fn b3Matrix3x3_timesTranspose(
        this: *const b3Matrix3x3,
        m: *const b3Matrix3x3,
    ) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?serialize@b3Matrix3x3@@QEBAXAEAUb3Matrix3x3FloatData@@@Z"]
    pub fn b3Matrix3x3_serialize(this: *const b3Matrix3x3, dataOut: *mut b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}?serializeFloat@b3Matrix3x3@@QEBAXAEAUb3Matrix3x3FloatData@@@Z"]
    pub fn b3Matrix3x3_serializeFloat(this: *const b3Matrix3x3, dataOut: *mut b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3FloatData@@@Z"]
    pub fn b3Matrix3x3_deSerialize(this: *mut b3Matrix3x3, dataIn: *const b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerializeFloat@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3FloatData@@@Z"]
    pub fn b3Matrix3x3_deSerializeFloat(
        this: *mut b3Matrix3x3,
        dataIn: *const b3Matrix3x3FloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerializeDouble@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3DoubleData@@@Z"]
    pub fn b3Matrix3x3_deSerializeDouble(
        this: *mut b3Matrix3x3,
        dataIn: *const b3Matrix3x3DoubleData,
    );
}
impl b3Matrix3x3 {
    #[inline]
    pub unsafe fn determinant(&self) -> b3Scalar {
        b3Matrix3x3_determinant(self)
    }
    #[inline]
    pub unsafe fn adjoint(&self) -> b3Matrix3x3 {
        b3Matrix3x3_adjoint(self)
    }
    #[inline]
    pub unsafe fn absolute(&self) -> b3Matrix3x3 {
        b3Matrix3x3_absolute(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> b3Matrix3x3 {
        b3Matrix3x3_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> b3Matrix3x3 {
        b3Matrix3x3_inverse(self)
    }
    #[inline]
    pub unsafe fn transposeTimes(&self, m: *const b3Matrix3x3) -> b3Matrix3x3 {
        b3Matrix3x3_transposeTimes(self, m)
    }
    #[inline]
    pub unsafe fn timesTranspose(&self, m: *const b3Matrix3x3) -> b3Matrix3x3 {
        b3Matrix3x3_timesTranspose(self, m)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut b3Matrix3x3FloatData) {
        b3Matrix3x3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut b3Matrix3x3FloatData) {
        b3Matrix3x3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const b3Matrix3x3FloatData) {
        b3Matrix3x3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const b3Matrix3x3FloatData) {
        b3Matrix3x3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const b3Matrix3x3DoubleData) {
        b3Matrix3x3_deSerializeDouble(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Matrix3x3FloatData {
    pub m_el: [b3Vector3FloatData; 3usize],
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Matrix3x3DoubleData {
    pub m_el: [b3Vector3DoubleData; 3usize],
}
/// @brief The b3Transform class supports rigid transforms with only translation and rotation and no scaling/shear.
/// It can be used in combination with b3Vector3, b3Quaternion and b3Matrix3x3 linear algebra classes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Transform {
    /// Storage for the rotation
    pub m_basis: b3Matrix3x3,
    /// Storage for the translation
    pub m_origin: b3Vector3,
}
extern "C" {
    /// @brief Return the inverse of this transform times the other transform
    /// @param t The other transform
    /// return this.inverse() * the other
    #[link_name = "\u{1}?inverseTimes@b3Transform@@QEBA?AV1@AEBV1@@Z"]
    pub fn b3Transform_inverseTimes(this: *const b3Transform, t: *const b3Transform)
        -> b3Transform;
}
extern "C" {
    #[link_name = "\u{1}?serialize@b3Transform@@QEBAXAEAUb3TransformFloatData@@@Z"]
    pub fn b3Transform_serialize(this: *const b3Transform, dataOut: *mut b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}?serializeFloat@b3Transform@@QEBAXAEAUb3TransformFloatData@@@Z"]
    pub fn b3Transform_serializeFloat(this: *const b3Transform, dataOut: *mut b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@b3Transform@@QEAAXAEBUb3TransformFloatData@@@Z"]
    pub fn b3Transform_deSerialize(this: *mut b3Transform, dataIn: *const b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerializeDouble@b3Transform@@QEAAXAEBUb3TransformDoubleData@@@Z"]
    pub fn b3Transform_deSerializeDouble(
        this: *mut b3Transform,
        dataIn: *const b3TransformDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerializeFloat@b3Transform@@QEAAXAEBUb3TransformFloatData@@@Z"]
    pub fn b3Transform_deSerializeFloat(
        this: *mut b3Transform,
        dataIn: *const b3TransformFloatData,
    );
}
impl b3Transform {
    #[inline]
    pub unsafe fn inverseTimes(&self, t: *const b3Transform) -> b3Transform {
        b3Transform_inverseTimes(self, t)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut b3TransformFloatData) {
        b3Transform_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut b3TransformFloatData) {
        b3Transform_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const b3TransformFloatData) {
        b3Transform_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const b3TransformDoubleData) {
        b3Transform_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const b3TransformFloatData) {
        b3Transform_deSerializeFloat(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformFloatData {
    pub m_basis: b3Matrix3x3FloatData,
    pub m_origin: b3Vector3FloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformDoubleData {
    pub m_basis: b3Matrix3x3DoubleData,
    pub m_origin: b3Vector3DoubleData,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtAabbMm {
    pub mi: b3Vector3,
    pub mx: b3Vector3,
}
pub type b3DbvtVolume = b3DbvtAabbMm;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtNode {
    pub volume: b3DbvtVolume,
    pub parent: *mut b3DbvtNode,
    pub __bindgen_anon_1: b3DbvtNode__bindgen_ty_1,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3DbvtNode__bindgen_ty_1 {
    pub childs: [*mut b3DbvtNode; 2usize],
    pub data: *mut ::std::os::raw::c_void,
    pub dataAsInt: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 2usize],
}
/// The b3DynamicBvh class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
/// This b3DynamicBvh is used for soft body collision detection and for the b3DynamicBvhBroadphase. It has a fast insert, remove and update of nodes.
/// Unlike the b3QuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh {
    pub m_root: *mut b3DbvtNode,
    pub m_free: *mut b3DbvtNode,
    pub m_lkhd: ::std::os::raw::c_int,
    pub m_leaves: ::std::os::raw::c_int,
    pub m_opath: ::std::os::raw::c_uint,
    pub m_stkStack: b3AlignedObjectArray<b3DynamicBvh_sStkNN>,
    pub m_rayTestStack: b3AlignedObjectArray<*const b3DbvtNode>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNN {
    pub a: *const b3DbvtNode,
    pub b: *const b3DbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNP {
    pub node: *const b3DbvtNode,
    pub mask: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNPS {
    pub node: *const b3DbvtNode,
    pub mask: ::std::os::raw::c_int,
    pub value: b3Scalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkCLN {
    pub node: *const b3DbvtNode,
    pub parent: *mut b3DbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_ICollide {
    pub _address: u8,
}
#[repr(C)]
pub struct b3DynamicBvh_IWriter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh_IWriter {
    pub vtable_: *const b3DynamicBvh_IWriter__bindgen_vtable,
}
#[repr(C)]
pub struct b3DynamicBvh_IClone__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh_IClone {
    pub vtable_: *const b3DynamicBvh_IClone__bindgen_vtable,
}
pub const b3DynamicBvh_B3_SIMPLE_STACKSIZE: b3DynamicBvh__bindgen_ty_1 = 64;
pub const b3DynamicBvh_B3_DOUBLE_STACKSIZE: b3DynamicBvh__bindgen_ty_1 = 128;
pub type b3DynamicBvh__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?clear@b3DynamicBvh@@QEAAXXZ"]
    pub fn b3DynamicBvh_clear(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}?optimizeBottomUp@b3DynamicBvh@@QEAAXXZ"]
    pub fn b3DynamicBvh_optimizeBottomUp(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}?optimizeTopDown@b3DynamicBvh@@QEAAXH@Z"]
    pub fn b3DynamicBvh_optimizeTopDown(
        this: *mut b3DynamicBvh,
        bu_treshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?optimizeIncremental@b3DynamicBvh@@QEAAXH@Z"]
    pub fn b3DynamicBvh_optimizeIncremental(this: *mut b3DynamicBvh, passes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?insert@b3DynamicBvh@@QEAAPEAUb3DbvtNode@@AEBUb3DbvtAabbMm@@PEAX@Z"]
    pub fn b3DynamicBvh_insert(
        this: *mut b3DynamicBvh,
        box_: *const b3DbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut b3DbvtNode;
}
extern "C" {
    #[link_name = "\u{1}?update@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@H@Z"]
    pub fn b3DynamicBvh_update(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        lookahead: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@@Z"]
    pub fn b3DynamicBvh_update1(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@AEBVb3Vector3@@M@Z"]
    pub fn b3DynamicBvh_update2(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@AEBVb3Vector3@@@Z"]
    pub fn b3DynamicBvh_update3(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@M@Z"]
    pub fn b3DynamicBvh_update4(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@@Z"]
    pub fn b3DynamicBvh_remove(this: *mut b3DynamicBvh, leaf: *mut b3DbvtNode);
}
extern "C" {
    #[link_name = "\u{1}?write@b3DynamicBvh@@QEBAXPEAUIWriter@1@@Z"]
    pub fn b3DynamicBvh_write(this: *const b3DynamicBvh, iwriter: *mut b3DynamicBvh_IWriter);
}
extern "C" {
    #[link_name = "\u{1}?clone@b3DynamicBvh@@QEBAXAEAU1@PEAUIClone@1@@Z"]
    pub fn b3DynamicBvh_clone(
        this: *const b3DynamicBvh,
        dest: *mut b3DynamicBvh,
        iclone: *mut b3DynamicBvh_IClone,
    );
}
extern "C" {
    #[link_name = "\u{1}?maxdepth@b3DynamicBvh@@SAHPEBUb3DbvtNode@@@Z"]
    pub fn b3DynamicBvh_maxdepth(node: *const b3DbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?countLeaves@b3DynamicBvh@@SAHPEBUb3DbvtNode@@@Z"]
    pub fn b3DynamicBvh_countLeaves(node: *const b3DbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?extractLeaves@b3DynamicBvh@@SAXPEBUb3DbvtNode@@AEAV?$b3AlignedObjectArray@PEBUb3DbvtNode@@@@@Z"]
    pub fn b3DynamicBvh_extractLeaves(
        node: *const b3DbvtNode,
        leaves: *mut b3AlignedObjectArray<*const b3DbvtNode>,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3DynamicBvh@@QEAA@XZ"]
    pub fn b3DynamicBvh_b3DynamicBvh(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}??_Db3DynamicBvh@@QEAAXXZ"]
    pub fn b3DynamicBvh_b3DynamicBvh_destructor(this: *mut b3DynamicBvh);
}
impl b3DynamicBvh {
    #[inline]
    pub unsafe fn clear(&mut self) {
        b3DynamicBvh_clear(self)
    }
    #[inline]
    pub unsafe fn optimizeBottomUp(&mut self) {
        b3DynamicBvh_optimizeBottomUp(self)
    }
    #[inline]
    pub unsafe fn optimizeTopDown(&mut self, bu_treshold: ::std::os::raw::c_int) {
        b3DynamicBvh_optimizeTopDown(self, bu_treshold)
    }
    #[inline]
    pub unsafe fn optimizeIncremental(&mut self, passes: ::std::os::raw::c_int) {
        b3DynamicBvh_optimizeIncremental(self, passes)
    }
    #[inline]
    pub unsafe fn insert(
        &mut self,
        box_: *const b3DbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut b3DbvtNode {
        b3DynamicBvh_insert(self, box_, data)
    }
    #[inline]
    pub unsafe fn update(&mut self, leaf: *mut b3DbvtNode, lookahead: ::std::os::raw::c_int) {
        b3DynamicBvh_update(self, leaf, lookahead)
    }
    #[inline]
    pub unsafe fn update1(&mut self, leaf: *mut b3DbvtNode, volume: *mut b3DbvtVolume) {
        b3DynamicBvh_update1(self, leaf, volume)
    }
    #[inline]
    pub unsafe fn update2(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3DynamicBvh_update2(self, leaf, volume, velocity, margin)
    }
    #[inline]
    pub unsafe fn update3(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
    ) -> bool {
        b3DynamicBvh_update3(self, leaf, volume, velocity)
    }
    #[inline]
    pub unsafe fn update4(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        margin: b3Scalar,
    ) -> bool {
        b3DynamicBvh_update4(self, leaf, volume, margin)
    }
    #[inline]
    pub unsafe fn remove(&mut self, leaf: *mut b3DbvtNode) {
        b3DynamicBvh_remove(self, leaf)
    }
    #[inline]
    pub unsafe fn write(&self, iwriter: *mut b3DynamicBvh_IWriter) {
        b3DynamicBvh_write(self, iwriter)
    }
    #[inline]
    pub unsafe fn clone(&self, dest: *mut b3DynamicBvh, iclone: *mut b3DynamicBvh_IClone) {
        b3DynamicBvh_clone(self, dest, iclone)
    }
    #[inline]
    pub unsafe fn maxdepth(node: *const b3DbvtNode) -> ::std::os::raw::c_int {
        b3DynamicBvh_maxdepth(node)
    }
    #[inline]
    pub unsafe fn countLeaves(node: *const b3DbvtNode) -> ::std::os::raw::c_int {
        b3DynamicBvh_countLeaves(node)
    }
    #[inline]
    pub unsafe fn extractLeaves(
        node: *const b3DbvtNode,
        leaves: *mut b3AlignedObjectArray<*const b3DbvtNode>,
    ) {
        b3DynamicBvh_extractLeaves(node, leaves)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3DynamicBvh_b3DynamicBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        b3DynamicBvh_b3DynamicBvh_destructor(self)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3UnsignedInt2 {
    pub __bindgen_anon_1: b3UnsignedInt2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3UnsignedInt2__bindgen_ty_1 {
    pub __bindgen_anon_1: b3UnsignedInt2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3UnsignedInt2__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt2__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt2__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Int2 {
    pub __bindgen_anon_1: b3Int2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Int2__bindgen_ty_1 {
    pub __bindgen_anon_1: b3Int2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3Int2__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int2__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int2__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Dispatcher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3UnsignedInt4 {
    pub __bindgen_anon_1: b3UnsignedInt4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3UnsignedInt4__bindgen_ty_1 {
    pub __bindgen_anon_1: b3UnsignedInt4__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3UnsignedInt4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt4__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt4__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Int4 {
    pub __bindgen_anon_1: b3Int4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Int4__bindgen_ty_1 {
    pub __bindgen_anon_1: b3Int4__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3Int4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int4__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int4__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_int; 4usize],
}
pub type b3BroadphasePair = b3Int4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BroadphasePairSortPredicate {
    pub _address: u8,
}
pub type b3BroadphasePairArray = b3AlignedObjectArray<b3BroadphasePair>;
#[repr(C)]
pub struct b3OverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlapCallback {
    pub vtable_: *const b3OverlapCallback__bindgen_vtable,
}
#[repr(C)]
pub struct b3OverlapFilterCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlapFilterCallback {
    pub vtable_: *const b3OverlapFilterCallback__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}?b3g_removePairs@@3HA"]
    pub static mut b3g_removePairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?b3g_addedPairs@@3HA"]
    pub static mut b3g_addedPairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?b3g_findPairs@@3HA"]
    pub static mut b3g_findPairs: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct b3OverlappingPairCache__bindgen_vtable(::std::os::raw::c_void);
/// The b3OverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the b3BroadphaseInterface broadphases.
/// The b3HashedOverlappingPairCache and b3SortedOverlappingPairCache classes are two implementations.
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlappingPairCache {
    pub vtable_: *const b3OverlappingPairCache__bindgen_vtable,
}
/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
#[repr(C)]
pub struct b3HashedOverlappingPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
    pub m_overlapFilterCallback: *mut b3OverlapFilterCallback,
    pub m_hashTable: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: b3AlignedObjectArray<::std::os::raw::c_int>,
}
extern "C" {
    #[link_name = "\u{1}??0b3HashedOverlappingPairCache@@QEAA@XZ"]
    pub fn b3HashedOverlappingPairCache_b3HashedOverlappingPairCache(
        this: *mut b3HashedOverlappingPairCache,
    );
}
impl b3HashedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3HashedOverlappingPairCache_b3HashedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3HashedOverlappingPairCache@@QEAAXXZ"]
    pub fn b3HashedOverlappingPairCache_b3HashedOverlappingPairCache_destructor(
        this: *mut b3HashedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPairsContainingProxy@b3HashedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z"]
    pub fn b3HashedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPair@b3HashedOverlappingPairCache@@UEAAPEAXHHPEAVb3Dispatcher@@@Z"]
    pub fn b3HashedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?cleanProxyFromPairs@b3HashedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z"]
    pub fn b3HashedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllOverlappingPairs@b3HashedOverlappingPairCache@@UEAAXPEAUb3OverlapCallback@@PEAVb3Dispatcher@@@Z"]
    pub fn b3HashedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut b3OverlapCallback,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?cleanOverlappingPair@b3HashedOverlappingPairCache@@UEAAXAEAUb3Int4@@PEAVb3Dispatcher@@@Z"]
    pub fn b3HashedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut b3BroadphasePair,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?findPair@b3HashedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z"]
    pub fn b3HashedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
/// b3SortedOverlappingPairCache maintains the objects with overlapping AABB
/// Typically managed by the Broadphase, Axis3Sweep or b3SimpleBroadphase
#[repr(C)]
pub struct b3SortedOverlappingPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
    pub m_blockedForChanges: bool,
    /// by default, do the removal during the pair traversal
    pub m_hasDeferredRemoval: bool,
    pub m_overlapFilterCallback: *mut b3OverlapFilterCallback,
}
extern "C" {
    #[link_name = "\u{1}??0b3SortedOverlappingPairCache@@QEAA@XZ"]
    pub fn b3SortedOverlappingPairCache_b3SortedOverlappingPairCache(
        this: *mut b3SortedOverlappingPairCache,
    );
}
impl b3SortedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3SortedOverlappingPairCache_b3SortedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3SortedOverlappingPairCache@@QEAAXXZ"]
    pub fn b3SortedOverlappingPairCache_b3SortedOverlappingPairCache_destructor(
        this: *mut b3SortedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllOverlappingPairs@b3SortedOverlappingPairCache@@UEAAXPEAUb3OverlapCallback@@PEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut b3OverlapCallback,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPair@b3SortedOverlappingPairCache@@UEAAPEAXHHPEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?cleanOverlappingPair@b3SortedOverlappingPairCache@@UEAAXAEAUb3Int4@@PEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut b3BroadphasePair,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?addOverlappingPair@b3SortedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z"]
    pub fn b3SortedOverlappingPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}?findPair@b3SortedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z"]
    pub fn b3SortedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}?cleanProxyFromPairs@b3SortedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPairsContainingProxy@b3SortedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?sortOverlappingPairs@b3SortedOverlappingPairCache@@UEAAXPEAVb3Dispatcher@@@Z"]
    pub fn b3SortedOverlappingPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
/// b3NullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
#[repr(C)]
pub struct b3NullPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
}
#[repr(C)]
pub struct b3BroadphaseAabbCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3BroadphaseAabbCallback {
    pub vtable_: *const b3BroadphaseAabbCallback__bindgen_vtable,
}
#[repr(C)]
pub struct b3BroadphaseRayCallback {
    pub _base: b3BroadphaseAabbCallback,
    pub __bindgen_padding_0: u64,
    /// added some cached data to accelerate ray-AABB tests
    pub m_rayDirectionInverse: b3Vector3,
    pub m_signs: [::std::os::raw::c_uint; 3usize],
    pub m_lambda_max: b3Scalar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3BroadphaseProxy {
    pub m_clientObject: *mut ::std::os::raw::c_void,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_aabbMin: b3Vector3,
    pub m_aabbMax: b3Vector3,
}
pub const b3BroadphaseProxy_CollisionFilterGroups_DefaultFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 1;
pub const b3BroadphaseProxy_CollisionFilterGroups_StaticFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 2;
pub const b3BroadphaseProxy_CollisionFilterGroups_KinematicFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 4;
pub const b3BroadphaseProxy_CollisionFilterGroups_DebrisFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 8;
pub const b3BroadphaseProxy_CollisionFilterGroups_SensorTrigger:
    b3BroadphaseProxy_CollisionFilterGroups = 16;
pub const b3BroadphaseProxy_CollisionFilterGroups_CharacterFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 32;
pub const b3BroadphaseProxy_CollisionFilterGroups_AllFilter:
    b3BroadphaseProxy_CollisionFilterGroups = -1;
/// optional filtering to cull potential collisions
pub type b3BroadphaseProxy_CollisionFilterGroups = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtProxy {
    pub _base: b3BroadphaseProxy,
    pub leaf: *mut b3DbvtNode,
    pub links: [*mut b3DbvtProxy; 2usize],
    pub stage: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
pub type b3DbvtProxyArray = b3AlignedObjectArray<*mut b3DbvtProxy>;
#[repr(C)]
pub struct b3DynamicBvhBroadphase__bindgen_vtable(::std::os::raw::c_void);
/// The b3DynamicBvhBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see b3DynamicBvh).
/// One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
/// This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases b3AxisSweep3 and b332BitAxisSweep3.
#[repr(C)]
pub struct b3DynamicBvhBroadphase {
    pub vtable_: *const b3DynamicBvhBroadphase__bindgen_vtable,
    pub m_sets: [b3DynamicBvh; 2usize],
    pub m_stageRoots: [*mut b3DbvtProxy; 3usize],
    pub m_proxies: b3AlignedObjectArray<b3DbvtProxy>,
    pub m_paircache: *mut b3OverlappingPairCache,
    pub m_prediction: b3Scalar,
    pub m_stageCurrent: ::std::os::raw::c_int,
    pub m_fupdates: ::std::os::raw::c_int,
    pub m_dupdates: ::std::os::raw::c_int,
    pub m_cupdates: ::std::os::raw::c_int,
    pub m_newpairs: ::std::os::raw::c_int,
    pub m_fixedleft: ::std::os::raw::c_int,
    pub m_updates_call: ::std::os::raw::c_uint,
    pub m_updates_done: ::std::os::raw::c_uint,
    pub m_updates_ratio: b3Scalar,
    pub m_pid: ::std::os::raw::c_int,
    pub m_cid: ::std::os::raw::c_int,
    pub m_releasepaircache: bool,
    pub m_deferedcollide: bool,
    pub m_needcleanup: bool,
}
pub const b3DynamicBvhBroadphase_DYNAMIC_SET: b3DynamicBvhBroadphase__bindgen_ty_1 = 0;
pub const b3DynamicBvhBroadphase_FIXED_SET: b3DynamicBvhBroadphase__bindgen_ty_1 = 1;
pub const b3DynamicBvhBroadphase_STAGECOUNT: b3DynamicBvhBroadphase__bindgen_ty_1 = 2;
pub type b3DynamicBvhBroadphase__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?collide@b3DynamicBvhBroadphase@@QEAAXPEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_collide(
        this: *mut b3DynamicBvhBroadphase,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?optimize@b3DynamicBvhBroadphase@@QEAAXXZ"]
    pub fn b3DynamicBvhBroadphase_optimize(this: *mut b3DynamicBvhBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?createProxy@b3DynamicBvhBroadphase@@QEAAPEAUb3BroadphaseProxy@@AEBVb3Vector3@@0HPEAXHH@Z"]
    pub fn b3DynamicBvhBroadphase_createProxy(
        this: *mut b3DynamicBvhBroadphase,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        objectIndex: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> *mut b3BroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}?performDeferredRemoval@b3DynamicBvhBroadphase@@QEAAXPEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_performDeferredRemoval(
        this: *mut b3DynamicBvhBroadphase,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    /// this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    /// ///it is not part of the b3BroadphaseInterface but specific to b3DynamicBvhBroadphase.
    /// ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    /// ///http://code.google.com/p/bullet/issues/detail?id=223
    #[link_name = "\u{1}?setAabbForceUpdate@b3DynamicBvhBroadphase@@QEAAXPEAUb3BroadphaseProxy@@AEBVb3Vector3@@1PEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_setAabbForceUpdate(
        this: *mut b3DynamicBvhBroadphase,
        absproxy: *mut b3BroadphaseProxy,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        arg1: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3DynamicBvhBroadphase@@QEAA@HPEAVb3OverlappingPairCache@@@Z"]
    pub fn b3DynamicBvhBroadphase_b3DynamicBvhBroadphase(
        this: *mut b3DynamicBvhBroadphase,
        proxyCapacity: ::std::os::raw::c_int,
        paircache: *mut b3OverlappingPairCache,
    );
}
impl b3DynamicBvhBroadphase {
    #[inline]
    pub unsafe fn collide(&mut self, dispatcher: *mut b3Dispatcher) {
        b3DynamicBvhBroadphase_collide(self, dispatcher)
    }
    #[inline]
    pub unsafe fn optimize(&mut self) {
        b3DynamicBvhBroadphase_optimize(self)
    }
    #[inline]
    pub unsafe fn createProxy(
        &mut self,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        objectIndex: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> *mut b3BroadphaseProxy {
        b3DynamicBvhBroadphase_createProxy(
            self,
            aabbMin,
            aabbMax,
            objectIndex,
            userPtr,
            collisionFilterGroup,
            collisionFilterMask,
        )
    }
    #[inline]
    pub unsafe fn performDeferredRemoval(&mut self, dispatcher: *mut b3Dispatcher) {
        b3DynamicBvhBroadphase_performDeferredRemoval(self, dispatcher)
    }
    #[inline]
    pub unsafe fn setAabbForceUpdate(
        &mut self,
        absproxy: *mut b3BroadphaseProxy,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        arg1: *mut b3Dispatcher,
    ) {
        b3DynamicBvhBroadphase_setAabbForceUpdate(self, absproxy, aabbMin, aabbMax, arg1)
    }
    #[inline]
    pub unsafe fn new(
        proxyCapacity: ::std::os::raw::c_int,
        paircache: *mut b3OverlappingPairCache,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3DynamicBvhBroadphase_b3DynamicBvhBroadphase(&mut __bindgen_tmp, proxyCapacity, paircache);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3DynamicBvhBroadphase@@QEAAXXZ"]
    pub fn b3DynamicBvhBroadphase_b3DynamicBvhBroadphase_destructor(
        this: *mut b3DynamicBvhBroadphase,
    );
}
extern "C" {
    #[link_name = "\u{1}?destroyProxy@b3DynamicBvhBroadphase@@UEAAXPEAUb3BroadphaseProxy@@PEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut b3BroadphaseProxy,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAabb@b3DynamicBvhBroadphase@@UEAAXHAEBVb3Vector3@@0PEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        objectId: ::std::os::raw::c_int,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@b3DynamicBvhBroadphase@@UEAAXAEBVb3Vector3@@0AEAUb3BroadphaseRayCallback@@00@Z"]
    pub fn b3DynamicBvhBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        rayCallback: *mut b3BroadphaseRayCallback,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?aabbTest@b3DynamicBvhBroadphase@@UEAAXAEBVb3Vector3@@0AEAUb3BroadphaseAabbCallback@@@Z"]
    pub fn b3DynamicBvhBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        callback: *mut b3BroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@b3DynamicBvhBroadphase@@UEBAXHAEAVb3Vector3@@0@Z"]
    pub fn b3DynamicBvhBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        objectId: ::std::os::raw::c_int,
        aabbMin: *mut b3Vector3,
        aabbMax: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@b3DynamicBvhBroadphase@@UEAAXPEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairCache@b3DynamicBvhBroadphase@@UEAAPEAVb3OverlappingPairCache@@XZ"]
    pub fn b3DynamicBvhBroadphase_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairCache@b3DynamicBvhBroadphase@@UEBAPEBVb3OverlappingPairCache@@XZ"]
    pub fn b3DynamicBvhBroadphase_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const b3OverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}?getBroadphaseAabb@b3DynamicBvhBroadphase@@UEBAXAEAVb3Vector3@@0@Z"]
    pub fn b3DynamicBvhBroadphase_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut b3Vector3,
        aabbMax: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?printStats@b3DynamicBvhBroadphase@@UEAAXXZ"]
    pub fn b3DynamicBvhBroadphase_printStats(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// reset broadphase internal structures, to ensure determinism/reproducability
    #[link_name = "\u{1}?resetPool@b3DynamicBvhBroadphase@@UEAAXPEAVb3Dispatcher@@@Z"]
    pub fn b3DynamicBvhBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct b3MyFace {
    pub m_indices: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_plane: [b3Scalar; 4usize],
}
#[repr(C)]
pub struct b3ConvexUtility__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3ConvexUtility {
    pub vtable_: *const b3ConvexUtility__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_localCenter: b3Vector3,
    pub m_extents: b3Vector3,
    pub mC: b3Vector3,
    pub mE: b3Vector3,
    pub m_radius: b3Scalar,
    pub m_vertices: b3AlignedObjectArray<b3Vector3>,
    pub m_faces: b3AlignedObjectArray<b3MyFace>,
    pub m_uniqueEdges: b3AlignedObjectArray<b3Vector3>,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}?initializePolyhedralFeatures@b3ConvexUtility@@QEAA_NPEBVb3Vector3@@H_N@Z"]
    pub fn b3ConvexUtility_initializePolyhedralFeatures(
        this: *mut b3ConvexUtility,
        orgVertices: *const b3Vector3,
        numVertices: ::std::os::raw::c_int,
        mergeCoplanarTriangles: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?initialize@b3ConvexUtility@@QEAAXXZ"]
    pub fn b3ConvexUtility_initialize(this: *mut b3ConvexUtility);
}
extern "C" {
    #[link_name = "\u{1}?testContainment@b3ConvexUtility@@QEBA_NXZ"]
    pub fn b3ConvexUtility_testContainment(this: *const b3ConvexUtility) -> bool;
}
impl b3ConvexUtility {
    #[inline]
    pub unsafe fn initializePolyhedralFeatures(
        &mut self,
        orgVertices: *const b3Vector3,
        numVertices: ::std::os::raw::c_int,
        mergeCoplanarTriangles: bool,
    ) -> bool {
        b3ConvexUtility_initializePolyhedralFeatures(
            self,
            orgVertices,
            numVertices,
            mergeCoplanarTriangles,
        )
    }
    #[inline]
    pub unsafe fn initialize(&mut self) {
        b3ConvexUtility_initialize(self)
    }
    #[inline]
    pub unsafe fn testContainment(&self) -> bool {
        b3ConvexUtility_testContainment(self)
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3ConvexUtility@@QEAAXXZ"]
    pub fn b3ConvexUtility_b3ConvexUtility_destructor(this: *mut b3ConvexUtility);
}
pub const b3ShapeTypes_SHAPE_HEIGHT_FIELD: b3ShapeTypes = 1;
pub const b3ShapeTypes_SHAPE_CONVEX_HULL: b3ShapeTypes = 3;
pub const b3ShapeTypes_SHAPE_PLANE: b3ShapeTypes = 4;
pub const b3ShapeTypes_SHAPE_CONCAVE_TRIMESH: b3ShapeTypes = 5;
pub const b3ShapeTypes_SHAPE_COMPOUND_OF_CONVEX_HULLS: b3ShapeTypes = 6;
pub const b3ShapeTypes_SHAPE_SPHERE: b3ShapeTypes = 7;
pub const b3ShapeTypes_MAX_NUM_SHAPE_TYPES: b3ShapeTypes = 8;
pub type b3ShapeTypes = i32;
pub type b3Collidable_t = b3Collidable;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Collidable {
    pub __bindgen_anon_1: b3Collidable__bindgen_ty_1,
    pub __bindgen_anon_2: b3Collidable__bindgen_ty_2,
    pub m_shapeType: ::std::os::raw::c_int,
    pub __bindgen_anon_3: b3Collidable__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_1 {
    pub m_numChildShapes: ::std::os::raw::c_int,
    pub m_bvhIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_2 {
    pub m_radius: f32,
    pub m_compoundBvhIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_3 {
    pub m_shapeIndex: ::std::os::raw::c_int,
    pub m_height: f32,
    _bindgen_union_align: u32,
}
pub type b3GpuChildShape_t = b3GpuChildShape;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuChildShape {
    pub m_childPosition: b3Vector3,
    pub m_childOrientation: b3Quaternion,
    pub __bindgen_anon_1: b3GpuChildShape__bindgen_ty_1,
    pub __bindgen_anon_2: b3GpuChildShape__bindgen_ty_2,
    pub __bindgen_anon_3: b3GpuChildShape__bindgen_ty_3,
    pub m_shapeType: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_1 {
    pub m_shapeIndex: ::std::os::raw::c_int,
    pub m_capsuleAxis: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_2 {
    pub m_radius: f32,
    pub m_numChildShapes: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_3 {
    pub m_height: f32,
    pub m_collidableShapeIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CompoundOverlappingPair {
    pub m_bodyIndexA: ::std::os::raw::c_int,
    pub m_bodyIndexB: ::std::os::raw::c_int,
    pub m_childShapeIndexA: ::std::os::raw::c_int,
    pub m_childShapeIndexB: ::std::os::raw::c_int,
}
pub type b3Aabb_t = b3Aabb;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Aabb {
    pub __bindgen_anon_1: b3Aabb__bindgen_ty_1,
    pub __bindgen_anon_2: b3Aabb__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Aabb__bindgen_ty_1 {
    pub m_min: [f32; 4usize],
    pub m_minVec: b3Vector3,
    pub m_minIndices: [::std::os::raw::c_int; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Aabb__bindgen_ty_2 {
    pub m_max: [f32; 4usize],
    pub m_maxVec: b3Vector3,
    pub m_signedMaxIndices: [::std::os::raw::c_int; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
pub type b3RigidBodyData_t = b3RigidBodyData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RigidBodyData {
    pub m_pos: b3Vector3,
    pub m_quat: b3Quaternion,
    pub m_linVel: b3Vector3,
    pub m_angVel: b3Vector3,
    pub m_collidableIdx: ::std::os::raw::c_int,
    pub m_invMass: f32,
    pub m_restituitionCoeff: f32,
    pub m_frictionCoeff: f32,
}
pub type b3InertiaData_t = b3InertiaData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3InertiaData {
    pub m_invInertiaWorld: b3Matrix3x3,
    pub m_initInvInertia: b3Matrix3x3,
}
pub type b3Contact4Data_t = b3Contact4Data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Contact4Data {
    pub m_worldPosB: [b3Vector3; 4usize],
    pub m_worldNormalOnB: b3Vector3,
    pub m_restituitionCoeffCmp: ::std::os::raw::c_ushort,
    pub m_frictionCoeffCmp: ::std::os::raw::c_ushort,
    pub m_batchIdx: ::std::os::raw::c_int,
    pub m_bodyAPtrAndSignBit: ::std::os::raw::c_int,
    pub m_bodyBPtrAndSignBit: ::std::os::raw::c_int,
    pub m_childIndexA: ::std::os::raw::c_int,
    pub m_childIndexB: ::std::os::raw::c_int,
    pub m_unused1: ::std::os::raw::c_int,
    pub m_unused2: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3CpuNarrowPhase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3CpuNarrowPhase {
    pub vtable_: *const b3CpuNarrowPhase__bindgen_vtable,
    pub m_data: *mut b3CpuNarrowPhaseInternalData,
    pub m_acceleratedCompanionShapeIndex: ::std::os::raw::c_int,
    pub m_planeBodyIndex: ::std::os::raw::c_int,
    pub m_static0Index: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShapeInternal@b3CpuNarrowPhase@@IEAAHPEAVb3ConvexUtility@@AEAUb3Collidable@@@Z"]
    pub fn b3CpuNarrowPhase_registerConvexHullShapeInternal(
        this: *mut b3CpuNarrowPhase,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConcaveMeshShape@b3CpuNarrowPhase@@IEAAHPEAV?$b3AlignedObjectArray@Vb3Vector3@@@@PEAV?$b3AlignedObjectArray@H@@AEAUb3Collidable@@PEBM@Z"]
    pub fn b3CpuNarrowPhase_registerConcaveMeshShape(
        this: *mut b3CpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerSphereShape@b3CpuNarrowPhase@@QEAAHM@Z"]
    pub fn b3CpuNarrowPhase_registerSphereShape(
        this: *mut b3CpuNarrowPhase,
        radius: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerPlaneShape@b3CpuNarrowPhase@@QEAAHAEBVb3Vector3@@M@Z"]
    pub fn b3CpuNarrowPhase_registerPlaneShape(
        this: *mut b3CpuNarrowPhase,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerCompoundShape@b3CpuNarrowPhase@@QEAAHPEAV?$b3AlignedObjectArray@Ub3GpuChildShape@@@@@Z"]
    pub fn b3CpuNarrowPhase_registerCompoundShape(
        this: *mut b3CpuNarrowPhase,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerFace@b3CpuNarrowPhase@@QEAAHAEBVb3Vector3@@M@Z"]
    pub fn b3CpuNarrowPhase_registerFace(
        this: *mut b3CpuNarrowPhase,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConcaveMesh@b3CpuNarrowPhase@@QEAAHPEAV?$b3AlignedObjectArray@Vb3Vector3@@@@PEAV?$b3AlignedObjectArray@H@@PEBM@Z"]
    pub fn b3CpuNarrowPhase_registerConcaveMesh(
        this: *mut b3CpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShape@b3CpuNarrowPhase@@QEAAHPEAVb3ConvexUtility@@@Z"]
    pub fn b3CpuNarrowPhase_registerConvexHullShape(
        this: *mut b3CpuNarrowPhase,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShape@b3CpuNarrowPhase@@QEAAHPEBMHH0@Z"]
    pub fn b3CpuNarrowPhase_registerConvexHullShape1(
        this: *mut b3CpuNarrowPhase,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setObjectTransform@b3CpuNarrowPhase@@QEAAXPEBM0H@Z"]
    pub fn b3CpuNarrowPhase_setObjectTransform(
        this: *mut b3CpuNarrowPhase,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeAllBodiesToGpu@b3CpuNarrowPhase@@QEAAXXZ"]
    pub fn b3CpuNarrowPhase_writeAllBodiesToGpu(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?reset@b3CpuNarrowPhase@@QEAAXXZ"]
    pub fn b3CpuNarrowPhase_reset(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?readbackAllBodiesToCpu@b3CpuNarrowPhase@@QEAAXXZ"]
    pub fn b3CpuNarrowPhase_readbackAllBodiesToCpu(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?getObjectTransformFromCpu@b3CpuNarrowPhase@@QEBA_NPEAM0H@Z"]
    pub fn b3CpuNarrowPhase_getObjectTransformFromCpu(
        this: *const b3CpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setObjectTransformCpu@b3CpuNarrowPhase@@QEAAXPEAM0H@Z"]
    pub fn b3CpuNarrowPhase_setObjectTransformCpu(
        this: *mut b3CpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setObjectVelocityCpu@b3CpuNarrowPhase@@QEAAXPEAM0H@Z"]
    pub fn b3CpuNarrowPhase_setObjectVelocityCpu(
        this: *mut b3CpuNarrowPhase,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBodiesCpu@b3CpuNarrowPhase@@QEBAPEBUb3RigidBodyData@@XZ"]
    pub fn b3CpuNarrowPhase_getBodiesCpu(this: *const b3CpuNarrowPhase) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodiesGpu@b3CpuNarrowPhase@@QEBAHXZ"]
    pub fn b3CpuNarrowPhase_getNumBodiesGpu(this: *const b3CpuNarrowPhase)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodyInertiasGpu@b3CpuNarrowPhase@@QEBAHXZ"]
    pub fn b3CpuNarrowPhase_getNumBodyInertiasGpu(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getCollidablesCpu@b3CpuNarrowPhase@@QEBAPEBUb3Collidable@@XZ"]
    pub fn b3CpuNarrowPhase_getCollidablesCpu(this: *const b3CpuNarrowPhase)
        -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getNumCollidablesGpu@b3CpuNarrowPhase@@QEBAHXZ"]
    pub fn b3CpuNarrowPhase_getNumCollidablesGpu(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getContacts@b3CpuNarrowPhase@@QEBAAEBV?$b3AlignedObjectArray@Ub3Contact4Data@@@@XZ"]
    pub fn b3CpuNarrowPhase_getContacts(
        this: *const b3CpuNarrowPhase,
    ) -> *const b3AlignedObjectArray<b3Contact4Data>;
}
extern "C" {
    #[link_name = "\u{1}?getNumRigidBodies@b3CpuNarrowPhase@@QEBAHXZ"]
    pub fn b3CpuNarrowPhase_getNumRigidBodies(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?allocateCollidable@b3CpuNarrowPhase@@QEAAHXZ"]
    pub fn b3CpuNarrowPhase_allocateCollidable(
        this: *mut b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getCollidableCpu@b3CpuNarrowPhase@@QEAAAEAUb3Collidable@@H@Z"]
    pub fn b3CpuNarrowPhase_getCollidableCpu(
        this: *mut b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getCollidableCpu@b3CpuNarrowPhase@@QEBAAEBUb3Collidable@@H@Z"]
    pub fn b3CpuNarrowPhase_getCollidableCpu1(
        this: *const b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getLocalSpaceAabb@b3CpuNarrowPhase@@QEBAAEBUb3Aabb@@H@Z"]
    pub fn b3CpuNarrowPhase_getLocalSpaceAabb(
        this: *const b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Aabb;
}
extern "C" {
    #[link_name = "\u{1}??0b3CpuNarrowPhase@@QEAA@AEBUb3Config@@@Z"]
    pub fn b3CpuNarrowPhase_b3CpuNarrowPhase(this: *mut b3CpuNarrowPhase, config: *const b3Config);
}
impl b3CpuNarrowPhase {
    #[inline]
    pub unsafe fn registerConvexHullShapeInternal(
        &mut self,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShapeInternal(self, convexPtr, col)
    }
    #[inline]
    pub unsafe fn registerConcaveMeshShape(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConcaveMeshShape(self, vertices, indices, col, scaling)
    }
    #[inline]
    pub unsafe fn registerSphereShape(&mut self, radius: f32) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerSphereShape(self, radius)
    }
    #[inline]
    pub unsafe fn registerPlaneShape(
        &mut self,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerPlaneShape(self, planeNormal, planeConstant)
    }
    #[inline]
    pub unsafe fn registerCompoundShape(
        &mut self,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerCompoundShape(self, childShapes)
    }
    #[inline]
    pub unsafe fn registerFace(
        &mut self,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerFace(self, faceNormal, faceConstant)
    }
    #[inline]
    pub unsafe fn registerConcaveMesh(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConcaveMesh(self, vertices, indices, scaling)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape(
        &mut self,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShape(self, utilPtr)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape1(
        &mut self,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShape1(
            self,
            vertices,
            strideInBytes,
            numVertices,
            scaling,
        )
    }
    #[inline]
    pub unsafe fn setObjectTransform(
        &mut self,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectTransform(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn writeAllBodiesToGpu(&mut self) {
        b3CpuNarrowPhase_writeAllBodiesToGpu(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3CpuNarrowPhase_reset(self)
    }
    #[inline]
    pub unsafe fn readbackAllBodiesToCpu(&mut self) {
        b3CpuNarrowPhase_readbackAllBodiesToCpu(self)
    }
    #[inline]
    pub unsafe fn getObjectTransformFromCpu(
        &self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool {
        b3CpuNarrowPhase_getObjectTransformFromCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectTransformCpu(
        &mut self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectTransformCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectVelocityCpu(
        &mut self,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectVelocityCpu(self, linVel, angVel, bodyIndex)
    }
    #[inline]
    pub unsafe fn getBodiesCpu(&self) -> *const b3RigidBodyData {
        b3CpuNarrowPhase_getBodiesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodiesGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodyInertiasGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesCpu(&self) -> *const b3Collidable {
        b3CpuNarrowPhase_getCollidablesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumCollidablesGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getContacts(&self) -> *const b3AlignedObjectArray<b3Contact4Data> {
        b3CpuNarrowPhase_getContacts(self)
    }
    #[inline]
    pub unsafe fn getNumRigidBodies(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumRigidBodies(self)
    }
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn getCollidableCpu(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable {
        b3CpuNarrowPhase_getCollidableCpu(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getCollidableCpu1(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable {
        b3CpuNarrowPhase_getCollidableCpu1(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabb(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Aabb {
        b3CpuNarrowPhase_getLocalSpaceAabb(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn new(config: *const b3Config) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3CpuNarrowPhase_b3CpuNarrowPhase(&mut __bindgen_tmp, config);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3CpuNarrowPhase@@QEAAXXZ"]
    pub fn b3CpuNarrowPhase_b3CpuNarrowPhase_destructor(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?computeContacts@b3CpuNarrowPhase@@UEAAXAEAV?$b3AlignedObjectArray@Ub3Int4@@@@AEAV?$b3AlignedObjectArray@Ub3Aabb@@@@AEAV?$b3AlignedObjectArray@Ub3RigidBodyData@@@@@Z"]
    pub fn b3CpuNarrowPhase_computeContacts(
        this: *mut ::std::os::raw::c_void,
        pairs: *mut b3AlignedObjectArray<b3Int4>,
        aabbsWorldSpace: *mut b3AlignedObjectArray<b3Aabb>,
        bodies: *mut b3AlignedObjectArray<b3RigidBodyData>,
    );
}
pub type b3GpuFace_t = b3GpuFace;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuFace {
    pub m_plane: b3Vector3,
    pub m_indexOffset: ::std::os::raw::c_int,
    pub m_numIndices: ::std::os::raw::c_int,
    pub m_unusedPadding1: ::std::os::raw::c_int,
    pub m_unusedPadding2: ::std::os::raw::c_int,
}
pub type b3ConvexPolyhedronData_t = b3ConvexPolyhedronData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ConvexPolyhedronData {
    pub m_localCenter: b3Vector3,
    pub m_extents: b3Vector3,
    pub mC: b3Vector3,
    pub mE: b3Vector3,
    pub m_radius: f32,
    pub m_faceOffset: ::std::os::raw::c_int,
    pub m_numFaces: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertexOffset: ::std::os::raw::c_int,
    pub m_uniqueEdgesOffset: ::std::os::raw::c_int,
    pub m_numUniqueEdges: ::std::os::raw::c_int,
    pub m_unused: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _b3MprSupport_t {
    /// !< Support point in minkowski sum
    pub v: b3Vector3,
    /// !< Support point in obj1
    pub v1: b3Vector3,
    /// !< Support point in obj2
    pub v2: b3Vector3,
}
pub type b3MprSupport_t = _b3MprSupport_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _b3MprSimplex_t {
    pub ps: [b3MprSupport_t; 4usize],
    /// !< index of last added point
    pub last: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
pub type b3MprSimplex_t = _b3MprSimplex_t;
extern "C" {
    #[link_name = "\u{1}?b3ComputeWorldAabb@@YAXHPEBUb3RigidBodyData@@PEBUb3Collidable@@PEBUb3Aabb@@PEAU3@@Z"]
    pub fn b3ComputeWorldAabb(
        bodyId: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData_t,
        collidables: *const b3Collidable_t,
        localShapeAABB: *const b3Aabb_t,
        worldAabbs: *mut b3Aabb_t,
    );
}
#[repr(C)]
pub struct b3FileUtils__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3FileUtils {
    pub vtable_: *const b3FileUtils__bindgen_vtable,
}
/// The b3PoolAllocator class allows to efficiently allocate a large pool of objects, instead of dynamically allocating them separately.
#[repr(C)]
#[derive(Debug)]
pub struct b3PoolAllocator {
    pub m_elemSize: ::std::os::raw::c_int,
    pub m_maxElements: ::std::os::raw::c_int,
    pub m_freeCount: ::std::os::raw::c_int,
    pub m_firstFree: *mut ::std::os::raw::c_void,
    pub m_pool: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PoolBodyHandle<U> {
    pub _base: U,
    pub m_nextFreeHandle: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<U>>,
}
#[repr(C)]
pub struct b3ResizablePool__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3ResizablePool<T> {
    pub vtable_: *const b3ResizablePool__bindgen_vtable,
    pub m_bodyHandles: b3AlignedObjectArray<T>,
    pub m_numUsedHandles: ::std::os::raw::c_int,
    pub m_firstFreeHandle: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
/// Utils related to temporal transforms
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformUtil {
    pub _address: u8,
}
/// The b3ConvexSeparatingDistanceUtil can help speed up convex collision detection
/// by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ConvexSeparatingDistanceUtil {
    pub m_ornA: b3Quaternion,
    pub m_ornB: b3Quaternion,
    pub m_posA: b3Vector3,
    pub m_posB: b3Vector3,
    pub m_separatingNormal: b3Vector3,
    pub m_boundingRadiusA: b3Scalar,
    pub m_boundingRadiusB: b3Scalar,
    pub m_separatingDistance: b3Scalar,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SimdScalar {
    pub __bindgen_anon_1: b3SimdScalar__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SimdScalar__bindgen_ty_1 {
    pub m_vec128: __m128,
    pub m_floats: [f32; 4usize],
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
    pub m_ints: [::std::os::raw::c_int; 4usize],
    pub m_unusedPadding: b3Scalar,
    _bindgen_union_align: [u8; 16usize],
}
/// The b3SolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SolverBody {
    pub m_worldTransform: b3Transform,
    pub m_deltaLinearVelocity: b3Vector3,
    pub m_deltaAngularVelocity: b3Vector3,
    pub m_angularFactor: b3Vector3,
    pub m_linearFactor: b3Vector3,
    pub m_invMass: b3Vector3,
    pub m_pushVelocity: b3Vector3,
    pub m_turnVelocity: b3Vector3,
    pub m_linearVelocity: b3Vector3,
    pub m_angularVelocity: b3Vector3,
    pub __bindgen_anon_1: b3SolverBody__bindgen_ty_1,
    pub padding: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SolverBody__bindgen_ty_1 {
    pub m_originalBody: *mut ::std::os::raw::c_void,
    pub m_originalBodyIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SolverConstraint {
    pub m_relpos1CrossNormal: b3Vector3,
    pub m_contactNormal: b3Vector3,
    pub m_relpos2CrossNormal: b3Vector3,
    pub m_angularComponentA: b3Vector3,
    pub m_angularComponentB: b3Vector3,
    pub m_appliedPushImpulse: b3SimdScalar,
    pub m_appliedImpulse: b3SimdScalar,
    pub m_padding1: ::std::os::raw::c_int,
    pub m_padding2: ::std::os::raw::c_int,
    pub m_friction: b3Scalar,
    pub m_jacDiagABInv: b3Scalar,
    pub m_rhs: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_lowerLimit: b3Scalar,
    pub m_upperLimit: b3Scalar,
    pub m_rhsPenetration: b3Scalar,
    pub __bindgen_anon_1: b3SolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_unusedPadding4: b3Scalar,
    _bindgen_union_align: u64,
}
pub const b3SolverConstraint_b3SolverConstraintType_B3_SOLVER_CONTACT_1D:
    b3SolverConstraint_b3SolverConstraintType = 0;
pub const b3SolverConstraint_b3SolverConstraintType_B3_SOLVER_FRICTION_1D:
    b3SolverConstraint_b3SolverConstraintType = 1;
pub type b3SolverConstraint_b3SolverConstraintType = i32;
pub type b3ConstraintArray = b3AlignedObjectArray<b3SolverConstraint>;
pub const b3TypedConstraintType_B3_POINT2POINT_CONSTRAINT_TYPE: b3TypedConstraintType = 3;
pub const b3TypedConstraintType_B3_HINGE_CONSTRAINT_TYPE: b3TypedConstraintType = 4;
pub const b3TypedConstraintType_B3_CONETWIST_CONSTRAINT_TYPE: b3TypedConstraintType = 5;
pub const b3TypedConstraintType_B3_D6_CONSTRAINT_TYPE: b3TypedConstraintType = 6;
pub const b3TypedConstraintType_B3_SLIDER_CONSTRAINT_TYPE: b3TypedConstraintType = 7;
pub const b3TypedConstraintType_B3_CONTACT_CONSTRAINT_TYPE: b3TypedConstraintType = 8;
pub const b3TypedConstraintType_B3_D6_SPRING_CONSTRAINT_TYPE: b3TypedConstraintType = 9;
pub const b3TypedConstraintType_B3_GEAR_CONSTRAINT_TYPE: b3TypedConstraintType = 10;
pub const b3TypedConstraintType_B3_FIXED_CONSTRAINT_TYPE: b3TypedConstraintType = 11;
pub const b3TypedConstraintType_B3_MAX_CONSTRAINT_TYPE: b3TypedConstraintType = 12;
pub type b3TypedConstraintType = i32;
pub const b3ConstraintParams_B3_CONSTRAINT_ERP: b3ConstraintParams = 1;
pub const b3ConstraintParams_B3_CONSTRAINT_STOP_ERP: b3ConstraintParams = 2;
pub const b3ConstraintParams_B3_CONSTRAINT_CFM: b3ConstraintParams = 3;
pub const b3ConstraintParams_B3_CONSTRAINT_STOP_CFM: b3ConstraintParams = 4;
pub type b3ConstraintParams = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3JointFeedback {
    pub m_appliedForceBodyA: b3Vector3,
    pub m_appliedTorqueBodyA: b3Vector3,
    pub m_appliedForceBodyB: b3Vector3,
    pub m_appliedTorqueBodyB: b3Vector3,
}
#[repr(C)]
pub struct b3TypedConstraint__bindgen_vtable(::std::os::raw::c_void);
/// TypedConstraint is the baseclass for Bullet constraints and vehicles
#[repr(C)]
pub struct b3TypedConstraint {
    pub vtable_: *const b3TypedConstraint__bindgen_vtable,
    pub _base: b3TypedObject,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub __bindgen_anon_1: b3TypedConstraint__bindgen_ty_1,
    pub m_breakingImpulseThreshold: b3Scalar,
    pub m_isEnabled: bool,
    pub m_needsFeedback: bool,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_rbA: ::std::os::raw::c_int,
    pub m_rbB: ::std::os::raw::c_int,
    pub m_appliedImpulse: b3Scalar,
    pub m_dbgDrawSize: b3Scalar,
    pub m_jointFeedback: *mut b3JointFeedback,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3TypedConstraint__bindgen_ty_1 {
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_userConstraintPtr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraint_b3ConstraintInfo1 {
    pub m_numConstraintRows: ::std::os::raw::c_int,
    pub nub: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraint_b3ConstraintInfo2 {
    pub fps: b3Scalar,
    pub erp: b3Scalar,
    pub m_J1linearAxis: *mut b3Scalar,
    pub m_J1angularAxis: *mut b3Scalar,
    pub m_J2linearAxis: *mut b3Scalar,
    pub m_J2angularAxis: *mut b3Scalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut b3Scalar,
    pub cfm: *mut b3Scalar,
    pub m_lowerLimit: *mut b3Scalar,
    pub m_upperLimit: *mut b3Scalar,
    pub findex: *mut ::std::os::raw::c_int,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: b3Scalar,
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getMotorFactor@b3TypedConstraint@@IEAAMMMMMM@Z"]
    pub fn b3TypedConstraint_getMotorFactor(
        this: *mut b3TypedConstraint,
        pos: b3Scalar,
        lowLim: b3Scalar,
        uppLim: b3Scalar,
        vel: b3Scalar,
        timeFact: b3Scalar,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}??0b3TypedConstraint@@QEAA@W4b3TypedConstraintType@@HH@Z"]
    pub fn b3TypedConstraint_b3TypedConstraint(
        this: *mut b3TypedConstraint,
        type_: b3TypedConstraintType,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
    );
}
impl b3TypedConstraint {
    #[inline]
    pub unsafe fn getMotorFactor(
        &mut self,
        pos: b3Scalar,
        lowLim: b3Scalar,
        uppLim: b3Scalar,
        vel: b3Scalar,
        timeFact: b3Scalar,
    ) -> b3Scalar {
        b3TypedConstraint_getMotorFactor(self, pos, lowLim, uppLim, vel, timeFact)
    }
    #[inline]
    pub unsafe fn new(
        type_: b3TypedConstraintType,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3TypedConstraint_b3TypedConstraint(&mut __bindgen_tmp, type_, bodyA, bodyB);
        __bindgen_tmp
    }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraintData {
    pub m_bodyA: ::std::os::raw::c_int,
    pub m_bodyB: ::std::os::raw::c_int,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AngularLimit {
    pub m_center: b3Scalar,
    pub m_halfRange: b3Scalar,
    pub m_softness: b3Scalar,
    pub m_biasFactor: b3Scalar,
    pub m_relaxationFactor: b3Scalar,
    pub m_correction: b3Scalar,
    pub m_sign: b3Scalar,
    pub m_solveLimit: bool,
}
extern "C" {
    /// Sets all limit's parameters.
    /// /// When low > high limit becomes inactive.
    /// /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
    #[link_name = "\u{1}?set@b3AngularLimit@@QEAAXMMMMM@Z"]
    pub fn b3AngularLimit_set(
        this: *mut b3AngularLimit,
        low: b3Scalar,
        high: b3Scalar,
        _softness: b3Scalar,
        _biasFactor: b3Scalar,
        _relaxationFactor: b3Scalar,
    );
}
extern "C" {
    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// /// correction is calculated.
    #[link_name = "\u{1}?test@b3AngularLimit@@QEAAXM@Z"]
    pub fn b3AngularLimit_test(this: *mut b3AngularLimit, angle: b3Scalar);
}
extern "C" {
    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// /// returned is modified so it equals to the limit closest to given angle.
    #[link_name = "\u{1}?fit@b3AngularLimit@@QEBAXAEAM@Z"]
    pub fn b3AngularLimit_fit(this: *const b3AngularLimit, angle: *mut b3Scalar);
}
extern "C" {
    /// Returns correction value multiplied by sign value
    #[link_name = "\u{1}?getError@b3AngularLimit@@QEBAMXZ"]
    pub fn b3AngularLimit_getError(this: *const b3AngularLimit) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?getLow@b3AngularLimit@@QEBAMXZ"]
    pub fn b3AngularLimit_getLow(this: *const b3AngularLimit) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?getHigh@b3AngularLimit@@QEBAMXZ"]
    pub fn b3AngularLimit_getHigh(this: *const b3AngularLimit) -> b3Scalar;
}
impl b3AngularLimit {
    #[inline]
    pub unsafe fn set(
        &mut self,
        low: b3Scalar,
        high: b3Scalar,
        _softness: b3Scalar,
        _biasFactor: b3Scalar,
        _relaxationFactor: b3Scalar,
    ) {
        b3AngularLimit_set(self, low, high, _softness, _biasFactor, _relaxationFactor)
    }
    #[inline]
    pub unsafe fn test(&mut self, angle: b3Scalar) {
        b3AngularLimit_test(self, angle)
    }
    #[inline]
    pub unsafe fn fit(&self, angle: *mut b3Scalar) {
        b3AngularLimit_fit(self, angle)
    }
    #[inline]
    pub unsafe fn getError(&self) -> b3Scalar {
        b3AngularLimit_getError(self)
    }
    #[inline]
    pub unsafe fn getLow(&self) -> b3Scalar {
        b3AngularLimit_getLow(self)
    }
    #[inline]
    pub unsafe fn getHigh(&self) -> b3Scalar {
        b3AngularLimit_getHigh(self)
    }
}
#[repr(C)]
pub struct b3FixedConstraint {
    pub _base: b3TypedConstraint,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_relTargetAB: b3Quaternion,
}
extern "C" {
    #[link_name = "\u{1}??0b3FixedConstraint@@QEAA@HHAEBVb3Transform@@0@Z"]
    pub fn b3FixedConstraint_b3FixedConstraint(
        this: *mut b3FixedConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
    );
}
impl b3FixedConstraint {
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3FixedConstraint_b3FixedConstraint(&mut __bindgen_tmp, rbA, rbB, frameInA, frameInB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3FixedConstraint@@QEAAXXZ"]
    pub fn b3FixedConstraint_b3FixedConstraint_destructor(this: *mut b3FixedConstraint);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@b3FixedConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3FixedConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@b3FixedConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3FixedConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3JacobianEntry {
    pub m_linearJointAxis: b3Vector3,
    pub m_aJ: b3Vector3,
    pub m_bJ: b3Vector3,
    pub m_0MinvJt: b3Vector3,
    pub m_1MinvJt: b3Vector3,
    pub m_Adiag: b3Scalar,
    pub __bindgen_padding_0: [u32; 3usize],
}
/// ! Rotation Limit structure for generic joints
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RotationalLimitMotor {
    /// !< joint limit
    pub m_loLimit: b3Scalar,
    /// !< joint limit
    pub m_hiLimit: b3Scalar,
    /// !< target motor velocity
    pub m_targetVelocity: b3Scalar,
    /// !< max force on motor
    pub m_maxMotorForce: b3Scalar,
    /// !< max force on limit
    pub m_maxLimitForce: b3Scalar,
    /// !< Damping.
    pub m_damping: b3Scalar,
    pub m_limitSoftness: b3Scalar,
    /// !< Constraint force mixing factor
    pub m_normalCFM: b3Scalar,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: b3Scalar,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: b3Scalar,
    /// !< restitution factor
    pub m_bounce: b3Scalar,
    pub m_enableMotor: bool,
    /// ! temp_variables
    /// //!@{
    pub m_currentLimitError: b3Scalar,
    /// !  How much is violated this limit
    pub m_currentPosition: b3Scalar,
    /// !< 0=free, 1=at lo limit, 2=at hi limit
    pub m_currentLimit: ::std::os::raw::c_int,
    pub m_accumulatedImpulse: b3Scalar,
}
extern "C" {
    /// ! calculates  error
    /// /*!
    /// calculates m_currentLimit and m_currentLimitError.
    /// */
    #[link_name = "\u{1}?testLimitValue@b3RotationalLimitMotor@@QEAAHM@Z"]
    pub fn b3RotationalLimitMotor_testLimitValue(
        this: *mut b3RotationalLimitMotor,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ! apply the correction impulses for two bodies
    #[link_name = "\u{1}?solveAngularLimits@b3RotationalLimitMotor@@QEAAMMAEAVb3Vector3@@MPEAUb3RigidBodyData@@1@Z"]
    pub fn b3RotationalLimitMotor_solveAngularLimits(
        this: *mut b3RotationalLimitMotor,
        timeStep: b3Scalar,
        axis: *mut b3Vector3,
        jacDiagABInv: b3Scalar,
        body0: *mut b3RigidBodyData,
        body1: *mut b3RigidBodyData,
    ) -> b3Scalar;
}
impl b3RotationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: b3Scalar) -> ::std::os::raw::c_int {
        b3RotationalLimitMotor_testLimitValue(self, test_value)
    }
    #[inline]
    pub unsafe fn solveAngularLimits(
        &mut self,
        timeStep: b3Scalar,
        axis: *mut b3Vector3,
        jacDiagABInv: b3Scalar,
        body0: *mut b3RigidBodyData,
        body1: *mut b3RigidBodyData,
    ) -> b3Scalar {
        b3RotationalLimitMotor_solveAngularLimits(self, timeStep, axis, jacDiagABInv, body0, body1)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3TranslationalLimitMotor {
    /// !< the constraint lower limits
    pub m_lowerLimit: b3Vector3,
    /// !< the constraint upper limits
    pub m_upperLimit: b3Vector3,
    pub m_accumulatedImpulse: b3Vector3,
    /// !< Constraint force mixing factor
    pub m_normalCFM: b3Vector3,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: b3Vector3,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: b3Vector3,
    /// !< target motor velocity
    pub m_targetVelocity: b3Vector3,
    /// !< max force on motor
    pub m_maxMotorForce: b3Vector3,
    pub m_currentLimitError: b3Vector3,
    /// !  How much is violated this limit
    pub m_currentLinearDiff: b3Vector3,
    /// !< Softness for linear limit
    pub m_limitSoftness: b3Scalar,
    /// !< Damping for linear limit
    pub m_damping: b3Scalar,
    pub m_restitution: b3Scalar,
    /// ! Bounce parameter for linear limit
    /// //!@}
    pub m_enableMotor: [bool; 3usize],
    /// !< 0=free, 1=at lower limit, 2=at upper limit
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}?testLimitValue@b3TranslationalLimitMotor@@QEAAHHM@Z"]
    pub fn b3TranslationalLimitMotor_testLimitValue(
        this: *mut b3TranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?solveLinearAxis@b3TranslationalLimitMotor@@QEAAMMMAEAUb3RigidBodyData@@AEBVb3Vector3@@01H11@Z"]
    pub fn b3TranslationalLimitMotor_solveLinearAxis(
        this: *mut b3TranslationalLimitMotor,
        timeStep: b3Scalar,
        jacDiagABInv: b3Scalar,
        body1: *mut b3RigidBodyData,
        pointInA: *const b3Vector3,
        body2: *mut b3RigidBodyData,
        pointInB: *const b3Vector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const b3Vector3,
        anchorPos: *const b3Vector3,
    ) -> b3Scalar;
}
impl b3TranslationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int {
        b3TranslationalLimitMotor_testLimitValue(self, limitIndex, test_value)
    }
    #[inline]
    pub unsafe fn solveLinearAxis(
        &mut self,
        timeStep: b3Scalar,
        jacDiagABInv: b3Scalar,
        body1: *mut b3RigidBodyData,
        pointInA: *const b3Vector3,
        body2: *mut b3RigidBodyData,
        pointInB: *const b3Vector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const b3Vector3,
        anchorPos: *const b3Vector3,
    ) -> b3Scalar {
        b3TranslationalLimitMotor_solveLinearAxis(
            self,
            timeStep,
            jacDiagABInv,
            body1,
            pointInA,
            body2,
            pointInB,
            limit_index,
            axis_normal_on_a,
            anchorPos,
        )
    }
}
pub const b36DofFlags_B3_6DOF_FLAGS_CFM_NORM: b36DofFlags = 1;
pub const b36DofFlags_B3_6DOF_FLAGS_CFM_STOP: b36DofFlags = 2;
pub const b36DofFlags_B3_6DOF_FLAGS_ERP_STOP: b36DofFlags = 4;
pub type b36DofFlags = i32;
/// b3Generic6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// *!
/// b3Generic6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
/// currently this limit supports rotational motors<br>
/// <ul>
/// <li> For Linear limits, use b3Generic6DofConstraint.setLinearUpperLimit, b3Generic6DofConstraint.setLinearLowerLimit. You can set the parameters with the b3TranslationalLimitMotor structure accsesible through the b3Generic6DofConstraint.getTranslationalLimitMotor method.
/// At this moment translational motors are not supported. May be in the future. </li>
///
/// <li> For Angular limits, use the b3RotationalLimitMotor structure for configuring the limit.
/// This is accessible through b3Generic6DofConstraint.getLimitMotor method,
/// This brings support for limit parameters and motors. </li>
///
/// <li> Angulars limits have these possible ranges:
/// <table border=1 >
/// <tr>
/// <td><b>AXIS</b></td>
/// <td><b>MIN ANGLE</b></td>
/// <td><b>MAX ANGLE</b></td>
/// </tr><tr>
/// <td>X</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr><tr>
/// <td>Y</td>
/// <td>-PI/2</td>
/// <td>PI/2</td>
/// </tr><tr>
/// <td>Z</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr>
/// </table>
/// </li>
/// </ul>
///
/// */
#[repr(C)]
pub struct b3Generic6DofConstraint {
    pub _base: b3TypedConstraint,
    /// !< the constraint space w.r.t body A
    pub m_frameInA: b3Transform,
    /// !< the constraint space w.r.t body B
    pub m_frameInB: b3Transform,
    /// ! Linear_Limit_parameters
    /// //!@{
    pub m_linearLimits: b3TranslationalLimitMotor,
    /// ! hinge_parameters
    /// //!@{
    pub m_angularLimits: [b3RotationalLimitMotor; 3usize],
    /// ! temporal variables
    /// //!@{
    pub m_calculatedTransformA: b3Transform,
    pub m_calculatedTransformB: b3Transform,
    pub m_calculatedAxisAngleDiff: b3Vector3,
    pub m_calculatedAxis: [b3Vector3; 3usize],
    pub m_calculatedLinearDiff: b3Vector3,
    pub m_timeStep: b3Scalar,
    pub m_factA: b3Scalar,
    pub m_factB: b3Scalar,
    pub m_hasStaticBody: bool,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_AnchorPos: b3Vector3,
    pub m_useLinearReferenceFrameA: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_flags: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}?setAngularLimits@b3Generic6DofConstraint@@IEAAHPEAUb3ConstraintInfo2@b3TypedConstraint@@HAEBVb3Transform@@1AEBVb3Vector3@@222@Z"]
    pub fn b3Generic6DofConstraint_setAngularLimits(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setLinearLimits@b3Generic6DofConstraint@@IEAAHPEAUb3ConstraintInfo2@b3TypedConstraint@@HAEBVb3Transform@@1AEBVb3Vector3@@222@Z"]
    pub fn b3Generic6DofConstraint_setLinearLimits(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?calculateLinearInfo@b3Generic6DofConstraint@@IEAAXXZ"]
    pub fn b3Generic6DofConstraint_calculateLinearInfo(this: *mut b3Generic6DofConstraint);
}
extern "C" {
    /// ! calcs the euler angles between the two bodies.
    #[link_name = "\u{1}?calculateAngleInfo@b3Generic6DofConstraint@@IEAAXXZ"]
    pub fn b3Generic6DofConstraint_calculateAngleInfo(this: *mut b3Generic6DofConstraint);
}
extern "C" {
    /// ! Calcs global transform of the offsets
    /// /*!
    /// Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    /// \sa b3Generic6DofConstraint.getCalculatedTransformA , b3Generic6DofConstraint.getCalculatedTransformB, b3Generic6DofConstraint.calculateAngleInfo
    /// */
    #[link_name = "\u{1}?calculateTransforms@b3Generic6DofConstraint@@QEAAXAEBVb3Transform@@0PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_calculateTransforms(
        this: *mut b3Generic6DofConstraint,
        transA: *const b3Transform,
        transB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTransforms@b3Generic6DofConstraint@@QEAAXPEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_calculateTransforms1(
        this: *mut b3Generic6DofConstraint,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@b3Generic6DofConstraint@@QEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_getInfo1NonVirtual(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@b3Generic6DofConstraint@@QEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@AEBVb3Transform@@1AEBVb3Vector3@@222PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_getInfo2NonVirtual(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@b3Generic6DofConstraint@@QEAAXM@Z"]
    pub fn b3Generic6DofConstraint_updateRHS(
        this: *mut b3Generic6DofConstraint,
        timeStep: b3Scalar,
    );
}
extern "C" {
    /// ! Get the rotation axis in global coordinates
    #[link_name = "\u{1}?getAxis@b3Generic6DofConstraint@@QEBA?AVb3Vector3@@H@Z"]
    pub fn b3Generic6DofConstraint_getAxis(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Vector3;
}
extern "C" {
    /// ! Get the relative Euler angle
    /// /*!
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?getAngle@b3Generic6DofConstraint@@QEBAMH@Z"]
    pub fn b3Generic6DofConstraint_getAngle(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
extern "C" {
    /// ! Get the relative position of the constraint pivot
    /// /*!
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?getRelativePivotPosition@b3Generic6DofConstraint@@QEBAMH@Z"]
    pub fn b3Generic6DofConstraint_getRelativePivotPosition(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?setFrames@b3Generic6DofConstraint@@QEAAXAEBVb3Transform@@0PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_setFrames(
        this: *mut b3Generic6DofConstraint,
        frameA: *const b3Transform,
        frameB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// ! Test angular limit.
    /// /*!
    /// Calculates angular correction and returns true if limit needs to be corrected.
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?testAngularLimitMotor@b3Generic6DofConstraint@@QEAA_NH@Z"]
    pub fn b3Generic6DofConstraint_testAngularLimitMotor(
        this: *mut b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get_limit_motor_info2@b3Generic6DofConstraint@@QEAAHPEAVb3RotationalLimitMotor@@AEBVb3Transform@@1AEBVb3Vector3@@222PEAUb3ConstraintInfo2@b3TypedConstraint@@HAEAV4@HH@Z"]
    pub fn b3Generic6DofConstraint_get_limit_motor_info2(
        this: *mut b3Generic6DofConstraint,
        limot: *mut b3RotationalLimitMotor,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut b3Vector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setAxis@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@0PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_setAxis(
        this: *mut b3Generic6DofConstraint,
        axis1: *const b3Vector3,
        axis2: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3Generic6DofConstraint@@QEAA@HHAEBVb3Transform@@0_NPEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_b3Generic6DofConstraint(
        this: *mut b3Generic6DofConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
        useLinearReferenceFrameA: bool,
        bodies: *const b3RigidBodyData,
    );
}
impl b3Generic6DofConstraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_setAngularLimits(
            self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_setLinearLimits(
            self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        b3Generic6DofConstraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        b3Generic6DofConstraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const b3Transform,
        transB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_calculateTransforms(self, transA, transB, bodies)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self, bodies: *const b3RigidBodyData) {
        b3Generic6DofConstraint_calculateTransforms1(self, bodies)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_getInfo1NonVirtual(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_getInfo2NonVirtual(
            self, info, transA, transB, linVelA, linVelB, angVelA, angVelB, bodies,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: b3Scalar) {
        b3Generic6DofConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> b3Vector3 {
        b3Generic6DofConstraint_getAxis(self, axis_index)
    }
    #[inline]
    pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> b3Scalar {
        b3Generic6DofConstraint_getAngle(self, axis_index)
    }
    #[inline]
    pub unsafe fn getRelativePivotPosition(&self, axis_index: ::std::os::raw::c_int) -> b3Scalar {
        b3Generic6DofConstraint_getRelativePivotPosition(self, axis_index)
    }
    #[inline]
    pub unsafe fn setFrames(
        &mut self,
        frameA: *const b3Transform,
        frameB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_setFrames(self, frameA, frameB, bodies)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) -> bool {
        b3Generic6DofConstraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut b3RotationalLimitMotor,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut b3Vector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_get_limit_motor_info2(
            self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
            rotational, rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn setAxis(
        &mut self,
        axis1: *const b3Vector3,
        axis2: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_setAxis(self, axis1, axis2, bodies)
    }
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
        useLinearReferenceFrameA: bool,
        bodies: *const b3RigidBodyData,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Generic6DofConstraint_b3Generic6DofConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
            bodies,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@b3Generic6DofConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@b3Generic6DofConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?calcAnchorPos@b3Generic6DofConstraint@@UEAAXPEBUb3RigidBodyData@@@Z"]
    pub fn b3Generic6DofConstraint_calcAnchorPos(
        this: *mut ::std::os::raw::c_void,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@b3Generic6DofConstraint@@UEAAXHMH@Z"]
    pub fn b3Generic6DofConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: b3Scalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@b3Generic6DofConstraint@@UEBAMHH@Z"]
    pub fn b3Generic6DofConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactPoint {
    _unused: [u8; 0],
}
pub const b3SolverMode_B3_SOLVER_RANDMIZE_ORDER: b3SolverMode = 1;
pub const b3SolverMode_B3_SOLVER_FRICTION_SEPARATE: b3SolverMode = 2;
pub const b3SolverMode_B3_SOLVER_USE_WARMSTARTING: b3SolverMode = 4;
pub const b3SolverMode_B3_SOLVER_USE_2_FRICTION_DIRECTIONS: b3SolverMode = 16;
pub const b3SolverMode_B3_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING: b3SolverMode = 32;
pub const b3SolverMode_B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION: b3SolverMode = 64;
pub const b3SolverMode_B3_SOLVER_CACHE_FRIENDLY: b3SolverMode = 128;
pub const b3SolverMode_B3_SOLVER_SIMD: b3SolverMode = 256;
pub const b3SolverMode_B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: b3SolverMode = 512;
pub const b3SolverMode_B3_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: b3SolverMode = 1024;
pub type b3SolverMode = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoData {
    pub m_tau: b3Scalar,
    pub m_damping: b3Scalar,
    pub m_friction: b3Scalar,
    pub m_timeStep: b3Scalar,
    pub m_restitution: b3Scalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_maxErrorReduction: b3Scalar,
    pub m_sor: b3Scalar,
    pub m_erp: b3Scalar,
    pub m_erp2: b3Scalar,
    pub m_globalCfm: b3Scalar,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_splitImpulsePenetrationThreshold: b3Scalar,
    pub m_splitImpulseTurnErp: b3Scalar,
    pub m_linearSlop: b3Scalar,
    pub m_warmstartingFactor: b3Scalar,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_maxGyroscopicForce: b3Scalar,
    pub m_singleAxisRollingFrictionThreshold: b3Scalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfo {
    pub _base: b3ContactSolverInfoData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoDoubleData {
    pub m_tau: f64,
    pub m_damping: f64,
    pub m_friction: f64,
    pub m_timeStep: f64,
    pub m_restitution: f64,
    pub m_maxErrorReduction: f64,
    pub m_sor: f64,
    pub m_erp: f64,
    pub m_erp2: f64,
    pub m_globalCfm: f64,
    pub m_splitImpulsePenetrationThreshold: f64,
    pub m_splitImpulseTurnErp: f64,
    pub m_linearSlop: f64,
    pub m_warmstartingFactor: f64,
    pub m_maxGyroscopicForce: f64,
    pub m_singleAxisRollingFrictionThreshold: f64,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoFloatData {
    pub m_tau: f32,
    pub m_damping: f32,
    pub m_friction: f32,
    pub m_timeStep: f32,
    pub m_restitution: f32,
    pub m_maxErrorReduction: f32,
    pub m_sor: f32,
    pub m_erp: f32,
    pub m_erp2: f32,
    pub m_globalCfm: f32,
    pub m_splitImpulsePenetrationThreshold: f32,
    pub m_splitImpulseTurnErp: f32,
    pub m_linearSlop: f32,
    pub m_warmstartingFactor: f32,
    pub m_maxGyroscopicForce: f32,
    pub m_singleAxisRollingFrictionThreshold: f32,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
pub struct b3PgsJacobiSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3PgsJacobiSolver {
    pub vtable_: *const b3PgsJacobiSolver__bindgen_vtable,
    pub m_tmpSolverBodyPool: b3AlignedObjectArray<b3SolverBody>,
    pub m_tmpSolverContactConstraintPool: b3ConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: b3ConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: b3ConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: b3ConstraintArray,
    pub m_orderTmpConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderNonContactConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderFrictionConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_tmpConstraintSizesPool: b3AlignedObjectArray<b3TypedConstraint_b3ConstraintInfo1>,
    pub m_bodyCount: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_bodyCountCheck: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_deltaLinearVelocities: b3AlignedObjectArray<b3Vector3>,
    pub m_deltaAngularVelocities: b3AlignedObjectArray<b3Vector3>,
    pub m_usePgs: bool,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_numSplitImpulseRecoveries: ::std::os::raw::c_int,
    /// m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    pub m_btSeed2: ::std::os::raw::c_ulong,
}
extern "C" {
    #[link_name = "\u{1}?averageVelocities@b3PgsJacobiSolver@@IEAAXXZ"]
    pub fn b3PgsJacobiSolver_averageVelocities(this: *mut b3PgsJacobiSolver);
}
extern "C" {
    #[link_name = "\u{1}?setupFrictionConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@AEBVb3Vector3@@HHAEAUb3ContactPoint@@3300MMM@Z"]
    pub fn b3PgsJacobiSolver_setupFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupRollingFrictionConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@AEBVb3Vector3@@HHAEAUb3ContactPoint@@3300MMM@Z"]
    pub fn b3PgsJacobiSolver_setupRollingFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?addFrictionConstraint@b3PgsJacobiSolver@@IEAAAEAUb3SolverConstraint@@PEAUb3RigidBodyData@@PEAUb3InertiaData@@AEBVb3Vector3@@HHHAEAUb3ContactPoint@@2200MMM@Z"]
    pub fn b3PgsJacobiSolver_addFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?addRollingFrictionConstraint@b3PgsJacobiSolver@@IEAAAEAUb3SolverConstraint@@PEAUb3RigidBodyData@@PEAUb3InertiaData@@AEBVb3Vector3@@HHHAEAUb3ContactPoint@@2200MMM@Z"]
    pub fn b3PgsJacobiSolver_addRollingFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?setupContactConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@HHAEAUb3ContactPoint@@AEBUb3ContactSolverInfo@@AEAVb3Vector3@@AEAM655@Z"]
    pub fn b3PgsJacobiSolver_setupContactConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
        vel: *mut b3Vector3,
        rel_vel: *mut b3Scalar,
        relaxation: *mut b3Scalar,
        rel_pos1: *mut b3Vector3,
        rel_pos2: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFrictionConstraintImpulse@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@HHAEAUb3ContactPoint@@AEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_setFrictionConstraintImpulse(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?restitutionCurve@b3PgsJacobiSolver@@IEAAMMM@Z"]
    pub fn b3PgsJacobiSolver_restitutionCurve(
        this: *mut b3PgsJacobiSolver,
        rel_vel: b3Scalar,
        restitution: b3Scalar,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?convertContact@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@PEAUb3Contact4@@AEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_convertContact(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        manifold: *mut b3Contact4,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSplitPenetrationSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSplitPenetrationSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSplitPenetrationImpulseCacheFriendly@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSplitPenetrationImpulseCacheFriendly(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOrInitSolverBody@b3PgsJacobiSolver@@IEAAHHPEAUb3RigidBodyData@@PEAUb3InertiaData@@@Z"]
    pub fn b3PgsJacobiSolver_getOrInitSolverBody(
        this: *mut b3PgsJacobiSolver,
        bodyIndex: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?initSolverBody@b3PgsJacobiSolver@@IEAAXHPEAUb3SolverBody@@PEAUb3RigidBodyData@@@Z"]
    pub fn b3PgsJacobiSolver_initSolverBody(
        this: *mut b3PgsJacobiSolver,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3SolverBody,
        collisionObject: *mut b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowGeneric@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowGeneric(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowGenericSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowGenericSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowLowerLimit@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimit(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowLowerLimitSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimitSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveSingleIteration@b3PgsJacobiSolver@@IEAAMHPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveSingleIteration(
        this: *mut b3PgsJacobiSolver,
        iteration: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveContacts@b3PgsJacobiSolver@@QEAAXHPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@@Z"]
    pub fn b3PgsJacobiSolver_solveContacts(
        this: *mut b3PgsJacobiSolver,
        numBodies: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numContacts: ::std::os::raw::c_int,
        contacts: *mut b3Contact4,
        numConstraints: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroup@b3PgsJacobiSolver@@QEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveGroup(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?b3Rand2@b3PgsJacobiSolver@@QEAAKXZ"]
    pub fn b3PgsJacobiSolver_b3Rand2(this: *mut b3PgsJacobiSolver) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?b3RandInt2@b3PgsJacobiSolver@@QEAAHH@Z"]
    pub fn b3PgsJacobiSolver_b3RandInt2(
        this: *mut b3PgsJacobiSolver,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}??0b3PgsJacobiSolver@@QEAA@_N@Z"]
    pub fn b3PgsJacobiSolver_b3PgsJacobiSolver(this: *mut b3PgsJacobiSolver, usePgs: bool);
}
impl b3PgsJacobiSolver {
    #[inline]
    pub unsafe fn averageVelocities(&mut self) {
        b3PgsJacobiSolver_averageVelocities(self)
    }
    #[inline]
    pub unsafe fn setupFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) {
        b3PgsJacobiSolver_setupFrictionConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupRollingFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) {
        b3PgsJacobiSolver_setupRollingFrictionConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint {
        b3PgsJacobiSolver_addFrictionConstraint(
            self,
            bodies,
            inertias,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addRollingFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint {
        b3PgsJacobiSolver_addRollingFrictionConstraint(
            self,
            bodies,
            inertias,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupContactConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
        vel: *mut b3Vector3,
        rel_vel: *mut b3Scalar,
        relaxation: *mut b3Scalar,
        rel_pos1: *mut b3Vector3,
        rel_pos2: *mut b3Vector3,
    ) {
        b3PgsJacobiSolver_setupContactConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
            vel,
            rel_vel,
            relaxation,
            rel_pos1,
            rel_pos2,
        )
    }
    #[inline]
    pub unsafe fn setFrictionConstraintImpulse(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
    ) {
        b3PgsJacobiSolver_setFrictionConstraintImpulse(
            self,
            bodies,
            inertias,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn restitutionCurve(
        &mut self,
        rel_vel: b3Scalar,
        restitution: b3Scalar,
    ) -> b3Scalar {
        b3PgsJacobiSolver_restitutionCurve(self, rel_vel, restitution)
    }
    #[inline]
    pub unsafe fn convertContact(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        manifold: *mut b3Contact4,
        infoGlobal: *const b3ContactSolverInfo,
    ) {
        b3PgsJacobiSolver_convertContact(self, bodies, inertias, manifold, infoGlobal)
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSplitPenetrationSIMD(self, bodyA, bodyB, contactConstraint)
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationImpulseCacheFriendly(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSplitPenetrationImpulseCacheFriendly(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn getOrInitSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
    ) -> ::std::os::raw::c_int {
        b3PgsJacobiSolver_getOrInitSolverBody(self, bodyIndex, bodies, inertias)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3SolverBody,
        collisionObject: *mut b3RigidBodyData,
    ) {
        b3PgsJacobiSolver_initSolverBody(self, bodyIndex, solverBody, collisionObject)
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGeneric(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowGeneric(self, bodyA, bodyB, contactConstraint)
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGenericSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowGenericSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimit(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimit(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimitSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimitSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn solveSingleIteration(
        &mut self,
        iteration: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3PgsJacobiSolver_solveSingleIteration(
            self,
            iteration,
            constraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numContacts: ::std::os::raw::c_int,
        contacts: *mut b3Contact4,
        numConstraints: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
    ) {
        b3PgsJacobiSolver_solveContacts(
            self,
            numBodies,
            bodies,
            inertias,
            numContacts,
            contacts,
            numConstraints,
            constraints,
        )
    }
    #[inline]
    pub unsafe fn solveGroup(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3PgsJacobiSolver_solveGroup(
            self,
            bodies,
            inertias,
            numBodies,
            manifoldPtr,
            numManifolds,
            constraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn b3Rand2(&mut self) -> ::std::os::raw::c_ulong {
        b3PgsJacobiSolver_b3Rand2(self)
    }
    #[inline]
    pub unsafe fn b3RandInt2(&mut self, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        b3PgsJacobiSolver_b3RandInt2(self, n)
    }
    #[inline]
    pub unsafe fn new(usePgs: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3PgsJacobiSolver_b3PgsJacobiSolver(&mut __bindgen_tmp, usePgs);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@b3PgsJacobiSolver@@MEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyIterations@b3PgsJacobiSolver@@MEAAMPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySplitImpulseIterations@b3PgsJacobiSolver@@MEAAXPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlySplitImpulseIterations(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@b3PgsJacobiSolver@@MEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}??_Db3PgsJacobiSolver@@QEAAXXZ"]
    pub fn b3PgsJacobiSolver_b3PgsJacobiSolver_destructor(this: *mut b3PgsJacobiSolver);
}
extern "C" {
    /// clear internal cached data and reset random seed
    #[link_name = "\u{1}?reset@b3PgsJacobiSolver@@UEAAXXZ"]
    pub fn b3PgsJacobiSolver_reset(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RigidBody {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ConstraintSetting {
    pub m_tau: b3Scalar,
    pub m_damping: b3Scalar,
    pub m_impulseClamp: b3Scalar,
}
pub const b3Point2PointFlags_B3_P2P_FLAGS_ERP: b3Point2PointFlags = 1;
pub const b3Point2PointFlags_B3_P2P_FLAGS_CFM: b3Point2PointFlags = 2;
pub type b3Point2PointFlags = i32;
/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
#[repr(C)]
pub struct b3Point2PointConstraint {
    pub _base: b3TypedConstraint,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_erp: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_setting: b3ConstraintSetting,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@b3Point2PointConstraint@@QEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Point2PointConstraint_getInfo1NonVirtual(
        this: *mut b3Point2PointConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@b3Point2PointConstraint@@QEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@AEBVb3Transform@@1@Z"]
    pub fn b3Point2PointConstraint_getInfo2NonVirtual(
        this: *mut b3Point2PointConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        body0_trans: *const b3Transform,
        body1_trans: *const b3Transform,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@b3Point2PointConstraint@@QEAAXM@Z"]
    pub fn b3Point2PointConstraint_updateRHS(
        this: *mut b3Point2PointConstraint,
        timeStep: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3Point2PointConstraint@@QEAA@HHAEBVb3Vector3@@0@Z"]
    pub fn b3Point2PointConstraint_b3Point2PointConstraint(
        this: *mut b3Point2PointConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        pivotInA: *const b3Vector3,
        pivotInB: *const b3Vector3,
    );
}
impl b3Point2PointConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    ) {
        b3Point2PointConstraint_getInfo1NonVirtual(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        body0_trans: *const b3Transform,
        body1_trans: *const b3Transform,
    ) {
        b3Point2PointConstraint_getInfo2NonVirtual(self, info, body0_trans, body1_trans)
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: b3Scalar) {
        b3Point2PointConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        pivotInA: *const b3Vector3,
        pivotInB: *const b3Vector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Point2PointConstraint_b3Point2PointConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@b3Point2PointConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Point2PointConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@b3Point2PointConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3Point2PointConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@b3Point2PointConstraint@@UEAAXHMH@Z"]
    pub fn b3Point2PointConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: b3Scalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@b3Point2PointConstraint@@UEBAMHH@Z"]
    pub fn b3Point2PointConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Point2PointConstraintFloatData {
    pub m_typeConstraintData: b3TypedConstraintData,
    pub m_pivotInA: b3Vector3FloatData,
    pub m_pivotInB: b3Vector3FloatData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Point2PointConstraintDoubleData {
    pub m_typeConstraintData: b3TypedConstraintData,
    pub m_pivotInA: b3Vector3DoubleData,
    pub m_pivotInB: b3Vector3DoubleData,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RayInfo {
    pub m_from: b3Vector3,
    pub m_to: b3Vector3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RayHit {
    pub m_hitFraction: b3Scalar,
    pub m_hitBody: ::std::os::raw::c_int,
    pub m_hitResult1: ::std::os::raw::c_int,
    pub m_hitResult2: ::std::os::raw::c_int,
    pub m_hitPoint: b3Vector3,
    pub m_hitNormal: b3Vector3,
}
#[repr(C)]
pub struct b3CpuRigidBodyPipeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3CpuRigidBodyPipeline {
    pub vtable_: *const b3CpuRigidBodyPipeline__bindgen_vtable,
    pub m_data: *mut b3CpuRigidBodyPipelineInternalData,
}
extern "C" {
    #[link_name = "\u{1}?allocateCollidable@b3CpuRigidBodyPipeline@@IEAAHXZ"]
    pub fn b3CpuRigidBodyPipeline_allocateCollidable(
        this: *mut b3CpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConvexPolyhedron@b3CpuRigidBodyPipeline@@QEAAHPEAVb3ConvexUtility@@@Z"]
    pub fn b3CpuRigidBodyPipeline_registerConvexPolyhedron(
        this: *mut b3CpuRigidBodyPipeline,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerPhysicsInstance@b3CpuRigidBodyPipeline@@QEAAHMPEBM0HH@Z"]
    pub fn b3CpuRigidBodyPipeline_registerPhysicsInstance(
        this: *mut b3CpuRigidBodyPipeline,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?writeAllInstancesToGpu@b3CpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_writeAllInstancesToGpu(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?copyConstraintsToHost@b3CpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_copyConstraintsToHost(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?setGravity@b3CpuRigidBodyPipeline@@QEAAXPEBM@Z"]
    pub fn b3CpuRigidBodyPipeline_setGravity(this: *mut b3CpuRigidBodyPipeline, grav: *const f32);
}
extern "C" {
    #[link_name = "\u{1}?reset@b3CpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_reset(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?createPoint2PointConstraint@b3CpuRigidBodyPipeline@@QEAAHHHPEBM0M@Z"]
    pub fn b3CpuRigidBodyPipeline_createPoint2PointConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createFixedConstraint@b3CpuRigidBodyPipeline@@QEAAHHHPEBM00M@Z"]
    pub fn b3CpuRigidBodyPipeline_createFixedConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?removeConstraintByUid@b3CpuRigidBodyPipeline@@QEAAXH@Z"]
    pub fn b3CpuRigidBodyPipeline_removeConstraintByUid(
        this: *mut b3CpuRigidBodyPipeline,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addConstraint@b3CpuRigidBodyPipeline@@QEAAXPEAVb3TypedConstraint@@@Z"]
    pub fn b3CpuRigidBodyPipeline_addConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeConstraint@b3CpuRigidBodyPipeline@@QEAAXPEAVb3TypedConstraint@@@Z"]
    pub fn b3CpuRigidBodyPipeline_removeConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?castRays@b3CpuRigidBodyPipeline@@QEAAXAEBV?$b3AlignedObjectArray@Ub3RayInfo@@@@AEAV?$b3AlignedObjectArray@Ub3RayHit@@@@@Z"]
    pub fn b3CpuRigidBodyPipeline_castRays(
        this: *mut b3CpuRigidBodyPipeline,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBodyBuffer@b3CpuRigidBodyPipeline@@QEBAPEBUb3RigidBodyData@@XZ"]
    pub fn b3CpuRigidBodyPipeline_getBodyBuffer(
        this: *const b3CpuRigidBodyPipeline,
    ) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodies@b3CpuRigidBodyPipeline@@QEBAHXZ"]
    pub fn b3CpuRigidBodyPipeline_getNumBodies(
        this: *const b3CpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}??0b3CpuRigidBodyPipeline@@QEAA@PEAVb3CpuNarrowPhase@@PEAUb3DynamicBvhBroadphase@@AEBUb3Config@@@Z"]
    pub fn b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline(
        this: *mut b3CpuRigidBodyPipeline,
        narrowphase: *mut b3CpuNarrowPhase,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    );
}
impl b3CpuRigidBodyPipeline {
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn registerConvexPolyhedron(
        &mut self,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_registerConvexPolyhedron(self, convex)
    }
    #[inline]
    pub unsafe fn registerPhysicsInstance(
        &mut self,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_registerPhysicsInstance(
            self,
            mass,
            position,
            orientation,
            collisionShapeIndex,
            userData,
        )
    }
    #[inline]
    pub unsafe fn writeAllInstancesToGpu(&mut self) {
        b3CpuRigidBodyPipeline_writeAllInstancesToGpu(self)
    }
    #[inline]
    pub unsafe fn copyConstraintsToHost(&mut self) {
        b3CpuRigidBodyPipeline_copyConstraintsToHost(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, grav: *const f32) {
        b3CpuRigidBodyPipeline_setGravity(self, grav)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3CpuRigidBodyPipeline_reset(self)
    }
    #[inline]
    pub unsafe fn createPoint2PointConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_createPoint2PointConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn createFixedConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_createFixedConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            relTargetAB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn removeConstraintByUid(&mut self, uid: ::std::os::raw::c_int) {
        b3CpuRigidBodyPipeline_removeConstraintByUid(self, uid)
    }
    #[inline]
    pub unsafe fn addConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3CpuRigidBodyPipeline_addConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn removeConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3CpuRigidBodyPipeline_removeConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    ) {
        b3CpuRigidBodyPipeline_castRays(self, rays, hitResults)
    }
    #[inline]
    pub unsafe fn getBodyBuffer(&self) -> *const b3RigidBodyData {
        b3CpuRigidBodyPipeline_getBodyBuffer(self)
    }
    #[inline]
    pub unsafe fn getNumBodies(&self) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_getNumBodies(self)
    }
    #[inline]
    pub unsafe fn new(
        narrowphase: *mut b3CpuNarrowPhase,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline(
            &mut __bindgen_tmp,
            narrowphase,
            broadphaseDbvt,
            config,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3CpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline_destructor(
        this: *mut b3CpuRigidBodyPipeline,
    );
}
extern "C" {
    #[link_name = "\u{1}?stepSimulation@b3CpuRigidBodyPipeline@@UEAAXM@Z"]
    pub fn b3CpuRigidBodyPipeline_stepSimulation(this: *mut ::std::os::raw::c_void, deltaTime: f32);
}
extern "C" {
    #[link_name = "\u{1}?integrate@b3CpuRigidBodyPipeline@@UEAAXM@Z"]
    pub fn b3CpuRigidBodyPipeline_integrate(this: *mut ::std::os::raw::c_void, timeStep: f32);
}
extern "C" {
    #[link_name = "\u{1}?updateAabbWorldSpace@b3CpuRigidBodyPipeline@@UEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_updateAabbWorldSpace(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?computeOverlappingPairs@b3CpuRigidBodyPipeline@@UEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_computeOverlappingPairs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?computeContactPoints@b3CpuRigidBodyPipeline@@UEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_computeContactPoints(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?solveContactConstraints@b3CpuRigidBodyPipeline@@UEAAXXZ"]
    pub fn b3CpuRigidBodyPipeline_solveContactConstraints(this: *mut ::std::os::raw::c_void);
}
pub type b3ContactConstraint4_t = b3ContactConstraint4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ContactConstraint4 {
    pub m_linear: b3Vector3,
    pub m_worldPos: [b3Vector3; 4usize],
    pub m_center: b3Vector3,
    pub m_jacCoeffInv: [f32; 4usize],
    pub m_b: [f32; 4usize],
    pub m_appliedRambdaDt: [f32; 4usize],
    pub m_fJacCoeffInv: [f32; 2usize],
    pub m_fAppliedRambdaDt: [f32; 2usize],
    pub m_bodyA: ::std::os::raw::c_uint,
    pub m_bodyB: ::std::os::raw::c_uint,
    pub m_batchIdx: ::std::os::raw::c_int,
    pub m_paddings: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}?b3PlaneSpace1@@YAXAEBVb3Vector3@@PEAV1@1@Z"]
    pub fn b3PlaneSpace1(n: *const b3Vector3, p: *mut b3Vector3, q: *mut b3Vector3);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Inertia {
    pub m_invInertiaWorld: b3Matrix3x3,
    pub m_initInvInertia: b3Matrix3x3,
}
/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
#[repr(C)]
pub struct b3ConvexHullComputer {
    pub vertices: b3AlignedObjectArray<b3Vector3>,
    pub edges: b3AlignedObjectArray<b3ConvexHullComputer_Edge>,
    pub faces: b3AlignedObjectArray<::std::os::raw::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ConvexHullComputer_Edge {
    pub next: ::std::os::raw::c_int,
    pub reverse: ::std::os::raw::c_int,
    pub targetVertex: ::std::os::raw::c_int,
}
/// The b3GeometryUtil helper class provides a few methods to convert between plane equations and vertices.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GeometryUtil {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?getPlaneEquationsFromVertices@b3GeometryUtil@@SAXAEAV?$b3AlignedObjectArray@Vb3Vector3@@@@0@Z"]
    pub fn b3GeometryUtil_getPlaneEquationsFromVertices(
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        planeEquationsOut: *mut b3AlignedObjectArray<b3Vector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVerticesFromPlaneEquations@b3GeometryUtil@@SAXAEBV?$b3AlignedObjectArray@Vb3Vector3@@@@AEAV2@@Z"]
    pub fn b3GeometryUtil_getVerticesFromPlaneEquations(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        verticesOut: *mut b3AlignedObjectArray<b3Vector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?isInside@b3GeometryUtil@@SA_NAEBV?$b3AlignedObjectArray@Vb3Vector3@@@@AEBVb3Vector3@@M@Z"]
    pub fn b3GeometryUtil_isInside(
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        planeNormal: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?isPointInsidePlanes@b3GeometryUtil@@SA_NAEBV?$b3AlignedObjectArray@Vb3Vector3@@@@AEBVb3Vector3@@M@Z"]
    pub fn b3GeometryUtil_isPointInsidePlanes(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        point: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?areVerticesBehindPlane@b3GeometryUtil@@SA_NAEBVb3Vector3@@AEBV?$b3AlignedObjectArray@Vb3Vector3@@@@M@Z"]
    pub fn b3GeometryUtil_areVerticesBehindPlane(
        planeNormal: *const b3Vector3,
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        margin: b3Scalar,
    ) -> bool;
}
impl b3GeometryUtil {
    #[inline]
    pub unsafe fn getPlaneEquationsFromVertices(
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        planeEquationsOut: *mut b3AlignedObjectArray<b3Vector3>,
    ) {
        b3GeometryUtil_getPlaneEquationsFromVertices(vertices, planeEquationsOut)
    }
    #[inline]
    pub unsafe fn getVerticesFromPlaneEquations(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        verticesOut: *mut b3AlignedObjectArray<b3Vector3>,
    ) {
        b3GeometryUtil_getVerticesFromPlaneEquations(planeEquations, verticesOut)
    }
    #[inline]
    pub unsafe fn isInside(
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        planeNormal: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_isInside(vertices, planeNormal, margin)
    }
    #[inline]
    pub unsafe fn isPointInsidePlanes(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        point: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_isPointInsidePlanes(planeEquations, point, margin)
    }
    #[inline]
    pub unsafe fn areVerticesBehindPlane(
        planeNormal: *const b3Vector3,
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_areVerticesBehindPlane(planeNormal, vertices, margin)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GrahamVector3 {
    pub _base: b3Vector3,
    pub m_angle: b3Scalar,
    pub m_orgIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3AngleCompareFunc {
    pub m_anchor: b3Vector3,
}
pub type cl_int = ::std::os::raw::c_int;
pub type cl_uint = ::std::os::raw::c_uint;
pub type cl_long = ::std::os::raw::c_longlong;
pub type cl_ulong = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_platform_id {
    _unused: [u8; 0],
}

pub type cl_platform_id = *mut _cl_platform_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_device_id {
    _unused: [u8; 0],
}
pub type cl_device_id = *mut _cl_device_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_context {
    _unused: [u8; 0],
}
pub type cl_context = *mut _cl_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_command_queue {
    _unused: [u8; 0],
}
pub type cl_command_queue = *mut _cl_command_queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_mem {
    _unused: [u8; 0],
}
pub type cl_mem = *mut _cl_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_program {
    _unused: [u8; 0],
}
pub type cl_program = *mut _cl_program;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_kernel {
    _unused: [u8; 0],
}
pub type cl_kernel = *mut _cl_kernel;
pub type cl_bool = cl_uint;
pub type cl_bitfield = cl_ulong;
pub type cl_device_type = cl_bitfield;
pub type cl_device_local_mem_type = cl_uint;
pub type cl_command_queue_properties = cl_bitfield;
/// just make sure that the b3Aabb is 16-byte aligned
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SapAabb {
    pub _base: b3Aabb,
}
#[repr(C)]
pub struct b3OpenCLArray__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OpenCLArray {
    pub vtable_: *const b3OpenCLArray__bindgen_vtable,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_clBuffer: cl_mem,
    pub m_clContext: cl_context,
    pub m_commandQueue: cl_command_queue,
    pub m_ownsMemory: bool,
    pub m_allowGrowingCapacity: bool,
}
#[repr(C)]
pub struct b3GpuBroadphaseInterface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuBroadphaseInterface {
    pub vtable_: *const b3GpuBroadphaseInterface__bindgen_vtable,
}
pub type b3GpuBroadphaseInterface_CreateFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: cl_context, device: cl_device_id, q: cl_command_queue)
        -> *mut b3GpuBroadphaseInterface,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SortData {
    pub __bindgen_anon_1: b3SortData__bindgen_ty_1,
    pub __bindgen_anon_2: b3SortData__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SortData__bindgen_ty_1 {
    pub m_key: ::std::os::raw::c_uint,
    pub x: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SortData__bindgen_ty_2 {
    pub m_value: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BufferInfoCL {
    pub m_clBuffer: cl_mem,
    pub m_isReadOnly: bool,
}
#[repr(C)]
pub struct b3RadixSort32CL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3RadixSort32CL {
    pub vtable_: *const b3RadixSort32CL__bindgen_vtable,
    pub m_workBuffer1: *mut b3OpenCLArray,
    pub m_workBuffer2: *mut b3OpenCLArray,
    pub m_workBuffer3: *mut b3OpenCLArray,
    pub m_workBuffer4: *mut b3OpenCLArray,
    pub m_workBuffer3a: *mut b3OpenCLArray,
    pub m_workBuffer4a: *mut b3OpenCLArray,
    pub m_commandQueue: cl_command_queue,
    pub m_streamCountSortDataKernel: cl_kernel,
    pub m_streamCountKernel: cl_kernel,
    pub m_prefixScanKernel: cl_kernel,
    pub m_sortAndScatterSortDataKernel: cl_kernel,
    pub m_sortAndScatterKernel: cl_kernel,
    pub m_deviceCPU: bool,
    pub m_scan: *mut b3PrefixScanCL,
    pub m_fill: *mut b3FillCL,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RadixSort32CL_b3ConstData {
    pub m_n: ::std::os::raw::c_int,
    pub m_nWGs: ::std::os::raw::c_int,
    pub m_startBit: ::std::os::raw::c_int,
    pub m_nBlocksPerWG: ::std::os::raw::c_int,
}
pub const b3RadixSort32CL_DATA_ALIGNMENT: b3RadixSort32CL__bindgen_ty_1 = 256;
pub const b3RadixSort32CL_WG_SIZE: b3RadixSort32CL__bindgen_ty_1 = 64;
pub const b3RadixSort32CL_BLOCK_SIZE: b3RadixSort32CL__bindgen_ty_1 = 256;
pub const b3RadixSort32CL_ELEMENTS_PER_WORK_ITEM: b3RadixSort32CL__bindgen_ty_1 = 4;
pub const b3RadixSort32CL_BITS_PER_PASS: b3RadixSort32CL__bindgen_ty_1 = 4;
pub const b3RadixSort32CL_NUM_BUCKET: b3RadixSort32CL__bindgen_ty_1 = 16;
pub const b3RadixSort32CL_NUM_WGS: b3RadixSort32CL__bindgen_ty_1 = 120;
pub type b3RadixSort32CL__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?execute@b3RadixSort32CL@@QEAAXAEAV?$b3OpenCLArray@I@@000HH@Z"]
    pub fn b3RadixSort32CL_execute(
        this: *mut b3RadixSort32CL,
        keysIn: *mut b3OpenCLArray,
        keysOut: *mut b3OpenCLArray,
        valuesIn: *mut b3OpenCLArray,
        valuesOut: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// keys only
    #[link_name = "\u{1}?execute@b3RadixSort32CL@@QEAAXAEAV?$b3OpenCLArray@I@@H@Z"]
    pub fn b3RadixSort32CL_execute1(
        this: *mut b3RadixSort32CL,
        keysInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?execute@b3RadixSort32CL@@QEAAXAEAV?$b3OpenCLArray@Ub3SortData@@@@H@Z"]
    pub fn b3RadixSort32CL_execute2(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3RadixSort32CL@@QEAAXAEAV?$b3OpenCLArray@Ub3SortData@@@@H@Z"]
    pub fn b3RadixSort32CL_executeHost(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3RadixSort32CL@@QEAAXAEAV?$b3AlignedObjectArray@Ub3SortData@@@@H@Z"]
    pub fn b3RadixSort32CL_executeHost1(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3AlignedObjectArray<b3SortData>,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3RadixSort32CL@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3RadixSort32CL_b3RadixSort32CL(
        this: *mut b3RadixSort32CL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        initialCapacity: ::std::os::raw::c_int,
    );
}
impl b3RadixSort32CL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        keysIn: *mut b3OpenCLArray,
        keysOut: *mut b3OpenCLArray,
        valuesIn: *mut b3OpenCLArray,
        valuesOut: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute(self, keysIn, keysOut, valuesIn, valuesOut, n, sortBits)
    }
    #[inline]
    pub unsafe fn execute1(
        &mut self,
        keysInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute1(self, keysInOut, sortBits)
    }
    #[inline]
    pub unsafe fn execute2(
        &mut self,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute2(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_executeHost(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn executeHost1(
        &mut self,
        keyValuesInOut: *mut b3AlignedObjectArray<b3SortData>,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_executeHost1(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        initialCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3RadixSort32CL_b3RadixSort32CL(&mut __bindgen_tmp, ctx, device, queue, initialCapacity);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3RadixSort32CL@@QEAAXXZ"]
    pub fn b3RadixSort32CL_b3RadixSort32CL_destructor(this: *mut b3RadixSort32CL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ParamsGridBroadphaseCL {
    pub m_invCellSize: [f32; 4usize],
    pub m_gridSize: [::std::os::raw::c_int; 4usize],
}
#[repr(C)]
pub struct b3GpuGridBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_allAabbsGPU1: b3OpenCLArray,
    pub m_allAabbsCPU1: b3AlignedObjectArray<b3SapAabb>,
    pub m_smallAabbsMappingGPU: b3OpenCLArray,
    pub m_smallAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingGPU: b3OpenCLArray,
    pub m_largeAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_hostPairs: b3AlignedObjectArray<b3Int4>,
    pub m_gpuPairs: b3OpenCLArray,
    pub m_hashGpu: b3OpenCLArray,
    pub m_cellStartGpu: b3OpenCLArray,
    pub m_paramsCPU: b3ParamsGridBroadphaseCL,
    pub m_paramsGPU: b3OpenCLArray,
    pub m_sorter: *mut b3RadixSort32CL,
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuGridBroadphase@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@@Z"]
    pub fn b3GpuGridBroadphase_b3GpuGridBroadphase(
        this: *mut b3GpuGridBroadphase,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
    );
}
impl b3GpuGridBroadphase {
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, q: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuGridBroadphase_b3GpuGridBroadphase(&mut __bindgen_tmp, ctx, device, q);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuGridBroadphase@@QEAAXXZ"]
    pub fn b3GpuGridBroadphase_b3GpuGridBroadphase_destructor(this: *mut b3GpuGridBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?createProxy@b3GpuGridBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuGridBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?createLargeProxy@b3GpuGridBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuGridBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@b3GpuGridBroadphase@@UEAAXH@Z"]
    pub fn b3GpuGridBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairsHost@b3GpuGridBroadphase@@UEAAXH@Z"]
    pub fn b3GpuGridBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeAabbsToGpu@b3GpuGridBroadphase@@UEAAXXZ"]
    pub fn b3GpuGridBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getAabbBufferWS@b3GpuGridBroadphase@@UEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuGridBroadphase_getAabbBufferWS(this: *mut ::std::os::raw::c_void) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumOverlap@b3GpuGridBroadphase@@UEAAHXZ"]
    pub fn b3GpuGridBroadphase_getNumOverlap(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairBuffer@b3GpuGridBroadphase@@UEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuGridBroadphase_getOverlappingPairBuffer(
        this: *mut ::std::os::raw::c_void,
    ) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getAllAabbsGPU@b3GpuGridBroadphase@@UEAAAEAV?$b3OpenCLArray@Ub3SapAabb@@@@XZ"]
    pub fn b3GpuGridBroadphase_getAllAabbsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}?getAllAabbsCPU@b3GpuGridBroadphase@@UEAAAEAV?$b3AlignedObjectArray@Ub3SapAabb@@@@XZ"]
    pub fn b3GpuGridBroadphase_getAllAabbsCPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3AlignedObjectArray<b3SapAabb>;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairsGPU@b3GpuGridBroadphase@@UEAAAEAV?$b3OpenCLArray@Ub3Int4@@@@XZ"]
    pub fn b3GpuGridBroadphase_getOverlappingPairsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}?getSmallAabbIndicesGPU@b3GpuGridBroadphase@@UEAAAEAV?$b3OpenCLArray@H@@XZ"]
    pub fn b3GpuGridBroadphase_getSmallAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}?getLargeAabbIndicesGPU@b3GpuGridBroadphase@@UEAAAEAV?$b3OpenCLArray@H@@XZ"]
    pub fn b3GpuGridBroadphase_getLargeAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
#[repr(C)]
pub struct b3FillCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3FillCL {
    pub vtable_: *const b3FillCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_fillKernelInt2: cl_kernel,
    pub m_fillIntKernel: cl_kernel,
    pub m_fillUnsignedIntKernel: cl_kernel,
    pub m_fillFloatKernel: cl_kernel,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3FillCL_b3ConstData {
    pub __bindgen_anon_1: b3FillCL_b3ConstData__bindgen_ty_1,
    pub m_offset: ::std::os::raw::c_int,
    pub m_n: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3FillCL_b3ConstData__bindgen_ty_1 {
    pub m_data: b3Int4,
    pub m_UnsignedData: b3UnsignedInt4,
    _bindgen_union_align: [u8; 16usize],
}
extern "C" {
    #[link_name = "\u{1}?execute@b3FillCL@@QEAAXAEAV?$b3OpenCLArray@I@@IHH@Z"]
    pub fn b3FillCL_execute(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?execute@b3FillCL@@QEAAXAEAV?$b3OpenCLArray@H@@HHH@Z"]
    pub fn b3FillCL_execute1(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?execute@b3FillCL@@QEAAXAEAV?$b3OpenCLArray@M@@MHH@Z"]
    pub fn b3FillCL_execute2(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: f32,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?execute@b3FillCL@@QEAAXAEAV?$b3OpenCLArray@Ub3Int2@@@@AEBUb3Int2@@HH@Z"]
    pub fn b3FillCL_execute3(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3FillCL@@QEAAXAEAV?$b3AlignedObjectArray@Ub3Int2@@@@AEBUb3Int2@@HH@Z"]
    pub fn b3FillCL_executeHost(
        this: *mut b3FillCL,
        src: *mut b3AlignedObjectArray<b3Int2>,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3FillCL@@QEAAXAEAV?$b3AlignedObjectArray@H@@HHH@Z"]
    pub fn b3FillCL_executeHost1(
        this: *mut b3FillCL,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3FillCL@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@@Z"]
    pub fn b3FillCL_b3FillCL(
        this: *mut b3FillCL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3FillCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute1(
        &mut self,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute1(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute2(
        &mut self,
        src: *mut b3OpenCLArray,
        value: f32,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute2(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute3(
        &mut self,
        src: *mut b3OpenCLArray,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute3(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<b3Int2>,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_executeHost(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn executeHost1(
        &mut self,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_executeHost1(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3FillCL_b3FillCL(&mut __bindgen_tmp, ctx, device, queue);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3FillCL@@QEAAXXZ"]
    pub fn b3FillCL_b3FillCL_destructor(this: *mut b3FillCL);
}
#[repr(C)]
pub struct b3PrefixScanCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3PrefixScanCL {
    pub vtable_: *const b3PrefixScanCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_localScanKernel: cl_kernel,
    pub m_blockSumKernel: cl_kernel,
    pub m_propagationKernel: cl_kernel,
    pub m_workBuffer: *mut b3OpenCLArray,
}
pub const b3PrefixScanCL_BLOCK_SIZE: b3PrefixScanCL__bindgen_ty_1 = 128;
pub type b3PrefixScanCL__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?execute@b3PrefixScanCL@@QEAAXAEAV?$b3OpenCLArray@I@@0HPEAI@Z"]
    pub fn b3PrefixScanCL_execute(
        this: *mut b3PrefixScanCL,
        src: *mut b3OpenCLArray,
        dst: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3PrefixScanCL@@QEAAXAEAV?$b3AlignedObjectArray@I@@0HPEAI@Z"]
    pub fn b3PrefixScanCL_executeHost(
        this: *mut b3PrefixScanCL,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3PrefixScanCL@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3PrefixScanCL_b3PrefixScanCL(
        this: *mut b3PrefixScanCL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    );
}
impl b3PrefixScanCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        dst: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    ) {
        b3PrefixScanCL_execute(self, src, dst, n, sum)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    ) {
        b3PrefixScanCL_executeHost(self, src, dst, n, sum)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3PrefixScanCL_b3PrefixScanCL(&mut __bindgen_tmp, ctx, device, queue, size);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3PrefixScanCL@@QEAAXXZ"]
    pub fn b3PrefixScanCL_b3PrefixScanCL_destructor(this: *mut b3PrefixScanCL);
}
#[repr(C)]
pub struct b3GpuParallelLinearBvh__bindgen_vtable(::std::os::raw::c_void);
/// @brief GPU Parallel Linearized Bounding Volume Heirarchy(LBVH) that is reconstructed every frame
/// @remarks
/// See presentation in docs/b3GpuParallelLinearBvh.pdf for algorithm details.
/// @par
/// Related papers: \n
/// "Fast BVH Construction on GPUs" [Lauterbach et al. 2009] \n
/// "Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d trees" [Karras 2012] \n
/// @par
/// The basic algorithm for building the BVH as presented in [Lauterbach et al. 2009] consists of 4 stages:
/// - [fully parallel] Assign morton codes for each AABB using its center (after quantizing the AABB centers into a virtual grid)
/// - [fully parallel] Sort morton codes
/// - [somewhat parallel] Build binary radix tree (assign parent/child pointers for internal nodes of the BVH)
/// - [somewhat parallel] Set internal node AABBs
/// @par
/// [Karras 2012] improves on the algorithm by introducing fully parallel methods for the last 2 stages.
/// The BVH implementation here shares many concepts with [Karras 2012], but a different method is used for constructing the tree.
/// Instead of searching for the child nodes of each internal node, we search for the parent node of each node.
/// Additionally, a non-atomic traversal that starts from the leaf nodes and moves towards the root node is used to set the AABBs.
#[repr(C)]
pub struct b3GpuParallelLinearBvh {
    pub vtable_: *const b3GpuParallelLinearBvh__bindgen_vtable,
    pub m_queue: cl_command_queue,
    pub m_parallelLinearBvhProgram: cl_program,
    pub m_separateAabbsKernel: cl_kernel,
    pub m_findAllNodesMergedAabbKernel: cl_kernel,
    pub m_assignMortonCodesAndAabbIndiciesKernel: cl_kernel,
    pub m_computeAdjacentPairCommonPrefixKernel: cl_kernel,
    pub m_buildBinaryRadixTreeLeafNodesKernel: cl_kernel,
    pub m_buildBinaryRadixTreeInternalNodesKernel: cl_kernel,
    pub m_findDistanceFromRootKernel: cl_kernel,
    pub m_buildBinaryRadixTreeAabbsRecursiveKernel: cl_kernel,
    pub m_findLeafIndexRangesKernel: cl_kernel,
    pub m_plbvhCalculateOverlappingPairsKernel: cl_kernel,
    pub m_plbvhRayTraverseKernel: cl_kernel,
    pub m_plbvhLargeAabbAabbTestKernel: cl_kernel,
    pub m_plbvhLargeAabbRayTestKernel: cl_kernel,
    pub m_radixSorter: b3RadixSort32CL,
    pub m_rootNodeIndex: b3OpenCLArray,
    pub m_maxDistanceFromRoot: b3OpenCLArray,
    pub m_temp: b3OpenCLArray,
    pub m_internalNodeAabbs: b3OpenCLArray,
    pub m_internalNodeLeafIndexRanges: b3OpenCLArray,
    pub m_internalNodeChildNodes: b3OpenCLArray,
    pub m_internalNodeParentNodes: b3OpenCLArray,
    pub m_commonPrefixes: b3OpenCLArray,
    pub m_commonPrefixLengths: b3OpenCLArray,
    pub m_distanceFromRoot: b3OpenCLArray,
    pub m_leafNodeParentNodes: b3OpenCLArray,
    pub m_mortonCodesAndAabbIndicies: b3OpenCLArray,
    pub m_mergedAabb: b3OpenCLArray,
    pub m_leafNodeAabbs: b3OpenCLArray,
    pub m_largeAabbs: b3OpenCLArray,
}
extern "C" {
    /// Must be called before any other function
    #[link_name = "\u{1}?build@b3GpuParallelLinearBvh@@QEAAXAEBV?$b3OpenCLArray@Ub3SapAabb@@@@AEBV?$b3OpenCLArray@H@@1@Z"]
    pub fn b3GpuParallelLinearBvh_build(
        this: *mut b3GpuParallelLinearBvh,
        worldSpaceAabbs: *const b3OpenCLArray,
        smallAabbIndices: *const b3OpenCLArray,
        largeAabbIndices: *const b3OpenCLArray,
    );
}
extern "C" {
    /// calculateOverlappingPairs() uses the worldSpaceAabbs parameter of b3GpuParallelLinearBvh::build() as the query AABBs.
    /// ///@param out_overlappingPairs The size() of this array is used to determine the max number of pairs.
    /// ///If the number of overlapping pairs is < out_overlappingPairs.size(), out_overlappingPairs is resized.
    #[link_name = "\u{1}?calculateOverlappingPairs@b3GpuParallelLinearBvh@@QEAAXAEAV?$b3OpenCLArray@Ub3Int4@@@@@Z"]
    pub fn b3GpuParallelLinearBvh_calculateOverlappingPairs(
        this: *mut b3GpuParallelLinearBvh,
        out_overlappingPairs: *mut b3OpenCLArray,
    );
}
extern "C" {
    /// @param out_numRigidRayPairs Array of length 1; contains the number of detected ray-rigid AABB intersections;
    /// ///this value may be greater than out_rayRigidPairs.size() if out_rayRigidPairs is not large enough.
    /// ///@param out_rayRigidPairs Contains an array of rays intersecting rigid AABBs; x == ray index, y == rigid body index.
    /// ///If the size of this array is insufficient to hold all ray-rigid AABB intersections, additional intersections are discarded.
    #[link_name = "\u{1}?testRaysAgainstBvhAabbs@b3GpuParallelLinearBvh@@QEAAXAEBV?$b3OpenCLArray@Ub3RayInfo@@@@AEAV?$b3OpenCLArray@H@@AEAV?$b3OpenCLArray@Ub3Int2@@@@@Z"]
    pub fn b3GpuParallelLinearBvh_testRaysAgainstBvhAabbs(
        this: *mut b3GpuParallelLinearBvh,
        rays: *const b3OpenCLArray,
        out_numRayRigidPairs: *mut b3OpenCLArray,
        out_rayRigidPairs: *mut b3OpenCLArray,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuParallelLinearBvh@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@@Z"]
    pub fn b3GpuParallelLinearBvh_b3GpuParallelLinearBvh(
        this: *mut b3GpuParallelLinearBvh,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3GpuParallelLinearBvh {
    #[inline]
    pub unsafe fn build(
        &mut self,
        worldSpaceAabbs: *const b3OpenCLArray,
        smallAabbIndices: *const b3OpenCLArray,
        largeAabbIndices: *const b3OpenCLArray,
    ) {
        b3GpuParallelLinearBvh_build(self, worldSpaceAabbs, smallAabbIndices, largeAabbIndices)
    }
    #[inline]
    pub unsafe fn calculateOverlappingPairs(&mut self, out_overlappingPairs: *mut b3OpenCLArray) {
        b3GpuParallelLinearBvh_calculateOverlappingPairs(self, out_overlappingPairs)
    }
    #[inline]
    pub unsafe fn testRaysAgainstBvhAabbs(
        &mut self,
        rays: *const b3OpenCLArray,
        out_numRayRigidPairs: *mut b3OpenCLArray,
        out_rayRigidPairs: *mut b3OpenCLArray,
    ) {
        b3GpuParallelLinearBvh_testRaysAgainstBvhAabbs(
            self,
            rays,
            out_numRayRigidPairs,
            out_rayRigidPairs,
        )
    }
    #[inline]
    pub unsafe fn new(context: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuParallelLinearBvh_b3GpuParallelLinearBvh(&mut __bindgen_tmp, context, device, queue);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuParallelLinearBvh@@QEAAXXZ"]
    pub fn b3GpuParallelLinearBvh_b3GpuParallelLinearBvh_destructor(
        this: *mut b3GpuParallelLinearBvh,
    );
}
#[repr(C)]
pub struct b3GpuParallelLinearBvhBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_plbvh: b3GpuParallelLinearBvh,
    pub m_overlappingPairsGpu: b3OpenCLArray,
    pub m_aabbsGpu: b3OpenCLArray,
    pub m_smallAabbsMappingGpu: b3OpenCLArray,
    pub m_largeAabbsMappingGpu: b3OpenCLArray,
    pub m_aabbsCpu: b3AlignedObjectArray<b3SapAabb>,
    pub m_smallAabbsMappingCpu: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingCpu: b3AlignedObjectArray<::std::os::raw::c_int>,
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuParallelLinearBvhBroadphase@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@@Z"]
    pub fn b3GpuParallelLinearBvhBroadphase_b3GpuParallelLinearBvhBroadphase(
        this: *mut b3GpuParallelLinearBvhBroadphase,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3GpuParallelLinearBvhBroadphase {
    #[inline]
    pub unsafe fn new(context: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuParallelLinearBvhBroadphase_b3GpuParallelLinearBvhBroadphase(
            &mut __bindgen_tmp,
            context,
            device,
            queue,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?createProxy@b3GpuParallelLinearBvhBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuParallelLinearBvhBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?createLargeProxy@b3GpuParallelLinearBvhBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuParallelLinearBvhBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@b3GpuParallelLinearBvhBroadphase@@UEAAXH@Z"]
    pub fn b3GpuParallelLinearBvhBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairsHost@b3GpuParallelLinearBvhBroadphase@@UEAAXH@Z"]
    pub fn b3GpuParallelLinearBvhBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeAabbsToGpu@b3GpuParallelLinearBvhBroadphase@@UEAAXXZ"]
    pub fn b3GpuParallelLinearBvhBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct b3GpuSapBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_flipFloatKernel: cl_kernel,
    pub m_scatterKernel: cl_kernel,
    pub m_copyAabbsKernel: cl_kernel,
    pub m_sapKernel: cl_kernel,
    pub m_sap2Kernel: cl_kernel,
    pub m_prepareSumVarianceKernel: cl_kernel,
    pub m_sorter: *mut b3RadixSort32CL,
    /// test for 3d SAP
    pub m_sortedAxisCPU: [[b3AlignedObjectArray<b3SortData>; 2usize]; 3usize],
    pub m_objectMinMaxIndexCPU: [[b3AlignedObjectArray<b3UnsignedInt2>; 2usize]; 3usize],
    pub m_objectMinMaxIndexGPUaxis0: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis1: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis2: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis0prev: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis1prev: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis2prev: b3OpenCLArray,
    pub m_sortedAxisGPU0: b3OpenCLArray,
    pub m_sortedAxisGPU1: b3OpenCLArray,
    pub m_sortedAxisGPU2: b3OpenCLArray,
    pub m_sortedAxisGPU0prev: b3OpenCLArray,
    pub m_sortedAxisGPU1prev: b3OpenCLArray,
    pub m_sortedAxisGPU2prev: b3OpenCLArray,
    pub m_addedHostPairsGPU: b3OpenCLArray,
    pub m_removedHostPairsGPU: b3OpenCLArray,
    pub m_addedCountGPU: b3OpenCLArray,
    pub m_removedCountGPU: b3OpenCLArray,
    pub m_currentBuffer: ::std::os::raw::c_int,
    pub m_pairCount: b3OpenCLArray,
    pub m_allAabbsGPU: b3OpenCLArray,
    pub m_allAabbsCPU: b3AlignedObjectArray<b3SapAabb>,
    pub m_sum: b3OpenCLArray,
    pub m_sum2: b3OpenCLArray,
    pub m_dst: b3OpenCLArray,
    pub m_smallAabbsMappingGPU: b3OpenCLArray,
    pub m_smallAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingGPU: b3OpenCLArray,
    pub m_largeAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_overlappingPairs: b3OpenCLArray,
    pub m_gpuSmallSortData: b3OpenCLArray,
    pub m_gpuSmallSortedAabbs: b3OpenCLArray,
    pub m_prefixScanFloat4: *mut b3PrefixScanFloat4CL,
}
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BRUTE_FORCE_CPU:
    b3GpuSapBroadphase_b3GpuSapKernelType = 1;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BRUTE_FORCE_GPU:
    b3GpuSapBroadphase_b3GpuSapKernelType = 2;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_ORIGINAL:
    b3GpuSapBroadphase_b3GpuSapKernelType = 3;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BARRIER:
    b3GpuSapBroadphase_b3GpuSapKernelType = 4;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_LOCAL_SHARED_MEMORY:
    b3GpuSapBroadphase_b3GpuSapKernelType = 5;
pub type b3GpuSapBroadphase_b3GpuSapKernelType = i32;
extern "C" {
    #[link_name = "\u{1}?reset@b3GpuSapBroadphase@@QEAAXXZ"]
    pub fn b3GpuSapBroadphase_reset(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?init3dSap@b3GpuSapBroadphase@@QEAAXXZ"]
    pub fn b3GpuSapBroadphase_init3dSap(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuSapBroadphase@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@W4b3GpuSapKernelType@0@@Z"]
    pub fn b3GpuSapBroadphase_b3GpuSapBroadphase(
        this: *mut b3GpuSapBroadphase,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        kernelType: b3GpuSapBroadphase_b3GpuSapKernelType,
    );
}
impl b3GpuSapBroadphase {
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuSapBroadphase_reset(self)
    }
    #[inline]
    pub unsafe fn init3dSap(&mut self) {
        b3GpuSapBroadphase_init3dSap(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        kernelType: b3GpuSapBroadphase_b3GpuSapKernelType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuSapBroadphase_b3GpuSapBroadphase(&mut __bindgen_tmp, ctx, device, q, kernelType);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuSapBroadphase@@QEAAXXZ"]
    pub fn b3GpuSapBroadphase_b3GpuSapBroadphase_destructor(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@b3GpuSapBroadphase@@UEAAXH@Z"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairsHost@b3GpuSapBroadphase@@UEAAXH@Z"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairsHostIncremental3Sap@b3GpuSapBroadphase@@UEAAXXZ"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairsHostIncremental3Sap(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?createProxy@b3GpuSapBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuSapBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?createLargeProxy@b3GpuSapBroadphase@@UEAAXAEBVb3Vector3@@0HHH@Z"]
    pub fn b3GpuSapBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeAabbsToGpu@b3GpuSapBroadphase@@UEAAXXZ"]
    pub fn b3GpuSapBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getAabbBufferWS@b3GpuSapBroadphase@@UEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuSapBroadphase_getAabbBufferWS(this: *mut ::std::os::raw::c_void) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumOverlap@b3GpuSapBroadphase@@UEAAHXZ"]
    pub fn b3GpuSapBroadphase_getNumOverlap(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairBuffer@b3GpuSapBroadphase@@UEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuSapBroadphase_getOverlappingPairBuffer(this: *mut ::std::os::raw::c_void)
        -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairsGPU@b3GpuSapBroadphase@@UEAAAEAV?$b3OpenCLArray@Ub3Int4@@@@XZ"]
    pub fn b3GpuSapBroadphase_getOverlappingPairsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}?getSmallAabbIndicesGPU@b3GpuSapBroadphase@@UEAAAEAV?$b3OpenCLArray@H@@XZ"]
    pub fn b3GpuSapBroadphase_getSmallAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}?getLargeAabbIndicesGPU@b3GpuSapBroadphase@@UEAAAEAV?$b3OpenCLArray@H@@XZ"]
    pub fn b3GpuSapBroadphase_getLargeAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
/// b3ContactCache is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
/// Those contact points are created by the collision narrow phase.
/// The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
/// updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
/// reduces the cache to 4 points, when more then 4 points are added, using following rules:
/// the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
/// note that some pairs of objects might have more then one contact manifold.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactCache {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?addManifoldPoint@b3ContactCache@@QEAAHAEBVb3Vector3@@@Z"]
    pub fn b3ContactCache_addManifoldPoint(
        this: *mut b3ContactCache,
        newPoint: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?validContactDistance@b3ContactCache@@SA_NAEBVb3Vector3@@@Z"]
    pub fn b3ContactCache_validContactDistance(pt: *const b3Vector3) -> bool;
}
extern "C" {
    /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
    #[link_name = "\u{1}?refreshContactPoints@b3ContactCache@@SAXAEBVb3Transform@@0AEAUb3Contact4Data@@@Z"]
    pub fn b3ContactCache_refreshContactPoints(
        trA: *const b3Transform,
        trB: *const b3Transform,
        newContactCache: *mut b3Contact4Data,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeContactPoint@b3ContactCache@@SAXAEAUb3Contact4Data@@H@Z"]
    pub fn b3ContactCache_removeContactPoint(
        newContactCache: *mut b3Contact4Data,
        i: ::std::os::raw::c_int,
    );
}
impl b3ContactCache {
    #[inline]
    pub unsafe fn addManifoldPoint(&mut self, newPoint: *const b3Vector3) -> ::std::os::raw::c_int {
        b3ContactCache_addManifoldPoint(self, newPoint)
    }
    #[inline]
    pub unsafe fn validContactDistance(pt: *const b3Vector3) -> bool {
        b3ContactCache_validContactDistance(pt)
    }
    #[inline]
    pub unsafe fn refreshContactPoints(
        trA: *const b3Transform,
        trB: *const b3Transform,
        newContactCache: *mut b3Contact4Data,
    ) {
        b3ContactCache_refreshContactPoints(trA, trB, newContactCache)
    }
    #[inline]
    pub unsafe fn removeContactPoint(
        newContactCache: *mut b3Contact4Data,
        i: ::std::os::raw::c_int,
    ) {
        b3ContactCache_removeContactPoint(newContactCache, i)
    }
}
/// btGjkEpaSolver contributed under zlib by Nathanael Presson
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GjkEpaSolver2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GjkEpaSolver2_sResults {
    pub status: b3GjkEpaSolver2_sResults_eStatus,
    pub __bindgen_padding_0: u64,
    pub witnesses: [b3Vector3; 2usize],
    pub normal: b3Vector3,
    pub distance: b3Scalar,
    pub __bindgen_padding_1: [u32; 3usize],
}
pub const b3GjkEpaSolver2_sResults_eStatus_Separated: b3GjkEpaSolver2_sResults_eStatus = 0;
pub const b3GjkEpaSolver2_sResults_eStatus_Penetrating: b3GjkEpaSolver2_sResults_eStatus = 1;
pub const b3GjkEpaSolver2_sResults_eStatus_GJK_Failed: b3GjkEpaSolver2_sResults_eStatus = 2;
pub const b3GjkEpaSolver2_sResults_eStatus_EPA_Failed: b3GjkEpaSolver2_sResults_eStatus = 3;
pub type b3GjkEpaSolver2_sResults_eStatus = i32;
extern "C" {
    #[link_name = "\u{1}?StackSizeRequirement@b3GjkEpaSolver2@@SAHXZ"]
    pub fn b3GjkEpaSolver2_StackSizeRequirement() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?Distance@b3GjkEpaSolver2@@SA_NAEBVb3Transform@@0PEBUb3ConvexPolyhedronData@@1AEBV?$b3AlignedObjectArray@Vb3Vector3@@@@2AEBVb3Vector3@@AEAUsResults@1@@Z"]
    pub fn b3GjkEpaSolver2_Distance(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Penetration@b3GjkEpaSolver2@@SA_NAEBVb3Transform@@0PEBUb3ConvexPolyhedronData@@1AEBV?$b3AlignedObjectArray@Vb3Vector3@@@@2AEBVb3Vector3@@AEAUsResults@1@_N@Z"]
    pub fn b3GjkEpaSolver2_Penetration(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool;
}
impl b3GjkEpaSolver2 {
    #[inline]
    pub unsafe fn StackSizeRequirement() -> ::std::os::raw::c_int {
        b3GjkEpaSolver2_StackSizeRequirement()
    }
    #[inline]
    pub unsafe fn Distance(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
    ) -> bool {
        b3GjkEpaSolver2_Distance(
            transA, transB, hullA, hullB, verticesA, verticesB, guess, results,
        )
    }
    #[inline]
    pub unsafe fn Penetration(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool {
        b3GjkEpaSolver2_Penetration(
            transA, transB, hullA, hullB, verticesA, verticesB, guess, results, usemargins,
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GjkPairDetector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UsageBitfield {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
    pub __bindgen_align: [u16; 0usize],
}
impl b3UsageBitfield {
    #[inline]
    pub fn usedVertexA(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexA(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexB(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexB(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexC(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexC(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexD(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexD(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused4(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused4(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usedVertexA: ::std::os::raw::c_ushort,
        usedVertexB: ::std::os::raw::c_ushort,
        usedVertexC: ::std::os::raw::c_ushort,
        usedVertexD: ::std::os::raw::c_ushort,
        unused1: ::std::os::raw::c_ushort,
        unused2: ::std::os::raw::c_ushort,
        unused3: ::std::os::raw::c_ushort,
        unused4: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let usedVertexA: u16 = unsafe { ::std::mem::transmute(usedVertexA) };
            usedVertexA as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usedVertexB: u16 = unsafe { ::std::mem::transmute(usedVertexB) };
            usedVertexB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usedVertexC: u16 = unsafe { ::std::mem::transmute(usedVertexC) };
            usedVertexC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let usedVertexD: u16 = unsafe { ::std::mem::transmute(usedVertexD) };
            usedVertexD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unused1: u16 = unsafe { ::std::mem::transmute(unused1) };
            unused1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unused2: u16 = unsafe { ::std::mem::transmute(unused2) };
            unused2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let unused3: u16 = unsafe { ::std::mem::transmute(unused3) };
            unused3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let unused4: u16 = unsafe { ::std::mem::transmute(unused4) };
            unused4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SubSimplexClosestResult {
    pub m_closestPointOnSimplex: b3Vector3,
    pub m_usedVertices: b3UsageBitfield,
    pub m_barycentricCoords: [b3Scalar; 4usize],
    pub m_degenerate: bool,
    pub __bindgen_padding_0: [u8; 11usize],
}
/// b3VoronoiSimplexSolver is an implementation of the closest point distance algorithm from a 1-4 points simplex to the origin.
/// Can be used with GJK, as an alternative to Johnson distance algorithm.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3VoronoiSimplexSolver {
    pub m_numVertices: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_simplexVectorW: [b3Vector3; 5usize],
    pub m_simplexPointsP: [b3Vector3; 5usize],
    pub m_simplexPointsQ: [b3Vector3; 5usize],
    pub m_cachedP1: b3Vector3,
    pub m_cachedP2: b3Vector3,
    pub m_cachedV: b3Vector3,
    pub m_lastW: b3Vector3,
    pub m_equalVertexThreshold: b3Scalar,
    pub m_cachedValidClosest: bool,
    pub __bindgen_padding_1: u64,
    pub m_cachedBC: b3SubSimplexClosestResult,
    pub m_needsUpdate: bool,
    pub __bindgen_padding_2: [u8; 15usize],
}
extern "C" {
    #[link_name = "\u{1}?removeVertex@b3VoronoiSimplexSolver@@QEAAXH@Z"]
    pub fn b3VoronoiSimplexSolver_removeVertex(
        this: *mut b3VoronoiSimplexSolver,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?reduceVertices@b3VoronoiSimplexSolver@@QEAAXAEBUb3UsageBitfield@@@Z"]
    pub fn b3VoronoiSimplexSolver_reduceVertices(
        this: *mut b3VoronoiSimplexSolver,
        usedVerts: *const b3UsageBitfield,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateClosestVectorAndPoints@b3VoronoiSimplexSolver@@QEAA_NXZ"]
    pub fn b3VoronoiSimplexSolver_updateClosestVectorAndPoints(
        this: *mut b3VoronoiSimplexSolver,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?closestPtPointTetrahedron@b3VoronoiSimplexSolver@@QEAA_NAEBVb3Vector3@@0000AEAUb3SubSimplexClosestResult@@@Z"]
    pub fn b3VoronoiSimplexSolver_closestPtPointTetrahedron(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
        finalResult: *mut b3SubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?pointOutsideOfPlane@b3VoronoiSimplexSolver@@QEAAHAEBVb3Vector3@@0000@Z"]
    pub fn b3VoronoiSimplexSolver_pointOutsideOfPlane(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?closestPtPointTriangle@b3VoronoiSimplexSolver@@QEAA_NAEBVb3Vector3@@000AEAUb3SubSimplexClosestResult@@@Z"]
    pub fn b3VoronoiSimplexSolver_closestPtPointTriangle(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        result: *mut b3SubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?reset@b3VoronoiSimplexSolver@@QEAAXXZ"]
    pub fn b3VoronoiSimplexSolver_reset(this: *mut b3VoronoiSimplexSolver);
}
extern "C" {
    #[link_name = "\u{1}?addVertex@b3VoronoiSimplexSolver@@QEAAXAEBVb3Vector3@@00@Z"]
    pub fn b3VoronoiSimplexSolver_addVertex(
        this: *mut b3VoronoiSimplexSolver,
        w: *const b3Vector3,
        p: *const b3Vector3,
        q: *const b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?closest@b3VoronoiSimplexSolver@@QEAA_NAEAVb3Vector3@@@Z"]
    pub fn b3VoronoiSimplexSolver_closest(
        this: *mut b3VoronoiSimplexSolver,
        v: *mut b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?maxVertex@b3VoronoiSimplexSolver@@QEAAMXZ"]
    pub fn b3VoronoiSimplexSolver_maxVertex(this: *mut b3VoronoiSimplexSolver) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?getSimplex@b3VoronoiSimplexSolver@@QEBAHPEAVb3Vector3@@00@Z"]
    pub fn b3VoronoiSimplexSolver_getSimplex(
        this: *const b3VoronoiSimplexSolver,
        pBuf: *mut b3Vector3,
        qBuf: *mut b3Vector3,
        yBuf: *mut b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?inSimplex@b3VoronoiSimplexSolver@@QEAA_NAEBVb3Vector3@@@Z"]
    pub fn b3VoronoiSimplexSolver_inSimplex(
        this: *mut b3VoronoiSimplexSolver,
        w: *const b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?backup_closest@b3VoronoiSimplexSolver@@QEAAXAEAVb3Vector3@@@Z"]
    pub fn b3VoronoiSimplexSolver_backup_closest(
        this: *mut b3VoronoiSimplexSolver,
        v: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?emptySimplex@b3VoronoiSimplexSolver@@QEBA_NXZ"]
    pub fn b3VoronoiSimplexSolver_emptySimplex(this: *const b3VoronoiSimplexSolver) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?compute_points@b3VoronoiSimplexSolver@@QEAAXAEAVb3Vector3@@0@Z"]
    pub fn b3VoronoiSimplexSolver_compute_points(
        this: *mut b3VoronoiSimplexSolver,
        p1: *mut b3Vector3,
        p2: *mut b3Vector3,
    );
}
impl b3VoronoiSimplexSolver {
    #[inline]
    pub unsafe fn removeVertex(&mut self, index: ::std::os::raw::c_int) {
        b3VoronoiSimplexSolver_removeVertex(self, index)
    }
    #[inline]
    pub unsafe fn reduceVertices(&mut self, usedVerts: *const b3UsageBitfield) {
        b3VoronoiSimplexSolver_reduceVertices(self, usedVerts)
    }
    #[inline]
    pub unsafe fn updateClosestVectorAndPoints(&mut self) -> bool {
        b3VoronoiSimplexSolver_updateClosestVectorAndPoints(self)
    }
    #[inline]
    pub unsafe fn closestPtPointTetrahedron(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
        finalResult: *mut b3SubSimplexClosestResult,
    ) -> bool {
        b3VoronoiSimplexSolver_closestPtPointTetrahedron(self, p, a, b, c, d, finalResult)
    }
    #[inline]
    pub unsafe fn pointOutsideOfPlane(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3VoronoiSimplexSolver_pointOutsideOfPlane(self, p, a, b, c, d)
    }
    #[inline]
    pub unsafe fn closestPtPointTriangle(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        result: *mut b3SubSimplexClosestResult,
    ) -> bool {
        b3VoronoiSimplexSolver_closestPtPointTriangle(self, p, a, b, c, result)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3VoronoiSimplexSolver_reset(self)
    }
    #[inline]
    pub unsafe fn addVertex(
        &mut self,
        w: *const b3Vector3,
        p: *const b3Vector3,
        q: *const b3Vector3,
    ) {
        b3VoronoiSimplexSolver_addVertex(self, w, p, q)
    }
    #[inline]
    pub unsafe fn closest(&mut self, v: *mut b3Vector3) -> bool {
        b3VoronoiSimplexSolver_closest(self, v)
    }
    #[inline]
    pub unsafe fn maxVertex(&mut self) -> b3Scalar {
        b3VoronoiSimplexSolver_maxVertex(self)
    }
    #[inline]
    pub unsafe fn getSimplex(
        &self,
        pBuf: *mut b3Vector3,
        qBuf: *mut b3Vector3,
        yBuf: *mut b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3VoronoiSimplexSolver_getSimplex(self, pBuf, qBuf, yBuf)
    }
    #[inline]
    pub unsafe fn inSimplex(&mut self, w: *const b3Vector3) -> bool {
        b3VoronoiSimplexSolver_inSimplex(self, w)
    }
    #[inline]
    pub unsafe fn backup_closest(&mut self, v: *mut b3Vector3) {
        b3VoronoiSimplexSolver_backup_closest(self, v)
    }
    #[inline]
    pub unsafe fn emptySimplex(&self) -> bool {
        b3VoronoiSimplexSolver_emptySimplex(self)
    }
    #[inline]
    pub unsafe fn compute_points(&mut self, p1: *mut b3Vector3, p2: *mut b3Vector3) {
        b3VoronoiSimplexSolver_compute_points(self, p1, p2)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3KernelArgData {
    pub m_isBuffer: ::std::os::raw::c_int,
    pub m_argIndex: ::std::os::raw::c_int,
    pub m_argSizeInBytes: ::std::os::raw::c_int,
    pub m_unusedPadding: ::std::os::raw::c_int,
    pub __bindgen_anon_1: b3KernelArgData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3KernelArgData__bindgen_ty_1 {
    pub m_clBuffer: cl_mem,
    pub m_argData: [::std::os::raw::c_uchar; 16usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
pub struct b3LauncherCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3LauncherCL {
    pub vtable_: *const b3LauncherCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_kernel: cl_kernel,
    pub m_idx: ::std::os::raw::c_int,
    pub m_kernelArguments: b3AlignedObjectArray<b3KernelArgData>,
    pub m_serializationSizeInBytes: ::std::os::raw::c_int,
    pub m_enableSerialization: bool,
    pub m_name: *const ::std::os::raw::c_char,
    pub m_arrays: b3AlignedObjectArray<*mut b3OpenCLArray>,
}
extern "C" {
    #[link_name = "\u{1}?setBuffer@b3LauncherCL@@QEAAXPEAU_cl_mem@@@Z"]
    pub fn b3LauncherCL_setBuffer(this: *mut b3LauncherCL, clBuffer: cl_mem);
}
extern "C" {
    #[link_name = "\u{1}?setBuffers@b3LauncherCL@@QEAAXPEAUb3BufferInfoCL@@H@Z"]
    pub fn b3LauncherCL_setBuffers(
        this: *mut b3LauncherCL,
        buffInfo: *mut b3BufferInfoCL,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?deserializeArgs@b3LauncherCL@@QEAAHPEAEHPEAU_cl_context@@@Z"]
    pub fn b3LauncherCL_deserializeArgs(
        this: *mut b3LauncherCL,
        buf: *mut ::std::os::raw::c_uchar,
        bufSize: ::std::os::raw::c_int,
        ctx: cl_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?serializeArguments@b3LauncherCL@@QEAAHPEAEH@Z"]
    pub fn b3LauncherCL_serializeArguments(
        this: *mut b3LauncherCL,
        destBuffer: *mut ::std::os::raw::c_uchar,
        destBufferCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?serializeToFile@b3LauncherCL@@QEAAXPEBDH@Z"]
    pub fn b3LauncherCL_serializeToFile(
        this: *mut b3LauncherCL,
        fileName: *const ::std::os::raw::c_char,
        numWorkItems: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3LauncherCL@@QEAA@PEAU_cl_command_queue@@PEAU_cl_kernel@@PEBD@Z"]
    pub fn b3LauncherCL_b3LauncherCL(
        this: *mut b3LauncherCL,
        queue: cl_command_queue,
        kernel: cl_kernel,
        name: *const ::std::os::raw::c_char,
    );
}
impl b3LauncherCL {
    #[inline]
    pub unsafe fn setBuffer(&mut self, clBuffer: cl_mem) {
        b3LauncherCL_setBuffer(self, clBuffer)
    }
    #[inline]
    pub unsafe fn setBuffers(&mut self, buffInfo: *mut b3BufferInfoCL, n: ::std::os::raw::c_int) {
        b3LauncherCL_setBuffers(self, buffInfo, n)
    }
    #[inline]
    pub unsafe fn deserializeArgs(
        &mut self,
        buf: *mut ::std::os::raw::c_uchar,
        bufSize: ::std::os::raw::c_int,
        ctx: cl_context,
    ) -> ::std::os::raw::c_int {
        b3LauncherCL_deserializeArgs(self, buf, bufSize, ctx)
    }
    #[inline]
    pub unsafe fn serializeArguments(
        &mut self,
        destBuffer: *mut ::std::os::raw::c_uchar,
        destBufferCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3LauncherCL_serializeArguments(self, destBuffer, destBufferCapacity)
    }
    #[inline]
    pub unsafe fn serializeToFile(
        &mut self,
        fileName: *const ::std::os::raw::c_char,
        numWorkItems: ::std::os::raw::c_int,
    ) {
        b3LauncherCL_serializeToFile(self, fileName, numWorkItems)
    }
    #[inline]
    pub unsafe fn new(
        queue: cl_command_queue,
        kernel: cl_kernel,
        name: *const ::std::os::raw::c_char,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3LauncherCL_b3LauncherCL(&mut __bindgen_tmp, queue, kernel, name);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3LauncherCL@@QEAAXXZ"]
    pub fn b3LauncherCL_b3LauncherCL_destructor(this: *mut b3LauncherCL);
}
#[repr(C)]
pub struct b3GpuRaycast__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuRaycast {
    pub vtable_: *const b3GpuRaycast__bindgen_vtable,
    pub m_data: *mut b3GpuRaycastInternalData,
}
extern "C" {
    #[link_name = "\u{1}?castRaysHost@b3GpuRaycast@@QEAAXAEBV?$b3AlignedObjectArray@Ub3RayInfo@@@@AEAV?$b3AlignedObjectArray@Ub3RayHit@@@@HPEBUb3RigidBodyData@@HPEBUb3Collidable@@PEBUb3GpuNarrowPhaseInternalData@@@Z"]
    pub fn b3GpuRaycast_castRaysHost(
        this: *mut b3GpuRaycast,
        raysIn: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *mut b3GpuNarrowPhaseInternalData,
    );
}
extern "C" {
    #[link_name = "\u{1}?castRays@b3GpuRaycast@@QEAAXAEBV?$b3AlignedObjectArray@Ub3RayInfo@@@@AEAV?$b3AlignedObjectArray@Ub3RayHit@@@@HPEBUb3RigidBodyData@@HPEBUb3Collidable@@PEBUb3GpuNarrowPhaseInternalData@@PEAVb3GpuBroadphaseInterface@@@Z"]
    pub fn b3GpuRaycast_castRays(
        this: *mut b3GpuRaycast,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *const b3GpuNarrowPhaseInternalData,
        broadphase: *mut b3GpuBroadphaseInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuRaycast@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@@Z"]
    pub fn b3GpuRaycast_b3GpuRaycast(
        this: *mut b3GpuRaycast,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
    );
}
impl b3GpuRaycast {
    #[inline]
    pub unsafe fn castRaysHost(
        &mut self,
        raysIn: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *mut b3GpuNarrowPhaseInternalData,
    ) {
        b3GpuRaycast_castRaysHost(
            self,
            raysIn,
            hitResults,
            numBodies,
            bodies,
            numCollidables,
            collidables,
            narrowphaseData,
        )
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *const b3GpuNarrowPhaseInternalData,
        broadphase: *mut b3GpuBroadphaseInterface,
    ) {
        b3GpuRaycast_castRays(
            self,
            rays,
            hitResults,
            numBodies,
            bodies,
            numCollidables,
            collidables,
            narrowphaseData,
            broadphase,
        )
    }
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, q: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuRaycast_b3GpuRaycast(&mut __bindgen_tmp, ctx, device, q);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuRaycast@@QEAAXXZ"]
    pub fn b3GpuRaycast_b3GpuRaycast_destructor(this: *mut b3GpuRaycast);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3JacobiSolverInfo {
    pub m_fixedBodyIndex: ::std::os::raw::c_int,
    pub m_deltaTime: f32,
    pub m_positionDrift: f32,
    pub m_positionConstraintCoeff: f32,
    pub m_numIterations: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3GpuJacobiContactSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuJacobiContactSolver {
    pub vtable_: *const b3GpuJacobiContactSolver__bindgen_vtable,
    pub m_data: *mut b3GpuJacobiSolverInternalData,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
}
extern "C" {
    #[link_name = "\u{1}?solveContacts@b3GpuJacobiContactSolver@@QEAAXHPEAU_cl_mem@@0H0AEBUb3Config@@H@Z"]
    pub fn b3GpuJacobiContactSolver_solveContacts(
        this: *mut b3GpuJacobiContactSolver,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupHost@b3GpuJacobiContactSolver@@QEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HAEBUb3JacobiSolverInfo@@@Z"]
    pub fn b3GpuJacobiContactSolver_solveGroupHost(
        this: *mut b3GpuJacobiContactSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        solverInfo: *const b3JacobiSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuJacobiContactSolver@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3GpuJacobiContactSolver_b3GpuJacobiContactSolver(
        this: *mut b3GpuJacobiContactSolver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3GpuJacobiContactSolver {
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    ) {
        b3GpuJacobiContactSolver_solveContacts(
            self,
            numBodies,
            bodyBuf,
            inertiaBuf,
            numContacts,
            contactBuf,
            config,
            static0Index,
        )
    }
    #[inline]
    pub unsafe fn solveGroupHost(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        solverInfo: *const b3JacobiSolverInfo,
    ) {
        b3GpuJacobiContactSolver_solveGroupHost(
            self,
            bodies,
            inertias,
            numBodies,
            manifoldPtr,
            numManifolds,
            solverInfo,
        )
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuJacobiContactSolver_b3GpuJacobiContactSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            queue,
            pairCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuJacobiContactSolver@@QEAAXXZ"]
    pub fn b3GpuJacobiContactSolver_b3GpuJacobiContactSolver_destructor(
        this: *mut b3GpuJacobiContactSolver,
    );
}
#[repr(C)]
pub struct b3GpuNarrowPhase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuNarrowPhase {
    pub vtable_: *const b3GpuNarrowPhase__bindgen_vtable,
    pub m_data: *mut b3GpuNarrowPhaseInternalData,
    pub m_acceleratedCompanionShapeIndex: ::std::os::raw::c_int,
    pub m_planeBodyIndex: ::std::os::raw::c_int,
    pub m_static0Index: ::std::os::raw::c_int,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShapeInternal@b3GpuNarrowPhase@@IEAAHPEAVb3ConvexUtility@@AEAUb3Collidable@@@Z"]
    pub fn b3GpuNarrowPhase_registerConvexHullShapeInternal(
        this: *mut b3GpuNarrowPhase,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConcaveMeshShape@b3GpuNarrowPhase@@IEAAHPEAV?$b3AlignedObjectArray@Vb3Vector3@@@@PEAV?$b3AlignedObjectArray@H@@AEAUb3Collidable@@PEBM@Z"]
    pub fn b3GpuNarrowPhase_registerConcaveMeshShape(
        this: *mut b3GpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerSphereShape@b3GpuNarrowPhase@@QEAAHM@Z"]
    pub fn b3GpuNarrowPhase_registerSphereShape(
        this: *mut b3GpuNarrowPhase,
        radius: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerPlaneShape@b3GpuNarrowPhase@@QEAAHAEBVb3Vector3@@M@Z"]
    pub fn b3GpuNarrowPhase_registerPlaneShape(
        this: *mut b3GpuNarrowPhase,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerCompoundShape@b3GpuNarrowPhase@@QEAAHPEAV?$b3AlignedObjectArray@Ub3GpuChildShape@@@@@Z"]
    pub fn b3GpuNarrowPhase_registerCompoundShape(
        this: *mut b3GpuNarrowPhase,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerFace@b3GpuNarrowPhase@@QEAAHAEBVb3Vector3@@M@Z"]
    pub fn b3GpuNarrowPhase_registerFace(
        this: *mut b3GpuNarrowPhase,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConcaveMesh@b3GpuNarrowPhase@@QEAAHPEAV?$b3AlignedObjectArray@Vb3Vector3@@@@PEAV?$b3AlignedObjectArray@H@@PEBM@Z"]
    pub fn b3GpuNarrowPhase_registerConcaveMesh(
        this: *mut b3GpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShape@b3GpuNarrowPhase@@QEAAHPEAVb3ConvexUtility@@@Z"]
    pub fn b3GpuNarrowPhase_registerConvexHullShape(
        this: *mut b3GpuNarrowPhase,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerConvexHullShape@b3GpuNarrowPhase@@QEAAHPEBMHH0@Z"]
    pub fn b3GpuNarrowPhase_registerConvexHullShape1(
        this: *mut b3GpuNarrowPhase,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerRigidBody@b3GpuNarrowPhase@@QEAAHHMPEBM000_N@Z"]
    pub fn b3GpuNarrowPhase_registerRigidBody(
        this: *mut b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        aabbMin: *const f32,
        aabbMax: *const f32,
        writeToGpu: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setObjectTransform@b3GpuNarrowPhase@@QEAAXPEBM0H@Z"]
    pub fn b3GpuNarrowPhase_setObjectTransform(
        this: *mut b3GpuNarrowPhase,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeAllBodiesToGpu@b3GpuNarrowPhase@@QEAAXXZ"]
    pub fn b3GpuNarrowPhase_writeAllBodiesToGpu(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?reset@b3GpuNarrowPhase@@QEAAXXZ"]
    pub fn b3GpuNarrowPhase_reset(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?readbackAllBodiesToCpu@b3GpuNarrowPhase@@QEAAXXZ"]
    pub fn b3GpuNarrowPhase_readbackAllBodiesToCpu(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?getObjectTransformFromCpu@b3GpuNarrowPhase@@QEBA_NPEAM0H@Z"]
    pub fn b3GpuNarrowPhase_getObjectTransformFromCpu(
        this: *const b3GpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setObjectTransformCpu@b3GpuNarrowPhase@@QEAAXPEAM0H@Z"]
    pub fn b3GpuNarrowPhase_setObjectTransformCpu(
        this: *mut b3GpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setObjectVelocityCpu@b3GpuNarrowPhase@@QEAAXPEAM0H@Z"]
    pub fn b3GpuNarrowPhase_setObjectVelocityCpu(
        this: *mut b3GpuNarrowPhase,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBodiesGpu@b3GpuNarrowPhase@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuNarrowPhase_getBodiesGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getBodiesCpu@b3GpuNarrowPhase@@QEBAPEBUb3RigidBodyData@@XZ"]
    pub fn b3GpuNarrowPhase_getBodiesCpu(this: *const b3GpuNarrowPhase) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodiesGpu@b3GpuNarrowPhase@@QEBAHXZ"]
    pub fn b3GpuNarrowPhase_getNumBodiesGpu(this: *const b3GpuNarrowPhase)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBodyInertiasGpu@b3GpuNarrowPhase@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuNarrowPhase_getBodyInertiasGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodyInertiasGpu@b3GpuNarrowPhase@@QEBAHXZ"]
    pub fn b3GpuNarrowPhase_getNumBodyInertiasGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getCollidablesGpu@b3GpuNarrowPhase@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuNarrowPhase_getCollidablesGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getCollidablesCpu@b3GpuNarrowPhase@@QEBAPEBUb3Collidable@@XZ"]
    pub fn b3GpuNarrowPhase_getCollidablesCpu(this: *const b3GpuNarrowPhase)
        -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getNumCollidablesGpu@b3GpuNarrowPhase@@QEBAHXZ"]
    pub fn b3GpuNarrowPhase_getNumCollidablesGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getLocalSpaceAabbsCpu@b3GpuNarrowPhase@@QEBAPEBUb3SapAabb@@XZ"]
    pub fn b3GpuNarrowPhase_getLocalSpaceAabbsCpu(
        this: *const b3GpuNarrowPhase,
    ) -> *const b3SapAabb;
}
extern "C" {
    #[link_name = "\u{1}?getContactsCPU@b3GpuNarrowPhase@@QEBAPEBUb3Contact4@@XZ"]
    pub fn b3GpuNarrowPhase_getContactsCPU(this: *const b3GpuNarrowPhase) -> *const b3Contact4;
}
extern "C" {
    #[link_name = "\u{1}?getContactsGpu@b3GpuNarrowPhase@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuNarrowPhase_getContactsGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumContactsGpu@b3GpuNarrowPhase@@QEBAHXZ"]
    pub fn b3GpuNarrowPhase_getNumContactsGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getAabbLocalSpaceBufferGpu@b3GpuNarrowPhase@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuNarrowPhase_getAabbLocalSpaceBufferGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumRigidBodies@b3GpuNarrowPhase@@QEBAHXZ"]
    pub fn b3GpuNarrowPhase_getNumRigidBodies(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?allocateCollidable@b3GpuNarrowPhase@@QEAAHXZ"]
    pub fn b3GpuNarrowPhase_allocateCollidable(
        this: *mut b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getCollidableCpu@b3GpuNarrowPhase@@QEAAAEAUb3Collidable@@H@Z"]
    pub fn b3GpuNarrowPhase_getCollidableCpu(
        this: *mut b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getCollidableCpu@b3GpuNarrowPhase@@QEBAAEBUb3Collidable@@H@Z"]
    pub fn b3GpuNarrowPhase_getCollidableCpu1(
        this: *const b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}?getLocalSpaceAabb@b3GpuNarrowPhase@@QEBAAEBUb3SapAabb@@H@Z"]
    pub fn b3GpuNarrowPhase_getLocalSpaceAabb(
        this: *const b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3SapAabb;
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuNarrowPhase@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@AEBUb3Config@@@Z"]
    pub fn b3GpuNarrowPhase_b3GpuNarrowPhase(
        this: *mut b3GpuNarrowPhase,
        vtx: cl_context,
        dev: cl_device_id,
        q: cl_command_queue,
        config: *const b3Config,
    );
}
impl b3GpuNarrowPhase {
    #[inline]
    pub unsafe fn registerConvexHullShapeInternal(
        &mut self,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShapeInternal(self, convexPtr, col)
    }
    #[inline]
    pub unsafe fn registerConcaveMeshShape(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConcaveMeshShape(self, vertices, indices, col, scaling)
    }
    #[inline]
    pub unsafe fn registerSphereShape(&mut self, radius: f32) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerSphereShape(self, radius)
    }
    #[inline]
    pub unsafe fn registerPlaneShape(
        &mut self,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerPlaneShape(self, planeNormal, planeConstant)
    }
    #[inline]
    pub unsafe fn registerCompoundShape(
        &mut self,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerCompoundShape(self, childShapes)
    }
    #[inline]
    pub unsafe fn registerFace(
        &mut self,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerFace(self, faceNormal, faceConstant)
    }
    #[inline]
    pub unsafe fn registerConcaveMesh(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConcaveMesh(self, vertices, indices, scaling)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape(
        &mut self,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShape(self, utilPtr)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape1(
        &mut self,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShape1(
            self,
            vertices,
            strideInBytes,
            numVertices,
            scaling,
        )
    }
    #[inline]
    pub unsafe fn registerRigidBody(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        aabbMin: *const f32,
        aabbMax: *const f32,
        writeToGpu: bool,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerRigidBody(
            self,
            collidableIndex,
            mass,
            position,
            orientation,
            aabbMin,
            aabbMax,
            writeToGpu,
        )
    }
    #[inline]
    pub unsafe fn setObjectTransform(
        &mut self,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectTransform(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn writeAllBodiesToGpu(&mut self) {
        b3GpuNarrowPhase_writeAllBodiesToGpu(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuNarrowPhase_reset(self)
    }
    #[inline]
    pub unsafe fn readbackAllBodiesToCpu(&mut self) {
        b3GpuNarrowPhase_readbackAllBodiesToCpu(self)
    }
    #[inline]
    pub unsafe fn getObjectTransformFromCpu(
        &self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool {
        b3GpuNarrowPhase_getObjectTransformFromCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectTransformCpu(
        &mut self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectTransformCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectVelocityCpu(
        &mut self,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectVelocityCpu(self, linVel, angVel, bodyIndex)
    }
    #[inline]
    pub unsafe fn getBodiesGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getBodiesCpu(&self) -> *const b3RigidBodyData {
        b3GpuNarrowPhase_getBodiesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodiesGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getBodyInertiasGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodyInertiasGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesCpu(&self) -> *const b3Collidable {
        b3GpuNarrowPhase_getCollidablesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumCollidablesGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabbsCpu(&self) -> *const b3SapAabb {
        b3GpuNarrowPhase_getLocalSpaceAabbsCpu(self)
    }
    #[inline]
    pub unsafe fn getContactsCPU(&self) -> *const b3Contact4 {
        b3GpuNarrowPhase_getContactsCPU(self)
    }
    #[inline]
    pub unsafe fn getContactsGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getContactsGpu(self)
    }
    #[inline]
    pub unsafe fn getNumContactsGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumContactsGpu(self)
    }
    #[inline]
    pub unsafe fn getAabbLocalSpaceBufferGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getAabbLocalSpaceBufferGpu(self)
    }
    #[inline]
    pub unsafe fn getNumRigidBodies(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumRigidBodies(self)
    }
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn getCollidableCpu(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable {
        b3GpuNarrowPhase_getCollidableCpu(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getCollidableCpu1(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable {
        b3GpuNarrowPhase_getCollidableCpu1(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabb(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3SapAabb {
        b3GpuNarrowPhase_getLocalSpaceAabb(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn new(
        vtx: cl_context,
        dev: cl_device_id,
        q: cl_command_queue,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuNarrowPhase_b3GpuNarrowPhase(&mut __bindgen_tmp, vtx, dev, q, config);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuNarrowPhase@@QEAAXXZ"]
    pub fn b3GpuNarrowPhase_b3GpuNarrowPhase_destructor(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}?computeContacts@b3GpuNarrowPhase@@UEAAXPEAU_cl_mem@@H0H@Z"]
    pub fn b3GpuNarrowPhase_computeContacts(
        this: *mut ::std::os::raw::c_void,
        broadphasePairs: cl_mem,
        numBroadphasePairs: ::std::os::raw::c_int,
        aabbsWorldSpace: cl_mem,
        numObjects: ::std::os::raw::c_int,
    );
}
/// The b3SolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuSolverBody {
    pub m_deltaLinearVelocity: b3Vector3,
    pub m_deltaAngularVelocity: b3Vector3,
    pub m_angularFactor: b3Vector3,
    pub m_linearFactor: b3Vector3,
    pub m_invMass: b3Vector3,
    pub m_pushVelocity: b3Vector3,
    pub m_turnVelocity: b3Vector3,
    pub m_linearVelocity: b3Vector3,
    pub m_angularVelocity: b3Vector3,
    pub __bindgen_anon_1: b3GpuSolverBody__bindgen_ty_1,
    pub padding: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuSolverBody__bindgen_ty_1 {
    pub m_originalBody: *mut ::std::os::raw::c_void,
    pub m_originalBodyIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuSolverConstraint {
    pub m_relpos1CrossNormal: b3Vector3,
    pub m_contactNormal: b3Vector3,
    pub m_relpos2CrossNormal: b3Vector3,
    pub m_angularComponentA: b3Vector3,
    pub m_angularComponentB: b3Vector3,
    pub m_appliedPushImpulse: b3Scalar,
    pub m_appliedImpulse: b3Scalar,
    pub m_padding1: ::std::os::raw::c_int,
    pub m_padding2: ::std::os::raw::c_int,
    pub m_friction: b3Scalar,
    pub m_jacDiagABInv: b3Scalar,
    pub m_rhs: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_lowerLimit: b3Scalar,
    pub m_upperLimit: b3Scalar,
    pub m_rhsPenetration: b3Scalar,
    pub __bindgen_anon_1: b3GpuSolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuSolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_originalConstraintIndex: ::std::os::raw::c_int,
    pub m_unusedPadding4: b3Scalar,
    _bindgen_union_align: u64,
}
pub const b3GpuSolverConstraint_b3SolverConstraintType_B3_SOLVER_CONTACT_1D:
    b3GpuSolverConstraint_b3SolverConstraintType = 0;
pub const b3GpuSolverConstraint_b3SolverConstraintType_B3_SOLVER_FRICTION_1D:
    b3GpuSolverConstraint_b3SolverConstraintType = 1;
pub type b3GpuSolverConstraint_b3SolverConstraintType = i32;
pub type b3GpuConstraintArray = b3AlignedObjectArray<b3GpuSolverConstraint>;
pub const b3GpuGenericConstraintType_B3_GPU_POINT2POINT_CONSTRAINT_TYPE:
    b3GpuGenericConstraintType = 3;
pub const b3GpuGenericConstraintType_B3_GPU_FIXED_CONSTRAINT_TYPE: b3GpuGenericConstraintType = 4;
pub const b3GpuGenericConstraintType_B3_GPU_MAX_CONSTRAINT_TYPE: b3GpuGenericConstraintType = 5;
pub type b3GpuGenericConstraintType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuConstraintInfo2 {
    pub fps: b3Scalar,
    pub erp: b3Scalar,
    pub m_J1linearAxis: *mut b3Scalar,
    pub m_J1angularAxis: *mut b3Scalar,
    pub m_J2linearAxis: *mut b3Scalar,
    pub m_J2angularAxis: *mut b3Scalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut b3Scalar,
    pub cfm: *mut b3Scalar,
    pub m_lowerLimit: *mut b3Scalar,
    pub m_upperLimit: *mut b3Scalar,
    pub findex: *mut ::std::os::raw::c_int,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: b3Scalar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuGenericConstraint {
    pub m_constraintType: ::std::os::raw::c_int,
    pub m_rbA: ::std::os::raw::c_int,
    pub m_rbB: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_relTargetAB: b3Quaternion,
    pub m_flags: ::std::os::raw::c_int,
    pub m_uid: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 2usize],
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getInfo1@b3GpuGenericConstraint@@QEAAXPEAIPEBUb3RigidBodyData@@@Z"]
    pub fn b3GpuGenericConstraint_getInfo1(
        this: *mut b3GpuGenericConstraint,
        info: *mut ::std::os::raw::c_uint,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getInfo2@b3GpuGenericConstraint@@QEAAXPEAUb3GpuConstraintInfo2@@PEBUb3RigidBodyData@@@Z"]
    pub fn b3GpuGenericConstraint_getInfo2(
        this: *mut b3GpuGenericConstraint,
        info: *mut b3GpuConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
impl b3GpuGenericConstraint {
    #[inline]
    pub unsafe fn getInfo1(
        &mut self,
        info: *mut ::std::os::raw::c_uint,
        bodies: *const b3RigidBodyData,
    ) {
        b3GpuGenericConstraint_getInfo1(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2(
        &mut self,
        info: *mut b3GpuConstraintInfo2,
        bodies: *const b3RigidBodyData,
    ) {
        b3GpuGenericConstraint_getInfo2(self, info, bodies)
    }
}
#[repr(C)]
pub struct b3GpuPgsConstraintSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3GpuPgsConstraintSolver {
    pub vtable_: *const b3GpuPgsConstraintSolver__bindgen_vtable,
    pub m_staticIdx: ::std::os::raw::c_int,
    pub m_gpuData: *mut b3GpuPgsJacobiSolverInternalData,
    pub m_tmpSolverBodyPool: b3AlignedObjectArray<b3GpuSolverBody>,
    pub m_tmpSolverContactConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: b3GpuConstraintArray,
    pub m_tmpConstraintSizesPool: b3AlignedObjectArray<::std::os::raw::c_uint>,
    pub m_usePgs: bool,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_numSplitImpulseRecoveries: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?averageVelocities@b3GpuPgsConstraintSolver@@IEAAXXZ"]
    pub fn b3GpuPgsConstraintSolver_averageVelocities(this: *mut b3GpuPgsConstraintSolver);
}
extern "C" {
    #[link_name = "\u{1}?initSolverBody@b3GpuPgsConstraintSolver@@IEAAXHPEAUb3GpuSolverBody@@PEAUb3RigidBodyData@@@Z"]
    pub fn b3GpuPgsConstraintSolver_initSolverBody(
        this: *mut b3GpuPgsConstraintSolver,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3GpuSolverBody,
        rb: *mut b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@b3GpuPgsConstraintSolver@@QEAAMPEAV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEAV?$b3OpenCLArray@Ub3InertiaData@@@@HPEAV?$b3OpenCLArray@Ub3GpuGenericConstraint@@@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut b3GpuPgsConstraintSolver,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroup@b3GpuPgsConstraintSolver@@QEAAMPEAV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEAV?$b3OpenCLArray@Ub3InertiaData@@@@HPEAV?$b3OpenCLArray@Ub3GpuGenericConstraint@@@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3GpuPgsConstraintSolver_solveGroup(
        this: *mut b3GpuPgsConstraintSolver,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveJoints@b3GpuPgsConstraintSolver@@QEAAXHPEAV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEAV?$b3OpenCLArray@Ub3InertiaData@@@@HPEAV?$b3OpenCLArray@Ub3GpuGenericConstraint@@@@@Z"]
    pub fn b3GpuPgsConstraintSolver_solveJoints(
        this: *mut b3GpuPgsConstraintSolver,
        numBodies: ::std::os::raw::c_int,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?sortConstraintByBatch3@b3GpuPgsConstraintSolver@@QEAAHPEAUb3BatchConstraint@@HHHH@Z"]
    pub fn b3GpuPgsConstraintSolver_sortConstraintByBatch3(
        this: *mut b3GpuPgsConstraintSolver,
        cs: *mut b3BatchConstraint,
        numConstraints: ::std::os::raw::c_int,
        simdWidth: ::std::os::raw::c_int,
        staticIdx: ::std::os::raw::c_int,
        numBodies: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?recomputeBatches@b3GpuPgsConstraintSolver@@QEAAXXZ"]
    pub fn b3GpuPgsConstraintSolver_recomputeBatches(this: *mut b3GpuPgsConstraintSolver);
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuPgsConstraintSolver@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@_N@Z"]
    pub fn b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver(
        this: *mut b3GpuPgsConstraintSolver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        usePgs: bool,
    );
}
impl b3GpuPgsConstraintSolver {
    #[inline]
    pub unsafe fn averageVelocities(&mut self) {
        b3GpuPgsConstraintSolver_averageVelocities(self)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3GpuSolverBody,
        rb: *mut b3RigidBodyData,
    ) {
        b3GpuPgsConstraintSolver_initSolverBody(self, bodyIndex, solverBody, rb)
    }
    #[inline]
    pub unsafe fn solveGroupCacheFriendlyFinish(
        &mut self,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3GpuPgsConstraintSolver_solveGroupCacheFriendlyFinish(
            self,
            gpuBodies,
            gpuInertias,
            numBodies,
            gpuConstraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveGroup(
        &mut self,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3GpuPgsConstraintSolver_solveGroup(
            self,
            gpuBodies,
            gpuInertias,
            numBodies,
            gpuConstraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveJoints(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
    ) {
        b3GpuPgsConstraintSolver_solveJoints(
            self,
            numBodies,
            gpuBodies,
            gpuInertias,
            numConstraints,
            gpuConstraints,
        )
    }
    #[inline]
    pub unsafe fn sortConstraintByBatch3(
        &mut self,
        cs: *mut b3BatchConstraint,
        numConstraints: ::std::os::raw::c_int,
        simdWidth: ::std::os::raw::c_int,
        staticIdx: ::std::os::raw::c_int,
        numBodies: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3GpuPgsConstraintSolver_sortConstraintByBatch3(
            self,
            cs,
            numConstraints,
            simdWidth,
            staticIdx,
            numBodies,
        )
    }
    #[inline]
    pub unsafe fn recomputeBatches(&mut self) {
        b3GpuPgsConstraintSolver_recomputeBatches(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        usePgs: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            queue,
            usePgs,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuPgsConstraintSolver@@QEAAXXZ"]
    pub fn b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver_destructor(
        this: *mut b3GpuPgsConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyIterations@b3GpuPgsConstraintSolver@@UEAAMPEAV?$b3OpenCLArray@Ub3GpuGenericConstraint@@@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        gpuConstraints1: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@b3GpuPgsConstraintSolver@@UEAAMPEAV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEAV?$b3OpenCLArray@Ub3InertiaData@@@@HPEAV?$b3OpenCLArray@Ub3GpuGenericConstraint@@@@HAEBUb3ContactSolverInfo@@@Z"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Contact4 {
    pub _base: b3Contact4Data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuConstraint4 {
    pub _base: b3ContactConstraint4,
}
#[repr(C)]
pub struct b3GpuPgsContactSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuPgsContactSolver {
    pub vtable_: *const b3GpuPgsContactSolver__bindgen_vtable,
    pub m_debugOutput: ::std::os::raw::c_int,
    pub m_data: *mut b3GpuBatchingPgsSolverInternalData,
}
extern "C" {
    #[link_name = "\u{1}?batchContacts@b3GpuPgsContactSolver@@IEAAXPEAV?$b3OpenCLArray@Ub3Contact4@@@@HPEAV?$b3OpenCLArray@I@@1H@Z"]
    pub fn b3GpuPgsContactSolver_batchContacts(
        this: *mut b3GpuPgsContactSolver,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveContactConstraintBatchSizes@b3GpuPgsContactSolver@@IEAAXPEBV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEBV?$b3OpenCLArray@Ub3InertiaData@@@@PEAV?$b3OpenCLArray@Ub3GpuConstraint4@@@@PEAXHHHPEBV?$b3AlignedObjectArray@H@@@Z"]
    pub fn b3GpuPgsContactSolver_solveContactConstraintBatchSizes(
        this: *mut b3GpuPgsContactSolver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveContactConstraint@b3GpuPgsContactSolver@@IEAAXPEBV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEBV?$b3OpenCLArray@Ub3InertiaData@@@@PEAV?$b3OpenCLArray@Ub3GpuConstraint4@@@@PEAXHHHPEBV?$b3AlignedObjectArray@H@@@Z"]
    pub fn b3GpuPgsContactSolver_solveContactConstraint(
        this: *mut b3GpuPgsContactSolver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveContacts@b3GpuPgsContactSolver@@QEAAXHPEAU_cl_mem@@0H0AEBUb3Config@@H@Z"]
    pub fn b3GpuPgsContactSolver_solveContacts(
        this: *mut b3GpuPgsContactSolver,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuPgsContactSolver@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3GpuPgsContactSolver_b3GpuPgsContactSolver(
        this: *mut b3GpuPgsContactSolver,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3GpuPgsContactSolver {
    #[inline]
    pub unsafe fn batchContacts(
        &mut self,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    ) {
        b3GpuPgsContactSolver_batchContacts(self, contacts, nContacts, n, offsets, staticIdx)
    }
    #[inline]
    pub unsafe fn solveContactConstraintBatchSizes(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3GpuPgsContactSolver_solveContactConstraintBatchSizes(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            numIterations,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn solveContactConstraint(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3GpuPgsContactSolver_solveContactConstraint(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            numIterations,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    ) {
        b3GpuPgsContactSolver_solveContacts(
            self,
            numBodies,
            bodyBuf,
            inertiaBuf,
            numContacts,
            contactBuf,
            config,
            static0Index,
        )
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuPgsContactSolver_b3GpuPgsContactSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            q,
            pairCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuPgsContactSolver@@QEAAXXZ"]
    pub fn b3GpuPgsContactSolver_b3GpuPgsContactSolver_destructor(this: *mut b3GpuPgsContactSolver);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Config {
    pub m_maxConvexBodies: ::std::os::raw::c_int,
    pub m_maxConvexShapes: ::std::os::raw::c_int,
    pub m_maxBroadphasePairs: ::std::os::raw::c_int,
    pub m_maxContactCapacity: ::std::os::raw::c_int,
    pub m_compoundPairCapacity: ::std::os::raw::c_int,
    pub m_maxVerticesPerFace: ::std::os::raw::c_int,
    pub m_maxFacesPerShape: ::std::os::raw::c_int,
    pub m_maxConvexVertices: ::std::os::raw::c_int,
    pub m_maxConvexIndices: ::std::os::raw::c_int,
    pub m_maxConvexUniqueEdges: ::std::os::raw::c_int,
    pub m_maxCompoundChildShapes: ::std::os::raw::c_int,
    pub m_maxTriConvexPairCapacity: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3GpuRigidBodyPipeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuRigidBodyPipeline {
    pub vtable_: *const b3GpuRigidBodyPipeline__bindgen_vtable,
    pub m_data: *mut b3GpuRigidBodyPipelineInternalData,
}
extern "C" {
    #[link_name = "\u{1}?allocateCollidable@b3GpuRigidBodyPipeline@@IEAAHXZ"]
    pub fn b3GpuRigidBodyPipeline_allocateCollidable(
        this: *mut b3GpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?stepSimulation@b3GpuRigidBodyPipeline@@QEAAXM@Z"]
    pub fn b3GpuRigidBodyPipeline_stepSimulation(this: *mut b3GpuRigidBodyPipeline, deltaTime: f32);
}
extern "C" {
    #[link_name = "\u{1}?integrate@b3GpuRigidBodyPipeline@@QEAAXM@Z"]
    pub fn b3GpuRigidBodyPipeline_integrate(this: *mut b3GpuRigidBodyPipeline, timeStep: f32);
}
extern "C" {
    #[link_name = "\u{1}?setupGpuAabbsFull@b3GpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3GpuRigidBodyPipeline_setupGpuAabbsFull(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?registerConvexPolyhedron@b3GpuRigidBodyPipeline@@QEAAHPEAVb3ConvexUtility@@@Z"]
    pub fn b3GpuRigidBodyPipeline_registerConvexPolyhedron(
        this: *mut b3GpuRigidBodyPipeline,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?registerPhysicsInstance@b3GpuRigidBodyPipeline@@QEAAHMPEBM0HH_N@Z"]
    pub fn b3GpuRigidBodyPipeline_registerPhysicsInstance(
        this: *mut b3GpuRigidBodyPipeline,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
        writeInstanceToGpu: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?writeAllInstancesToGpu@b3GpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3GpuRigidBodyPipeline_writeAllInstancesToGpu(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?copyConstraintsToHost@b3GpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3GpuRigidBodyPipeline_copyConstraintsToHost(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?setGravity@b3GpuRigidBodyPipeline@@QEAAXPEBM@Z"]
    pub fn b3GpuRigidBodyPipeline_setGravity(this: *mut b3GpuRigidBodyPipeline, grav: *const f32);
}
extern "C" {
    #[link_name = "\u{1}?reset@b3GpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3GpuRigidBodyPipeline_reset(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}?createPoint2PointConstraint@b3GpuRigidBodyPipeline@@QEAAHHHPEBM0M@Z"]
    pub fn b3GpuRigidBodyPipeline_createPoint2PointConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createFixedConstraint@b3GpuRigidBodyPipeline@@QEAAHHHPEBM00M@Z"]
    pub fn b3GpuRigidBodyPipeline_createFixedConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?removeConstraintByUid@b3GpuRigidBodyPipeline@@QEAAXH@Z"]
    pub fn b3GpuRigidBodyPipeline_removeConstraintByUid(
        this: *mut b3GpuRigidBodyPipeline,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addConstraint@b3GpuRigidBodyPipeline@@QEAAXPEAVb3TypedConstraint@@@Z"]
    pub fn b3GpuRigidBodyPipeline_addConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeConstraint@b3GpuRigidBodyPipeline@@QEAAXPEAVb3TypedConstraint@@@Z"]
    pub fn b3GpuRigidBodyPipeline_removeConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?castRays@b3GpuRigidBodyPipeline@@QEAAXAEBV?$b3AlignedObjectArray@Ub3RayInfo@@@@AEAV?$b3AlignedObjectArray@Ub3RayHit@@@@@Z"]
    pub fn b3GpuRigidBodyPipeline_castRays(
        this: *mut b3GpuRigidBodyPipeline,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    );
}
extern "C" {
    #[link_name = "\u{1}?getBodyBuffer@b3GpuRigidBodyPipeline@@QEAAPEAU_cl_mem@@XZ"]
    pub fn b3GpuRigidBodyPipeline_getBodyBuffer(this: *mut b3GpuRigidBodyPipeline) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}?getNumBodies@b3GpuRigidBodyPipeline@@QEBAHXZ"]
    pub fn b3GpuRigidBodyPipeline_getNumBodies(
        this: *const b3GpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}??0b3GpuRigidBodyPipeline@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@PEAVb3GpuNarrowPhase@@PEAVb3GpuBroadphaseInterface@@PEAUb3DynamicBvhBroadphase@@AEBUb3Config@@@Z"]
    pub fn b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline(
        this: *mut b3GpuRigidBodyPipeline,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        narrowphase: *mut b3GpuNarrowPhase,
        broadphaseSap: *mut b3GpuBroadphaseInterface,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    );
}
impl b3GpuRigidBodyPipeline {
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn stepSimulation(&mut self, deltaTime: f32) {
        b3GpuRigidBodyPipeline_stepSimulation(self, deltaTime)
    }
    #[inline]
    pub unsafe fn integrate(&mut self, timeStep: f32) {
        b3GpuRigidBodyPipeline_integrate(self, timeStep)
    }
    #[inline]
    pub unsafe fn setupGpuAabbsFull(&mut self) {
        b3GpuRigidBodyPipeline_setupGpuAabbsFull(self)
    }
    #[inline]
    pub unsafe fn registerConvexPolyhedron(
        &mut self,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_registerConvexPolyhedron(self, convex)
    }
    #[inline]
    pub unsafe fn registerPhysicsInstance(
        &mut self,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
        writeInstanceToGpu: bool,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_registerPhysicsInstance(
            self,
            mass,
            position,
            orientation,
            collisionShapeIndex,
            userData,
            writeInstanceToGpu,
        )
    }
    #[inline]
    pub unsafe fn writeAllInstancesToGpu(&mut self) {
        b3GpuRigidBodyPipeline_writeAllInstancesToGpu(self)
    }
    #[inline]
    pub unsafe fn copyConstraintsToHost(&mut self) {
        b3GpuRigidBodyPipeline_copyConstraintsToHost(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, grav: *const f32) {
        b3GpuRigidBodyPipeline_setGravity(self, grav)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuRigidBodyPipeline_reset(self)
    }
    #[inline]
    pub unsafe fn createPoint2PointConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_createPoint2PointConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn createFixedConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_createFixedConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            relTargetAB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn removeConstraintByUid(&mut self, uid: ::std::os::raw::c_int) {
        b3GpuRigidBodyPipeline_removeConstraintByUid(self, uid)
    }
    #[inline]
    pub unsafe fn addConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3GpuRigidBodyPipeline_addConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn removeConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3GpuRigidBodyPipeline_removeConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    ) {
        b3GpuRigidBodyPipeline_castRays(self, rays, hitResults)
    }
    #[inline]
    pub unsafe fn getBodyBuffer(&mut self) -> cl_mem {
        b3GpuRigidBodyPipeline_getBodyBuffer(self)
    }
    #[inline]
    pub unsafe fn getNumBodies(&self) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_getNumBodies(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        narrowphase: *mut b3GpuNarrowPhase,
        broadphaseSap: *mut b3GpuBroadphaseInterface,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline(
            &mut __bindgen_tmp,
            ctx,
            device,
            q,
            narrowphase,
            broadphaseSap,
            broadphaseDbvt,
            config,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3GpuRigidBodyPipeline@@QEAAXXZ"]
    pub fn b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline_destructor(
        this: *mut b3GpuRigidBodyPipeline,
    );
}
#[repr(C)]
pub struct b3GpuRigidBodyPipelineInternalData {
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_integrateTransformsKernel: cl_kernel,
    pub m_updateAabbsKernel: cl_kernel,
    pub m_clearOverlappingPairsKernel: cl_kernel,
    pub m_solver: *mut b3PgsJacobiSolver,
    pub m_gpuSolver: *mut b3GpuPgsConstraintSolver,
    pub m_solver2: *mut b3GpuPgsContactSolver,
    pub m_solver3: *mut b3GpuJacobiContactSolver,
    pub m_raycaster: *mut b3GpuRaycast,
    pub m_broadphaseSap: *mut b3GpuBroadphaseInterface,
    pub m_broadphaseDbvt: *mut b3DynamicBvhBroadphase,
    pub m_allAabbsGPU: *mut b3OpenCLArray,
    pub m_allAabbsCPU: b3AlignedObjectArray<b3SapAabb>,
    pub m_overlappingPairsGPU: *mut b3OpenCLArray,
    pub m_gpuConstraints: *mut b3OpenCLArray,
    pub m_cpuConstraints: b3AlignedObjectArray<b3GpuGenericConstraint>,
    pub m_joints: b3AlignedObjectArray<*mut b3TypedConstraint>,
    pub m_constraintUid: ::std::os::raw::c_int,
    pub m_narrowphase: *mut b3GpuNarrowPhase,
    pub m_gravity: b3Vector3,
    pub m_config: b3Config,
}
#[repr(C)]
pub struct b3BoundSearchCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3BoundSearchCL {
    pub vtable_: *const b3BoundSearchCL__bindgen_vtable,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_lowerSortDataKernel: cl_kernel,
    pub m_upperSortDataKernel: cl_kernel,
    pub m_subtractKernel: cl_kernel,
    pub m_constbtOpenCLArray: *mut b3OpenCLArray,
    pub m_lower: *mut b3OpenCLArray,
    pub m_upper: *mut b3OpenCLArray,
    pub m_filler: *mut b3FillCL,
}
pub const b3BoundSearchCL_Option_BOUND_LOWER: b3BoundSearchCL_Option = 0;
pub const b3BoundSearchCL_Option_BOUND_UPPER: b3BoundSearchCL_Option = 1;
pub const b3BoundSearchCL_Option_COUNT: b3BoundSearchCL_Option = 2;
pub type b3BoundSearchCL_Option = i32;
extern "C" {
    #[link_name = "\u{1}?execute@b3BoundSearchCL@@QEAAXAEAV?$b3OpenCLArray@Ub3SortData@@@@HAEAV?$b3OpenCLArray@I@@HW4Option@1@@Z"]
    pub fn b3BoundSearchCL_execute(
        this: *mut b3BoundSearchCL,
        src: *mut b3OpenCLArray,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3OpenCLArray,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    );
}
extern "C" {
    #[link_name = "\u{1}?executeHost@b3BoundSearchCL@@QEAAXAEAV?$b3AlignedObjectArray@Ub3SortData@@@@HAEAV?$b3AlignedObjectArray@I@@HW4Option@1@@Z"]
    pub fn b3BoundSearchCL_executeHost(
        this: *mut b3BoundSearchCL,
        src: *mut b3AlignedObjectArray<b3SortData>,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3BoundSearchCL@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3BoundSearchCL_b3BoundSearchCL(
        this: *mut b3BoundSearchCL,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    );
}
impl b3BoundSearchCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3OpenCLArray,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    ) {
        b3BoundSearchCL_execute(self, src, nSrc, dst, nDst, option)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<b3SortData>,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    ) {
        b3BoundSearchCL_executeHost(self, src, nSrc, dst, nDst, option)
    }
    #[inline]
    pub unsafe fn new(
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3BoundSearchCL_b3BoundSearchCL(&mut __bindgen_tmp, context, device, queue, size);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3BoundSearchCL@@QEAAXXZ"]
    pub fn b3BoundSearchCL_b3BoundSearchCL_destructor(this: *mut b3BoundSearchCL);
}
extern "C" {
    /// CL Context optionally takes a GL context. This is a generic type because we don't really want this code
    /// to have to understand GL types. It is a HGLRC in _WIN32 or a GLXContext otherwise.
    pub fn b3OpenCLUtils_createContextFromType(
        deviceType: cl_device_type,
        pErrNum: *mut cl_int,
        pGLCtx: *mut ::std::os::raw::c_void,
        pGLDC: *mut ::std::os::raw::c_void,
        preferredDeviceIndex: ::std::os::raw::c_int,
        preferredPlatformIndex: ::std::os::raw::c_int,
        platformId: *mut cl_platform_id,
    ) -> cl_context;
}
extern "C" {
    pub fn b3OpenCLUtils_getNumDevices(cxMainContext: cl_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3OpenCLUtils_getDevice(
        cxMainContext: cl_context,
        nr: ::std::os::raw::c_int,
    ) -> cl_device_id;
}
extern "C" {
    pub fn b3OpenCLUtils_printDeviceInfo(device: cl_device_id);
}
extern "C" {
    pub fn b3OpenCLUtils_compileCLKernelFromString(
        clContext: cl_context,
        device: cl_device_id,
        kernelSource: *const ::std::os::raw::c_char,
        kernelName: *const ::std::os::raw::c_char,
        pErrNum: *mut cl_int,
        prog: cl_program,
        additionalMacros: *const ::std::os::raw::c_char,
    ) -> cl_kernel;
}
extern "C" {
    pub fn b3OpenCLUtils_compileCLProgramFromString(
        clContext: cl_context,
        device: cl_device_id,
        kernelSource: *const ::std::os::raw::c_char,
        pErrNum: *mut cl_int,
        additionalMacros: *const ::std::os::raw::c_char,
        srcFileNameForCaching: *const ::std::os::raw::c_char,
        disableBinaryCaching: bool,
    ) -> cl_program;
}
extern "C" {
    pub fn b3OpenCLUtils_getNumPlatforms(pErrNum: *mut cl_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get the nr'th platform, where nr is in the range [0..getNumPlatforms)
    pub fn b3OpenCLUtils_getPlatform(
        nr: ::std::os::raw::c_int,
        pErrNum: *mut cl_int,
    ) -> cl_platform_id;
}
extern "C" {
    pub fn b3OpenCLUtils_printPlatformInfo(platform: cl_platform_id);
}
extern "C" {
    pub fn b3OpenCLUtils_getSdkVendorName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// set the path (directory/folder) where the compiled OpenCL kernel are stored
    pub fn b3OpenCLUtils_setCachePath(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn b3OpenCLUtils_createContextFromPlatform(
        platform: cl_platform_id,
        deviceType: cl_device_type,
        pErrNum: *mut cl_int,
        pGLCtx: *mut ::std::os::raw::c_void,
        pGLDC: *mut ::std::os::raw::c_void,
        preferredDeviceIndex: ::std::os::raw::c_int,
        preferredPlatformIndex: ::std::os::raw::c_int,
    ) -> cl_context;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3OpenCLDeviceInfo {
    pub m_deviceName: [::std::os::raw::c_char; 1024usize],
    pub m_deviceVendor: [::std::os::raw::c_char; 1024usize],
    pub m_driverVersion: [::std::os::raw::c_char; 1024usize],
    pub m_deviceExtensions: [::std::os::raw::c_char; 1024usize],
    pub m_deviceType: cl_device_type,
    pub m_computeUnits: cl_uint,
    pub m_workitemDims: usize,
    pub m_workItemSize: [usize; 3usize],
    pub m_image2dMaxWidth: usize,
    pub m_image2dMaxHeight: usize,
    pub m_image3dMaxWidth: usize,
    pub m_image3dMaxHeight: usize,
    pub m_image3dMaxDepth: usize,
    pub m_workgroupSize: usize,
    pub m_clockFrequency: cl_uint,
    pub m_constantBufferSize: cl_ulong,
    pub m_localMemSize: cl_ulong,
    pub m_globalMemSize: cl_ulong,
    pub m_errorCorrectionSupport: cl_bool,
    pub m_localMemType: cl_device_local_mem_type,
    pub m_maxReadImageArgs: cl_uint,
    pub m_maxWriteImageArgs: cl_uint,
    pub m_addressBits: cl_uint,
    pub m_maxMemAllocSize: cl_ulong,
    pub m_queueProperties: cl_command_queue_properties,
    pub m_imageSupport: cl_bool,
    pub m_vecWidthChar: cl_uint,
    pub m_vecWidthShort: cl_uint,
    pub m_vecWidthInt: cl_uint,
    pub m_vecWidthLong: cl_uint,
    pub m_vecWidthFloat: cl_uint,
    pub m_vecWidthDouble: cl_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3OpenCLPlatformInfo {
    pub m_platformVendor: [::std::os::raw::c_char; 1024usize],
    pub m_platformName: [::std::os::raw::c_char; 1024usize],
    pub m_platformVersion: [::std::os::raw::c_char; 1024usize],
}
/// C++ API for OpenCL utilities: convenience functions
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3OpenCLUtils {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?getDeviceInfo@b3OpenCLUtils@@SAXPEAU_cl_device_id@@PEAUb3OpenCLDeviceInfo@@@Z"]
    pub fn b3OpenCLUtils_getDeviceInfo(device: cl_device_id, info: *mut b3OpenCLDeviceInfo);
}
extern "C" {
    #[link_name = "\u{1}?getPlatformInfo@b3OpenCLUtils@@SAXPEAU_cl_platform_id@@PEAUb3OpenCLPlatformInfo@@@Z"]
    pub fn b3OpenCLUtils_getPlatformInfo(
        platform: cl_platform_id,
        platformInfo: *mut b3OpenCLPlatformInfo,
    );
}
impl b3OpenCLUtils {
    #[inline]
    pub unsafe fn getDeviceInfo(device: cl_device_id, info: *mut b3OpenCLDeviceInfo) {
        b3OpenCLUtils_getDeviceInfo(device, info)
    }
    #[inline]
    pub unsafe fn getPlatformInfo(
        platform: cl_platform_id,
        platformInfo: *mut b3OpenCLPlatformInfo,
    ) {
        b3OpenCLUtils_getPlatformInfo(platform, platformInfo)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SolverBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SolverBase_ConstraintCfg {
    pub m_positionDrift: f32,
    pub m_positionConstraintCoeff: f32,
    pub m_dt: f32,
    pub m_enableParallelSolve: bool,
    pub m_batchCellSize: f32,
    pub m_staticIdx: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3Solver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3Solver {
    pub vtable_: *const b3Solver__bindgen_vtable,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_numConstraints: *mut b3OpenCLArray,
    pub m_offsets: *mut b3OpenCLArray,
    pub m_batchSizes: b3OpenCLArray,
    pub m_nIterations: ::std::os::raw::c_int,
    pub m_batchingKernel: cl_kernel,
    pub m_batchingKernelNew: cl_kernel,
    pub m_solveContactKernel: cl_kernel,
    pub m_solveFrictionKernel: cl_kernel,
    pub m_contactToConstraintKernel: cl_kernel,
    pub m_setSortDataKernel: cl_kernel,
    pub m_reorderContactKernel: cl_kernel,
    pub m_copyConstraintKernel: cl_kernel,
    pub m_sort32: *mut b3RadixSort32CL,
    pub m_search: *mut b3BoundSearchCL,
    pub m_scan: *mut b3PrefixScanCL,
    pub m_sortDataBuffer: *mut b3OpenCLArray,
    pub m_contactBuffer2: *mut b3OpenCLArray,
}
pub const b3Solver_DYNAMIC_CONTACT_ALLOCATION_THRESHOLD: b3Solver__bindgen_ty_1 = 2000000;
pub type b3Solver__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?solveContactConstraint@b3Solver@@QEAAXPEBV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEBV?$b3OpenCLArray@Ub3InertiaData@@@@PEAV?$b3OpenCLArray@Ub3GpuConstraint4@@@@PEAXHH@Z"]
    pub fn b3Solver_solveContactConstraint(
        this: *mut b3Solver,
        bodyBuf: *const b3OpenCLArray,
        inertiaBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveContactConstraintHost@b3Solver@@QEAAXPEAV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEAV?$b3OpenCLArray@Ub3InertiaData@@@@PEAV?$b3OpenCLArray@Ub3GpuConstraint4@@@@PEAXHHPEAV?$b3AlignedObjectArray@H@@@Z"]
    pub fn b3Solver_solveContactConstraintHost(
        this: *mut b3Solver,
        bodyBuf: *mut b3OpenCLArray,
        shapeBuf: *mut b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        batchSizes: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertToConstraints@b3Solver@@QEAAXPEBV?$b3OpenCLArray@Ub3RigidBodyData@@@@PEBV?$b3OpenCLArray@Ub3InertiaData@@@@PEAV?$b3OpenCLArray@Ub3Contact4@@@@PEAV?$b3OpenCLArray@Ub3GpuConstraint4@@@@PEAXHAEBUConstraintCfg@b3SolverBase@@@Z"]
    pub fn b3Solver_convertToConstraints(
        this: *mut b3Solver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        contactsIn: *mut b3OpenCLArray,
        contactCOut: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        nContacts: ::std::os::raw::c_int,
        cfg: *const b3SolverBase_ConstraintCfg,
    );
}
extern "C" {
    #[link_name = "\u{1}?batchContacts@b3Solver@@QEAAXPEAV?$b3OpenCLArray@Ub3Contact4@@@@HPEAV?$b3OpenCLArray@I@@1H@Z"]
    pub fn b3Solver_batchContacts(
        this: *mut b3Solver,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0b3Solver@@QEAA@PEAU_cl_context@@PEAU_cl_device_id@@PEAU_cl_command_queue@@H@Z"]
    pub fn b3Solver_b3Solver(
        this: *mut b3Solver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3Solver {
    #[inline]
    pub unsafe fn solveContactConstraint(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        inertiaBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
    ) {
        b3Solver_solveContactConstraint(
            self,
            bodyBuf,
            inertiaBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
        )
    }
    #[inline]
    pub unsafe fn solveContactConstraintHost(
        &mut self,
        bodyBuf: *mut b3OpenCLArray,
        shapeBuf: *mut b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        batchSizes: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3Solver_solveContactConstraintHost(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn convertToConstraints(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        contactsIn: *mut b3OpenCLArray,
        contactCOut: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        nContacts: ::std::os::raw::c_int,
        cfg: *const b3SolverBase_ConstraintCfg,
    ) {
        b3Solver_convertToConstraints(
            self,
            bodyBuf,
            shapeBuf,
            contactsIn,
            contactCOut,
            additionalData,
            nContacts,
            cfg,
        )
    }
    #[inline]
    pub unsafe fn batchContacts(
        &mut self,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    ) {
        b3Solver_batchContacts(self, contacts, nContacts, n, offsets, staticIdx)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Solver_b3Solver(&mut __bindgen_tmp, ctx, device, queue, pairCapacity);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_Db3Solver@@QEAAXXZ"]
    pub fn b3Solver_b3Solver_destructor(this: *mut b3Solver);
}
/// very basic hashable string implementation, compatible with b3HashMap
#[repr(C)]
#[derive(Debug)]
pub struct b3HashString {
    pub m_string: std_string,
    pub m_hash: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashInt {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3HashPtr {
    pub __bindgen_anon_1: b3HashPtr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3HashPtr__bindgen_ty_1 {
    pub m_pointer: *const ::std::os::raw::c_void,
    pub m_hashValues: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashKeyPtr {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashKey {
    pub m_uid: ::std::os::raw::c_int,
}
/// The b3HashMap template class implements a generic and lightweight hashmap.
/// A basic sample of how to use b3HashMap is located in Demos\BasicDemo\main.cpp
#[repr(C)]
#[derive(Debug)]
pub struct b3HashMap<Key, Value> {
    pub m_hashTable: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_valueArray: b3AlignedObjectArray<Value>,
    pub m_keyArray: b3AlignedObjectArray<Key>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Key>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bStructHandle {
    pub unused: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bChunkInd {
    pub code: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
    pub oldPtr: *mut ::std::os::raw::c_void,
    pub dna_nr: ::std::os::raw::c_int,
    pub nr: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bNameInfo {
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_isPointer: bool,
    pub m_dim0: ::std::os::raw::c_int,
    pub m_dim1: ::std::os::raw::c_int,
}
/// The b3Block class is an internal structure for the b3StackAlloc memory allocator.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Block {
    pub previous: *mut b3Block,
    pub address: *mut ::std::os::raw::c_uchar,
}
/// The StackAlloc class provides some fast stack-based memory allocator (LIFO last-in first-out)
#[repr(C)]
#[derive(Debug)]
pub struct b3StackAlloc {
    pub data: *mut ::std::os::raw::c_uchar,
    pub totalsize: ::std::os::raw::c_uint,
    pub usedsize: ::std::os::raw::c_uint,
    pub current: *mut b3Block,
    pub ischild: bool,
}
extern "C" {
    #[link_name = "\u{1}?b3s_bulletDNAstr@@3PADA"]
    pub static mut b3s_bulletDNAstr: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}?b3s_bulletDNAlen@@3HA"]
    pub static mut b3s_bulletDNAlen: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?b3s_bulletDNAstr64@@3PADA"]
    pub static mut b3s_bulletDNAstr64: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}?b3s_bulletDNAlen64@@3HA"]
    pub static mut b3s_bulletDNAlen64: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Chunk {
    pub m_chunkCode: ::std::os::raw::c_int,
    pub m_length: ::std::os::raw::c_int,
    pub m_oldPtr: *mut ::std::os::raw::c_void,
    pub m_dna_nr: ::std::os::raw::c_int,
    pub m_number: ::std::os::raw::c_int,
}
pub const b3SerializationFlags_B3_SERIALIZE_NO_BVH: b3SerializationFlags = 1;
pub const b3SerializationFlags_B3_SERIALIZE_NO_TRIANGLEINFOMAP: b3SerializationFlags = 2;
pub const b3SerializationFlags_B3_SERIALIZE_NO_DUPLICATE_ASSERT: b3SerializationFlags = 4;
pub type b3SerializationFlags = i32;
#[repr(C)]
pub struct b3Serializer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3Serializer {
    pub vtable_: *const b3Serializer__bindgen_vtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3PointerUid {
    pub __bindgen_anon_1: b3PointerUid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3PointerUid__bindgen_ty_1 {
    pub m_ptr: *mut ::std::os::raw::c_void,
    pub m_uniqueIds: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
/// The b3DefaultSerializer is the main Bullet serialization class.
/// The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
#[repr(C)]
pub struct b3DefaultSerializer {
    pub _base: b3Serializer,
    pub mTypes: b3AlignedObjectArray<*mut ::std::os::raw::c_char>,
    pub mStructs: b3AlignedObjectArray<*mut ::std::os::raw::c_short>,
    pub mTlens: b3AlignedObjectArray<::std::os::raw::c_short>,
    pub mStructReverse: b3HashMap<b3HashInt, ::std::os::raw::c_int>,
    pub mTypeLookup: b3HashMap<b3HashString, ::std::os::raw::c_int>,
    pub m_chunkP: b3HashMap<b3HashPtr, *mut ::std::os::raw::c_void>,
    pub m_nameMap: b3HashMap<b3HashPtr, *const ::std::os::raw::c_char>,
    pub m_uniquePointers: b3HashMap<b3HashPtr, b3PointerUid>,
    pub m_uniqueIdGenerator: ::std::os::raw::c_int,
    pub m_totalSize: ::std::os::raw::c_int,
    pub m_buffer: *mut ::std::os::raw::c_uchar,
    pub m_currentSize: ::std::os::raw::c_int,
    pub m_dna: *mut ::std::os::raw::c_void,
    pub m_dnaLength: ::std::os::raw::c_int,
    pub m_serializationFlags: ::std::os::raw::c_int,
    pub m_chunkPtrs: b3AlignedObjectArray<*mut b3Chunk>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CpuNarrowPhaseInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CpuRigidBodyPipelineInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PrefixScanFloat4CL {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuRaycastInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuNarrowPhaseInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuJacobiSolverInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuPgsJacobiSolverInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BatchConstraint {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuBatchingPgsSolverInternalData {
    pub _address: u8,
}
