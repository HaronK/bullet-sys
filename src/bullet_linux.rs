/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const btVector3DataName: &'static [u8; 19usize] = b"btVector3FloatData\0";
    pub const btQuaternionDataName: &'static [u8; 22usize] = b"btQuaternionFloatData\0";
    pub const btCollisionObjectDataName: &'static [u8; 27usize] = b"btCollisionObjectFloatData\0";
    pub const btPersistentManifoldDataName: &'static [u8; 30usize] =
        b"btPersistentManifoldFloatData\0";
    pub const btQuantizedBvhDataName: &'static [u8; 24usize] = b"btQuantizedBvhFloatData\0";
    pub const btRigidBodyDataName: &'static [u8; 21usize] = b"btRigidBodyFloatData\0";
    pub const btTypedConstraintDataName: &'static [u8; 27usize] = b"btTypedConstraintFloatData\0";
    pub const btPoint2PointConstraintDataName: &'static [u8; 33usize] =
        b"btPoint2PointConstraintFloatData\0";
    pub const btHingeConstraintDataName: &'static [u8; 27usize] = b"btHingeConstraintFloatData\0";
    pub const btConeTwistConstraintDataName: &'static [u8; 26usize] =
        b"btConeTwistConstraintData\0";
    pub const btGeneric6DofConstraintDataName: &'static [u8; 28usize] =
        b"btGeneric6DofConstraintData\0";
    pub const btSliderConstraintDataName: &'static [u8; 23usize] = b"btSliderConstraintData\0";
    pub const btGeneric6DofSpringConstraintDataName: &'static [u8; 34usize] =
        b"btGeneric6DofSpringConstraintData\0";
    pub const btGeneric6DofSpring2ConstraintDataName: &'static [u8; 35usize] =
        b"btGeneric6DofSpring2ConstraintData\0";
    pub const btGearConstraintDataName: &'static [u8; 26usize] = b"btGearConstraintFloatData\0";
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type btScalar = f32;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btInfMaskConverter {
        pub __bindgen_anon_1: root::btInfMaskConverter__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btInfMaskConverter__bindgen_ty_1 {
        pub mask: f32,
        pub intmask: ::std::os::raw::c_int,
        _bindgen_union_align: u32,
    }
    extern "C" {
        #[link_name = "\u{1}_ZL14btInfinityMask"]
        pub static mut btInfinityMask: root::btInfMaskConverter;
    }
    /// rudimentary class to provide type info
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedObject {
        pub m_objectType: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_Z22btAlignedAllocInternalmi"]
        pub fn btAlignedAllocInternal(
            size: usize,
            alignment: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21btAlignedFreeInternalPv"]
        pub fn btAlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
    }
    pub type btAlignedAllocFunc = ::std::option::Option<
        unsafe extern "C" fn(size: usize, alignment: ::std::os::raw::c_int)
            -> *mut ::std::os::raw::c_void,
    >;
    pub type btAlignedFreeFunc =
        ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
    pub type btAllocFunc =
        ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
    pub type btFreeFunc =
        ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
    extern "C" {
        /// The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
        #[link_name = "\u{1}_Z23btAlignedAllocSetCustomPFPvmEPFvS_E"]
        pub fn btAlignedAllocSetCustom(allocFunc: root::btAllocFunc, freeFunc: root::btFreeFunc);
    }
    extern "C" {
        /// If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
        #[link_name = "\u{1}_Z30btAlignedAllocSetCustomAlignedPFPvmiEPFvS_E"]
        pub fn btAlignedAllocSetCustomAligned(
            allocFunc: root::btAlignedAllocFunc,
            freeFunc: root::btAlignedFreeFunc,
        );
    }
    pub type btAlignedAllocator_self_type = u8;
    pub type btAlignedAllocator_const_pointer<T> = *mut T;
    pub type btAlignedAllocator_const_reference<T> = *mut T;
    pub type btAlignedAllocator_pointer<T> = *mut T;
    pub type btAlignedAllocator_reference<T> = *mut T;
    pub type btAlignedAllocator_value_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btAlignedAllocator_rebind {
        pub _address: u8,
    }
    pub type btAlignedAllocator_rebind_other = u8;
    /// @brief btVector3 can be used to represent 3D points and vectors.
    /// It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
    /// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVector3 {
        pub m_floats: [root::btScalar; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVector4 {
        pub _base: root::btVector3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVector3FloatData {
        pub m_floats: [f32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVector3DoubleData {
        pub m_floats: [f64; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuadWord {
        pub m_floats: [root::btScalar; 4usize],
    }
    /// @brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuaternion {
        pub _base: root::btQuadWord,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuaternionFloatData {
        pub m_floats: [f32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuaternionDoubleData {
        pub m_floats: [f64; 4usize],
    }
    /// @brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
    /// Make sure to only include a pure orthogonal matrix without scaling.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btMatrix3x3 {
        /// Data storage for the matrix, each vector is a row of the matrix
        pub m_el: [root::btVector3; 3usize],
    }
    extern "C" {
        /// @brief Return the determinant of the matrix
        #[link_name = "\u{1}_ZNK11btMatrix3x311determinantEv"]
        pub fn btMatrix3x3_determinant(this: *const root::btMatrix3x3) -> root::btScalar;
    }
    extern "C" {
        /// @brief Return the adjoint of the matrix
        #[link_name = "\u{1}_ZNK11btMatrix3x37adjointEv"]
        pub fn btMatrix3x3_adjoint(this: *const root::btMatrix3x3) -> root::btMatrix3x3;
    }
    extern "C" {
        /// @brief Return the matrix with all values non negative
        #[link_name = "\u{1}_ZNK11btMatrix3x38absoluteEv"]
        pub fn btMatrix3x3_absolute(this: *const root::btMatrix3x3) -> root::btMatrix3x3;
    }
    extern "C" {
        /// @brief Return the transpose of the matrix
        #[link_name = "\u{1}_ZNK11btMatrix3x39transposeEv"]
        pub fn btMatrix3x3_transpose(this: *const root::btMatrix3x3) -> root::btMatrix3x3;
    }
    extern "C" {
        /// @brief Return the inverse of the matrix
        #[link_name = "\u{1}_ZNK11btMatrix3x37inverseEv"]
        pub fn btMatrix3x3_inverse(this: *const root::btMatrix3x3) -> root::btMatrix3x3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btMatrix3x314transposeTimesERKS_"]
        pub fn btMatrix3x3_transposeTimes(
            this: *const root::btMatrix3x3,
            m: *const root::btMatrix3x3,
        ) -> root::btMatrix3x3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btMatrix3x314timesTransposeERKS_"]
        pub fn btMatrix3x3_timesTranspose(
            this: *const root::btMatrix3x3,
            m: *const root::btMatrix3x3,
        ) -> root::btMatrix3x3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btMatrix3x39serializeER20btMatrix3x3FloatData"]
        pub fn btMatrix3x3_serialize(
            this: *const root::btMatrix3x3,
            dataOut: *mut root::btMatrix3x3FloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btMatrix3x314serializeFloatER20btMatrix3x3FloatData"]
        pub fn btMatrix3x3_serializeFloat(
            this: *const root::btMatrix3x3,
            dataOut: *mut root::btMatrix3x3FloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btMatrix3x311deSerializeERK20btMatrix3x3FloatData"]
        pub fn btMatrix3x3_deSerialize(
            this: *mut root::btMatrix3x3,
            dataIn: *const root::btMatrix3x3FloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btMatrix3x316deSerializeFloatERK20btMatrix3x3FloatData"]
        pub fn btMatrix3x3_deSerializeFloat(
            this: *mut root::btMatrix3x3,
            dataIn: *const root::btMatrix3x3FloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btMatrix3x317deSerializeDoubleERK21btMatrix3x3DoubleData"]
        pub fn btMatrix3x3_deSerializeDouble(
            this: *mut root::btMatrix3x3,
            dataIn: *const root::btMatrix3x3DoubleData,
        );
    }
    impl btMatrix3x3 {
        #[inline]
        pub unsafe fn determinant(&self) -> root::btScalar {
            btMatrix3x3_determinant(self)
        }
        #[inline]
        pub unsafe fn adjoint(&self) -> root::btMatrix3x3 {
            btMatrix3x3_adjoint(self)
        }
        #[inline]
        pub unsafe fn absolute(&self) -> root::btMatrix3x3 {
            btMatrix3x3_absolute(self)
        }
        #[inline]
        pub unsafe fn transpose(&self) -> root::btMatrix3x3 {
            btMatrix3x3_transpose(self)
        }
        #[inline]
        pub unsafe fn inverse(&self) -> root::btMatrix3x3 {
            btMatrix3x3_inverse(self)
        }
        #[inline]
        pub unsafe fn transposeTimes(&self, m: *const root::btMatrix3x3) -> root::btMatrix3x3 {
            btMatrix3x3_transposeTimes(self, m)
        }
        #[inline]
        pub unsafe fn timesTranspose(&self, m: *const root::btMatrix3x3) -> root::btMatrix3x3 {
            btMatrix3x3_timesTranspose(self, m)
        }
        #[inline]
        pub unsafe fn serialize(&self, dataOut: *mut root::btMatrix3x3FloatData) {
            btMatrix3x3_serialize(self, dataOut)
        }
        #[inline]
        pub unsafe fn serializeFloat(&self, dataOut: *mut root::btMatrix3x3FloatData) {
            btMatrix3x3_serializeFloat(self, dataOut)
        }
        #[inline]
        pub unsafe fn deSerialize(&mut self, dataIn: *const root::btMatrix3x3FloatData) {
            btMatrix3x3_deSerialize(self, dataIn)
        }
        #[inline]
        pub unsafe fn deSerializeFloat(&mut self, dataIn: *const root::btMatrix3x3FloatData) {
            btMatrix3x3_deSerializeFloat(self, dataIn)
        }
        #[inline]
        pub unsafe fn deSerializeDouble(&mut self, dataIn: *const root::btMatrix3x3DoubleData) {
            btMatrix3x3_deSerializeDouble(self, dataIn)
        }
    }
    /// for serialization
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btMatrix3x3FloatData {
        pub m_el: [root::btVector3FloatData; 3usize],
    }
    /// for serialization
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btMatrix3x3DoubleData {
        pub m_el: [root::btVector3DoubleData; 3usize],
    }
    /// @brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
    /// It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTransform {
        /// Storage for the rotation
        pub m_basis: root::btMatrix3x3,
        /// Storage for the translation
        pub m_origin: root::btVector3,
    }
    extern "C" {
        /// @brief Return the inverse of this transform times the other transform
        /// @param t The other transform
        /// return this.inverse() * the other
        #[link_name = "\u{1}_ZNK11btTransform12inverseTimesERKS_"]
        pub fn btTransform_inverseTimes(
            this: *const root::btTransform,
            t: *const root::btTransform,
        ) -> root::btTransform;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btTransform9serializeER20btTransformFloatData"]
        pub fn btTransform_serialize(
            this: *const root::btTransform,
            dataOut: *mut root::btTransformFloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btTransform14serializeFloatER20btTransformFloatData"]
        pub fn btTransform_serializeFloat(
            this: *const root::btTransform,
            dataOut: *mut root::btTransformFloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btTransform11deSerializeERK20btTransformFloatData"]
        pub fn btTransform_deSerialize(
            this: *mut root::btTransform,
            dataIn: *const root::btTransformFloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btTransform17deSerializeDoubleERK21btTransformDoubleData"]
        pub fn btTransform_deSerializeDouble(
            this: *mut root::btTransform,
            dataIn: *const root::btTransformDoubleData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btTransform16deSerializeFloatERK20btTransformFloatData"]
        pub fn btTransform_deSerializeFloat(
            this: *mut root::btTransform,
            dataIn: *const root::btTransformFloatData,
        );
    }
    impl btTransform {
        #[inline]
        pub unsafe fn inverseTimes(&self, t: *const root::btTransform) -> root::btTransform {
            btTransform_inverseTimes(self, t)
        }
        #[inline]
        pub unsafe fn serialize(&self, dataOut: *mut root::btTransformFloatData) {
            btTransform_serialize(self, dataOut)
        }
        #[inline]
        pub unsafe fn serializeFloat(&self, dataOut: *mut root::btTransformFloatData) {
            btTransform_serializeFloat(self, dataOut)
        }
        #[inline]
        pub unsafe fn deSerialize(&mut self, dataIn: *const root::btTransformFloatData) {
            btTransform_deSerialize(self, dataIn)
        }
        #[inline]
        pub unsafe fn deSerializeDouble(&mut self, dataIn: *const root::btTransformDoubleData) {
            btTransform_deSerializeDouble(self, dataIn)
        }
        #[inline]
        pub unsafe fn deSerializeFloat(&mut self, dataIn: *const root::btTransformFloatData) {
            btTransform_deSerializeFloat(self, dataIn)
        }
    }
    /// for serialization
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTransformFloatData {
        pub m_basis: root::btMatrix3x3FloatData,
        pub m_origin: root::btVector3FloatData,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTransformDoubleData {
        pub m_basis: root::btMatrix3x3DoubleData,
        pub m_origin: root::btVector3DoubleData,
    }
    #[repr(C)]
    pub struct btMotionState__bindgen_vtable(::std::os::raw::c_void);
    /// The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
    /// For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
    #[repr(C)]
    #[derive(Debug)]
    pub struct btMotionState {
        pub vtable_: *const btMotionState__bindgen_vtable,
    }
    /// The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
    /// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
    #[repr(C)]
    #[derive(Debug)]
    pub struct btAlignedObjectArray<T> {
        pub m_allocator: u8,
        pub m_size: ::std::os::raw::c_int,
        pub m_capacity: ::std::os::raw::c_int,
        pub m_data: *mut T,
        pub m_ownsMemory: bool,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btAlignedObjectArray_less {
        pub _address: u8,
    }
    pub type btCollisionObjectArray = root::btAlignedObjectArray<*mut root::btCollisionObject>;
    #[repr(C)]
    pub struct btCollisionObject__bindgen_vtable(::std::os::raw::c_void);
    /// btCollisionObject can be used to manage collision detection objects.
    /// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
    /// They can be added to the btCollisionWorld.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionObject {
        pub vtable_: *const btCollisionObject__bindgen_vtable,
        pub m_worldTransform: root::btTransform,
        /// m_interpolationWorldTransform is used for CCD and interpolation
        /// ///it can be either previous or future (predicted) transform
        pub m_interpolationWorldTransform: root::btTransform,
        pub m_interpolationLinearVelocity: root::btVector3,
        pub m_interpolationAngularVelocity: root::btVector3,
        pub m_anisotropicFriction: root::btVector3,
        pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
        pub m_contactProcessingThreshold: root::btScalar,
        pub m_broadphaseHandle: *mut root::btBroadphaseProxy,
        pub m_collisionShape: *mut root::btCollisionShape,
        /// m_extensionPointer is used by some internal low-level Bullet extensions.
        pub m_extensionPointer: *mut ::std::os::raw::c_void,
        /// m_rootCollisionShape is temporarily used to store the original collision shape
        /// ///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
        /// ///If it is NULL, the m_collisionShape is not temporarily replaced.
        pub m_rootCollisionShape: *mut root::btCollisionShape,
        pub m_collisionFlags: ::std::os::raw::c_int,
        pub m_islandTag1: ::std::os::raw::c_int,
        pub m_companionId: ::std::os::raw::c_int,
        pub m_worldArrayIndex: ::std::os::raw::c_int,
        pub m_activationState1: ::std::os::raw::c_int,
        pub m_deactivationTime: root::btScalar,
        pub m_friction: root::btScalar,
        pub m_restitution: root::btScalar,
        pub m_rollingFriction: root::btScalar,
        pub m_spinningFriction: root::btScalar,
        pub m_contactDamping: root::btScalar,
        pub m_contactStiffness: root::btScalar,
        /// m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
        /// ///do not assign your own m_internalType unless you write a new dynamics object class.
        pub m_internalType: ::std::os::raw::c_int,
        /// users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
        pub m_userObjectPointer: *mut ::std::os::raw::c_void,
        pub m_userIndex2: ::std::os::raw::c_int,
        pub m_userIndex: ::std::os::raw::c_int,
        /// time of impact calculation
        pub m_hitFraction: root::btScalar,
        /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
        pub m_ccdSweptSphereRadius: root::btScalar,
        /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
        pub m_ccdMotionThreshold: root::btScalar,
        /// If some object should have elaborate collision filtering by sub-classes
        pub m_checkCollideWith: ::std::os::raw::c_int,
        pub m_objectsWithoutCollisionCheck:
            root::btAlignedObjectArray<*const root::btCollisionObject>,
        /// internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
        pub m_updateRevision: ::std::os::raw::c_int,
        pub m_customDebugColorRGB: root::btVector3,
    }
    pub const btCollisionObject_CollisionFlags_CF_STATIC_OBJECT:
        root::btCollisionObject_CollisionFlags = 1;
    pub const btCollisionObject_CollisionFlags_CF_KINEMATIC_OBJECT:
        root::btCollisionObject_CollisionFlags = 2;
    pub const btCollisionObject_CollisionFlags_CF_NO_CONTACT_RESPONSE:
        root::btCollisionObject_CollisionFlags = 4;
    pub const btCollisionObject_CollisionFlags_CF_CUSTOM_MATERIAL_CALLBACK:
        root::btCollisionObject_CollisionFlags = 8;
    pub const btCollisionObject_CollisionFlags_CF_CHARACTER_OBJECT:
        root::btCollisionObject_CollisionFlags = 16;
    pub const btCollisionObject_CollisionFlags_CF_DISABLE_VISUALIZE_OBJECT:
        root::btCollisionObject_CollisionFlags = 32;
    pub const btCollisionObject_CollisionFlags_CF_DISABLE_SPU_COLLISION_PROCESSING:
        root::btCollisionObject_CollisionFlags = 64;
    pub const btCollisionObject_CollisionFlags_CF_HAS_CONTACT_STIFFNESS_DAMPING:
        root::btCollisionObject_CollisionFlags = 128;
    pub const btCollisionObject_CollisionFlags_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR:
        root::btCollisionObject_CollisionFlags = 256;
    pub const btCollisionObject_CollisionFlags_CF_HAS_FRICTION_ANCHOR:
        root::btCollisionObject_CollisionFlags = 512;
    pub const btCollisionObject_CollisionFlags_CF_HAS_COLLISION_SOUND_TRIGGER:
        root::btCollisionObject_CollisionFlags = 1024;
    pub type btCollisionObject_CollisionFlags = u32;
    pub const btCollisionObject_CollisionObjectTypes_CO_COLLISION_OBJECT:
        root::btCollisionObject_CollisionObjectTypes = 1;
    pub const btCollisionObject_CollisionObjectTypes_CO_RIGID_BODY:
        root::btCollisionObject_CollisionObjectTypes = 2;
    /// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
    /// ///It is useful for collision sensors, explosion objects, character controller etc.
    pub const btCollisionObject_CollisionObjectTypes_CO_GHOST_OBJECT:
        root::btCollisionObject_CollisionObjectTypes = 4;
    /// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
    /// ///It is useful for collision sensors, explosion objects, character controller etc.
    pub const btCollisionObject_CollisionObjectTypes_CO_SOFT_BODY:
        root::btCollisionObject_CollisionObjectTypes = 8;
    /// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
    /// ///It is useful for collision sensors, explosion objects, character controller etc.
    pub const btCollisionObject_CollisionObjectTypes_CO_HF_FLUID:
        root::btCollisionObject_CollisionObjectTypes = 16;
    /// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
    /// ///It is useful for collision sensors, explosion objects, character controller etc.
    pub const btCollisionObject_CollisionObjectTypes_CO_USER_TYPE:
        root::btCollisionObject_CollisionObjectTypes = 32;
    /// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
    /// ///It is useful for collision sensors, explosion objects, character controller etc.
    pub const btCollisionObject_CollisionObjectTypes_CO_FEATHERSTONE_LINK:
        root::btCollisionObject_CollisionObjectTypes = 64;
    pub type btCollisionObject_CollisionObjectTypes = u32;
    pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION_DISABLED:
        root::btCollisionObject_AnisotropicFrictionFlags = 0;
    pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION:
        root::btCollisionObject_AnisotropicFrictionFlags = 1;
    pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_ROLLING_FRICTION:
        root::btCollisionObject_AnisotropicFrictionFlags = 2;
    pub type btCollisionObject_AnisotropicFrictionFlags = u32;
    extern "C" {
        #[link_name = "\u{1}_ZNK17btCollisionObject18setActivationStateEi"]
        pub fn btCollisionObject_setActivationState(
            this: *const root::btCollisionObject,
            newState: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btCollisionObject20forceActivationStateEi"]
        pub fn btCollisionObject_forceActivationState(
            this: *const root::btCollisionObject,
            newState: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btCollisionObject8activateEb"]
        pub fn btCollisionObject_activate(
            this: *const root::btCollisionObject,
            forceActivation: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btCollisionObjectC1Ev"]
        pub fn btCollisionObject_btCollisionObject(this: *mut root::btCollisionObject);
    }
    impl btCollisionObject {
        #[inline]
        pub unsafe fn setActivationState(&self, newState: ::std::os::raw::c_int) {
            btCollisionObject_setActivationState(self, newState)
        }
        #[inline]
        pub unsafe fn forceActivationState(&self, newState: ::std::os::raw::c_int) {
            btCollisionObject_forceActivationState(self, newState)
        }
        #[inline]
        pub unsafe fn activate(&self, forceActivation: bool) {
            btCollisionObject_activate(self, forceActivation)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCollisionObject_btCollisionObject(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btCollisionObjectD1Ev"]
        pub fn btCollisionObject_btCollisionObject_destructor(this: *mut root::btCollisionObject);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btCollisionObject28calculateSerializeBufferSizeEv"]
        pub fn btCollisionObject_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK17btCollisionObject9serializeEPvP12btSerializer"]
        pub fn btCollisionObject_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btCollisionObject21serializeSingleObjectEP12btSerializer"]
        pub fn btCollisionObject_serializeSingleObject(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionObjectDoubleData {
        pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
        pub m_collisionShape: *mut ::std::os::raw::c_void,
        pub m_rootCollisionShape: *mut root::btCollisionShapeData,
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_worldTransform: root::btTransformDoubleData,
        pub m_interpolationWorldTransform: root::btTransformDoubleData,
        pub m_interpolationLinearVelocity: root::btVector3DoubleData,
        pub m_interpolationAngularVelocity: root::btVector3DoubleData,
        pub m_anisotropicFriction: root::btVector3DoubleData,
        pub m_contactProcessingThreshold: f64,
        pub m_deactivationTime: f64,
        pub m_friction: f64,
        pub m_rollingFriction: f64,
        pub m_contactDamping: f64,
        pub m_contactStiffness: f64,
        pub m_restitution: f64,
        pub m_hitFraction: f64,
        pub m_ccdSweptSphereRadius: f64,
        pub m_ccdMotionThreshold: f64,
        pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
        pub m_collisionFlags: ::std::os::raw::c_int,
        pub m_islandTag1: ::std::os::raw::c_int,
        pub m_companionId: ::std::os::raw::c_int,
        pub m_activationState1: ::std::os::raw::c_int,
        pub m_internalType: ::std::os::raw::c_int,
        pub m_checkCollideWith: ::std::os::raw::c_int,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
        pub m_uniqueId: ::std::os::raw::c_int,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionObjectFloatData {
        pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
        pub m_collisionShape: *mut ::std::os::raw::c_void,
        pub m_rootCollisionShape: *mut root::btCollisionShapeData,
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_worldTransform: root::btTransformFloatData,
        pub m_interpolationWorldTransform: root::btTransformFloatData,
        pub m_interpolationLinearVelocity: root::btVector3FloatData,
        pub m_interpolationAngularVelocity: root::btVector3FloatData,
        pub m_anisotropicFriction: root::btVector3FloatData,
        pub m_contactProcessingThreshold: f32,
        pub m_deactivationTime: f32,
        pub m_friction: f32,
        pub m_rollingFriction: f32,
        pub m_contactDamping: f32,
        pub m_contactStiffness: f32,
        pub m_restitution: f32,
        pub m_hitFraction: f32,
        pub m_ccdSweptSphereRadius: f32,
        pub m_ccdMotionThreshold: f32,
        pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
        pub m_collisionFlags: ::std::os::raw::c_int,
        pub m_islandTag1: ::std::os::raw::c_int,
        pub m_companionId: ::std::os::raw::c_int,
        pub m_activationState1: ::std::os::raw::c_int,
        pub m_internalType: ::std::os::raw::c_int,
        pub m_checkCollideWith: ::std::os::raw::c_int,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
        pub m_uniqueId: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPoolAllocator {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDispatcherInfo {
        pub m_timeStep: root::btScalar,
        pub m_stepCount: ::std::os::raw::c_int,
        pub m_dispatchFunc: ::std::os::raw::c_int,
        pub m_timeOfImpact: root::btScalar,
        pub m_useContinuous: bool,
        pub m_debugDraw: *mut root::btIDebugDraw,
        pub m_enableSatConvex: bool,
        pub m_enableSPU: bool,
        pub m_useEpa: bool,
        pub m_allowedCcdPenetration: root::btScalar,
        pub m_useConvexConservativeDistanceUtil: bool,
        pub m_convexConservativeDistanceThreshold: root::btScalar,
        pub m_deterministicOverlappingPairs: bool,
    }
    pub const btDispatcherInfo_DispatchFunc_DISPATCH_DISCRETE: root::btDispatcherInfo_DispatchFunc =
        1;
    pub const btDispatcherInfo_DispatchFunc_DISPATCH_CONTINUOUS:
        root::btDispatcherInfo_DispatchFunc = 2;
    pub type btDispatcherInfo_DispatchFunc = u32;
    pub const ebtDispatcherQueryType_BT_CONTACT_POINT_ALGORITHMS: root::ebtDispatcherQueryType = 1;
    pub const ebtDispatcherQueryType_BT_CLOSEST_POINT_ALGORITHMS: root::ebtDispatcherQueryType = 2;
    pub type ebtDispatcherQueryType = u32;
    #[repr(C)]
    pub struct btDispatcher__bindgen_vtable(::std::os::raw::c_void);
    /// The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
    /// For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDispatcher {
        pub vtable_: *const btDispatcher__bindgen_vtable,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btDispatcherD1Ev"]
        pub fn btDispatcher_btDispatcher_destructor(this: *mut root::btDispatcher);
    }
    /// Utils related to temporal transforms
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTransformUtil {
        pub _address: u8,
    }
    /// The btConvexSeparatingDistanceUtil can help speed up convex collision detection
    /// by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConvexSeparatingDistanceUtil {
        pub m_ornA: root::btQuaternion,
        pub m_ornB: root::btQuaternion,
        pub m_posA: root::btVector3,
        pub m_posB: root::btVector3,
        pub m_separatingNormal: root::btVector3,
        pub m_boundingRadiusA: root::btScalar,
        pub m_boundingRadiusB: root::btScalar,
        pub m_separatingDistance: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConstraintRow {
        pub m_normal: [root::btScalar; 3usize],
        pub m_rhs: root::btScalar,
        pub m_jacDiagInv: root::btScalar,
        pub m_lowerLimit: root::btScalar,
        pub m_upperLimit: root::btScalar,
        pub m_accumImpulse: root::btScalar,
    }
    pub const btContactPointFlags_BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED:
        root::btContactPointFlags = 1;
    pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_CFM: root::btContactPointFlags = 2;
    pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_ERP: root::btContactPointFlags = 4;
    pub const btContactPointFlags_BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING:
        root::btContactPointFlags = 8;
    pub const btContactPointFlags_BT_CONTACT_FLAG_FRICTION_ANCHOR: root::btContactPointFlags = 16;
    pub type btContactPointFlags = u32;
    /// ManifoldContactPoint collects and maintains persistent contactpoints.
    /// used to improve stability and performance of rigidbody dynamics response.
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btManifoldPoint {
        pub m_localPointA: root::btVector3,
        pub m_localPointB: root::btVector3,
        pub m_positionWorldOnB: root::btVector3,
        /// m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
        pub m_positionWorldOnA: root::btVector3,
        pub m_normalWorldOnB: root::btVector3,
        pub m_distance1: root::btScalar,
        pub m_combinedFriction: root::btScalar,
        pub m_combinedRollingFriction: root::btScalar,
        pub m_combinedSpinningFriction: root::btScalar,
        pub m_combinedRestitution: root::btScalar,
        pub m_partId0: ::std::os::raw::c_int,
        pub m_partId1: ::std::os::raw::c_int,
        pub m_index0: ::std::os::raw::c_int,
        pub m_index1: ::std::os::raw::c_int,
        pub m_userPersistentData: *mut ::std::os::raw::c_void,
        pub m_contactPointFlags: ::std::os::raw::c_int,
        pub m_appliedImpulse: root::btScalar,
        pub m_appliedImpulseLateral1: root::btScalar,
        pub m_appliedImpulseLateral2: root::btScalar,
        pub m_contactMotion1: root::btScalar,
        pub m_contactMotion2: root::btScalar,
        pub __bindgen_anon_1: root::btManifoldPoint__bindgen_ty_1,
        pub __bindgen_anon_2: root::btManifoldPoint__bindgen_ty_2,
        pub m_frictionCFM: root::btScalar,
        pub m_lifeTime: ::std::os::raw::c_int,
        pub m_lateralFrictionDir1: root::btVector3,
        pub m_lateralFrictionDir2: root::btVector3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btManifoldPoint__bindgen_ty_1 {
        pub m_contactCFM: root::btScalar,
        pub m_combinedContactStiffness1: root::btScalar,
        _bindgen_union_align: u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btManifoldPoint__bindgen_ty_2 {
        pub m_contactERP: root::btScalar,
        pub m_combinedContactDamping1: root::btScalar,
        _bindgen_union_align: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionResult {
        _unused: [u8; 0],
    }
    pub const btContactManifoldTypes_MIN_CONTACT_MANIFOLD_TYPE: root::btContactManifoldTypes = 1024;
    pub const btContactManifoldTypes_BT_PERSISTENT_MANIFOLD_TYPE: root::btContactManifoldTypes =
        1025;
    pub type btContactManifoldTypes = u32;
    /// btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
    /// Those contact points are created by the collision narrow phase.
    /// The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
    /// updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
    /// reduces the cache to 4 points, when more then 4 points are added, using following rules:
    /// the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
    /// note that some pairs of objects might have more then one contact manifold.
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btPersistentManifold {
        pub _base: root::btTypedObject,
        pub m_pointCache: [root::btManifoldPoint; 4usize],
        /// this two body pointers can point to the physics rigidbody class.
        pub m_body0: *const root::btCollisionObject,
        pub m_body1: *const root::btCollisionObject,
        pub m_cachedPoints: ::std::os::raw::c_int,
        pub m_contactBreakingThreshold: root::btScalar,
        pub m_contactProcessingThreshold: root::btScalar,
        pub m_companionIdA: ::std::os::raw::c_int,
        pub m_companionIdB: ::std::os::raw::c_int,
        pub m_index1a: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btPersistentManifold14clearUserCacheER15btManifoldPoint"]
        pub fn btPersistentManifold_clearUserCache(
            this: *mut root::btPersistentManifold,
            pt: *mut root::btManifoldPoint,
        );
    }
    extern "C" {
        /// @todo: get this margin from the current physics / collision environment
        #[link_name = "\u{1}_ZNK20btPersistentManifold27getContactBreakingThresholdEv"]
        pub fn btPersistentManifold_getContactBreakingThreshold(
            this: *const root::btPersistentManifold,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK20btPersistentManifold13getCacheEntryERK15btManifoldPoint"]
        pub fn btPersistentManifold_getCacheEntry(
            this: *const root::btPersistentManifold,
            newPoint: *const root::btManifoldPoint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btPersistentManifold16addManifoldPointERK15btManifoldPointb"]
        pub fn btPersistentManifold_addManifoldPoint(
            this: *mut root::btPersistentManifold,
            newPoint: *const root::btManifoldPoint,
            isPredictive: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
        #[link_name = "\u{1}_ZN20btPersistentManifold20refreshContactPointsERK11btTransformS2_"]
        pub fn btPersistentManifold_refreshContactPoints(
            this: *mut root::btPersistentManifold,
            trA: *const root::btTransform,
            trB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK20btPersistentManifold28calculateSerializeBufferSizeEv"]
        pub fn btPersistentManifold_calculateSerializeBufferSize(
            this: *const root::btPersistentManifold,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK20btPersistentManifold9serializeEPKS_PvP12btSerializer"]
        pub fn btPersistentManifold_serialize(
            this: *const root::btPersistentManifold,
            manifold: *const root::btPersistentManifold,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btPersistentManifold11deSerializeEPK30btPersistentManifoldDoubleData"]
        pub fn btPersistentManifold_deSerialize(
            this: *mut root::btPersistentManifold,
            manifoldDataPtr: *const root::btPersistentManifoldDoubleData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btPersistentManifold11deSerializeEPK29btPersistentManifoldFloatData"]
        pub fn btPersistentManifold_deSerialize1(
            this: *mut root::btPersistentManifold,
            manifoldDataPtr: *const root::btPersistentManifoldFloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btPersistentManifoldC1Ev"]
        pub fn btPersistentManifold_btPersistentManifold(this: *mut root::btPersistentManifold);
    }
    impl btPersistentManifold {
        #[inline]
        pub unsafe fn clearUserCache(&mut self, pt: *mut root::btManifoldPoint) {
            btPersistentManifold_clearUserCache(self, pt)
        }
        #[inline]
        pub unsafe fn getContactBreakingThreshold(&self) -> root::btScalar {
            btPersistentManifold_getContactBreakingThreshold(self)
        }
        #[inline]
        pub unsafe fn getCacheEntry(
            &self,
            newPoint: *const root::btManifoldPoint,
        ) -> ::std::os::raw::c_int {
            btPersistentManifold_getCacheEntry(self, newPoint)
        }
        #[inline]
        pub unsafe fn addManifoldPoint(
            &mut self,
            newPoint: *const root::btManifoldPoint,
            isPredictive: bool,
        ) -> ::std::os::raw::c_int {
            btPersistentManifold_addManifoldPoint(self, newPoint, isPredictive)
        }
        #[inline]
        pub unsafe fn refreshContactPoints(
            &mut self,
            trA: *const root::btTransform,
            trB: *const root::btTransform,
        ) {
            btPersistentManifold_refreshContactPoints(self, trA, trB)
        }
        #[inline]
        pub unsafe fn calculateSerializeBufferSize(&self) -> ::std::os::raw::c_int {
            btPersistentManifold_calculateSerializeBufferSize(self)
        }
        #[inline]
        pub unsafe fn serialize(
            &self,
            manifold: *const root::btPersistentManifold,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char {
            btPersistentManifold_serialize(self, manifold, dataBuffer, serializer)
        }
        #[inline]
        pub unsafe fn deSerialize(
            &mut self,
            manifoldDataPtr: *const root::btPersistentManifoldDoubleData,
        ) {
            btPersistentManifold_deSerialize(self, manifoldDataPtr)
        }
        #[inline]
        pub unsafe fn deSerialize1(
            &mut self,
            manifoldDataPtr: *const root::btPersistentManifoldFloatData,
        ) {
            btPersistentManifold_deSerialize1(self, manifoldDataPtr)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btPersistentManifold_btPersistentManifold(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPersistentManifoldDoubleData {
        pub m_pointCacheLocalPointA: [root::btVector3DoubleData; 4usize],
        pub m_pointCacheLocalPointB: [root::btVector3DoubleData; 4usize],
        pub m_pointCachePositionWorldOnA: [root::btVector3DoubleData; 4usize],
        pub m_pointCachePositionWorldOnB: [root::btVector3DoubleData; 4usize],
        pub m_pointCacheNormalWorldOnB: [root::btVector3DoubleData; 4usize],
        pub m_pointCacheLateralFrictionDir1: [root::btVector3DoubleData; 4usize],
        pub m_pointCacheLateralFrictionDir2: [root::btVector3DoubleData; 4usize],
        pub m_pointCacheDistance: [f64; 4usize],
        pub m_pointCacheAppliedImpulse: [f64; 4usize],
        pub m_pointCacheCombinedFriction: [f64; 4usize],
        pub m_pointCacheCombinedRollingFriction: [f64; 4usize],
        pub m_pointCacheCombinedSpinningFriction: [f64; 4usize],
        pub m_pointCacheCombinedRestitution: [f64; 4usize],
        pub m_pointCachePartId0: [::std::os::raw::c_int; 4usize],
        pub m_pointCachePartId1: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheIndex0: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheIndex1: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheContactPointFlags: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheAppliedImpulseLateral1: [f64; 4usize],
        pub m_pointCacheAppliedImpulseLateral2: [f64; 4usize],
        pub m_pointCacheContactMotion1: [f64; 4usize],
        pub m_pointCacheContactMotion2: [f64; 4usize],
        pub m_pointCacheContactCFM: [f64; 4usize],
        pub m_pointCacheCombinedContactStiffness1: [f64; 4usize],
        pub m_pointCacheContactERP: [f64; 4usize],
        pub m_pointCacheCombinedContactDamping1: [f64; 4usize],
        pub m_pointCacheFrictionCFM: [f64; 4usize],
        pub m_pointCacheLifeTime: [::std::os::raw::c_int; 4usize],
        pub m_numCachedPoints: ::std::os::raw::c_int,
        pub m_companionIdA: ::std::os::raw::c_int,
        pub m_companionIdB: ::std::os::raw::c_int,
        pub m_index1a: ::std::os::raw::c_int,
        pub m_objectType: ::std::os::raw::c_int,
        pub m_contactBreakingThreshold: f64,
        pub m_contactProcessingThreshold: f64,
        pub m_padding: ::std::os::raw::c_int,
        pub m_body0: *mut root::btCollisionObjectDoubleData,
        pub m_body1: *mut root::btCollisionObjectDoubleData,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPersistentManifoldFloatData {
        pub m_pointCacheLocalPointA: [root::btVector3FloatData; 4usize],
        pub m_pointCacheLocalPointB: [root::btVector3FloatData; 4usize],
        pub m_pointCachePositionWorldOnA: [root::btVector3FloatData; 4usize],
        pub m_pointCachePositionWorldOnB: [root::btVector3FloatData; 4usize],
        pub m_pointCacheNormalWorldOnB: [root::btVector3FloatData; 4usize],
        pub m_pointCacheLateralFrictionDir1: [root::btVector3FloatData; 4usize],
        pub m_pointCacheLateralFrictionDir2: [root::btVector3FloatData; 4usize],
        pub m_pointCacheDistance: [f32; 4usize],
        pub m_pointCacheAppliedImpulse: [f32; 4usize],
        pub m_pointCacheCombinedFriction: [f32; 4usize],
        pub m_pointCacheCombinedRollingFriction: [f32; 4usize],
        pub m_pointCacheCombinedSpinningFriction: [f32; 4usize],
        pub m_pointCacheCombinedRestitution: [f32; 4usize],
        pub m_pointCachePartId0: [::std::os::raw::c_int; 4usize],
        pub m_pointCachePartId1: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheIndex0: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheIndex1: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheContactPointFlags: [::std::os::raw::c_int; 4usize],
        pub m_pointCacheAppliedImpulseLateral1: [f32; 4usize],
        pub m_pointCacheAppliedImpulseLateral2: [f32; 4usize],
        pub m_pointCacheContactMotion1: [f32; 4usize],
        pub m_pointCacheContactMotion2: [f32; 4usize],
        pub m_pointCacheContactCFM: [f32; 4usize],
        pub m_pointCacheCombinedContactStiffness1: [f32; 4usize],
        pub m_pointCacheContactERP: [f32; 4usize],
        pub m_pointCacheCombinedContactDamping1: [f32; 4usize],
        pub m_pointCacheFrictionCFM: [f32; 4usize],
        pub m_pointCacheLifeTime: [::std::os::raw::c_int; 4usize],
        pub m_numCachedPoints: ::std::os::raw::c_int,
        pub m_companionIdA: ::std::os::raw::c_int,
        pub m_companionIdB: ::std::os::raw::c_int,
        pub m_index1a: ::std::os::raw::c_int,
        pub m_objectType: ::std::os::raw::c_int,
        pub m_contactBreakingThreshold: f32,
        pub m_contactProcessingThreshold: f32,
        pub m_padding: ::std::os::raw::c_int,
        pub m_body0: *mut root::btCollisionObjectFloatData,
        pub m_body1: *mut root::btCollisionObjectFloatData,
    }
    #[repr(C)]
    pub struct btDiscreteCollisionDetectorInterface__bindgen_vtable(::std::os::raw::c_void);
    /// This interface is made to be used by an iterative approach to do TimeOfImpact calculations
    /// This interface allows to query for closest points and penetration depth between two (convex) objects
    /// the closest point is on the second object (B), and the normal points from the surface on B towards A.
    /// distance is between closest points on B and closest point on A. So you can calculate closest point on A
    /// by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDiscreteCollisionDetectorInterface {
        pub vtable_: *const btDiscreteCollisionDetectorInterface__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btDiscreteCollisionDetectorInterface_Result__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDiscreteCollisionDetectorInterface_Result {
        pub vtable_: *const btDiscreteCollisionDetectorInterface_Result__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDiscreteCollisionDetectorInterface_ClosestPointInput {
        pub m_transformA: root::btTransform,
        pub m_transformB: root::btTransform,
        pub m_maximumDistanceSquared: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btStorageResult {
        pub _base: root::btDiscreteCollisionDetectorInterface_Result,
        pub m_normalOnSurfaceB: root::btVector3,
        pub m_closestPointInB: root::btVector3,
        pub m_distance: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionObjectWrapper {
        pub m_parent: *const root::btCollisionObjectWrapper,
        pub m_shape: *const root::btCollisionShape,
        pub m_collisionObject: *const root::btCollisionObject,
        pub m_worldTransform: *const root::btTransform,
        pub m_partId: ::std::os::raw::c_int,
        pub m_index: ::std::os::raw::c_int,
    }
    /// btManifoldResult is a helper class to manage  contact results.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btManifoldResult {
        pub _base: root::btDiscreteCollisionDetectorInterface_Result,
        pub m_manifoldPtr: *mut root::btPersistentManifold,
        pub m_body0Wrap: *const root::btCollisionObjectWrapper,
        pub m_body1Wrap: *const root::btCollisionObjectWrapper,
        pub m_partId0: ::std::os::raw::c_int,
        pub m_partId1: ::std::os::raw::c_int,
        pub m_index0: ::std::os::raw::c_int,
        pub m_index1: ::std::os::raw::c_int,
        pub m_closestPointDistanceThreshold: root::btScalar,
    }
    extern "C" {
        /// in the future we can let the user override the methods to combine restitution and friction
        #[link_name = "\u{1}_ZN16btManifoldResult28calculateCombinedRestitutionEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedRestitution(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult25calculateCombinedFrictionEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult32calculateCombinedRollingFrictionEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedRollingFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult33calculateCombinedSpinningFrictionEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedSpinningFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult31calculateCombinedContactDampingEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedContactDamping(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult33calculateCombinedContactStiffnessEPK17btCollisionObjectS2_"]
        pub fn btManifoldResult_calculateCombinedContactStiffness(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResultC1EPK24btCollisionObjectWrapperS2_"]
        pub fn btManifoldResult_btManifoldResult(
            this: *mut root::btManifoldResult,
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
        );
    }
    impl btManifoldResult {
        #[inline]
        pub unsafe fn calculateCombinedRestitution(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedRestitution(body0, body1)
        }
        #[inline]
        pub unsafe fn calculateCombinedFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedFriction(body0, body1)
        }
        #[inline]
        pub unsafe fn calculateCombinedRollingFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedRollingFriction(body0, body1)
        }
        #[inline]
        pub unsafe fn calculateCombinedSpinningFriction(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedSpinningFriction(body0, body1)
        }
        #[inline]
        pub unsafe fn calculateCombinedContactDamping(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedContactDamping(body0, body1)
        }
        #[inline]
        pub unsafe fn calculateCombinedContactStiffness(
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> root::btScalar {
            btManifoldResult_calculateCombinedContactStiffness(body0, body1)
        }
        #[inline]
        pub unsafe fn new(
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btManifoldResult_btManifoldResult(&mut __bindgen_tmp, body0Wrap, body1Wrap);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btManifoldResult15addContactPointERK9btVector3S2_f"]
        pub fn btManifoldResult_addContactPoint(
            this: *mut ::std::os::raw::c_void,
            normalOnBInWorld: *const root::btVector3,
            pointInWorld: *const root::btVector3,
            depth: root::btScalar,
        );
    }
    /// The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
    /// It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btBroadphaseProxy {
        pub m_clientObject: *mut ::std::os::raw::c_void,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
        pub m_uniqueId: ::std::os::raw::c_int,
        pub m_aabbMin: root::btVector3,
        pub m_aabbMax: root::btVector3,
    }
    pub const btBroadphaseProxy_CollisionFilterGroups_DefaultFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = 1;
    pub const btBroadphaseProxy_CollisionFilterGroups_StaticFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = 2;
    pub const btBroadphaseProxy_CollisionFilterGroups_KinematicFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = 4;
    pub const btBroadphaseProxy_CollisionFilterGroups_DebrisFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = 8;
    pub const btBroadphaseProxy_CollisionFilterGroups_SensorTrigger:
        root::btBroadphaseProxy_CollisionFilterGroups = 16;
    pub const btBroadphaseProxy_CollisionFilterGroups_CharacterFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = 32;
    pub const btBroadphaseProxy_CollisionFilterGroups_AllFilter:
        root::btBroadphaseProxy_CollisionFilterGroups = -1;
    /// optional filtering to cull potential collisions
    pub type btBroadphaseProxy_CollisionFilterGroups = i32;
    /// The btBroadphasePair class contains a pair of aabb-overlapping objects.
    /// A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btBroadphasePair {
        pub m_pProxy0: *mut root::btBroadphaseProxy,
        pub m_pProxy1: *mut root::btBroadphaseProxy,
        pub m_algorithm: *mut root::btCollisionAlgorithm,
        pub __bindgen_anon_1: root::btBroadphasePair__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btBroadphasePair__bindgen_ty_1 {
        pub m_internalInfo1: *mut ::std::os::raw::c_void,
        pub m_internalTmpValue: ::std::os::raw::c_int,
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btBroadphasePairSortPredicate {
        pub _address: u8,
    }
    #[repr(C)]
    pub struct btCollisionAlgorithmCreateFunc__bindgen_vtable(::std::os::raw::c_void);
    /// Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionAlgorithmCreateFunc {
        pub vtable_: *const btCollisionAlgorithmCreateFunc__bindgen_vtable,
        pub m_swapped: bool,
    }
    /// user can override this nearcallback for collision filtering and more finegrained control over collision detection
    pub type btNearCallback = ::std::option::Option<
        unsafe extern "C" fn(
            collisionPair: *mut root::btBroadphasePair,
            dispatcher: *mut root::btCollisionDispatcher,
            dispatchInfo: *const root::btDispatcherInfo,
        ),
    >;
    /// btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
    /// Time of Impact, Closest Points and Penetration Depth.
    #[repr(C)]
    pub struct btCollisionDispatcher {
        pub _base: root::btDispatcher,
        pub m_dispatcherFlags: ::std::os::raw::c_int,
        pub m_manifoldsPtr: root::btAlignedObjectArray<*mut root::btPersistentManifold>,
        pub m_defaultManifoldResult: root::btManifoldResult,
        pub m_nearCallback: root::btNearCallback,
        pub m_collisionAlgorithmPoolAllocator: *mut root::btPoolAllocator,
        pub m_persistentManifoldPoolAllocator: *mut root::btPoolAllocator,
        pub m_doubleDispatchContactPoints:
            [[*mut root::btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
        pub m_doubleDispatchClosestPoints:
            [[*mut root::btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
        pub m_collisionConfiguration: *mut root::btCollisionConfiguration,
    }
    pub const btCollisionDispatcher_DispatcherFlags_CD_STATIC_STATIC_REPORTED:
        root::btCollisionDispatcher_DispatcherFlags = 1;
    pub const btCollisionDispatcher_DispatcherFlags_CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD:
        root::btCollisionDispatcher_DispatcherFlags = 2;
    pub const btCollisionDispatcher_DispatcherFlags_CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION:
        root::btCollisionDispatcher_DispatcherFlags = 4;
    pub type btCollisionDispatcher_DispatcherFlags = u32;
    extern "C" {
        /// registerCollisionCreateFunc allows registration of custom/alternative collision create functions
        #[link_name = "\u{1}_ZN21btCollisionDispatcher27registerCollisionCreateFuncEiiP30btCollisionAlgorithmCreateFunc"]
        pub fn btCollisionDispatcher_registerCollisionCreateFunc(
            this: *mut root::btCollisionDispatcher,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
            createFunc: *mut root::btCollisionAlgorithmCreateFunc,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher31registerClosestPointsCreateFuncEiiP30btCollisionAlgorithmCreateFunc"]
        pub fn btCollisionDispatcher_registerClosestPointsCreateFunc(
            this: *mut root::btCollisionDispatcher,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
            createFunc: *mut root::btCollisionAlgorithmCreateFunc,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher19defaultNearCallbackER16btBroadphasePairRS_RK16btDispatcherInfo"]
        pub fn btCollisionDispatcher_defaultNearCallback(
            collisionPair: *mut root::btBroadphasePair,
            dispatcher: *mut root::btCollisionDispatcher,
            dispatchInfo: *const root::btDispatcherInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcherC1EP24btCollisionConfiguration"]
        pub fn btCollisionDispatcher_btCollisionDispatcher(
            this: *mut root::btCollisionDispatcher,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        );
    }
    impl btCollisionDispatcher {
        #[inline]
        pub unsafe fn registerCollisionCreateFunc(
            &mut self,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
            createFunc: *mut root::btCollisionAlgorithmCreateFunc,
        ) {
            btCollisionDispatcher_registerCollisionCreateFunc(
                self, proxyType0, proxyType1, createFunc,
            )
        }
        #[inline]
        pub unsafe fn registerClosestPointsCreateFunc(
            &mut self,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
            createFunc: *mut root::btCollisionAlgorithmCreateFunc,
        ) {
            btCollisionDispatcher_registerClosestPointsCreateFunc(
                self, proxyType0, proxyType1, createFunc,
            )
        }
        #[inline]
        pub unsafe fn defaultNearCallback(
            collisionPair: *mut root::btBroadphasePair,
            dispatcher: *mut root::btCollisionDispatcher,
            dispatchInfo: *const root::btDispatcherInfo,
        ) {
            btCollisionDispatcher_defaultNearCallback(collisionPair, dispatcher, dispatchInfo)
        }
        #[inline]
        pub unsafe fn new(collisionConfiguration: *mut root::btCollisionConfiguration) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCollisionDispatcher_btCollisionDispatcher(&mut __bindgen_tmp, collisionConfiguration);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcherD1Ev"]
        pub fn btCollisionDispatcher_btCollisionDispatcher_destructor(
            this: *mut root::btCollisionDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher14getNewManifoldEPK17btCollisionObjectS2_"]
        pub fn btCollisionDispatcher_getNewManifold(
            this: *mut ::std::os::raw::c_void,
            b0: *const root::btCollisionObject,
            b1: *const root::btCollisionObject,
        ) -> *mut root::btPersistentManifold;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher15releaseManifoldEP20btPersistentManifold"]
        pub fn btCollisionDispatcher_releaseManifold(
            this: *mut ::std::os::raw::c_void,
            manifold: *mut root::btPersistentManifold,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher13clearManifoldEP20btPersistentManifold"]
        pub fn btCollisionDispatcher_clearManifold(
            this: *mut ::std::os::raw::c_void,
            manifold: *mut root::btPersistentManifold,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher13findAlgorithmEPK24btCollisionObjectWrapperS2_P20btPersistentManifold22ebtDispatcherQueryType"]
        pub fn btCollisionDispatcher_findAlgorithm(
            this: *mut ::std::os::raw::c_void,
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
            sharedManifold: *mut root::btPersistentManifold,
            queryType: root::ebtDispatcherQueryType,
        ) -> *mut root::btCollisionAlgorithm;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher14needsCollisionEPK17btCollisionObjectS2_"]
        pub fn btCollisionDispatcher_needsCollision(
            this: *mut ::std::os::raw::c_void,
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher13needsResponseEPK17btCollisionObjectS2_"]
        pub fn btCollisionDispatcher_needsResponse(
            this: *mut ::std::os::raw::c_void,
            body0: *const root::btCollisionObject,
            body1: *const root::btCollisionObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher25dispatchAllCollisionPairsEP22btOverlappingPairCacheRK16btDispatcherInfoP12btDispatcher"]
        pub fn btCollisionDispatcher_dispatchAllCollisionPairs(
            this: *mut ::std::os::raw::c_void,
            pairCache: *mut root::btOverlappingPairCache,
            dispatchInfo: *const root::btDispatcherInfo,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher26allocateCollisionAlgorithmEi"]
        pub fn btCollisionDispatcher_allocateCollisionAlgorithm(
            this: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btCollisionDispatcher22freeCollisionAlgorithmEPv"]
        pub fn btCollisionDispatcher_freeCollisionAlgorithm(
            this: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
        );
    }
    #[repr(C)]
    pub struct btBroadphaseAabbCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBroadphaseAabbCallback {
        pub vtable_: *const btBroadphaseAabbCallback__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBroadphaseRayCallback {
        pub _base: root::btBroadphaseAabbCallback,
        /// added some cached data to accelerate ray-AABB tests
        pub m_rayDirectionInverse: root::btVector3,
        pub m_signs: [::std::os::raw::c_uint; 3usize],
        pub m_lambda_max: root::btScalar,
    }
    #[repr(C)]
    pub struct btBroadphaseInterface__bindgen_vtable(::std::os::raw::c_void);
    /// The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
    /// Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
    /// The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBroadphaseInterface {
        pub vtable_: *const btBroadphaseInterface__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btOverlappingPairCallback__bindgen_vtable(::std::os::raw::c_void);
    /// The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btOverlappingPairCallback {
        pub vtable_: *const btOverlappingPairCallback__bindgen_vtable,
    }
    pub type btBroadphasePairArray = root::btAlignedObjectArray<root::btBroadphasePair>;
    #[repr(C)]
    pub struct btOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btOverlapCallback {
        pub vtable_: *const btOverlapCallback__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btOverlapFilterCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btOverlapFilterCallback {
        pub vtable_: *const btOverlapFilterCallback__bindgen_vtable,
    }
    /// The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
    /// The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btOverlappingPairCache {
        pub _base: root::btOverlappingPairCallback,
    }
    /// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
    #[repr(C)]
    pub struct btHashedOverlappingPairCache {
        pub _base: root::btOverlappingPairCache,
        pub m_overlappingPairArray: root::btBroadphasePairArray,
        pub m_overlapFilterCallback: *mut root::btOverlapFilterCallback,
        pub m_hashTable: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_next: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_ghostPairCallback: *mut root::btOverlappingPairCallback,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCacheC1Ev"]
        pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache(
            this: *mut root::btHashedOverlappingPairCache,
        );
    }
    impl btHashedOverlappingPairCache {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHashedOverlappingPairCache_btHashedOverlappingPairCache(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCacheD1Ev"]
        pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache_destructor(
            this: *mut root::btHashedOverlappingPairCache,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
        pub fn btHashedOverlappingPairCache_removeOverlappingPair(
            this: *mut ::std::os::raw::c_void,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btHashedOverlappingPairCache_cleanProxyFromPairs(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
        pub fn btHashedOverlappingPairCache_processAllOverlappingPairs(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::btOverlapCallback,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
        pub fn btHashedOverlappingPairCache_cleanOverlappingPair(
            this: *mut ::std::os::raw::c_void,
            pair: *mut root::btBroadphasePair,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache8findPairEP17btBroadphaseProxyS1_"]
        pub fn btHashedOverlappingPairCache_findPair(
            this: *mut ::std::os::raw::c_void,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
        ) -> *mut root::btBroadphasePair;
    }
    /// btSortedOverlappingPairCache maintains the objects with overlapping AABB
    /// Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
    #[repr(C)]
    pub struct btSortedOverlappingPairCache {
        pub _base: root::btOverlappingPairCache,
        pub m_overlappingPairArray: root::btBroadphasePairArray,
        pub m_blockedForChanges: bool,
        /// by default, do the removal during the pair traversal
        pub m_hasDeferredRemoval: bool,
        pub m_overlapFilterCallback: *mut root::btOverlapFilterCallback,
        pub m_ghostPairCallback: *mut root::btOverlappingPairCallback,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCacheC1Ev"]
        pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache(
            this: *mut root::btSortedOverlappingPairCache,
        );
    }
    impl btSortedOverlappingPairCache {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSortedOverlappingPairCache_btSortedOverlappingPairCache(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCacheD1Ev"]
        pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache_destructor(
            this: *mut root::btSortedOverlappingPairCache,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
        pub fn btSortedOverlappingPairCache_processAllOverlappingPairs(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::btOverlapCallback,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
        pub fn btSortedOverlappingPairCache_removeOverlappingPair(
            this: *mut ::std::os::raw::c_void,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
        pub fn btSortedOverlappingPairCache_cleanOverlappingPair(
            this: *mut ::std::os::raw::c_void,
            pair: *mut root::btBroadphasePair,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache18addOverlappingPairEP17btBroadphaseProxyS1_"]
        pub fn btSortedOverlappingPairCache_addOverlappingPair(
            this: *mut ::std::os::raw::c_void,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
        ) -> *mut root::btBroadphasePair;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache8findPairEP17btBroadphaseProxyS1_"]
        pub fn btSortedOverlappingPairCache_findPair(
            this: *mut ::std::os::raw::c_void,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
        ) -> *mut root::btBroadphasePair;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btSortedOverlappingPairCache_cleanProxyFromPairs(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache20sortOverlappingPairsEP12btDispatcher"]
        pub fn btSortedOverlappingPairCache_sortOverlappingPairs(
            this: *mut ::std::os::raw::c_void,
            dispatcher: *mut root::btDispatcher,
        );
    }
    /// btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
    #[repr(C)]
    pub struct btNullPairCache {
        pub _base: root::btOverlappingPairCache,
        pub m_overlappingPairArray: root::btBroadphasePairArray,
    }
    #[repr(C)]
    pub struct btCollisionWorld__bindgen_vtable(::std::os::raw::c_void);
    /// CollisionWorld is interface and container for the collision detection
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld {
        pub vtable_: *const btCollisionWorld__bindgen_vtable,
        pub m_collisionObjects: root::btAlignedObjectArray<*mut root::btCollisionObject>,
        pub m_dispatcher1: *mut root::btDispatcher,
        pub m_dispatchInfo: root::btDispatcherInfo,
        pub m_broadphasePairCache: *mut root::btBroadphaseInterface,
        pub m_debugDrawer: *mut root::btIDebugDraw,
        /// m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
        /// ///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
        pub m_forceUpdateAllAabbs: bool,
    }
    /// LocalShapeInfo gives extra information for complex shapes
    /// ///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionWorld_LocalShapeInfo {
        pub m_shapePart: ::std::os::raw::c_int,
        pub m_triangleIndex: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionWorld_LocalRayResult {
        pub m_collisionObject: *const root::btCollisionObject,
        pub m_localShapeInfo: *mut root::btCollisionWorld_LocalShapeInfo,
        pub m_hitNormalLocal: root::btVector3,
        pub m_hitFraction: root::btScalar,
    }
    #[repr(C)]
    pub struct btCollisionWorld_RayResultCallback__bindgen_vtable(::std::os::raw::c_void);
    /// RayResultCallback is used to report new raycast results
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_RayResultCallback {
        pub vtable_: *const btCollisionWorld_RayResultCallback__bindgen_vtable,
        pub m_closestHitFraction: root::btScalar,
        pub m_collisionObject: *const root::btCollisionObject,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
        pub m_flags: ::std::os::raw::c_uint,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_ClosestRayResultCallback {
        pub _base: root::btCollisionWorld_RayResultCallback,
        pub m_rayFromWorld: root::btVector3,
        pub m_rayToWorld: root::btVector3,
        pub m_hitNormalWorld: root::btVector3,
        pub m_hitPointWorld: root::btVector3,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_AllHitsRayResultCallback {
        pub _base: root::btCollisionWorld_RayResultCallback,
        pub m_collisionObjects: root::btAlignedObjectArray<*const root::btCollisionObject>,
        pub m_rayFromWorld: root::btVector3,
        pub m_rayToWorld: root::btVector3,
        pub m_hitNormalWorld: root::btAlignedObjectArray<root::btVector3>,
        pub m_hitPointWorld: root::btAlignedObjectArray<root::btVector3>,
        pub m_hitFractions: root::btAlignedObjectArray<root::btScalar>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionWorld_LocalConvexResult {
        pub m_hitCollisionObject: *const root::btCollisionObject,
        pub m_localShapeInfo: *mut root::btCollisionWorld_LocalShapeInfo,
        pub m_hitNormalLocal: root::btVector3,
        pub m_hitPointLocal: root::btVector3,
        pub m_hitFraction: root::btScalar,
    }
    #[repr(C)]
    pub struct btCollisionWorld_ConvexResultCallback__bindgen_vtable(::std::os::raw::c_void);
    /// RayResultCallback is used to report new raycast results
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_ConvexResultCallback {
        pub vtable_: *const btCollisionWorld_ConvexResultCallback__bindgen_vtable,
        pub m_closestHitFraction: root::btScalar,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_ClosestConvexResultCallback {
        pub _base: root::btCollisionWorld_ConvexResultCallback,
        pub m_convexFromWorld: root::btVector3,
        pub m_convexToWorld: root::btVector3,
        pub m_hitNormalWorld: root::btVector3,
        pub m_hitPointWorld: root::btVector3,
        pub m_hitCollisionObject: *const root::btCollisionObject,
    }
    #[repr(C)]
    pub struct btCollisionWorld_ContactResultCallback__bindgen_vtable(::std::os::raw::c_void);
    /// ContactResultCallback is used to report contact points
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionWorld_ContactResultCallback {
        pub vtable_: *const btCollisionWorld_ContactResultCallback__bindgen_vtable,
        pub m_collisionFilterGroup: ::std::os::raw::c_int,
        pub m_collisionFilterMask: ::std::os::raw::c_int,
        pub m_closestDistanceThreshold: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld25serializeCollisionObjectsEP12btSerializer"]
        pub fn btCollisionWorld_serializeCollisionObjects(
            this: *mut root::btCollisionWorld,
            serializer: *mut root::btSerializer,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld25serializeContactManifoldsEP12btSerializer"]
        pub fn btCollisionWorld_serializeContactManifolds(
            this: *mut root::btCollisionWorld,
            serializer: *mut root::btSerializer,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld16updateSingleAabbEP17btCollisionObject"]
        pub fn btCollisionWorld_updateSingleAabb(
            this: *mut root::btCollisionWorld,
            colObj: *mut root::btCollisionObject,
        );
    }
    extern "C" {
        /// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
        /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
        #[link_name = "\u{1}_ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf"]
        pub fn btCollisionWorld_convexSweepTest(
            this: *const root::btCollisionWorld,
            castShape: *const root::btConvexShape,
            from: *const root::btTransform,
            to: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedCcdPenetration: root::btScalar,
        );
    }
    extern "C" {
        /// contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
        /// ///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
        #[link_name = "\u{1}_ZN16btCollisionWorld11contactTestEP17btCollisionObjectRNS_21ContactResultCallbackE"]
        pub fn btCollisionWorld_contactTest(
            this: *mut root::btCollisionWorld,
            colObj: *mut root::btCollisionObject,
            resultCallback: *mut root::btCollisionWorld_ContactResultCallback,
        );
    }
    extern "C" {
        /// contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
        /// ///it reports one or more contact points (including the one with deepest penetration)
        #[link_name = "\u{1}_ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE"]
        pub fn btCollisionWorld_contactPairTest(
            this: *mut root::btCollisionWorld,
            colObjA: *mut root::btCollisionObject,
            colObjB: *mut root::btCollisionObject,
            resultCallback: *mut root::btCollisionWorld_ContactResultCallback,
        );
    }
    extern "C" {
        /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
        /// /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
        /// /// This allows more customization.
        #[link_name = "\u{1}_ZN16btCollisionWorld13rayTestSingleERK11btTransformS2_P17btCollisionObjectPK16btCollisionShapeS2_RNS_17RayResultCallbackE"]
        pub fn btCollisionWorld_rayTestSingle(
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObject: *mut root::btCollisionObject,
            collisionShape: *const root::btCollisionShape,
            colObjWorldTransform: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_RayResultCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld21rayTestSingleInternalERK11btTransformS2_PK24btCollisionObjectWrapperRNS_17RayResultCallbackE"]
        pub fn btCollisionWorld_rayTestSingleInternal(
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObjectWrap: *const root::btCollisionObjectWrapper,
            resultCallback: *mut root::btCollisionWorld_RayResultCallback,
        );
    }
    extern "C" {
        /// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
        #[link_name = "\u{1}_ZN16btCollisionWorld17objectQuerySingleEPK13btConvexShapeRK11btTransformS5_P17btCollisionObjectPK16btCollisionShapeS5_RNS_20ConvexResultCallbackEf"]
        pub fn btCollisionWorld_objectQuerySingle(
            castShape: *const root::btConvexShape,
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObject: *mut root::btCollisionObject,
            collisionShape: *const root::btCollisionShape,
            colObjWorldTransform: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedPenetration: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld25objectQuerySingleInternalEPK13btConvexShapeRK11btTransformS5_PK24btCollisionObjectWrapperRNS_20ConvexResultCallbackEf"]
        pub fn btCollisionWorld_objectQuerySingleInternal(
            castShape: *const root::btConvexShape,
            convexFromTrans: *const root::btTransform,
            convexToTrans: *const root::btTransform,
            colObjWrap: *const root::btCollisionObjectWrapper,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedPenetration: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorldC1EP12btDispatcherP21btBroadphaseInterfaceP24btCollisionConfiguration"]
        pub fn btCollisionWorld_btCollisionWorld(
            this: *mut root::btCollisionWorld,
            dispatcher: *mut root::btDispatcher,
            broadphasePairCache: *mut root::btBroadphaseInterface,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        );
    }
    impl btCollisionWorld {
        #[inline]
        pub unsafe fn serializeCollisionObjects(&mut self, serializer: *mut root::btSerializer) {
            btCollisionWorld_serializeCollisionObjects(self, serializer)
        }
        #[inline]
        pub unsafe fn serializeContactManifolds(&mut self, serializer: *mut root::btSerializer) {
            btCollisionWorld_serializeContactManifolds(self, serializer)
        }
        #[inline]
        pub unsafe fn updateSingleAabb(&mut self, colObj: *mut root::btCollisionObject) {
            btCollisionWorld_updateSingleAabb(self, colObj)
        }
        #[inline]
        pub unsafe fn convexSweepTest(
            &self,
            castShape: *const root::btConvexShape,
            from: *const root::btTransform,
            to: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedCcdPenetration: root::btScalar,
        ) {
            btCollisionWorld_convexSweepTest(
                self,
                castShape,
                from,
                to,
                resultCallback,
                allowedCcdPenetration,
            )
        }
        #[inline]
        pub unsafe fn contactTest(
            &mut self,
            colObj: *mut root::btCollisionObject,
            resultCallback: *mut root::btCollisionWorld_ContactResultCallback,
        ) {
            btCollisionWorld_contactTest(self, colObj, resultCallback)
        }
        #[inline]
        pub unsafe fn contactPairTest(
            &mut self,
            colObjA: *mut root::btCollisionObject,
            colObjB: *mut root::btCollisionObject,
            resultCallback: *mut root::btCollisionWorld_ContactResultCallback,
        ) {
            btCollisionWorld_contactPairTest(self, colObjA, colObjB, resultCallback)
        }
        #[inline]
        pub unsafe fn rayTestSingle(
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObject: *mut root::btCollisionObject,
            collisionShape: *const root::btCollisionShape,
            colObjWorldTransform: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_RayResultCallback,
        ) {
            btCollisionWorld_rayTestSingle(
                rayFromTrans,
                rayToTrans,
                collisionObject,
                collisionShape,
                colObjWorldTransform,
                resultCallback,
            )
        }
        #[inline]
        pub unsafe fn rayTestSingleInternal(
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObjectWrap: *const root::btCollisionObjectWrapper,
            resultCallback: *mut root::btCollisionWorld_RayResultCallback,
        ) {
            btCollisionWorld_rayTestSingleInternal(
                rayFromTrans,
                rayToTrans,
                collisionObjectWrap,
                resultCallback,
            )
        }
        #[inline]
        pub unsafe fn objectQuerySingle(
            castShape: *const root::btConvexShape,
            rayFromTrans: *const root::btTransform,
            rayToTrans: *const root::btTransform,
            collisionObject: *mut root::btCollisionObject,
            collisionShape: *const root::btCollisionShape,
            colObjWorldTransform: *const root::btTransform,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedPenetration: root::btScalar,
        ) {
            btCollisionWorld_objectQuerySingle(
                castShape,
                rayFromTrans,
                rayToTrans,
                collisionObject,
                collisionShape,
                colObjWorldTransform,
                resultCallback,
                allowedPenetration,
            )
        }
        #[inline]
        pub unsafe fn objectQuerySingleInternal(
            castShape: *const root::btConvexShape,
            convexFromTrans: *const root::btTransform,
            convexToTrans: *const root::btTransform,
            colObjWrap: *const root::btCollisionObjectWrapper,
            resultCallback: *mut root::btCollisionWorld_ConvexResultCallback,
            allowedPenetration: root::btScalar,
        ) {
            btCollisionWorld_objectQuerySingleInternal(
                castShape,
                convexFromTrans,
                convexToTrans,
                colObjWrap,
                resultCallback,
                allowedPenetration,
            )
        }
        #[inline]
        pub unsafe fn new(
            dispatcher: *mut root::btDispatcher,
            broadphasePairCache: *mut root::btBroadphaseInterface,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCollisionWorld_btCollisionWorld(
                &mut __bindgen_tmp,
                dispatcher,
                broadphasePairCache,
                collisionConfiguration,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorldD1Ev"]
        pub fn btCollisionWorld_btCollisionWorld_destructor(this: *mut root::btCollisionWorld);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld11updateAabbsEv"]
        pub fn btCollisionWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        /// the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
        /// ///it can be useful to use if you perform ray tests without collision detection/simulation
        #[link_name = "\u{1}_ZN16btCollisionWorld23computeOverlappingPairsEv"]
        pub fn btCollisionWorld_computeOverlappingPairs(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld14debugDrawWorldEv"]
        pub fn btCollisionWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld15debugDrawObjectERK11btTransformPK16btCollisionShapeRK9btVector3"]
        pub fn btCollisionWorld_debugDrawObject(
            this: *mut ::std::os::raw::c_void,
            worldTransform: *const root::btTransform,
            shape: *const root::btCollisionShape,
            color: *const root::btVector3,
        );
    }
    extern "C" {
        /// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
        /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
        #[link_name = "\u{1}_ZNK16btCollisionWorld7rayTestERK9btVector3S2_RNS_17RayResultCallbackE"]
        pub fn btCollisionWorld_rayTest(
            this: *mut ::std::os::raw::c_void,
            rayFromWorld: *const root::btVector3,
            rayToWorld: *const root::btVector3,
            resultCallback: *mut root::btCollisionWorld_RayResultCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld18addCollisionObjectEP17btCollisionObjectii"]
        pub fn btCollisionWorld_addCollisionObject(
            this: *mut ::std::os::raw::c_void,
            collisionObject: *mut root::btCollisionObject,
            collisionFilterGroup: ::std::os::raw::c_int,
            collisionFilterMask: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld21removeCollisionObjectEP17btCollisionObject"]
        pub fn btCollisionWorld_removeCollisionObject(
            this: *mut ::std::os::raw::c_void,
            collisionObject: *mut root::btCollisionObject,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCollisionWorld33performDiscreteCollisionDetectionEv"]
        pub fn btCollisionWorld_performDiscreteCollisionDetection(
            this: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
        #[link_name = "\u{1}_ZN16btCollisionWorld9serializeEP12btSerializer"]
        pub fn btCollisionWorld_serialize(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    #[repr(C)]
    pub struct btCollisionShape__bindgen_vtable(::std::os::raw::c_void);
    /// The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionShape {
        pub vtable_: *const btCollisionShape__bindgen_vtable,
        pub m_shapeType: ::std::os::raw::c_int,
        pub m_userPointer: *mut ::std::os::raw::c_void,
        pub m_userIndex: ::std::os::raw::c_int,
    }
    extern "C" {
        /// calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
        /// ///result is conservative
        #[link_name = "\u{1}_ZNK16btCollisionShape21calculateTemporalAabbERK11btTransformRK9btVector3S5_fRS3_S6_"]
        pub fn btCollisionShape_calculateTemporalAabb(
            this: *const root::btCollisionShape,
            curTrans: *const root::btTransform,
            linvel: *const root::btVector3,
            angvel: *const root::btVector3,
            timeStep: root::btScalar,
            temporalAabbMin: *mut root::btVector3,
            temporalAabbMax: *mut root::btVector3,
        );
    }
    impl btCollisionShape {
        #[inline]
        pub unsafe fn calculateTemporalAabb(
            &self,
            curTrans: *const root::btTransform,
            linvel: *const root::btVector3,
            angvel: *const root::btVector3,
            timeStep: root::btScalar,
            temporalAabbMin: *mut root::btVector3,
            temporalAabbMax: *mut root::btVector3,
        ) {
            btCollisionShape_calculateTemporalAabb(
                self,
                curTrans,
                linvel,
                angvel,
                timeStep,
                temporalAabbMin,
                temporalAabbMax,
            )
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCollisionShape17getBoundingSphereER9btVector3Rf"]
        pub fn btCollisionShape_getBoundingSphere(
            this: *mut ::std::os::raw::c_void,
            center: *mut root::btVector3,
            radius: *mut root::btScalar,
        );
    }
    extern "C" {
        /// getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
        #[link_name = "\u{1}_ZNK16btCollisionShape20getAngularMotionDiscEv"]
        pub fn btCollisionShape_getAngularMotionDisc(
            this: *mut ::std::os::raw::c_void,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCollisionShape27getContactBreakingThresholdEf"]
        pub fn btCollisionShape_getContactBreakingThreshold(
            this: *mut ::std::os::raw::c_void,
            defaultContactThresholdFactor: root::btScalar,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCollisionShape28calculateSerializeBufferSizeEv"]
        pub fn btCollisionShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK16btCollisionShape9serializeEPvP12btSerializer"]
        pub fn btCollisionShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCollisionShape20serializeSingleShapeEP12btSerializer"]
        pub fn btCollisionShape_serializeSingleShape(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionShapeData {
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_shapeType: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
    /// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConvexShape {
        pub _base: root::btCollisionShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btConvexShape44localGetSupportVertexWithoutMarginNonVirtualERK9btVector3"]
        pub fn btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(
            this: *const root::btConvexShape,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btConvexShape31localGetSupportVertexNonVirtualERK9btVector3"]
        pub fn btConvexShape_localGetSupportVertexNonVirtual(
            this: *const root::btConvexShape,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btConvexShape19getMarginNonVirtualEv"]
        pub fn btConvexShape_getMarginNonVirtual(
            this: *const root::btConvexShape,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btConvexShape17getAabbNonVirtualERK11btTransformR9btVector3S4_"]
        pub fn btConvexShape_getAabbNonVirtual(
            this: *const root::btConvexShape,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13btConvexShapeC2Ev"]
        pub fn btConvexShape_btConvexShape(this: *mut root::btConvexShape);
    }
    impl btConvexShape {
        #[inline]
        pub unsafe fn localGetSupportVertexWithoutMarginNonVirtual(
            &self,
            vec: *const root::btVector3,
        ) -> root::btVector3 {
            btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(self, vec)
        }
        #[inline]
        pub unsafe fn localGetSupportVertexNonVirtual(
            &self,
            vec: *const root::btVector3,
        ) -> root::btVector3 {
            btConvexShape_localGetSupportVertexNonVirtual(self, vec)
        }
        #[inline]
        pub unsafe fn getMarginNonVirtual(&self) -> root::btScalar {
            btConvexShape_getMarginNonVirtual(self)
        }
        #[inline]
        pub unsafe fn getAabbNonVirtual(
            &self,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        ) {
            btConvexShape_getAabbNonVirtual(self, t, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConvexShape_btConvexShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN13btConvexShapeD1Ev"]
        pub fn btConvexShape_btConvexShape_destructor(this: *mut root::btConvexShape);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btConvexShape7projectERK11btTransformRK9btVector3RfS6_RS3_S7_"]
        pub fn btConvexShape_project(
            this: *mut ::std::os::raw::c_void,
            trans: *const root::btTransform,
            dir: *const root::btVector3,
            minProj: *mut root::btScalar,
            maxProj: *mut root::btScalar,
            witnesPtMin: *mut root::btVector3,
            witnesPtMax: *mut root::btVector3,
        );
    }
    /// The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
    /// The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
    /// This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
    /// Note that when creating small shapes (derived from btConvexInternalShape),
    /// you need to make sure to set a smaller collision margin, using the 'setMargin' API
    /// There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConvexInternalShape {
        pub _base: root::btConvexShape,
        pub m_localScaling: root::btVector3,
        pub m_implicitShapeDimensions: root::btVector3,
        pub m_collisionMargin: root::btScalar,
        pub m_padding: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConvexInternalShapeC2Ev"]
        pub fn btConvexInternalShape_btConvexInternalShape(this: *mut root::btConvexInternalShape);
    }
    impl btConvexInternalShape {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConvexInternalShape_btConvexInternalShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConvexInternalShape24localGetSupportingVertexERK9btVector3"]
        pub fn btConvexInternalShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConvexInternalShape11getAabbSlowERK11btTransformR9btVector3S4_"]
        pub fn btConvexInternalShape_getAabbSlow(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConvexInternalShape15setLocalScalingERK9btVector3"]
        pub fn btConvexInternalShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConvexInternalShape28calculateSerializeBufferSizeEv"]
        pub fn btConvexInternalShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK21btConvexInternalShape9serializeEPvP12btSerializer"]
        pub fn btConvexInternalShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConvexInternalShapeData {
        pub m_collisionShapeData: root::btCollisionShapeData,
        pub m_localScaling: root::btVector3FloatData,
        pub m_implicitShapeDimensions: root::btVector3FloatData,
        pub m_collisionMargin: f32,
        pub m_padding: ::std::os::raw::c_int,
    }
    /// btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConvexInternalAabbCachingShape {
        pub _base: root::btConvexInternalShape,
        pub m_localAabbMin: root::btVector3,
        pub m_localAabbMax: root::btVector3,
        pub m_isLocalAabbValid: bool,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShape15recalcLocalAabbEv"]
        pub fn btConvexInternalAabbCachingShape_recalcLocalAabb(
            this: *mut root::btConvexInternalAabbCachingShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShapeC2Ev"]
        pub fn btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(
            this: *mut root::btConvexInternalAabbCachingShape,
        );
    }
    impl btConvexInternalAabbCachingShape {
        #[inline]
        pub unsafe fn recalcLocalAabb(&mut self) {
            btConvexInternalAabbCachingShape_recalcLocalAabb(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShape15setLocalScalingERK9btVector3"]
        pub fn btConvexInternalAabbCachingShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK32btConvexInternalAabbCachingShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btConvexInternalAabbCachingShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConvexPolyhedron {
        _unused: [u8; 0],
    }
    /// The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btPolyhedralConvexShape {
        pub _base: root::btConvexInternalShape,
        pub m_polyhedron: *mut root::btConvexPolyhedron,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPolyhedralConvexShapeC2Ev"]
        pub fn btPolyhedralConvexShape_btPolyhedralConvexShape(
            this: *mut root::btPolyhedralConvexShape,
        );
    }
    impl btPolyhedralConvexShape {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btPolyhedralConvexShape_btPolyhedralConvexShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPolyhedralConvexShapeD1Ev"]
        pub fn btPolyhedralConvexShape_btPolyhedralConvexShape_destructor(
            this: *mut root::btPolyhedralConvexShape,
        );
    }
    extern "C" {
        /// optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
        /// ///experimental/work-in-progress
        #[link_name = "\u{1}_ZN23btPolyhedralConvexShape28initializePolyhedralFeaturesEi"]
        pub fn btPolyhedralConvexShape_initializePolyhedralFeatures(
            this: *mut ::std::os::raw::c_void,
            shiftVerticesByMargin: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btPolyhedralConvexShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    /// The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
    #[repr(C)]
    #[derive(Debug)]
    pub struct btPolyhedralConvexAabbCachingShape {
        pub _base: root::btPolyhedralConvexShape,
        pub m_localAabbMin: root::btVector3,
        pub m_localAabbMax: root::btVector3,
        pub m_isLocalAabbValid: bool,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShape15recalcLocalAabbEv"]
        pub fn btPolyhedralConvexAabbCachingShape_recalcLocalAabb(
            this: *mut root::btPolyhedralConvexAabbCachingShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShapeC2Ev"]
        pub fn btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(
            this: *mut root::btPolyhedralConvexAabbCachingShape,
        );
    }
    impl btPolyhedralConvexAabbCachingShape {
        #[inline]
        pub unsafe fn recalcLocalAabb(&mut self) {
            btPolyhedralConvexAabbCachingShape_recalcLocalAabb(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(
                &mut __bindgen_tmp,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShape15setLocalScalingERK9btVector3"]
        pub fn btPolyhedralConvexAabbCachingShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK34btPolyhedralConvexAabbCachingShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btPolyhedralConvexAabbCachingShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    /// The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBoxShape {
        pub _base: root::btPolyhedralConvexShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN10btBoxShapeC1ERK9btVector3"]
        pub fn btBoxShape_btBoxShape(
            this: *mut root::btBoxShape,
            boxHalfExtents: *const root::btVector3,
        );
    }
    impl btBoxShape {
        #[inline]
        pub unsafe fn new(boxHalfExtents: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBoxShape_btBoxShape(&mut __bindgen_tmp, boxHalfExtents);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10btBoxShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btBoxShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK10btBoxShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btBoxShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    /// The btSphereShape implements an implicit sphere, centered around a local origin with radius.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSphereShape {
        pub _base: root::btConvexInternalShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btSphereShape24localGetSupportingVertexERK9btVector3"]
        pub fn btSphereShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btSphereShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btSphereShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btSphereShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btSphereShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btSphereShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK13btSphereShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btSphereShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    /// The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
    /// The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
    /// The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCapsuleShape {
        pub _base: root::btConvexInternalShape,
        pub m_upAxis: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btCapsuleShapeC1Eff"]
        pub fn btCapsuleShape_btCapsuleShape(
            this: *mut root::btCapsuleShape,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btCapsuleShape {
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCapsuleShape_btCapsuleShape(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    extern "C" {
        /// CollisionShape Interface
        #[link_name = "\u{1}_ZNK14btCapsuleShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btCapsuleShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        /// btConvexShape Interface
        #[link_name = "\u{1}_ZNK14btCapsuleShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btCapsuleShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btCapsuleShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btCapsuleShape28calculateSerializeBufferSizeEv"]
        pub fn btCapsuleShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK14btCapsuleShape9serializeEPvP12btSerializer"]
        pub fn btCapsuleShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// btCapsuleShapeX represents a capsule around the Z axis
    /// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCapsuleShapeX {
        pub _base: root::btCapsuleShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCapsuleShapeXC1Eff"]
        pub fn btCapsuleShapeX_btCapsuleShapeX(
            this: *mut root::btCapsuleShapeX,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btCapsuleShapeX {
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCapsuleShapeX_btCapsuleShapeX(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    /// btCapsuleShapeZ represents a capsule around the Z axis
    /// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCapsuleShapeZ {
        pub _base: root::btCapsuleShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCapsuleShapeZC1Eff"]
        pub fn btCapsuleShapeZ_btCapsuleShapeZ(
            this: *mut root::btCapsuleShapeZ,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btCapsuleShapeZ {
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCapsuleShapeZ_btCapsuleShapeZ(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCapsuleShapeData {
        pub m_convexInternalShapeData: root::btConvexInternalShapeData,
        pub m_upAxis: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCylinderShape {
        pub _base: root::btConvexInternalShape,
        pub m_upAxis: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCylinderShapeC1ERK9btVector3"]
        pub fn btCylinderShape_btCylinderShape(
            this: *mut root::btCylinderShape,
            halfExtents: *const root::btVector3,
        );
    }
    impl btCylinderShape {
        #[inline]
        pub unsafe fn new(halfExtents: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCylinderShape_btCylinderShape(&mut __bindgen_tmp, halfExtents);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCylinderShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btCylinderShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCylinderShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btCylinderShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCylinderShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btCylinderShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCylinderShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btCylinderShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCylinderShape28calculateSerializeBufferSizeEv"]
        pub fn btCylinderShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK15btCylinderShape9serializeEPvP12btSerializer"]
        pub fn btCylinderShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCylinderShapeX {
        pub _base: root::btCylinderShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCylinderShapeXC1ERK9btVector3"]
        pub fn btCylinderShapeX_btCylinderShapeX(
            this: *mut root::btCylinderShapeX,
            halfExtents: *const root::btVector3,
        );
    }
    impl btCylinderShapeX {
        #[inline]
        pub unsafe fn new(halfExtents: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCylinderShapeX_btCylinderShapeX(&mut __bindgen_tmp, halfExtents);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCylinderShapeX37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btCylinderShapeX_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCylinderShapeX49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btCylinderShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCylinderShapeZ {
        pub _base: root::btCylinderShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btCylinderShapeZC1ERK9btVector3"]
        pub fn btCylinderShapeZ_btCylinderShapeZ(
            this: *mut root::btCylinderShapeZ,
            halfExtents: *const root::btVector3,
        );
    }
    impl btCylinderShapeZ {
        #[inline]
        pub unsafe fn new(halfExtents: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCylinderShapeZ_btCylinderShapeZ(&mut __bindgen_tmp, halfExtents);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCylinderShapeZ37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btCylinderShapeZ_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btCylinderShapeZ49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btCylinderShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCylinderShapeData {
        pub m_convexInternalShapeData: root::btConvexInternalShapeData,
        pub m_upAxis: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConeShape {
        pub _base: root::btConvexInternalShape,
        pub m_sinAngle: root::btScalar,
        pub m_radius: root::btScalar,
        pub m_height: root::btScalar,
        pub m_coneIndices: [::std::os::raw::c_int; 3usize],
    }
    extern "C" {
        /// choose upAxis index
        #[link_name = "\u{1}_ZN11btConeShape14setConeUpIndexEi"]
        pub fn btConeShape_setConeUpIndex(
            this: *mut root::btConeShape,
            upIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btConeShapeC1Eff"]
        pub fn btConeShape_btConeShape(
            this: *mut root::btConeShape,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btConeShape {
        #[inline]
        pub unsafe fn setConeUpIndex(&mut self, upIndex: ::std::os::raw::c_int) {
            btConeShape_setConeUpIndex(self, upIndex)
        }
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConeShape_btConeShape(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btConeShape24localGetSupportingVertexERK9btVector3"]
        pub fn btConeShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btConeShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btConeShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btConeShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btConeShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btConeShape15setLocalScalingERK9btVector3"]
        pub fn btConeShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btConeShape28calculateSerializeBufferSizeEv"]
        pub fn btConeShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK11btConeShape9serializeEPvP12btSerializer"]
        pub fn btConeShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// btConeShape implements a Cone shape, around the X axis
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConeShapeX {
        pub _base: root::btConeShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btConeShapeXC1Eff"]
        pub fn btConeShapeX_btConeShapeX(
            this: *mut root::btConeShapeX,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btConeShapeX {
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConeShapeX_btConeShapeX(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    /// btConeShapeZ implements a Cone shape, around the Z axis
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConeShapeZ {
        pub _base: root::btConeShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btConeShapeZC1Eff"]
        pub fn btConeShapeZ_btConeShapeZ(
            this: *mut root::btConeShapeZ,
            radius: root::btScalar,
            height: root::btScalar,
        );
    }
    impl btConeShapeZ {
        #[inline]
        pub unsafe fn new(radius: root::btScalar, height: root::btScalar) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConeShapeZ_btConeShapeZ(&mut __bindgen_tmp, radius, height);
            __bindgen_tmp
        }
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConeShapeData {
        pub m_convexInternalShapeData: root::btConvexInternalShapeData,
        pub m_upIndex: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    pub struct btTriangleCallback__bindgen_vtable(::std::os::raw::c_void);
    /// The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
    /// This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btTriangleCallback {
        pub vtable_: *const btTriangleCallback__bindgen_vtable,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btTriangleCallbackD1Ev"]
        pub fn btTriangleCallback_btTriangleCallback_destructor(
            this: *mut root::btTriangleCallback,
        );
    }
    #[repr(C)]
    pub struct btInternalTriangleIndexCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btInternalTriangleIndexCallback {
        pub vtable_: *const btInternalTriangleIndexCallback__bindgen_vtable,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btInternalTriangleIndexCallbackD1Ev"]
        pub fn btInternalTriangleIndexCallback_btInternalTriangleIndexCallback_destructor(
            this: *mut root::btInternalTriangleIndexCallback,
        );
    }
    pub const PHY_ScalarType_PHY_FLOAT: root::PHY_ScalarType = 0;
    pub const PHY_ScalarType_PHY_DOUBLE: root::PHY_ScalarType = 1;
    pub const PHY_ScalarType_PHY_INTEGER: root::PHY_ScalarType = 2;
    pub const PHY_ScalarType_PHY_SHORT: root::PHY_ScalarType = 3;
    pub const PHY_ScalarType_PHY_FIXEDPOINT88: root::PHY_ScalarType = 4;
    pub const PHY_ScalarType_PHY_UCHAR: root::PHY_ScalarType = 5;
    /// PHY_ScalarType enumerates possible scalar types.
    /// See the btStridingMeshInterface or btHeightfieldTerrainShape for its use
    pub type PHY_ScalarType = u32;
    /// The btConcaveShape class provides an interface for non-moving (static) concave shapes.
    /// It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConcaveShape {
        pub _base: root::btCollisionShape,
        pub m_collisionMargin: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btConcaveShapeC2Ev"]
        pub fn btConcaveShape_btConcaveShape(this: *mut root::btConcaveShape);
    }
    impl btConcaveShape {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConcaveShape_btConcaveShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btConcaveShapeD1Ev"]
        pub fn btConcaveShape_btConcaveShape_destructor(this: *mut root::btConcaveShape);
    }
    /// The btStaticPlaneShape simulates an infinite non-moving (static) collision plane.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btStaticPlaneShape {
        pub _base: root::btConcaveShape,
        pub m_localAabbMin: root::btVector3,
        pub m_localAabbMax: root::btVector3,
        pub m_planeNormal: root::btVector3,
        pub m_planeConstant: root::btScalar,
        pub m_localScaling: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btStaticPlaneShapeC1ERK9btVector3f"]
        pub fn btStaticPlaneShape_btStaticPlaneShape(
            this: *mut root::btStaticPlaneShape,
            planeNormal: *const root::btVector3,
            planeConstant: root::btScalar,
        );
    }
    impl btStaticPlaneShape {
        #[inline]
        pub unsafe fn new(
            planeNormal: *const root::btVector3,
            planeConstant: root::btScalar,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btStaticPlaneShape_btStaticPlaneShape(&mut __bindgen_tmp, planeNormal, planeConstant);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btStaticPlaneShapeD1Ev"]
        pub fn btStaticPlaneShape_btStaticPlaneShape_destructor(
            this: *mut root::btStaticPlaneShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btStaticPlaneShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
        pub fn btStaticPlaneShape_processAllTriangles(
            this: *mut ::std::os::raw::c_void,
            callback: *mut root::btTriangleCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btStaticPlaneShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btStaticPlaneShape15setLocalScalingERK9btVector3"]
        pub fn btStaticPlaneShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape15getLocalScalingEv"]
        pub fn btStaticPlaneShape_getLocalScaling(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape28calculateSerializeBufferSizeEv"]
        pub fn btStaticPlaneShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK18btStaticPlaneShape9serializeEPvP12btSerializer"]
        pub fn btStaticPlaneShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btStaticPlaneShapeData {
        pub m_collisionShapeData: root::btCollisionShapeData,
        pub m_localScaling: root::btVector3FloatData,
        pub m_planeNormal: root::btVector3FloatData,
        pub m_planeConstant: f32,
        pub m_pad: [::std::os::raw::c_char; 4usize],
    }
    /// The btConvexHullShape implements an implicit convex hull of an array of vertices.
    /// Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConvexHullShape {
        pub _base: root::btPolyhedralConvexAabbCachingShape,
        pub m_unscaledPoints: root::btAlignedObjectArray<root::btVector3>,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btConvexHullShape8addPointERK9btVector3b"]
        pub fn btConvexHullShape_addPoint(
            this: *mut root::btConvexHullShape,
            point: *const root::btVector3,
            recalculateLocalAabb: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btConvexHullShape18optimizeConvexHullEv"]
        pub fn btConvexHullShape_optimizeConvexHull(this: *mut root::btConvexHullShape);
    }
    extern "C" {
        /// this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
        /// ///It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
        /// ///btConvexHullShape make an internal copy of the points.
        #[link_name = "\u{1}_ZN17btConvexHullShapeC1EPKfii"]
        pub fn btConvexHullShape_btConvexHullShape(
            this: *mut root::btConvexHullShape,
            points: *const root::btScalar,
            numPoints: ::std::os::raw::c_int,
            stride: ::std::os::raw::c_int,
        );
    }
    impl btConvexHullShape {
        #[inline]
        pub unsafe fn addPoint(
            &mut self,
            point: *const root::btVector3,
            recalculateLocalAabb: bool,
        ) {
            btConvexHullShape_addPoint(self, point, recalculateLocalAabb)
        }
        #[inline]
        pub unsafe fn optimizeConvexHull(&mut self) {
            btConvexHullShape_optimizeConvexHull(self)
        }
        #[inline]
        pub unsafe fn new(
            points: *const root::btScalar,
            numPoints: ::std::os::raw::c_int,
            stride: ::std::os::raw::c_int,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConvexHullShape_btConvexHullShape(&mut __bindgen_tmp, points, numPoints, stride);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape24localGetSupportingVertexERK9btVector3"]
        pub fn btConvexHullShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btConvexHullShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape7projectERK11btTransformRK9btVector3RfS6_RS3_S7_"]
        pub fn btConvexHullShape_project(
            this: *mut ::std::os::raw::c_void,
            trans: *const root::btTransform,
            dir: *const root::btVector3,
            minProj: *mut root::btScalar,
            maxProj: *mut root::btScalar,
            witnesPtMin: *mut root::btVector3,
            witnesPtMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape14getNumVerticesEv"]
        pub fn btConvexHullShape_getNumVertices(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape11getNumEdgesEv"]
        pub fn btConvexHullShape_getNumEdges(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape7getEdgeEiR9btVector3S1_"]
        pub fn btConvexHullShape_getEdge(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            pa: *mut root::btVector3,
            pb: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape9getVertexEiR9btVector3"]
        pub fn btConvexHullShape_getVertex(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            vtx: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape12getNumPlanesEv"]
        pub fn btConvexHullShape_getNumPlanes(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape8getPlaneER9btVector3S1_i"]
        pub fn btConvexHullShape_getPlane(
            this: *mut ::std::os::raw::c_void,
            planeNormal: *mut root::btVector3,
            planeSupport: *mut root::btVector3,
            i: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape8isInsideERK9btVector3f"]
        pub fn btConvexHullShape_isInside(
            this: *mut ::std::os::raw::c_void,
            pt: *const root::btVector3,
            tolerance: root::btScalar,
        ) -> bool;
    }
    extern "C" {
        /// in case we receive negative scaling
        #[link_name = "\u{1}_ZN17btConvexHullShape15setLocalScalingERK9btVector3"]
        pub fn btConvexHullShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btConvexHullShape28calculateSerializeBufferSizeEv"]
        pub fn btConvexHullShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK17btConvexHullShape9serializeEPvP12btSerializer"]
        pub fn btConvexHullShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConvexHullShapeData {
        pub m_convexInternalShapeData: root::btConvexInternalShapeData,
        pub m_unscaledPointsFloatPtr: *mut root::btVector3FloatData,
        pub m_unscaledPointsDoublePtr: *mut root::btVector3DoubleData,
        pub m_numUnscaledPoints: ::std::os::raw::c_int,
        pub m_padding3: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    pub struct btStridingMeshInterface__bindgen_vtable(::std::os::raw::c_void);
    /// The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
    /// Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
    /// It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btStridingMeshInterface {
        pub vtable_: *const btStridingMeshInterface__bindgen_vtable,
        pub m_scaling: root::btVector3,
    }
    extern "C" {
        /// brute force method to calculate aabb
        #[link_name = "\u{1}_ZN23btStridingMeshInterface23calculateAabbBruteForceER9btVector3S1_"]
        pub fn btStridingMeshInterface_calculateAabbBruteForce(
            this: *mut root::btStridingMeshInterface,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    impl btStridingMeshInterface {
        #[inline]
        pub unsafe fn calculateAabbBruteForce(
            &mut self,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        ) {
            btStridingMeshInterface_calculateAabbBruteForce(self, aabbMin, aabbMax)
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btStridingMeshInterfaceD1Ev"]
        pub fn btStridingMeshInterface_btStridingMeshInterface_destructor(
            this: *mut root::btStridingMeshInterface,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btStridingMeshInterface27InternalProcessAllTrianglesEP31btInternalTriangleIndexCallbackRK9btVector3S4_"]
        pub fn btStridingMeshInterface_InternalProcessAllTriangles(
            this: *mut ::std::os::raw::c_void,
            callback: *mut root::btInternalTriangleIndexCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btStridingMeshInterface28calculateSerializeBufferSizeEv"]
        pub fn btStridingMeshInterface_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK23btStridingMeshInterface9serializeEPvP12btSerializer"]
        pub fn btStridingMeshInterface_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btIntIndexData {
        pub m_value: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btShortIntIndexData {
        pub m_value: ::std::os::raw::c_short,
        pub m_pad: [::std::os::raw::c_char; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btShortIntIndexTripletData {
        pub m_values: [::std::os::raw::c_short; 3usize],
        pub m_pad: [::std::os::raw::c_char; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCharIndexTripletData {
        pub m_values: [::std::os::raw::c_uchar; 3usize],
        pub m_pad: ::std::os::raw::c_char,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btMeshPartData {
        pub m_vertices3f: *mut root::btVector3FloatData,
        pub m_vertices3d: *mut root::btVector3DoubleData,
        pub m_indices32: *mut root::btIntIndexData,
        pub m_3indices16: *mut root::btShortIntIndexTripletData,
        pub m_3indices8: *mut root::btCharIndexTripletData,
        pub m_indices16: *mut root::btShortIntIndexData,
        pub m_numTriangles: ::std::os::raw::c_int,
        pub m_numVertices: ::std::os::raw::c_int,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btStridingMeshInterfaceData {
        pub m_meshPartsPtr: *mut root::btMeshPartData,
        pub m_scaling: root::btVector3FloatData,
        pub m_numMeshParts: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
    /// Instead of the number of indices, we pass the number of triangles.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btIndexedMesh {
        pub m_numTriangles: ::std::os::raw::c_int,
        pub m_triangleIndexBase: *const ::std::os::raw::c_uchar,
        pub m_triangleIndexStride: ::std::os::raw::c_int,
        pub m_numVertices: ::std::os::raw::c_int,
        pub m_vertexBase: *const ::std::os::raw::c_uchar,
        pub m_vertexStride: ::std::os::raw::c_int,
        pub m_indexType: root::PHY_ScalarType,
        pub m_vertexType: root::PHY_ScalarType,
    }
    pub type IndexedMeshArray = root::btAlignedObjectArray<root::btIndexedMesh>;
    /// The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
    /// Additional meshes can be added using addIndexedMesh
    /// No duplicate is made of the vertex/index data, it only indexes into external vertex/index arrays.
    /// So keep those arrays around during the lifetime of this btTriangleIndexVertexArray.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btTriangleIndexVertexArray {
        pub _base: root::btStridingMeshInterface,
        pub m_indexedMeshes: root::IndexedMeshArray,
        pub m_pad: [::std::os::raw::c_int; 2usize],
        pub m_hasAabb: ::std::os::raw::c_int,
        pub m_aabbMin: root::btVector3,
        pub m_aabbMax: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN26btTriangleIndexVertexArrayC1EiPiiiPfi"]
        pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray(
            this: *mut root::btTriangleIndexVertexArray,
            numTriangles: ::std::os::raw::c_int,
            triangleIndexBase: *mut ::std::os::raw::c_int,
            triangleIndexStride: ::std::os::raw::c_int,
            numVertices: ::std::os::raw::c_int,
            vertexBase: *mut root::btScalar,
            vertexStride: ::std::os::raw::c_int,
        );
    }
    impl btTriangleIndexVertexArray {
        #[inline]
        pub unsafe fn new(
            numTriangles: ::std::os::raw::c_int,
            triangleIndexBase: *mut ::std::os::raw::c_int,
            triangleIndexStride: ::std::os::raw::c_int,
            numVertices: ::std::os::raw::c_int,
            vertexBase: *mut root::btScalar,
            vertexStride: ::std::os::raw::c_int,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btTriangleIndexVertexArray_btTriangleIndexVertexArray(
                &mut __bindgen_tmp,
                numTriangles,
                triangleIndexBase,
                triangleIndexStride,
                numVertices,
                vertexBase,
                vertexStride,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN26btTriangleIndexVertexArrayD1Ev"]
        pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray_destructor(
            this: *mut root::btTriangleIndexVertexArray,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray24getLockedVertexIndexBaseEPPhRiR14PHY_ScalarTypeS2_S1_S2_S2_S4_i"]
        pub fn btTriangleIndexVertexArray_getLockedVertexIndexBase(
            this: *mut ::std::os::raw::c_void,
            vertexbase: *mut *mut ::std::os::raw::c_uchar,
            numverts: *mut ::std::os::raw::c_int,
            type_: *mut root::PHY_ScalarType,
            vertexStride: *mut ::std::os::raw::c_int,
            indexbase: *mut *mut ::std::os::raw::c_uchar,
            indexstride: *mut ::std::os::raw::c_int,
            numfaces: *mut ::std::os::raw::c_int,
            indicestype: *mut root::PHY_ScalarType,
            subpart: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray32getLockedReadOnlyVertexIndexBaseEPPKhRiR14PHY_ScalarTypeS3_S2_S3_S3_S5_i"]
        pub fn btTriangleIndexVertexArray_getLockedReadOnlyVertexIndexBase(
            this: *mut ::std::os::raw::c_void,
            vertexbase: *mut *const ::std::os::raw::c_uchar,
            numverts: *mut ::std::os::raw::c_int,
            type_: *mut root::PHY_ScalarType,
            vertexStride: *mut ::std::os::raw::c_int,
            indexbase: *mut *const ::std::os::raw::c_uchar,
            indexstride: *mut ::std::os::raw::c_int,
            numfaces: *mut ::std::os::raw::c_int,
            indicestype: *mut root::PHY_ScalarType,
            subpart: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14hasPremadeAabbEv"]
        pub fn btTriangleIndexVertexArray_hasPremadeAabb(this: *mut ::std::os::raw::c_void)
            -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14setPremadeAabbERK9btVector3S2_"]
        pub fn btTriangleIndexVertexArray_setPremadeAabb(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14getPremadeAabbEP9btVector3S1_"]
        pub fn btTriangleIndexVertexArray_getPremadeAabb(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    /// The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
    /// It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
    /// If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
    /// Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btTriangleMesh {
        pub _base: root::btTriangleIndexVertexArray,
        pub m_4componentVertices: root::btAlignedObjectArray<root::btVector3>,
        pub m_3componentVertices: root::btAlignedObjectArray<root::btScalar>,
        pub m_32bitIndices: root::btAlignedObjectArray<::std::os::raw::c_uint>,
        pub m_16bitIndices: root::btAlignedObjectArray<::std::os::raw::c_ushort>,
        pub m_use32bitIndices: bool,
        pub m_use4componentVertices: bool,
        pub m_weldingThreshold: root::btScalar,
    }
    extern "C" {
        /// By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
        /// ///In general it is better to directly use btTriangleIndexVertexArray instead.
        #[link_name = "\u{1}_ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b"]
        pub fn btTriangleMesh_addTriangle(
            this: *mut root::btTriangleMesh,
            vertex0: *const root::btVector3,
            vertex1: *const root::btVector3,
            vertex2: *const root::btVector3,
            removeDuplicateVertices: bool,
        );
    }
    extern "C" {
        /// Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices)
        #[link_name = "\u{1}_ZN14btTriangleMesh18addTriangleIndicesEiii"]
        pub fn btTriangleMesh_addTriangleIndices(
            this: *mut root::btTriangleMesh,
            index1: ::std::os::raw::c_int,
            index2: ::std::os::raw::c_int,
            index3: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btTriangleMesh15getNumTrianglesEv"]
        pub fn btTriangleMesh_getNumTriangles(
            this: *const root::btTriangleMesh,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// findOrAddVertex is an internal method, use addTriangle instead
        #[link_name = "\u{1}_ZN14btTriangleMesh15findOrAddVertexERK9btVector3b"]
        pub fn btTriangleMesh_findOrAddVertex(
            this: *mut root::btTriangleMesh,
            vertex: *const root::btVector3,
            removeDuplicateVertices: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// addIndex is an internal method, use addTriangle instead
        #[link_name = "\u{1}_ZN14btTriangleMesh8addIndexEi"]
        pub fn btTriangleMesh_addIndex(
            this: *mut root::btTriangleMesh,
            index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btTriangleMeshC1Ebb"]
        pub fn btTriangleMesh_btTriangleMesh(
            this: *mut root::btTriangleMesh,
            use32bitIndices: bool,
            use4componentVertices: bool,
        );
    }
    impl btTriangleMesh {
        #[inline]
        pub unsafe fn addTriangle(
            &mut self,
            vertex0: *const root::btVector3,
            vertex1: *const root::btVector3,
            vertex2: *const root::btVector3,
            removeDuplicateVertices: bool,
        ) {
            btTriangleMesh_addTriangle(self, vertex0, vertex1, vertex2, removeDuplicateVertices)
        }
        #[inline]
        pub unsafe fn addTriangleIndices(
            &mut self,
            index1: ::std::os::raw::c_int,
            index2: ::std::os::raw::c_int,
            index3: ::std::os::raw::c_int,
        ) {
            btTriangleMesh_addTriangleIndices(self, index1, index2, index3)
        }
        #[inline]
        pub unsafe fn getNumTriangles(&self) -> ::std::os::raw::c_int {
            btTriangleMesh_getNumTriangles(self)
        }
        #[inline]
        pub unsafe fn findOrAddVertex(
            &mut self,
            vertex: *const root::btVector3,
            removeDuplicateVertices: bool,
        ) -> ::std::os::raw::c_int {
            btTriangleMesh_findOrAddVertex(self, vertex, removeDuplicateVertices)
        }
        #[inline]
        pub unsafe fn addIndex(&mut self, index: ::std::os::raw::c_int) {
            btTriangleMesh_addIndex(self, index)
        }
        #[inline]
        pub unsafe fn new(use32bitIndices: bool, use4componentVertices: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btTriangleMesh_btTriangleMesh(
                &mut __bindgen_tmp,
                use32bitIndices,
                use4componentVertices,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btTriangleMesh19preallocateVerticesEi"]
        pub fn btTriangleMesh_preallocateVertices(
            this: *mut ::std::os::raw::c_void,
            numverts: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btTriangleMesh18preallocateIndicesEi"]
        pub fn btTriangleMesh_preallocateIndices(
            this: *mut ::std::os::raw::c_void,
            numindices: ::std::os::raw::c_int,
        );
    }
    /// The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
    /// A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConvexTriangleMeshShape {
        pub _base: root::btPolyhedralConvexAabbCachingShape,
        pub m_stridingMesh: *mut root::btStridingMeshInterface,
    }
    extern "C" {
        /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
        /// ///and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
        /// ///by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
        /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
        /// ///of the collision object by the principal transform. This method also computes the volume of the convex mesh.
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape31calculatePrincipalAxisTransformER11btTransformR9btVector3Rf"]
        pub fn btConvexTriangleMeshShape_calculatePrincipalAxisTransform(
            this: *const root::btConvexTriangleMeshShape,
            principal: *mut root::btTransform,
            inertia: *mut root::btVector3,
            volume: *mut root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb"]
        pub fn btConvexTriangleMeshShape_btConvexTriangleMeshShape(
            this: *mut root::btConvexTriangleMeshShape,
            meshInterface: *mut root::btStridingMeshInterface,
            calcAabb: bool,
        );
    }
    impl btConvexTriangleMeshShape {
        #[inline]
        pub unsafe fn calculatePrincipalAxisTransform(
            &self,
            principal: *mut root::btTransform,
            inertia: *mut root::btVector3,
            volume: *mut root::btScalar,
        ) {
            btConvexTriangleMeshShape_calculatePrincipalAxisTransform(
                self, principal, inertia, volume,
            )
        }
        #[inline]
        pub unsafe fn new(
            meshInterface: *mut root::btStridingMeshInterface,
            calcAabb: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConvexTriangleMeshShape_btConvexTriangleMeshShape(
                &mut __bindgen_tmp,
                meshInterface,
                calcAabb,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape24localGetSupportingVertexERK9btVector3"]
        pub fn btConvexTriangleMeshShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btConvexTriangleMeshShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape14getNumVerticesEv"]
        pub fn btConvexTriangleMeshShape_getNumVertices(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape11getNumEdgesEv"]
        pub fn btConvexTriangleMeshShape_getNumEdges(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape7getEdgeEiR9btVector3S1_"]
        pub fn btConvexTriangleMeshShape_getEdge(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            pa: *mut root::btVector3,
            pb: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape9getVertexEiR9btVector3"]
        pub fn btConvexTriangleMeshShape_getVertex(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            vtx: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape12getNumPlanesEv"]
        pub fn btConvexTriangleMeshShape_getNumPlanes(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape8getPlaneER9btVector3S1_i"]
        pub fn btConvexTriangleMeshShape_getPlane(
            this: *mut ::std::os::raw::c_void,
            planeNormal: *mut root::btVector3,
            planeSupport: *mut root::btVector3,
            i: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape8isInsideERK9btVector3f"]
        pub fn btConvexTriangleMeshShape_isInside(
            this: *mut ::std::os::raw::c_void,
            pt: *const root::btVector3,
            tolerance: root::btScalar,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN25btConvexTriangleMeshShape15setLocalScalingERK9btVector3"]
        pub fn btConvexTriangleMeshShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape15getLocalScalingEv"]
        pub fn btConvexTriangleMeshShape_getLocalScaling(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btVector3;
    }
    /// The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btTriangleMeshShape {
        pub _base: root::btConcaveShape,
        pub m_localAabbMin: root::btVector3,
        pub m_localAabbMax: root::btVector3,
        pub m_meshInterface: *mut root::btStridingMeshInterface,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19btTriangleMeshShape15recalcLocalAabbEv"]
        pub fn btTriangleMeshShape_recalcLocalAabb(this: *mut root::btTriangleMeshShape);
    }
    extern "C" {
        /// btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
        /// ///Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!
        #[link_name = "\u{1}_ZN19btTriangleMeshShapeC1EP23btStridingMeshInterface"]
        pub fn btTriangleMeshShape_btTriangleMeshShape(
            this: *mut root::btTriangleMeshShape,
            meshInterface: *mut root::btStridingMeshInterface,
        );
    }
    impl btTriangleMeshShape {
        #[inline]
        pub unsafe fn recalcLocalAabb(&mut self) {
            btTriangleMeshShape_recalcLocalAabb(self)
        }
        #[inline]
        pub unsafe fn new(meshInterface: *mut root::btStridingMeshInterface) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btTriangleMeshShape_btTriangleMeshShape(&mut __bindgen_tmp, meshInterface);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19btTriangleMeshShapeD1Ev"]
        pub fn btTriangleMeshShape_btTriangleMeshShape_destructor(
            this: *mut root::btTriangleMeshShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19btTriangleMeshShape24localGetSupportingVertexERK9btVector3"]
        pub fn btTriangleMeshShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19btTriangleMeshShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btTriangleMeshShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19btTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
        pub fn btTriangleMeshShape_processAllTriangles(
            this: *mut ::std::os::raw::c_void,
            callback: *mut root::btTriangleCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19btTriangleMeshShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btTriangleMeshShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN19btTriangleMeshShape15setLocalScalingERK9btVector3"]
        pub fn btTriangleMeshShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK19btTriangleMeshShape15getLocalScalingEv"]
        pub fn btTriangleMeshShape_getLocalScaling(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btVector3;
    }
    /// btQuantizedBvhNode is a compressed aabb node, 16 bytes.
    /// Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuantizedBvhNode {
        pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
        pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
        pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
    }
    /// btOptimizedBvhNode contains both internal and leaf node information.
    /// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btOptimizedBvhNode {
        pub m_aabbMinOrg: root::btVector3,
        pub m_aabbMaxOrg: root::btVector3,
        pub m_escapeIndex: ::std::os::raw::c_int,
        pub m_subPart: ::std::os::raw::c_int,
        pub m_triangleIndex: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 20usize],
    }
    /// btBvhSubtreeInfo provides info to gather a subtree of limited size
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btBvhSubtreeInfo {
        pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
        pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
        pub m_rootNodeIndex: ::std::os::raw::c_int,
        pub m_subtreeSize: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_int; 3usize],
    }
    #[repr(C)]
    pub struct btNodeOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btNodeOverlapCallback {
        pub vtable_: *const btNodeOverlapCallback__bindgen_vtable,
    }
    /// for code readability:
    pub type NodeArray = root::btAlignedObjectArray<root::btOptimizedBvhNode>;
    pub type QuantizedNodeArray = root::btAlignedObjectArray<root::btQuantizedBvhNode>;
    pub type BvhSubtreeInfoArray = root::btAlignedObjectArray<root::btBvhSubtreeInfo>;
    #[repr(C)]
    pub struct btQuantizedBvh__bindgen_vtable(::std::os::raw::c_void);
    /// The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
    /// It is used by the btBvhTriangleMeshShape as midphase.
    /// It is recommended to use quantization for better performance and lower memory requirements.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btQuantizedBvh {
        pub vtable_: *const btQuantizedBvh__bindgen_vtable,
        pub m_bvhAabbMin: root::btVector3,
        pub m_bvhAabbMax: root::btVector3,
        pub m_bvhQuantization: root::btVector3,
        pub m_bulletVersion: ::std::os::raw::c_int,
        pub m_curNodeIndex: ::std::os::raw::c_int,
        pub m_useQuantization: bool,
        pub m_leafNodes: root::NodeArray,
        pub m_contiguousNodes: root::NodeArray,
        pub m_quantizedLeafNodes: root::QuantizedNodeArray,
        pub m_quantizedContiguousNodes: root::QuantizedNodeArray,
        pub m_traversalMode: root::btQuantizedBvh_btTraversalMode,
        pub m_SubtreeHeaders: root::BvhSubtreeInfoArray,
        pub m_subtreeHeaderCount: ::std::os::raw::c_int,
    }
    pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS:
        root::btQuantizedBvh_btTraversalMode = 0;
    pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS_CACHE_FRIENDLY:
        root::btQuantizedBvh_btTraversalMode = 1;
    pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_RECURSIVE:
        root::btQuantizedBvh_btTraversalMode = 2;
    pub type btQuantizedBvh_btTraversalMode = u32;
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh13swapLeafNodesEii"]
        pub fn btQuantizedBvh_swapLeafNodes(
            this: *mut root::btQuantizedBvh,
            firstIndex: ::std::os::raw::c_int,
            secondIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh30assignInternalNodeFromLeafNodeEii"]
        pub fn btQuantizedBvh_assignInternalNodeFromLeafNode(
            this: *mut root::btQuantizedBvh,
            internalNode: ::std::os::raw::c_int,
            leafNodeIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh9buildTreeEii"]
        pub fn btQuantizedBvh_buildTree(
            this: *mut root::btQuantizedBvh,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh17calcSplittingAxisEii"]
        pub fn btQuantizedBvh_calcSplittingAxis(
            this: *mut root::btQuantizedBvh,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh25sortAndCalcSplittingIndexEiii"]
        pub fn btQuantizedBvh_sortAndCalcSplittingIndex(
            this: *mut root::btQuantizedBvh,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
            splitAxis: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh17walkStacklessTreeEP21btNodeOverlapCallbackRK9btVector3S4_"]
        pub fn btQuantizedBvh_walkStacklessTree(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh36walkStacklessQuantizedTreeAgainstRayEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_ii"]
        pub fn btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh26walkStacklessQuantizedTreeEP21btNodeOverlapCallbackPtS2_ii"]
        pub fn btQuantizedBvh_walkStacklessQuantizedTree(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh27walkStacklessTreeAgainstRayEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_ii"]
        pub fn btQuantizedBvh_walkStacklessTreeAgainstRay(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// tree traversal designed for small-memory processors like PS3 SPU
        #[link_name = "\u{1}_ZNK14btQuantizedBvh39walkStacklessQuantizedTreeCacheFriendlyEP21btNodeOverlapCallbackPtS2_"]
        pub fn btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        );
    }
    extern "C" {
        /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
        #[link_name = "\u{1}_ZNK14btQuantizedBvh42walkRecursiveQuantizedTreeAgainstQueryAabbEPK18btQuantizedBvhNodeP21btNodeOverlapCallbackPtS5_"]
        pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
            this: *const root::btQuantizedBvh,
            currentNode: *const root::btQuantizedBvhNode,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        );
    }
    extern "C" {
        /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
        #[link_name = "\u{1}_ZNK14btQuantizedBvh46walkRecursiveQuantizedTreeAgainstQuantizedTreeEPK18btQuantizedBvhNodeS2_P21btNodeOverlapCallback"]
        pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
            this: *const root::btQuantizedBvh,
            treeNodeA: *const root::btQuantizedBvhNode,
            treeNodeB: *const root::btQuantizedBvhNode,
            nodeCallback: *mut root::btNodeOverlapCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh20updateSubtreeHeadersEii"]
        pub fn btQuantizedBvh_updateSubtreeHeaders(
            this: *mut root::btQuantizedBvh,
            leftChildNodexIndex: ::std::os::raw::c_int,
            rightChildNodexIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// ***************************************** expert/internal use only *************************
        #[link_name = "\u{1}_ZN14btQuantizedBvh21setQuantizationValuesERK9btVector3S2_f"]
        pub fn btQuantizedBvh_setQuantizationValues(
            this: *mut root::btQuantizedBvh,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
            quantizationMargin: root::btScalar,
        );
    }
    extern "C" {
        /// buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized
        #[link_name = "\u{1}_ZN14btQuantizedBvh13buildInternalEv"]
        pub fn btQuantizedBvh_buildInternal(this: *mut root::btQuantizedBvh);
    }
    extern "C" {
        /// ***************************************** expert/internal use only *************************
        #[link_name = "\u{1}_ZNK14btQuantizedBvh26reportAabbOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_"]
        pub fn btQuantizedBvh_reportAabbOverlappingNodex(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh25reportRayOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_"]
        pub fn btQuantizedBvh_reportRayOverlappingNodex(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btQuantizedBvh29reportBoxCastOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_"]
        pub fn btQuantizedBvh_reportBoxCastOverlappingNodex(
            this: *const root::btQuantizedBvh,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        /// Calculate space needed to store BVH for serialization
        #[link_name = "\u{1}_ZNK14btQuantizedBvh28calculateSerializeBufferSizeEv"]
        pub fn btQuantizedBvh_calculateSerializeBufferSize(
            this: *const root::btQuantizedBvh,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
        #[link_name = "\u{1}_ZN14btQuantizedBvh18deSerializeInPlaceEPvjb"]
        pub fn btQuantizedBvh_deSerializeInPlace(
            i_alignedDataBuffer: *mut ::std::os::raw::c_void,
            i_dataBufferSize: ::std::os::raw::c_uint,
            i_swapEndian: bool,
        ) -> *mut root::btQuantizedBvh;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh32getAlignmentSerializationPaddingEv"]
        pub fn btQuantizedBvh_getAlignmentSerializationPadding() -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvhC1Ev"]
        pub fn btQuantizedBvh_btQuantizedBvh(this: *mut root::btQuantizedBvh);
    }
    impl btQuantizedBvh {
        #[inline]
        pub unsafe fn swapLeafNodes(
            &mut self,
            firstIndex: ::std::os::raw::c_int,
            secondIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_swapLeafNodes(self, firstIndex, secondIndex)
        }
        #[inline]
        pub unsafe fn assignInternalNodeFromLeafNode(
            &mut self,
            internalNode: ::std::os::raw::c_int,
            leafNodeIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_assignInternalNodeFromLeafNode(self, internalNode, leafNodeIndex)
        }
        #[inline]
        pub unsafe fn buildTree(
            &mut self,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_buildTree(self, startIndex, endIndex)
        }
        #[inline]
        pub unsafe fn calcSplittingAxis(
            &mut self,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            btQuantizedBvh_calcSplittingAxis(self, startIndex, endIndex)
        }
        #[inline]
        pub unsafe fn sortAndCalcSplittingIndex(
            &mut self,
            startIndex: ::std::os::raw::c_int,
            endIndex: ::std::os::raw::c_int,
            splitAxis: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            btQuantizedBvh_sortAndCalcSplittingIndex(self, startIndex, endIndex, splitAxis)
        }
        #[inline]
        pub unsafe fn walkStacklessTree(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btQuantizedBvh_walkStacklessTree(self, nodeCallback, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn walkStacklessQuantizedTreeAgainstRay(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
                self,
                nodeCallback,
                raySource,
                rayTarget,
                aabbMin,
                aabbMax,
                startNodeIndex,
                endNodeIndex,
            )
        }
        #[inline]
        pub unsafe fn walkStacklessQuantizedTree(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_walkStacklessQuantizedTree(
                self,
                nodeCallback,
                quantizedQueryAabbMin,
                quantizedQueryAabbMax,
                startNodeIndex,
                endNodeIndex,
            )
        }
        #[inline]
        pub unsafe fn walkStacklessTreeAgainstRay(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            startNodeIndex: ::std::os::raw::c_int,
            endNodeIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_walkStacklessTreeAgainstRay(
                self,
                nodeCallback,
                raySource,
                rayTarget,
                aabbMin,
                aabbMax,
                startNodeIndex,
                endNodeIndex,
            )
        }
        #[inline]
        pub unsafe fn walkStacklessQuantizedTreeCacheFriendly(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        ) {
            btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
                self,
                nodeCallback,
                quantizedQueryAabbMin,
                quantizedQueryAabbMax,
            )
        }
        #[inline]
        pub unsafe fn walkRecursiveQuantizedTreeAgainstQueryAabb(
            &self,
            currentNode: *const root::btQuantizedBvhNode,
            nodeCallback: *mut root::btNodeOverlapCallback,
            quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
            quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        ) {
            btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
                self,
                currentNode,
                nodeCallback,
                quantizedQueryAabbMin,
                quantizedQueryAabbMax,
            )
        }
        #[inline]
        pub unsafe fn walkRecursiveQuantizedTreeAgainstQuantizedTree(
            &self,
            treeNodeA: *const root::btQuantizedBvhNode,
            treeNodeB: *const root::btQuantizedBvhNode,
            nodeCallback: *mut root::btNodeOverlapCallback,
        ) {
            btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
                self,
                treeNodeA,
                treeNodeB,
                nodeCallback,
            )
        }
        #[inline]
        pub unsafe fn updateSubtreeHeaders(
            &mut self,
            leftChildNodexIndex: ::std::os::raw::c_int,
            rightChildNodexIndex: ::std::os::raw::c_int,
        ) {
            btQuantizedBvh_updateSubtreeHeaders(self, leftChildNodexIndex, rightChildNodexIndex)
        }
        #[inline]
        pub unsafe fn setQuantizationValues(
            &mut self,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
            quantizationMargin: root::btScalar,
        ) {
            btQuantizedBvh_setQuantizationValues(self, bvhAabbMin, bvhAabbMax, quantizationMargin)
        }
        #[inline]
        pub unsafe fn buildInternal(&mut self) {
            btQuantizedBvh_buildInternal(self)
        }
        #[inline]
        pub unsafe fn reportAabbOverlappingNodex(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btQuantizedBvh_reportAabbOverlappingNodex(self, nodeCallback, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn reportRayOverlappingNodex(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
        ) {
            btQuantizedBvh_reportRayOverlappingNodex(self, nodeCallback, raySource, rayTarget)
        }
        #[inline]
        pub unsafe fn reportBoxCastOverlappingNodex(
            &self,
            nodeCallback: *mut root::btNodeOverlapCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btQuantizedBvh_reportBoxCastOverlappingNodex(
                self,
                nodeCallback,
                raySource,
                rayTarget,
                aabbMin,
                aabbMax,
            )
        }
        #[inline]
        pub unsafe fn calculateSerializeBufferSize(&self) -> ::std::os::raw::c_uint {
            btQuantizedBvh_calculateSerializeBufferSize(self)
        }
        #[inline]
        pub unsafe fn deSerializeInPlace(
            i_alignedDataBuffer: *mut ::std::os::raw::c_void,
            i_dataBufferSize: ::std::os::raw::c_uint,
            i_swapEndian: bool,
        ) -> *mut root::btQuantizedBvh {
            btQuantizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
        }
        #[inline]
        pub unsafe fn getAlignmentSerializationPadding() -> ::std::os::raw::c_uint {
            btQuantizedBvh_getAlignmentSerializationPadding()
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btQuantizedBvh_btQuantizedBvh(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvhD1Ev"]
        pub fn btQuantizedBvh_btQuantizedBvh_destructor(this: *mut root::btQuantizedBvh);
    }
    extern "C" {
        /// Data buffer MUST be 16 byte aligned
        #[link_name = "\u{1}_ZNK14btQuantizedBvh9serializeEPvjb"]
        pub fn btQuantizedBvh_serialize(
            this: *mut ::std::os::raw::c_void,
            o_alignedDataBuffer: *mut ::std::os::raw::c_void,
            i_dataBufferSize: ::std::os::raw::c_uint,
            i_swapEndian: bool,
        ) -> bool;
    }
    extern "C" {
        ///
        #[link_name = "\u{1}_ZNK14btQuantizedBvh31calculateSerializeBufferSizeNewEv"]
        pub fn btQuantizedBvh_calculateSerializeBufferSizeNew(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK14btQuantizedBvh9serializeEPvP12btSerializer"]
        pub fn btQuantizedBvh_serialize1(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh16deSerializeFloatER23btQuantizedBvhFloatData"]
        pub fn btQuantizedBvh_deSerializeFloat(
            this: *mut ::std::os::raw::c_void,
            quantizedBvhFloatData: *mut root::btQuantizedBvhFloatData,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btQuantizedBvh17deSerializeDoubleER24btQuantizedBvhDoubleData"]
        pub fn btQuantizedBvh_deSerializeDouble(
            this: *mut ::std::os::raw::c_void,
            quantizedBvhDoubleData: *mut root::btQuantizedBvhDoubleData,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btBvhSubtreeInfoData {
        pub m_rootNodeIndex: ::std::os::raw::c_int,
        pub m_subtreeSize: ::std::os::raw::c_int,
        pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
        pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btOptimizedBvhNodeFloatData {
        pub m_aabbMinOrg: root::btVector3FloatData,
        pub m_aabbMaxOrg: root::btVector3FloatData,
        pub m_escapeIndex: ::std::os::raw::c_int,
        pub m_subPart: ::std::os::raw::c_int,
        pub m_triangleIndex: ::std::os::raw::c_int,
        pub m_pad: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btOptimizedBvhNodeDoubleData {
        pub m_aabbMinOrg: root::btVector3DoubleData,
        pub m_aabbMaxOrg: root::btVector3DoubleData,
        pub m_escapeIndex: ::std::os::raw::c_int,
        pub m_subPart: ::std::os::raw::c_int,
        pub m_triangleIndex: ::std::os::raw::c_int,
        pub m_pad: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuantizedBvhNodeData {
        pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
        pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
        pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuantizedBvhFloatData {
        pub m_bvhAabbMin: root::btVector3FloatData,
        pub m_bvhAabbMax: root::btVector3FloatData,
        pub m_bvhQuantization: root::btVector3FloatData,
        pub m_curNodeIndex: ::std::os::raw::c_int,
        pub m_useQuantization: ::std::os::raw::c_int,
        pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
        pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
        pub m_contiguousNodesPtr: *mut root::btOptimizedBvhNodeFloatData,
        pub m_quantizedContiguousNodesPtr: *mut root::btQuantizedBvhNodeData,
        pub m_subTreeInfoPtr: *mut root::btBvhSubtreeInfoData,
        pub m_traversalMode: ::std::os::raw::c_int,
        pub m_numSubtreeHeaders: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btQuantizedBvhDoubleData {
        pub m_bvhAabbMin: root::btVector3DoubleData,
        pub m_bvhAabbMax: root::btVector3DoubleData,
        pub m_bvhQuantization: root::btVector3DoubleData,
        pub m_curNodeIndex: ::std::os::raw::c_int,
        pub m_useQuantization: ::std::os::raw::c_int,
        pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
        pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
        pub m_contiguousNodesPtr: *mut root::btOptimizedBvhNodeDoubleData,
        pub m_quantizedContiguousNodesPtr: *mut root::btQuantizedBvhNodeData,
        pub m_traversalMode: ::std::os::raw::c_int,
        pub m_numSubtreeHeaders: ::std::os::raw::c_int,
        pub m_subTreeInfoPtr: *mut root::btBvhSubtreeInfoData,
    }
    /// The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btOptimizedBvh {
        pub _base: root::btQuantizedBvh,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvh5buildEP23btStridingMeshInterfacebRK9btVector3S4_"]
        pub fn btOptimizedBvh_build(
            this: *mut root::btOptimizedBvh,
            triangles: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvh5refitEP23btStridingMeshInterfaceRK9btVector3S4_"]
        pub fn btOptimizedBvh_refit(
            this: *mut root::btOptimizedBvh,
            triangles: *mut root::btStridingMeshInterface,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvh12refitPartialEP23btStridingMeshInterfaceRK9btVector3S4_"]
        pub fn btOptimizedBvh_refitPartial(
            this: *mut root::btOptimizedBvh,
            triangles: *mut root::btStridingMeshInterface,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvh14updateBvhNodesEP23btStridingMeshInterfaceiii"]
        pub fn btOptimizedBvh_updateBvhNodes(
            this: *mut root::btOptimizedBvh,
            meshInterface: *mut root::btStridingMeshInterface,
            firstNode: ::std::os::raw::c_int,
            endNode: ::std::os::raw::c_int,
            index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
        #[link_name = "\u{1}_ZN14btOptimizedBvh18deSerializeInPlaceEPvjb"]
        pub fn btOptimizedBvh_deSerializeInPlace(
            i_alignedDataBuffer: *mut ::std::os::raw::c_void,
            i_dataBufferSize: ::std::os::raw::c_uint,
            i_swapEndian: bool,
        ) -> *mut root::btOptimizedBvh;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvhC1Ev"]
        pub fn btOptimizedBvh_btOptimizedBvh(this: *mut root::btOptimizedBvh);
    }
    impl btOptimizedBvh {
        #[inline]
        pub unsafe fn build(
            &mut self,
            triangles: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
        ) {
            btOptimizedBvh_build(
                self,
                triangles,
                useQuantizedAabbCompression,
                bvhAabbMin,
                bvhAabbMax,
            )
        }
        #[inline]
        pub unsafe fn refit(
            &mut self,
            triangles: *mut root::btStridingMeshInterface,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btOptimizedBvh_refit(self, triangles, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn refitPartial(
            &mut self,
            triangles: *mut root::btStridingMeshInterface,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btOptimizedBvh_refitPartial(self, triangles, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn updateBvhNodes(
            &mut self,
            meshInterface: *mut root::btStridingMeshInterface,
            firstNode: ::std::os::raw::c_int,
            endNode: ::std::os::raw::c_int,
            index: ::std::os::raw::c_int,
        ) {
            btOptimizedBvh_updateBvhNodes(self, meshInterface, firstNode, endNode, index)
        }
        #[inline]
        pub unsafe fn deSerializeInPlace(
            i_alignedDataBuffer: *mut ::std::os::raw::c_void,
            i_dataBufferSize: ::std::os::raw::c_uint,
            i_swapEndian: bool,
        ) -> *mut root::btOptimizedBvh {
            btOptimizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btOptimizedBvh_btOptimizedBvh(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN14btOptimizedBvhD1Ev"]
        pub fn btOptimizedBvh_btOptimizedBvh_destructor(this: *mut root::btOptimizedBvh);
    }
    /// very basic hashable string implementation, compatible with btHashMap
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHashString {
        pub m_string: *const ::std::os::raw::c_char,
        pub m_hash: ::std::os::raw::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHashInt {
        pub m_uid: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btHashPtr {
        pub __bindgen_anon_1: root::btHashPtr__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btHashPtr__bindgen_ty_1 {
        pub m_pointer: *const ::std::os::raw::c_void,
        pub m_hashValues: [::std::os::raw::c_uint; 2usize],
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHashKeyPtr {
        pub m_uid: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHashKey {
        pub m_uid: ::std::os::raw::c_int,
    }
    /// The btHashMap template class implements a generic and lightweight hashmap.
    /// A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
    #[repr(C)]
    #[derive(Debug)]
    pub struct btHashMap<Key, Value> {
        pub m_hashTable: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_next: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_valueArray: root::btAlignedObjectArray<Value>,
        pub m_keyArray: root::btAlignedObjectArray<Key>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Key>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Value>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btChunk {
        pub m_chunkCode: ::std::os::raw::c_int,
        pub m_length: ::std::os::raw::c_int,
        pub m_oldPtr: *mut ::std::os::raw::c_void,
        pub m_dna_nr: ::std::os::raw::c_int,
        pub m_number: ::std::os::raw::c_int,
    }
    pub const btSerializationFlags_BT_SERIALIZE_NO_BVH: root::btSerializationFlags = 1;
    pub const btSerializationFlags_BT_SERIALIZE_NO_TRIANGLEINFOMAP: root::btSerializationFlags = 2;
    pub const btSerializationFlags_BT_SERIALIZE_NO_DUPLICATE_ASSERT: root::btSerializationFlags = 4;
    pub const btSerializationFlags_BT_SERIALIZE_CONTACT_MANIFOLDS: root::btSerializationFlags = 8;
    pub type btSerializationFlags = u32;
    #[repr(C)]
    pub struct btSerializer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSerializer {
        pub vtable_: *const btSerializer__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btPointerUid {
        pub __bindgen_anon_1: root::btPointerUid__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btPointerUid__bindgen_ty_1 {
        pub m_ptr: *mut ::std::os::raw::c_void,
        pub m_uniqueIds: [::std::os::raw::c_int; 2usize],
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBulletSerializedArrays {
        pub m_bvhsDouble: root::btAlignedObjectArray<*mut root::btQuantizedBvhDoubleData>,
        pub m_bvhsFloat: root::btAlignedObjectArray<*mut root::btQuantizedBvhFloatData>,
        pub m_colShapeData: root::btAlignedObjectArray<*mut root::btCollisionShapeData>,
        pub m_dynamicWorldInfoDataDouble:
            root::btAlignedObjectArray<*mut root::btDynamicsWorldDoubleData>,
        pub m_dynamicWorldInfoDataFloat:
            root::btAlignedObjectArray<*mut root::btDynamicsWorldFloatData>,
        pub m_rigidBodyDataDouble: root::btAlignedObjectArray<*mut root::btRigidBodyDoubleData>,
        pub m_rigidBodyDataFloat: root::btAlignedObjectArray<*mut root::btRigidBodyFloatData>,
        pub m_collisionObjectDataDouble:
            root::btAlignedObjectArray<*mut root::btCollisionObjectDoubleData>,
        pub m_collisionObjectDataFloat:
            root::btAlignedObjectArray<*mut root::btCollisionObjectFloatData>,
        pub m_constraintDataFloat:
            root::btAlignedObjectArray<*mut root::btTypedConstraintFloatData>,
        pub m_constraintDataDouble:
            root::btAlignedObjectArray<*mut root::btTypedConstraintDoubleData>,
        pub m_constraintData: root::btAlignedObjectArray<*mut root::btTypedConstraintData>,
        pub m_softBodyFloatData: root::btAlignedObjectArray<*mut root::btSoftBodyFloatData>,
        pub m_softBodyDoubleData: root::btAlignedObjectArray<*mut root::btSoftBodyDoubleData>,
    }
    /// The btDefaultSerializer is the main Bullet serialization class.
    /// The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
    #[repr(C)]
    pub struct btDefaultSerializer {
        pub _base: root::btSerializer,
        pub mTypes: root::btAlignedObjectArray<*mut ::std::os::raw::c_char>,
        pub mStructs: root::btAlignedObjectArray<*mut ::std::os::raw::c_short>,
        pub mTlens: root::btAlignedObjectArray<::std::os::raw::c_short>,
        pub mStructReverse: root::btHashMap<root::btHashInt, ::std::os::raw::c_int>,
        pub mTypeLookup: root::btHashMap<root::btHashString, ::std::os::raw::c_int>,
        pub m_chunkP: root::btHashMap<root::btHashPtr, *mut ::std::os::raw::c_void>,
        pub m_nameMap: root::btHashMap<root::btHashPtr, *const ::std::os::raw::c_char>,
        pub m_uniquePointers: root::btHashMap<root::btHashPtr, root::btPointerUid>,
        pub m_uniqueIdGenerator: ::std::os::raw::c_int,
        pub m_totalSize: ::std::os::raw::c_int,
        pub m_buffer: *mut ::std::os::raw::c_uchar,
        pub m_ownsBuffer: bool,
        pub m_currentSize: ::std::os::raw::c_int,
        pub m_dna: *mut ::std::os::raw::c_void,
        pub m_dnaLength: ::std::os::raw::c_int,
        pub m_serializationFlags: ::std::os::raw::c_int,
        pub m_chunkPtrs: root::btAlignedObjectArray<*mut root::btChunk>,
        pub m_skipPointers: root::btHashMap<root::btHashPtr, *mut ::std::os::raw::c_void>,
    }
    /// The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
    /// it can be generated using
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTriangleInfo {
        pub m_flags: ::std::os::raw::c_int,
        pub m_edgeV0V1Angle: root::btScalar,
        pub m_edgeV1V2Angle: root::btScalar,
        pub m_edgeV2V0Angle: root::btScalar,
    }
    pub type btInternalTriangleInfoMap = root::btHashMap<root::btHashInt, root::btTriangleInfo>;
    #[repr(C)]
    pub struct btTriangleInfoMap__bindgen_vtable(::std::os::raw::c_void);
    /// The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btTriangleInfoMap {
        pub vtable_: *const btTriangleInfoMap__bindgen_vtable,
        pub _base: root::btInternalTriangleInfoMap,
        pub m_convexEpsilon: root::btScalar,
        /// used to determine if an edge or contact normal is convex, using the dot product
        pub m_planarEpsilon: root::btScalar,
        /// used to determine if a triangle edge is planar with zero angle
        pub m_equalVertexThreshold: root::btScalar,
        /// used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared'
        pub m_edgeDistanceThreshold: root::btScalar,
        /// used to determine edge contacts: if the closest distance between a contact point and an edge is smaller than this distance threshold it is considered to "hit the edge"
        pub m_maxEdgeAngleThreshold: root::btScalar,
        pub m_zeroAreaThreshold: root::btScalar,
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZN17btTriangleInfoMap11deSerializeER21btTriangleInfoMapData"]
        pub fn btTriangleInfoMap_deSerialize(
            this: *mut root::btTriangleInfoMap,
            data: *mut root::btTriangleInfoMapData,
        );
    }
    impl btTriangleInfoMap {
        #[inline]
        pub unsafe fn deSerialize(&mut self, data: *mut root::btTriangleInfoMapData) {
            btTriangleInfoMap_deSerialize(self, data)
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btTriangleInfoMap28calculateSerializeBufferSizeEv"]
        pub fn btTriangleInfoMap_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK17btTriangleInfoMap9serializeEPvP12btSerializer"]
        pub fn btTriangleInfoMap_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// those fields have to be float and not btScalar for the serialization to work properly
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTriangleInfoData {
        pub m_flags: ::std::os::raw::c_int,
        pub m_edgeV0V1Angle: f32,
        pub m_edgeV1V2Angle: f32,
        pub m_edgeV2V0Angle: f32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTriangleInfoMapData {
        pub m_hashTablePtr: *mut ::std::os::raw::c_int,
        pub m_nextPtr: *mut ::std::os::raw::c_int,
        pub m_valueArrayPtr: *mut root::btTriangleInfoData,
        pub m_keyArrayPtr: *mut ::std::os::raw::c_int,
        pub m_convexEpsilon: f32,
        pub m_planarEpsilon: f32,
        pub m_equalVertexThreshold: f32,
        pub m_edgeDistanceThreshold: f32,
        pub m_zeroAreaThreshold: f32,
        pub m_nextSize: ::std::os::raw::c_int,
        pub m_hashTableSize: ::std::os::raw::c_int,
        pub m_numValues: ::std::os::raw::c_int,
        pub m_numKeys: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
    /// If you required moving concave triangle meshes, it is recommended to perform convex decomposition
    /// using HACD, see Bullet/Demos/ConvexDecompositionDemo.
    /// Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
    /// btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
    /// cache friendly traversal for PlayStation 3 Cell SPU.
    /// It is recommended to enable useQuantizedAabbCompression for better memory usage.
    /// It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
    /// Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
    /// See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBvhTriangleMeshShape {
        pub _base: root::btTriangleMeshShape,
        pub m_bvh: *mut root::btOptimizedBvh,
        pub m_triangleInfoMap: *mut root::btTriangleInfoMap,
        pub m_useQuantizedAabbCompression: bool,
        pub m_ownsBvh: bool,
        pub m_pad: [bool; 11usize],
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape14performRaycastEP18btTriangleCallbackRK9btVector3S4_"]
        pub fn btBvhTriangleMeshShape_performRaycast(
            this: *mut root::btBvhTriangleMeshShape,
            callback: *mut root::btTriangleCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape17performConvexcastEP18btTriangleCallbackRK9btVector3S4_S4_S4_"]
        pub fn btBvhTriangleMeshShape_performConvexcast(
            this: *mut root::btBvhTriangleMeshShape,
            callback: *mut root::btTriangleCallback,
            boxSource: *const root::btVector3,
            boxTarget: *const root::btVector3,
            boxMin: *const root::btVector3,
            boxMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape9refitTreeERK9btVector3S2_"]
        pub fn btBvhTriangleMeshShape_refitTree(
            this: *mut root::btBvhTriangleMeshShape,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        /// for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape16partialRefitTreeERK9btVector3S2_"]
        pub fn btBvhTriangleMeshShape_partialRefitTree(
            this: *mut root::btBvhTriangleMeshShape,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape15setOptimizedBvhEP14btOptimizedBvhRK9btVector3"]
        pub fn btBvhTriangleMeshShape_setOptimizedBvh(
            this: *mut root::btBvhTriangleMeshShape,
            bvh: *mut root::btOptimizedBvh,
            localScaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape17buildOptimizedBvhEv"]
        pub fn btBvhTriangleMeshShape_buildOptimizedBvh(this: *mut root::btBvhTriangleMeshShape);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb"]
        pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape(
            this: *mut root::btBvhTriangleMeshShape,
            meshInterface: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            buildBvh: bool,
        );
    }
    extern "C" {
        /// optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebRK9btVector3S4_b"]
        pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
            this: *mut root::btBvhTriangleMeshShape,
            meshInterface: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
            buildBvh: bool,
        );
    }
    impl btBvhTriangleMeshShape {
        #[inline]
        pub unsafe fn performRaycast(
            &mut self,
            callback: *mut root::btTriangleCallback,
            raySource: *const root::btVector3,
            rayTarget: *const root::btVector3,
        ) {
            btBvhTriangleMeshShape_performRaycast(self, callback, raySource, rayTarget)
        }
        #[inline]
        pub unsafe fn performConvexcast(
            &mut self,
            callback: *mut root::btTriangleCallback,
            boxSource: *const root::btVector3,
            boxTarget: *const root::btVector3,
            boxMin: *const root::btVector3,
            boxMax: *const root::btVector3,
        ) {
            btBvhTriangleMeshShape_performConvexcast(
                self, callback, boxSource, boxTarget, boxMin, boxMax,
            )
        }
        #[inline]
        pub unsafe fn refitTree(
            &mut self,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btBvhTriangleMeshShape_refitTree(self, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn partialRefitTree(
            &mut self,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        ) {
            btBvhTriangleMeshShape_partialRefitTree(self, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn setOptimizedBvh(
            &mut self,
            bvh: *mut root::btOptimizedBvh,
            localScaling: *const root::btVector3,
        ) {
            btBvhTriangleMeshShape_setOptimizedBvh(self, bvh, localScaling)
        }
        #[inline]
        pub unsafe fn buildOptimizedBvh(&mut self) {
            btBvhTriangleMeshShape_buildOptimizedBvh(self)
        }
        #[inline]
        pub unsafe fn new(
            meshInterface: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            buildBvh: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBvhTriangleMeshShape_btBvhTriangleMeshShape(
                &mut __bindgen_tmp,
                meshInterface,
                useQuantizedAabbCompression,
                buildBvh,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            meshInterface: *mut root::btStridingMeshInterface,
            useQuantizedAabbCompression: bool,
            bvhAabbMin: *const root::btVector3,
            bvhAabbMax: *const root::btVector3,
            buildBvh: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
                &mut __bindgen_tmp,
                meshInterface,
                useQuantizedAabbCompression,
                bvhAabbMin,
                bvhAabbMax,
                buildBvh,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeD1Ev"]
        pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape_destructor(
            this: *mut root::btBvhTriangleMeshShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
        pub fn btBvhTriangleMeshShape_processAllTriangles(
            this: *mut ::std::os::raw::c_void,
            callback: *mut root::btTriangleCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape15setLocalScalingERK9btVector3"]
        pub fn btBvhTriangleMeshShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape28calculateSerializeBufferSizeEv"]
        pub fn btBvhTriangleMeshShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape9serializeEPvP12btSerializer"]
        pub fn btBvhTriangleMeshShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape18serializeSingleBvhEP12btSerializer"]
        pub fn btBvhTriangleMeshShape_serializeSingleBvh(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape30serializeSingleTriangleInfoMapEP12btSerializer"]
        pub fn btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTriangleMeshShapeData {
        pub m_collisionShapeData: root::btCollisionShapeData,
        pub m_meshInterface: root::btStridingMeshInterfaceData,
        pub m_quantizedFloatBvh: *mut root::btQuantizedBvhFloatData,
        pub m_quantizedDoubleBvh: *mut root::btQuantizedBvhDoubleData,
        pub m_triangleInfoMap: *mut root::btTriangleInfoMapData,
        pub m_collisionMargin: f32,
        pub m_pad3: [::std::os::raw::c_char; 4usize],
    }
    /// The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
    /// Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling'
    #[repr(C)]
    #[derive(Debug)]
    pub struct btScaledBvhTriangleMeshShape {
        pub _base: root::btConcaveShape,
        pub m_localScaling: root::btVector3,
        pub m_bvhTriMeshShape: *mut root::btBvhTriangleMeshShape,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShapeC1EP22btBvhTriangleMeshShapeRK9btVector3"]
        pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
            this: *mut root::btScaledBvhTriangleMeshShape,
            childShape: *mut root::btBvhTriangleMeshShape,
            localScaling: *const root::btVector3,
        );
    }
    impl btScaledBvhTriangleMeshShape {
        #[inline]
        pub unsafe fn new(
            childShape: *mut root::btBvhTriangleMeshShape,
            localScaling: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
                &mut __bindgen_tmp,
                childShape,
                localScaling,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShapeD1Ev"]
        pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape_destructor(
            this: *mut root::btScaledBvhTriangleMeshShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btScaledBvhTriangleMeshShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShape15setLocalScalingERK9btVector3"]
        pub fn btScaledBvhTriangleMeshShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape15getLocalScalingEv"]
        pub fn btScaledBvhTriangleMeshShape_getLocalScaling(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btScaledBvhTriangleMeshShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
        pub fn btScaledBvhTriangleMeshShape_processAllTriangles(
            this: *mut ::std::os::raw::c_void,
            callback: *mut root::btTriangleCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape28calculateSerializeBufferSizeEv"]
        pub fn btScaledBvhTriangleMeshShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape9serializeEPvP12btSerializer"]
        pub fn btScaledBvhTriangleMeshShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btScaledTriangleMeshShapeData {
        pub m_trimeshShapeData: root::btTriangleMeshShapeData,
        pub m_localScaling: root::btVector3FloatData,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCompoundShapeChild {
        pub m_transform: root::btTransform,
        pub m_childShape: *mut root::btCollisionShape,
        pub m_childShapeType: ::std::os::raw::c_int,
        pub m_childMargin: root::btScalar,
        pub m_node: *mut root::btDbvtNode,
    }
    /// The btCompoundShape allows to store multiple other btCollisionShapes
    /// This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
    /// It has an (optional) dynamic aabb tree to accelerate early rejection tests.
    /// @todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
    /// Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape)
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCompoundShape {
        pub _base: root::btCollisionShape,
        pub m_children: root::btAlignedObjectArray<root::btCompoundShapeChild>,
        pub m_localAabbMin: root::btVector3,
        pub m_localAabbMax: root::btVector3,
        pub m_dynamicAabbTree: *mut root::btDbvt,
        /// increment m_updateRevision when adding/removing/replacing child shapes, so that some caches can be updated
        pub m_updateRevision: ::std::os::raw::c_int,
        pub m_collisionMargin: root::btScalar,
        pub m_localScaling: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape"]
        pub fn btCompoundShape_addChildShape(
            this: *mut root::btCompoundShape,
            localTransform: *const root::btTransform,
            shape: *mut root::btCollisionShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShape23removeChildShapeByIndexEi"]
        pub fn btCompoundShape_removeChildShapeByIndex(
            this: *mut root::btCompoundShape,
            childShapeindex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// set a new transform for a child, and update internal data structures (local aabb and dynamic tree)
        #[link_name = "\u{1}_ZN15btCompoundShape20updateChildTransformEiRK11btTransformb"]
        pub fn btCompoundShape_updateChildTransform(
            this: *mut root::btCompoundShape,
            childIndex: ::std::os::raw::c_int,
            newChildTransform: *const root::btTransform,
            shouldRecalculateLocalAabb: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShape26createAabbTreeFromChildrenEv"]
        pub fn btCompoundShape_createAabbTreeFromChildren(this: *mut root::btCompoundShape);
    }
    extern "C" {
        /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
        /// ///and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
        /// ///"principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
        /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
        /// ///of the collision object by the principal transform.
        #[link_name = "\u{1}_ZNK15btCompoundShape31calculatePrincipalAxisTransformEPKfR11btTransformR9btVector3"]
        pub fn btCompoundShape_calculatePrincipalAxisTransform(
            this: *const root::btCompoundShape,
            masses: *const root::btScalar,
            principal: *mut root::btTransform,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShapeC1Ebi"]
        pub fn btCompoundShape_btCompoundShape(
            this: *mut root::btCompoundShape,
            enableDynamicAabbTree: bool,
            initialChildCapacity: ::std::os::raw::c_int,
        );
    }
    impl btCompoundShape {
        #[inline]
        pub unsafe fn addChildShape(
            &mut self,
            localTransform: *const root::btTransform,
            shape: *mut root::btCollisionShape,
        ) {
            btCompoundShape_addChildShape(self, localTransform, shape)
        }
        #[inline]
        pub unsafe fn removeChildShapeByIndex(&mut self, childShapeindex: ::std::os::raw::c_int) {
            btCompoundShape_removeChildShapeByIndex(self, childShapeindex)
        }
        #[inline]
        pub unsafe fn updateChildTransform(
            &mut self,
            childIndex: ::std::os::raw::c_int,
            newChildTransform: *const root::btTransform,
            shouldRecalculateLocalAabb: bool,
        ) {
            btCompoundShape_updateChildTransform(
                self,
                childIndex,
                newChildTransform,
                shouldRecalculateLocalAabb,
            )
        }
        #[inline]
        pub unsafe fn createAabbTreeFromChildren(&mut self) {
            btCompoundShape_createAabbTreeFromChildren(self)
        }
        #[inline]
        pub unsafe fn calculatePrincipalAxisTransform(
            &self,
            masses: *const root::btScalar,
            principal: *mut root::btTransform,
            inertia: *mut root::btVector3,
        ) {
            btCompoundShape_calculatePrincipalAxisTransform(self, masses, principal, inertia)
        }
        #[inline]
        pub unsafe fn new(
            enableDynamicAabbTree: bool,
            initialChildCapacity: ::std::os::raw::c_int,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCompoundShape_btCompoundShape(
                &mut __bindgen_tmp,
                enableDynamicAabbTree,
                initialChildCapacity,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShapeD1Ev"]
        pub fn btCompoundShape_btCompoundShape_destructor(this: *mut root::btCompoundShape);
    }
    extern "C" {
        /// Remove all children shapes that contain the specified shape
        #[link_name = "\u{1}_ZN15btCompoundShape16removeChildShapeEP16btCollisionShape"]
        pub fn btCompoundShape_removeChildShape(
            this: *mut ::std::os::raw::c_void,
            shape: *mut root::btCollisionShape,
        );
    }
    extern "C" {
        /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
        #[link_name = "\u{1}_ZNK15btCompoundShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btCompoundShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        /// Re-calculate the local Aabb. Is called at the end of removeChildShapes.
        /// Use this yourself if you modify the children or their transforms.
        #[link_name = "\u{1}_ZN15btCompoundShape20recalculateLocalAabbEv"]
        pub fn btCompoundShape_recalculateLocalAabb(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN15btCompoundShape15setLocalScalingERK9btVector3"]
        pub fn btCompoundShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCompoundShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btCompoundShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK15btCompoundShape28calculateSerializeBufferSizeEv"]
        pub fn btCompoundShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK15btCompoundShape9serializeEPvP12btSerializer"]
        pub fn btCompoundShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCompoundShapeChildData {
        pub m_transform: root::btTransformFloatData,
        pub m_childShape: *mut root::btCollisionShapeData,
        pub m_childShapeType: ::std::os::raw::c_int,
        pub m_childMargin: f32,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCompoundShapeData {
        pub m_collisionShapeData: root::btCollisionShapeData,
        pub m_childShapePtr: *mut root::btCompoundShapeChildData,
        pub m_numChildShapes: ::std::os::raw::c_int,
        pub m_collisionMargin: f32,
    }
    /// The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btBU_Simplex1to4 {
        pub _base: root::btPolyhedralConvexAabbCachingShape,
        pub m_numVertices: ::std::os::raw::c_int,
        pub m_vertices: [root::btVector3; 4usize],
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to49addVertexERK9btVector3"]
        pub fn btBU_Simplex1to4_addVertex(
            this: *mut root::btBU_Simplex1to4,
            pt: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1Ev"]
        pub fn btBU_Simplex1to4_btBU_Simplex1to4(this: *mut root::btBU_Simplex1to4);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3"]
        pub fn btBU_Simplex1to4_btBU_Simplex1to41(
            this: *mut root::btBU_Simplex1to4,
            pt0: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_"]
        pub fn btBU_Simplex1to4_btBU_Simplex1to42(
            this: *mut root::btBU_Simplex1to4,
            pt0: *const root::btVector3,
            pt1: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_S2_"]
        pub fn btBU_Simplex1to4_btBU_Simplex1to43(
            this: *mut root::btBU_Simplex1to4,
            pt0: *const root::btVector3,
            pt1: *const root::btVector3,
            pt2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_S2_S2_"]
        pub fn btBU_Simplex1to4_btBU_Simplex1to44(
            this: *mut root::btBU_Simplex1to4,
            pt0: *const root::btVector3,
            pt1: *const root::btVector3,
            pt2: *const root::btVector3,
            pt3: *const root::btVector3,
        );
    }
    impl btBU_Simplex1to4 {
        #[inline]
        pub unsafe fn addVertex(&mut self, pt: *const root::btVector3) {
            btBU_Simplex1to4_addVertex(self, pt)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBU_Simplex1to4_btBU_Simplex1to4(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(pt0: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBU_Simplex1to4_btBU_Simplex1to41(&mut __bindgen_tmp, pt0);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(pt0: *const root::btVector3, pt1: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBU_Simplex1to4_btBU_Simplex1to42(&mut __bindgen_tmp, pt0, pt1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(
            pt0: *const root::btVector3,
            pt1: *const root::btVector3,
            pt2: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBU_Simplex1to4_btBU_Simplex1to43(&mut __bindgen_tmp, pt0, pt1, pt2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(
            pt0: *const root::btVector3,
            pt1: *const root::btVector3,
            pt2: *const root::btVector3,
            pt3: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btBU_Simplex1to4_btBU_Simplex1to44(&mut __bindgen_tmp, pt0, pt1, pt2, pt3);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to47getAabbERK11btTransformR9btVector3S4_"]
        pub fn btBU_Simplex1to4_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to414getNumVerticesEv"]
        pub fn btBU_Simplex1to4_getNumVertices(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to411getNumEdgesEv"]
        pub fn btBU_Simplex1to4_getNumEdges(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to47getEdgeEiR9btVector3S1_"]
        pub fn btBU_Simplex1to4_getEdge(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            pa: *mut root::btVector3,
            pb: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to49getVertexEiR9btVector3"]
        pub fn btBU_Simplex1to4_getVertex(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
            vtx: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to412getNumPlanesEv"]
        pub fn btBU_Simplex1to4_getNumPlanes(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to48getPlaneER9btVector3S1_i"]
        pub fn btBU_Simplex1to4_getPlane(
            this: *mut ::std::os::raw::c_void,
            planeNormal: *mut root::btVector3,
            planeSupport: *mut root::btVector3,
            i: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to48getIndexEi"]
        pub fn btBU_Simplex1to4_getIndex(
            this: *mut ::std::os::raw::c_void,
            i: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btBU_Simplex1to48isInsideERK9btVector3f"]
        pub fn btBU_Simplex1to4_isInside(
            this: *mut ::std::os::raw::c_void,
            pt: *const root::btVector3,
            tolerance: root::btScalar,
        ) -> bool;
    }
    /// The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
    /// It can be replaced by another shape during runtime, but the inertia tensor should be recomputed.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btEmptyShape {
        pub _base: root::btConcaveShape,
        pub m_localScaling: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btEmptyShapeC1Ev"]
        pub fn btEmptyShape_btEmptyShape(this: *mut root::btEmptyShape);
    }
    impl btEmptyShape {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btEmptyShape_btEmptyShape(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btEmptyShapeD1Ev"]
        pub fn btEmptyShape_btEmptyShape_destructor(this: *mut root::btEmptyShape);
    }
    extern "C" {
        /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
        #[link_name = "\u{1}_ZNK12btEmptyShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btEmptyShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK12btEmptyShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btEmptyShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    /// The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
    /// It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius
    #[repr(C)]
    #[derive(Debug)]
    pub struct btMultiSphereShape {
        pub _base: root::btConvexInternalAabbCachingShape,
        pub m_localPositionArray: root::btAlignedObjectArray<root::btVector3>,
        pub m_radiArray: root::btAlignedObjectArray<root::btScalar>,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btMultiSphereShapeC1EPK9btVector3PKfi"]
        pub fn btMultiSphereShape_btMultiSphereShape(
            this: *mut root::btMultiSphereShape,
            positions: *const root::btVector3,
            radi: *const root::btScalar,
            numSpheres: ::std::os::raw::c_int,
        );
    }
    impl btMultiSphereShape {
        #[inline]
        pub unsafe fn new(
            positions: *const root::btVector3,
            radi: *const root::btScalar,
            numSpheres: ::std::os::raw::c_int,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btMultiSphereShape_btMultiSphereShape(&mut __bindgen_tmp, positions, radi, numSpheres);
            __bindgen_tmp
        }
    }
    extern "C" {
        /// CollisionShape Interface
        #[link_name = "\u{1}_ZNK18btMultiSphereShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btMultiSphereShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        /// btConvexShape Interface
        #[link_name = "\u{1}_ZNK18btMultiSphereShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btMultiSphereShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btMultiSphereShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btMultiSphereShape28calculateSerializeBufferSizeEv"]
        pub fn btMultiSphereShape_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK18btMultiSphereShape9serializeEPvP12btSerializer"]
        pub fn btMultiSphereShape_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPositionAndRadius {
        pub m_pos: root::btVector3FloatData,
        pub m_radius: f32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btMultiSphereShapeData {
        pub m_convexInternalShapeData: root::btConvexInternalShapeData,
        pub m_localPositionArrayPtr: *mut root::btPositionAndRadius,
        pub m_localPositionArraySize: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
    /// Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btUniformScalingShape {
        pub _base: root::btConvexShape,
        pub m_childConvexShape: *mut root::btConvexShape,
        pub m_uniformScalingFactor: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniformScalingShapeC1EP13btConvexShapef"]
        pub fn btUniformScalingShape_btUniformScalingShape(
            this: *mut root::btUniformScalingShape,
            convexChildShape: *mut root::btConvexShape,
            uniformScalingFactor: root::btScalar,
        );
    }
    impl btUniformScalingShape {
        #[inline]
        pub unsafe fn new(
            convexChildShape: *mut root::btConvexShape,
            uniformScalingFactor: root::btScalar,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btUniformScalingShape_btUniformScalingShape(
                &mut __bindgen_tmp,
                convexChildShape,
                uniformScalingFactor,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniformScalingShapeD1Ev"]
        pub fn btUniformScalingShape_btUniformScalingShape_destructor(
            this: *mut root::btUniformScalingShape,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
        pub fn btUniformScalingShape_localGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape24localGetSupportingVertexERK9btVector3"]
        pub fn btUniformScalingShape_localGetSupportingVertex(
            this: *mut ::std::os::raw::c_void,
            vec: *const root::btVector3,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
        pub fn btUniformScalingShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
            this: *mut ::std::os::raw::c_void,
            vectors: *const root::btVector3,
            supportVerticesOut: *mut root::btVector3,
            numVectors: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape21calculateLocalInertiaEfR9btVector3"]
        pub fn btUniformScalingShape_calculateLocalInertia(
            this: *mut ::std::os::raw::c_void,
            mass: root::btScalar,
            inertia: *mut root::btVector3,
        );
    }
    extern "C" {
        /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
        #[link_name = "\u{1}_ZNK21btUniformScalingShape7getAabbERK11btTransformR9btVector3S4_"]
        pub fn btUniformScalingShape_getAabb(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape11getAabbSlowERK11btTransformR9btVector3S4_"]
        pub fn btUniformScalingShape_getAabbSlow(
            this: *mut ::std::os::raw::c_void,
            t: *const root::btTransform,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniformScalingShape15setLocalScalingERK9btVector3"]
        pub fn btUniformScalingShape_setLocalScaling(
            this: *mut ::std::os::raw::c_void,
            scaling: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape15getLocalScalingEv"]
        pub fn btUniformScalingShape_getLocalScaling(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniformScalingShape9setMarginEf"]
        pub fn btUniformScalingShape_setMargin(
            this: *mut ::std::os::raw::c_void,
            margin: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape9getMarginEv"]
        pub fn btUniformScalingShape_getMargin(this: *mut ::std::os::raw::c_void)
            -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape36getNumPreferredPenetrationDirectionsEv"]
        pub fn btUniformScalingShape_getNumPreferredPenetrationDirections(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btUniformScalingShape32getPreferredPenetrationDirectionEiR9btVector3"]
        pub fn btUniformScalingShape_getPreferredPenetrationDirection(
            this: *mut ::std::os::raw::c_void,
            index: ::std::os::raw::c_int,
            penetrationVector: *mut root::btVector3,
        );
    }
    pub type btManifoldArray = root::btAlignedObjectArray<*mut root::btPersistentManifold>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btCollisionAlgorithmConstructionInfo {
        pub m_dispatcher1: *mut root::btDispatcher,
        pub m_manifold: *mut root::btPersistentManifold,
    }
    #[repr(C)]
    pub struct btCollisionAlgorithm__bindgen_vtable(::std::os::raw::c_void);
    /// btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
    /// It is persistent over frames
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionAlgorithm {
        pub vtable_: *const btCollisionAlgorithm__bindgen_vtable,
        pub m_dispatcher: *mut root::btDispatcher,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN20btCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfo"]
        pub fn btCollisionAlgorithm_btCollisionAlgorithm(
            this: *mut root::btCollisionAlgorithm,
            ci: *const root::btCollisionAlgorithmConstructionInfo,
        );
    }
    impl btCollisionAlgorithm {
        #[inline]
        pub unsafe fn new(ci: *const root::btCollisionAlgorithmConstructionInfo) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btCollisionAlgorithm_btCollisionAlgorithm(&mut __bindgen_tmp, ci);
            __bindgen_tmp
        }
    }
    /// This class is not enabled yet (work-in-progress) to more aggressively activate objects.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btActivatingCollisionAlgorithm {
        pub _base: root::btCollisionAlgorithm,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfo"]
        pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(
            this: *mut root::btActivatingCollisionAlgorithm,
            ci: *const root::btCollisionAlgorithmConstructionInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS5_"]
        pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
            this: *mut root::btActivatingCollisionAlgorithm,
            ci: *const root::btCollisionAlgorithmConstructionInfo,
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
        );
    }
    impl btActivatingCollisionAlgorithm {
        #[inline]
        pub unsafe fn new(ci: *const root::btCollisionAlgorithmConstructionInfo) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(&mut __bindgen_tmp, ci);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            ci: *const root::btCollisionAlgorithmConstructionInfo,
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
                &mut __bindgen_tmp,
                ci,
                body0Wrap,
                body1Wrap,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmD1Ev"]
        pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm_destructor(
            this: *mut root::btActivatingCollisionAlgorithm,
        );
    }
    /// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
    /// Other features are frame-coherency (persistent data) and collision response.
    /// Also provides the most basic sample for custom/user btCollisionAlgorithm
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSphereSphereCollisionAlgorithm {
        pub _base: root::btActivatingCollisionAlgorithm,
        pub m_ownManifold: bool,
        pub m_manifoldPtr: *mut root::btPersistentManifold,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSphereSphereCollisionAlgorithm_CreateFunc {
        pub _base: root::btCollisionAlgorithmCreateFunc,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithmC1EP20btPersistentManifoldRK36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS7_"]
        pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
            this: *mut root::btSphereSphereCollisionAlgorithm,
            mf: *mut root::btPersistentManifold,
            ci: *const root::btCollisionAlgorithmConstructionInfo,
            col0Wrap: *const root::btCollisionObjectWrapper,
            col1Wrap: *const root::btCollisionObjectWrapper,
        );
    }
    impl btSphereSphereCollisionAlgorithm {
        #[inline]
        pub unsafe fn new(
            mf: *mut root::btPersistentManifold,
            ci: *const root::btCollisionAlgorithmConstructionInfo,
            col0Wrap: *const root::btCollisionObjectWrapper,
            col1Wrap: *const root::btCollisionObjectWrapper,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
                &mut __bindgen_tmp,
                mf,
                ci,
                col0Wrap,
                col1Wrap,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm16processCollisionEPK24btCollisionObjectWrapperS2_RK16btDispatcherInfoP16btManifoldResult"]
        pub fn btSphereSphereCollisionAlgorithm_processCollision(
            this: *mut ::std::os::raw::c_void,
            body0Wrap: *const root::btCollisionObjectWrapper,
            body1Wrap: *const root::btCollisionObjectWrapper,
            dispatchInfo: *const root::btDispatcherInfo,
            resultOut: *mut root::btManifoldResult,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm21calculateTimeOfImpactEP17btCollisionObjectS1_RK16btDispatcherInfoP16btManifoldResult"]
        pub fn btSphereSphereCollisionAlgorithm_calculateTimeOfImpact(
            this: *mut ::std::os::raw::c_void,
            body0: *mut root::btCollisionObject,
            body1: *mut root::btCollisionObject,
            dispatchInfo: *const root::btDispatcherInfo,
            resultOut: *mut root::btManifoldResult,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithmD1Ev"]
        pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm_destructor(
            this: *mut root::btSphereSphereCollisionAlgorithm,
        );
    }
    #[repr(C)]
    pub struct btCollisionConfiguration__bindgen_vtable(::std::os::raw::c_void);
    /// btCollisionConfiguration allows to configure Bullet collision detection
    /// stack allocator size, default collision algorithms and persistent manifold pool size
    /// @todo: describe the meaning
    #[repr(C)]
    #[derive(Debug)]
    pub struct btCollisionConfiguration {
        pub vtable_: *const btCollisionConfiguration__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVoronoiSimplexSolver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConvexPenetrationDepthSolver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDefaultCollisionConstructionInfo {
        pub m_persistentManifoldPool: *mut root::btPoolAllocator,
        pub m_collisionAlgorithmPool: *mut root::btPoolAllocator,
        pub m_defaultMaxPersistentManifoldPoolSize: ::std::os::raw::c_int,
        pub m_defaultMaxCollisionAlgorithmPoolSize: ::std::os::raw::c_int,
        pub m_customCollisionAlgorithmMaxElementSize: ::std::os::raw::c_int,
        pub m_useEpaPenetrationAlgorithm: ::std::os::raw::c_int,
    }
    /// btCollisionConfiguration allows to configure Bullet collision detection
    /// stack allocator, pool memory allocators
    /// @todo: describe the meaning
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDefaultCollisionConfiguration {
        pub _base: root::btCollisionConfiguration,
        pub m_persistentManifoldPoolSize: ::std::os::raw::c_int,
        pub m_persistentManifoldPool: *mut root::btPoolAllocator,
        pub m_ownsPersistentManifoldPool: bool,
        pub m_collisionAlgorithmPool: *mut root::btPoolAllocator,
        pub m_ownsCollisionAlgorithmPool: bool,
        pub m_pdSolver: *mut root::btConvexPenetrationDepthSolver,
        pub m_convexConvexCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_convexConcaveCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_swappedConvexConcaveCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_compoundCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_compoundCompoundCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_swappedCompoundCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_emptyCreateFunc: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_sphereSphereCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_sphereBoxCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_boxSphereCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_boxBoxCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_sphereTriangleCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_triangleSphereCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_planeConvexCF: *mut root::btCollisionAlgorithmCreateFunc,
        pub m_convexPlaneCF: *mut root::btCollisionAlgorithmCreateFunc,
    }
    extern "C" {
        /// Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
        /// ///By default, this feature is disabled for best performance.
        /// ///@param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
        /// ///@param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
        /// ///3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
        /// ///See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
        /// ///@todo we could add a per-object setting of those parameters, for level-of-detail collision detection.
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration35setConvexConvexMultipointIterationsEii"]
        pub fn btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
            this: *mut root::btDefaultCollisionConfiguration,
            numPerturbationIterations: ::std::os::raw::c_int,
            minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration34setPlaneConvexMultipointIterationsEii"]
        pub fn btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
            this: *mut root::btDefaultCollisionConfiguration,
            numPerturbationIterations: ::std::os::raw::c_int,
            minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo"]
        pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
            this: *mut root::btDefaultCollisionConfiguration,
            constructionInfo: *const root::btDefaultCollisionConstructionInfo,
        );
    }
    impl btDefaultCollisionConfiguration {
        #[inline]
        pub unsafe fn setConvexConvexMultipointIterations(
            &mut self,
            numPerturbationIterations: ::std::os::raw::c_int,
            minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
        ) {
            btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
                self,
                numPerturbationIterations,
                minimumPointsPerturbationThreshold,
            )
        }
        #[inline]
        pub unsafe fn setPlaneConvexMultipointIterations(
            &mut self,
            numPerturbationIterations: ::std::os::raw::c_int,
            minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
        ) {
            btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
                self,
                numPerturbationIterations,
                minimumPointsPerturbationThreshold,
            )
        }
        #[inline]
        pub unsafe fn new(
            constructionInfo: *const root::btDefaultCollisionConstructionInfo,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
                &mut __bindgen_tmp,
                constructionInfo,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfigurationD1Ev"]
        pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_destructor(
            this: *mut root::btDefaultCollisionConfiguration,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration31getCollisionAlgorithmCreateFuncEii"]
        pub fn btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc(
            this: *mut ::std::os::raw::c_void,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
        ) -> *mut root::btCollisionAlgorithmCreateFunc;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration35getClosestPointsAlgorithmCreateFuncEii"]
        pub fn btDefaultCollisionConfiguration_getClosestPointsAlgorithmCreateFunc(
            this: *mut ::std::os::raw::c_void,
            proxyType0: ::std::os::raw::c_int,
            proxyType1: ::std::os::raw::c_int,
        ) -> *mut root::btCollisionAlgorithmCreateFunc;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSimpleBroadphaseProxy {
        pub _base: root::btBroadphaseProxy,
        pub m_nextFree: ::std::os::raw::c_int,
    }
    /// The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
    /// It is a brute force aabb culling broadphase based on O(n^2) aabb checks
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSimpleBroadphase {
        pub _base: root::btBroadphaseInterface,
        pub m_numHandles: ::std::os::raw::c_int,
        pub m_maxHandles: ::std::os::raw::c_int,
        pub m_LastHandleIndex: ::std::os::raw::c_int,
        pub m_pHandles: *mut root::btSimpleBroadphaseProxy,
        pub m_pHandlesRawPtr: *mut ::std::os::raw::c_void,
        pub m_firstFreeHandle: ::std::os::raw::c_int,
        pub m_pairCache: *mut root::btOverlappingPairCache,
        pub m_ownsPairCache: bool,
        pub m_invalidPair: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase8validateEv"]
        pub fn btSimpleBroadphase_validate(this: *mut root::btSimpleBroadphase);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase11aabbOverlapEP23btSimpleBroadphaseProxyS1_"]
        pub fn btSimpleBroadphase_aabbOverlap(
            proxy0: *mut root::btSimpleBroadphaseProxy,
            proxy1: *mut root::btSimpleBroadphaseProxy,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase15testAabbOverlapEP17btBroadphaseProxyS1_"]
        pub fn btSimpleBroadphase_testAabbOverlap(
            this: *mut root::btSimpleBroadphase,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphaseC1EiP22btOverlappingPairCache"]
        pub fn btSimpleBroadphase_btSimpleBroadphase(
            this: *mut root::btSimpleBroadphase,
            maxProxies: ::std::os::raw::c_int,
            overlappingPairCache: *mut root::btOverlappingPairCache,
        );
    }
    impl btSimpleBroadphase {
        #[inline]
        pub unsafe fn validate(&mut self) {
            btSimpleBroadphase_validate(self)
        }
        #[inline]
        pub unsafe fn aabbOverlap(
            proxy0: *mut root::btSimpleBroadphaseProxy,
            proxy1: *mut root::btSimpleBroadphaseProxy,
        ) -> bool {
            btSimpleBroadphase_aabbOverlap(proxy0, proxy1)
        }
        #[inline]
        pub unsafe fn testAabbOverlap(
            &mut self,
            proxy0: *mut root::btBroadphaseProxy,
            proxy1: *mut root::btBroadphaseProxy,
        ) -> bool {
            btSimpleBroadphase_testAabbOverlap(self, proxy0, proxy1)
        }
        #[inline]
        pub unsafe fn new(
            maxProxies: ::std::os::raw::c_int,
            overlappingPairCache: *mut root::btOverlappingPairCache,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSimpleBroadphase_btSimpleBroadphase(
                &mut __bindgen_tmp,
                maxProxies,
                overlappingPairCache,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        /// reset broadphase internal structures, to ensure determinism/reproducability
        #[link_name = "\u{1}_ZN18btSimpleBroadphase9resetPoolEP12btDispatcher"]
        pub fn btSimpleBroadphase_resetPool(
            this: *mut ::std::os::raw::c_void,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphaseD1Ev"]
        pub fn btSimpleBroadphase_btSimpleBroadphase_destructor(
            this: *mut root::btSimpleBroadphase,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase11createProxyERK9btVector3S2_iPviiP12btDispatcher"]
        pub fn btSimpleBroadphase_createProxy(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            shapeType: ::std::os::raw::c_int,
            userPtr: *mut ::std::os::raw::c_void,
            collisionFilterGroup: ::std::os::raw::c_int,
            collisionFilterMask: ::std::os::raw::c_int,
            dispatcher: *mut root::btDispatcher,
        ) -> *mut root::btBroadphaseProxy;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase25calculateOverlappingPairsEP12btDispatcher"]
        pub fn btSimpleBroadphase_calculateOverlappingPairs(
            this: *mut ::std::os::raw::c_void,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase12destroyProxyEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btSimpleBroadphase_destroyProxy(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase7setAabbEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
        pub fn btSimpleBroadphase_setAabb(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btSimpleBroadphase7getAabbEP17btBroadphaseProxyR9btVector3S3_"]
        pub fn btSimpleBroadphase_getAabb(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase7rayTestERK9btVector3S2_R23btBroadphaseRayCallbackS2_S2_"]
        pub fn btSimpleBroadphase_rayTest(
            this: *mut ::std::os::raw::c_void,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            rayCallback: *mut root::btBroadphaseRayCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSimpleBroadphase8aabbTestERK9btVector3S2_R24btBroadphaseAabbCallback"]
        pub fn btSimpleBroadphase_aabbTest(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            callback: *mut root::btBroadphaseAabbCallback,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvtAabbMm {
        pub mi: root::btVector3,
        pub mx: root::btVector3,
    }
    pub type btDbvtVolume = root::btDbvtAabbMm;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btDbvtNode {
        pub volume: root::btDbvtVolume,
        pub parent: *mut root::btDbvtNode,
        pub __bindgen_anon_1: root::btDbvtNode__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btDbvtNode__bindgen_ty_1 {
        pub childs: [*mut root::btDbvtNode; 2usize],
        pub data: *mut ::std::os::raw::c_void,
        pub dataAsInt: ::std::os::raw::c_int,
        _bindgen_union_align: [u64; 2usize],
    }
    pub type btNodeStack = root::btAlignedObjectArray<*const root::btDbvtNode>;
    /// The btDbvt class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
    /// This btDbvt is used for soft body collision detection and for the btDbvtBroadphase. It has a fast insert, remove and update of nodes.
    /// Unlike the btQuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDbvt {
        pub m_root: *mut root::btDbvtNode,
        pub m_free: *mut root::btDbvtNode,
        pub m_lkhd: ::std::os::raw::c_int,
        pub m_leaves: ::std::os::raw::c_int,
        pub m_opath: ::std::os::raw::c_uint,
        pub m_stkStack: root::btAlignedObjectArray<root::btDbvt_sStkNN>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvt_sStkNN {
        pub a: *const root::btDbvtNode,
        pub b: *const root::btDbvtNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvt_sStkNP {
        pub node: *const root::btDbvtNode,
        pub mask: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvt_sStkNPS {
        pub node: *const root::btDbvtNode,
        pub mask: ::std::os::raw::c_int,
        pub value: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvt_sStkCLN {
        pub node: *const root::btDbvtNode,
        pub parent: *mut root::btDbvtNode,
    }
    #[repr(C)]
    pub struct btDbvt_ICollide__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDbvt_ICollide {
        pub vtable_: *const btDbvt_ICollide__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btDbvt_IWriter__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDbvt_IWriter {
        pub vtable_: *const btDbvt_IWriter__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btDbvt_IClone__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDbvt_IClone {
        pub vtable_: *const btDbvt_IClone__bindgen_vtable,
    }
    pub const btDbvt_SIMPLE_STACKSIZE: root::btDbvt__bindgen_ty_1 = 64;
    pub const btDbvt_DOUBLE_STACKSIZE: root::btDbvt__bindgen_ty_1 = 128;
    pub type btDbvt__bindgen_ty_1 = u32;
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt5clearEv"]
        pub fn btDbvt_clear(this: *mut root::btDbvt);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt16optimizeBottomUpEv"]
        pub fn btDbvt_optimizeBottomUp(this: *mut root::btDbvt);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt15optimizeTopDownEi"]
        pub fn btDbvt_optimizeTopDown(this: *mut root::btDbvt, bu_treshold: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt19optimizeIncrementalEi"]
        pub fn btDbvt_optimizeIncremental(this: *mut root::btDbvt, passes: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6insertERK12btDbvtAabbMmPv"]
        pub fn btDbvt_insert(
            this: *mut root::btDbvt,
            box_: *const root::btDbvtVolume,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut root::btDbvtNode;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodei"]
        pub fn btDbvt_update(
            this: *mut root::btDbvt,
            leaf: *mut root::btDbvtNode,
            lookahead: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMm"]
        pub fn btDbvt_update1(
            this: *mut root::btDbvt,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmRK9btVector3f"]
        pub fn btDbvt_update2(
            this: *mut root::btDbvt,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            velocity: *const root::btVector3,
            margin: root::btScalar,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmRK9btVector3"]
        pub fn btDbvt_update3(
            this: *mut root::btDbvt,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            velocity: *const root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmf"]
        pub fn btDbvt_update4(
            this: *mut root::btDbvt,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            margin: root::btScalar,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt6removeEP10btDbvtNode"]
        pub fn btDbvt_remove(this: *mut root::btDbvt, leaf: *mut root::btDbvtNode);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6btDbvt5writeEPNS_7IWriterE"]
        pub fn btDbvt_write(this: *const root::btDbvt, iwriter: *mut root::btDbvt_IWriter);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6btDbvt5cloneERS_PNS_6ICloneE"]
        pub fn btDbvt_clone(
            this: *const root::btDbvt,
            dest: *mut root::btDbvt,
            iclone: *mut root::btDbvt_IClone,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt8maxdepthEPK10btDbvtNode"]
        pub fn btDbvt_maxdepth(node: *const root::btDbvtNode) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt11countLeavesEPK10btDbvtNode"]
        pub fn btDbvt_countLeaves(node: *const root::btDbvtNode) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt13extractLeavesEPK10btDbvtNodeR20btAlignedObjectArrayIS2_E"]
        pub fn btDbvt_extractLeaves(
            node: *const root::btDbvtNode,
            leaves: *mut root::btAlignedObjectArray<*const root::btDbvtNode>,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt9enumNodesEPK10btDbvtNodeRNS_8ICollideE"]
        pub fn btDbvt_enumNodes(root: *const root::btDbvtNode, policy: *mut root::btDbvt_ICollide);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt10enumLeavesEPK10btDbvtNodeRNS_8ICollideE"]
        pub fn btDbvt_enumLeaves(root: *const root::btDbvtNode, policy: *mut root::btDbvt_ICollide);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt9collideTTEPK10btDbvtNodeS2_RNS_8ICollideE"]
        pub fn btDbvt_collideTT(
            this: *mut root::btDbvt,
            root0: *const root::btDbvtNode,
            root1: *const root::btDbvtNode,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt24collideTTpersistentStackEPK10btDbvtNodeS2_RNS_8ICollideE"]
        pub fn btDbvt_collideTTpersistentStack(
            this: *mut root::btDbvt,
            root0: *const root::btDbvtNode,
            root1: *const root::btDbvtNode,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6btDbvt9collideTVEPK10btDbvtNodeRK12btDbvtAabbMmRNS_8ICollideE"]
        pub fn btDbvt_collideTV(
            this: *const root::btDbvt,
            root: *const root::btDbvtNode,
            volume: *const root::btDbvtVolume,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK6btDbvt21collideTVNoStackAllocEPK10btDbvtNodeRK12btDbvtAabbMmR20btAlignedObjectArrayIS2_ERNS_8ICollideE"]
        pub fn btDbvt_collideTVNoStackAlloc(
            this: *const root::btDbvt,
            root: *const root::btDbvtNode,
            volume: *const root::btDbvtVolume,
            stack: *mut root::btNodeStack,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        /// rayTest is a re-entrant ray test, and can be called in parallel as long as the btAlignedAlloc is thread-safe (uses locking etc)
        /// ///rayTest is slower than rayTestInternal, because it builds a local stack, using memory allocations, and it recomputes signs/rayDirectionInverses each time
        #[link_name = "\u{1}_ZN6btDbvt7rayTestEPK10btDbvtNodeRK9btVector3S5_RNS_8ICollideE"]
        pub fn btDbvt_rayTest(
            root: *const root::btDbvtNode,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        /// rayTestInternal is faster than rayTest, because it uses a persistent stack (to reduce dynamic memory allocations to a minimum) and it uses precomputed signs/rayInverseDirections
        /// ///rayTestInternal is used by btDbvtBroadphase to accelerate world ray casts
        #[link_name = "\u{1}_ZNK6btDbvt15rayTestInternalEPK10btDbvtNodeRK9btVector3S5_S5_PjfS5_S5_R20btAlignedObjectArrayIS2_ERNS_8ICollideE"]
        pub fn btDbvt_rayTestInternal(
            this: *const root::btDbvt,
            root: *const root::btDbvtNode,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            rayDirectionInverse: *const root::btVector3,
            signs: *mut ::std::os::raw::c_uint,
            lambda_max: root::btScalar,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            stack: *mut root::btAlignedObjectArray<*const root::btDbvtNode>,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt11collideKDOPEPK10btDbvtNodePK9btVector3PKfiRNS_8ICollideE"]
        pub fn btDbvt_collideKDOP(
            root: *const root::btDbvtNode,
            normals: *const root::btVector3,
            offsets: *const root::btScalar,
            count: ::std::os::raw::c_int,
            policy: *mut root::btDbvt_ICollide,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt10collideOCLEPK10btDbvtNodePK9btVector3PKfRS4_iRNS_8ICollideEb"]
        pub fn btDbvt_collideOCL(
            root: *const root::btDbvtNode,
            normals: *const root::btVector3,
            offsets: *const root::btScalar,
            sortaxis: *const root::btVector3,
            count: ::std::os::raw::c_int,
            policy: *mut root::btDbvt_ICollide,
            fullsort: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvt9collideTUEPK10btDbvtNodeRNS_8ICollideE"]
        pub fn btDbvt_collideTU(root: *const root::btDbvtNode, policy: *mut root::btDbvt_ICollide);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvtC1Ev"]
        pub fn btDbvt_btDbvt(this: *mut root::btDbvt);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN6btDbvtD1Ev"]
        pub fn btDbvt_btDbvt_destructor(this: *mut root::btDbvt);
    }
    impl btDbvt {
        #[inline]
        pub unsafe fn clear(&mut self) {
            btDbvt_clear(self)
        }
        #[inline]
        pub unsafe fn optimizeBottomUp(&mut self) {
            btDbvt_optimizeBottomUp(self)
        }
        #[inline]
        pub unsafe fn optimizeTopDown(&mut self, bu_treshold: ::std::os::raw::c_int) {
            btDbvt_optimizeTopDown(self, bu_treshold)
        }
        #[inline]
        pub unsafe fn optimizeIncremental(&mut self, passes: ::std::os::raw::c_int) {
            btDbvt_optimizeIncremental(self, passes)
        }
        #[inline]
        pub unsafe fn insert(
            &mut self,
            box_: *const root::btDbvtVolume,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut root::btDbvtNode {
            btDbvt_insert(self, box_, data)
        }
        #[inline]
        pub unsafe fn update(
            &mut self,
            leaf: *mut root::btDbvtNode,
            lookahead: ::std::os::raw::c_int,
        ) {
            btDbvt_update(self, leaf, lookahead)
        }
        #[inline]
        pub unsafe fn update1(
            &mut self,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
        ) {
            btDbvt_update1(self, leaf, volume)
        }
        #[inline]
        pub unsafe fn update2(
            &mut self,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            velocity: *const root::btVector3,
            margin: root::btScalar,
        ) -> bool {
            btDbvt_update2(self, leaf, volume, velocity, margin)
        }
        #[inline]
        pub unsafe fn update3(
            &mut self,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            velocity: *const root::btVector3,
        ) -> bool {
            btDbvt_update3(self, leaf, volume, velocity)
        }
        #[inline]
        pub unsafe fn update4(
            &mut self,
            leaf: *mut root::btDbvtNode,
            volume: *mut root::btDbvtVolume,
            margin: root::btScalar,
        ) -> bool {
            btDbvt_update4(self, leaf, volume, margin)
        }
        #[inline]
        pub unsafe fn remove(&mut self, leaf: *mut root::btDbvtNode) {
            btDbvt_remove(self, leaf)
        }
        #[inline]
        pub unsafe fn write(&self, iwriter: *mut root::btDbvt_IWriter) {
            btDbvt_write(self, iwriter)
        }
        #[inline]
        pub unsafe fn clone(&self, dest: *mut root::btDbvt, iclone: *mut root::btDbvt_IClone) {
            btDbvt_clone(self, dest, iclone)
        }
        #[inline]
        pub unsafe fn maxdepth(node: *const root::btDbvtNode) -> ::std::os::raw::c_int {
            btDbvt_maxdepth(node)
        }
        #[inline]
        pub unsafe fn countLeaves(node: *const root::btDbvtNode) -> ::std::os::raw::c_int {
            btDbvt_countLeaves(node)
        }
        #[inline]
        pub unsafe fn extractLeaves(
            node: *const root::btDbvtNode,
            leaves: *mut root::btAlignedObjectArray<*const root::btDbvtNode>,
        ) {
            btDbvt_extractLeaves(node, leaves)
        }
        #[inline]
        pub unsafe fn enumNodes(root: *const root::btDbvtNode, policy: *mut root::btDbvt_ICollide) {
            btDbvt_enumNodes(root, policy)
        }
        #[inline]
        pub unsafe fn enumLeaves(
            root: *const root::btDbvtNode,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_enumLeaves(root, policy)
        }
        #[inline]
        pub unsafe fn collideTT(
            &mut self,
            root0: *const root::btDbvtNode,
            root1: *const root::btDbvtNode,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_collideTT(self, root0, root1, policy)
        }
        #[inline]
        pub unsafe fn collideTTpersistentStack(
            &mut self,
            root0: *const root::btDbvtNode,
            root1: *const root::btDbvtNode,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_collideTTpersistentStack(self, root0, root1, policy)
        }
        #[inline]
        pub unsafe fn collideTV(
            &self,
            root: *const root::btDbvtNode,
            volume: *const root::btDbvtVolume,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_collideTV(self, root, volume, policy)
        }
        #[inline]
        pub unsafe fn collideTVNoStackAlloc(
            &self,
            root: *const root::btDbvtNode,
            volume: *const root::btDbvtVolume,
            stack: *mut root::btNodeStack,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_collideTVNoStackAlloc(self, root, volume, stack, policy)
        }
        #[inline]
        pub unsafe fn rayTest(
            root: *const root::btDbvtNode,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_rayTest(root, rayFrom, rayTo, policy)
        }
        #[inline]
        pub unsafe fn rayTestInternal(
            &self,
            root: *const root::btDbvtNode,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            rayDirectionInverse: *const root::btVector3,
            signs: *mut ::std::os::raw::c_uint,
            lambda_max: root::btScalar,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            stack: *mut root::btAlignedObjectArray<*const root::btDbvtNode>,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_rayTestInternal(
                self,
                root,
                rayFrom,
                rayTo,
                rayDirectionInverse,
                signs,
                lambda_max,
                aabbMin,
                aabbMax,
                stack,
                policy,
            )
        }
        #[inline]
        pub unsafe fn collideKDOP(
            root: *const root::btDbvtNode,
            normals: *const root::btVector3,
            offsets: *const root::btScalar,
            count: ::std::os::raw::c_int,
            policy: *mut root::btDbvt_ICollide,
        ) {
            btDbvt_collideKDOP(root, normals, offsets, count, policy)
        }
        #[inline]
        pub unsafe fn collideOCL(
            root: *const root::btDbvtNode,
            normals: *const root::btVector3,
            offsets: *const root::btScalar,
            sortaxis: *const root::btVector3,
            count: ::std::os::raw::c_int,
            policy: *mut root::btDbvt_ICollide,
            fullsort: bool,
        ) {
            btDbvt_collideOCL(root, normals, offsets, sortaxis, count, policy, fullsort)
        }
        #[inline]
        pub unsafe fn collideTU(root: *const root::btDbvtNode, policy: *mut root::btDbvt_ICollide) {
            btDbvt_collideTU(root, policy)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btDbvt_btDbvt(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            btDbvt_btDbvt_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDbvtProxy {
        pub _base: root::btBroadphaseProxy,
        pub leaf: *mut root::btDbvtNode,
        pub links: [*mut root::btDbvtProxy; 2usize],
        pub stage: ::std::os::raw::c_int,
    }
    pub type btDbvtProxyArray = root::btAlignedObjectArray<*mut root::btDbvtProxy>;
    /// The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
    /// One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
    /// This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDbvtBroadphase {
        pub _base: root::btBroadphaseInterface,
        pub m_sets: [root::btDbvt; 2usize],
        pub m_stageRoots: [*mut root::btDbvtProxy; 3usize],
        pub m_paircache: *mut root::btOverlappingPairCache,
        pub m_prediction: root::btScalar,
        pub m_stageCurrent: ::std::os::raw::c_int,
        pub m_fupdates: ::std::os::raw::c_int,
        pub m_dupdates: ::std::os::raw::c_int,
        pub m_cupdates: ::std::os::raw::c_int,
        pub m_newpairs: ::std::os::raw::c_int,
        pub m_fixedleft: ::std::os::raw::c_int,
        pub m_updates_call: ::std::os::raw::c_uint,
        pub m_updates_done: ::std::os::raw::c_uint,
        pub m_updates_ratio: root::btScalar,
        pub m_pid: ::std::os::raw::c_int,
        pub m_cid: ::std::os::raw::c_int,
        pub m_gid: ::std::os::raw::c_int,
        pub m_releasepaircache: bool,
        pub m_deferedcollide: bool,
        pub m_needcleanup: bool,
        pub m_rayTestStacks:
            root::btAlignedObjectArray<root::btAlignedObjectArray<*const root::btDbvtNode>>,
    }
    pub const btDbvtBroadphase_DYNAMIC_SET: root::btDbvtBroadphase__bindgen_ty_1 = 0;
    pub const btDbvtBroadphase_FIXED_SET: root::btDbvtBroadphase__bindgen_ty_1 = 1;
    pub const btDbvtBroadphase_STAGECOUNT: root::btDbvtBroadphase__bindgen_ty_1 = 2;
    pub type btDbvtBroadphase__bindgen_ty_1 = u32;
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase7collideEP12btDispatcher"]
        pub fn btDbvtBroadphase_collide(
            this: *mut root::btDbvtBroadphase,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase8optimizeEv"]
        pub fn btDbvtBroadphase_optimize(this: *mut root::btDbvtBroadphase);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase22performDeferredRemovalEP12btDispatcher"]
        pub fn btDbvtBroadphase_performDeferredRemoval(
            this: *mut root::btDbvtBroadphase,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        /// this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
        /// ///it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
        /// ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
        /// ///http://code.google.com/p/bullet/issues/detail?id=223
        #[link_name = "\u{1}_ZN16btDbvtBroadphase18setAabbForceUpdateEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
        pub fn btDbvtBroadphase_setAabbForceUpdate(
            this: *mut root::btDbvtBroadphase,
            absproxy: *mut root::btBroadphaseProxy,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            arg1: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase9benchmarkEP21btBroadphaseInterface"]
        pub fn btDbvtBroadphase_benchmark(arg1: *mut root::btBroadphaseInterface);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache"]
        pub fn btDbvtBroadphase_btDbvtBroadphase(
            this: *mut root::btDbvtBroadphase,
            paircache: *mut root::btOverlappingPairCache,
        );
    }
    impl btDbvtBroadphase {
        #[inline]
        pub unsafe fn collide(&mut self, dispatcher: *mut root::btDispatcher) {
            btDbvtBroadphase_collide(self, dispatcher)
        }
        #[inline]
        pub unsafe fn optimize(&mut self) {
            btDbvtBroadphase_optimize(self)
        }
        #[inline]
        pub unsafe fn performDeferredRemoval(&mut self, dispatcher: *mut root::btDispatcher) {
            btDbvtBroadphase_performDeferredRemoval(self, dispatcher)
        }
        #[inline]
        pub unsafe fn setAabbForceUpdate(
            &mut self,
            absproxy: *mut root::btBroadphaseProxy,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            arg1: *mut root::btDispatcher,
        ) {
            btDbvtBroadphase_setAabbForceUpdate(self, absproxy, aabbMin, aabbMax, arg1)
        }
        #[inline]
        pub unsafe fn benchmark(arg1: *mut root::btBroadphaseInterface) {
            btDbvtBroadphase_benchmark(arg1)
        }
        #[inline]
        pub unsafe fn new(paircache: *mut root::btOverlappingPairCache) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btDbvtBroadphase_btDbvtBroadphase(&mut __bindgen_tmp, paircache);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphaseD1Ev"]
        pub fn btDbvtBroadphase_btDbvtBroadphase_destructor(this: *mut root::btDbvtBroadphase);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase11createProxyERK9btVector3S2_iPviiP12btDispatcher"]
        pub fn btDbvtBroadphase_createProxy(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            shapeType: ::std::os::raw::c_int,
            userPtr: *mut ::std::os::raw::c_void,
            collisionFilterGroup: ::std::os::raw::c_int,
            collisionFilterMask: ::std::os::raw::c_int,
            dispatcher: *mut root::btDispatcher,
        ) -> *mut root::btBroadphaseProxy;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase12destroyProxyEP17btBroadphaseProxyP12btDispatcher"]
        pub fn btDbvtBroadphase_destroyProxy(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase7setAabbEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
        pub fn btDbvtBroadphase_setAabb(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase7rayTestERK9btVector3S2_R23btBroadphaseRayCallbackS2_S2_"]
        pub fn btDbvtBroadphase_rayTest(
            this: *mut ::std::os::raw::c_void,
            rayFrom: *const root::btVector3,
            rayTo: *const root::btVector3,
            rayCallback: *mut root::btBroadphaseRayCallback,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase8aabbTestERK9btVector3S2_R24btBroadphaseAabbCallback"]
        pub fn btDbvtBroadphase_aabbTest(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *const root::btVector3,
            aabbMax: *const root::btVector3,
            callback: *mut root::btBroadphaseAabbCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btDbvtBroadphase7getAabbEP17btBroadphaseProxyR9btVector3S3_"]
        pub fn btDbvtBroadphase_getAabb(
            this: *mut ::std::os::raw::c_void,
            proxy: *mut root::btBroadphaseProxy,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase25calculateOverlappingPairsEP12btDispatcher"]
        pub fn btDbvtBroadphase_calculateOverlappingPairs(
            this: *mut ::std::os::raw::c_void,
            dispatcher: *mut root::btDispatcher,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase23getOverlappingPairCacheEv"]
        pub fn btDbvtBroadphase_getOverlappingPairCache(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::btOverlappingPairCache;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btDbvtBroadphase23getOverlappingPairCacheEv"]
        pub fn btDbvtBroadphase_getOverlappingPairCache1(
            this: *mut ::std::os::raw::c_void,
        ) -> *const root::btOverlappingPairCache;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btDbvtBroadphase17getBroadphaseAabbER9btVector3S1_"]
        pub fn btDbvtBroadphase_getBroadphaseAabb(
            this: *mut ::std::os::raw::c_void,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btDbvtBroadphase10printStatsEv"]
        pub fn btDbvtBroadphase_printStats(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        /// reset broadphase internal structures, to ensure determinism/reproducability
        #[link_name = "\u{1}_ZN16btDbvtBroadphase9resetPoolEP12btDispatcher"]
        pub fn btDbvtBroadphase_resetPool(
            this: *mut ::std::os::raw::c_void,
            dispatcher: *mut root::btDispatcher,
        );
    }
    /// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
    /// It uses quantized integers to represent the begin and end points for each of the 3 axis.
    /// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btAxisSweep3Internal<BP_FP_INT_TYPE> {
        pub _base: root::btBroadphaseInterface,
        pub m_bpHandleMask: BP_FP_INT_TYPE,
        pub m_handleSentinel: BP_FP_INT_TYPE,
        pub m_worldAabbMin: root::btVector3,
        pub m_worldAabbMax: root::btVector3,
        pub m_quantize: root::btVector3,
        pub m_numHandles: BP_FP_INT_TYPE,
        pub m_maxHandles: BP_FP_INT_TYPE,
        pub m_pHandles: *mut root::btAxisSweep3Internal_Handle<BP_FP_INT_TYPE>,
        pub m_firstFreeHandle: BP_FP_INT_TYPE,
        pub m_pEdges: [*mut root::btAxisSweep3Internal_Edge<BP_FP_INT_TYPE>; 3usize],
        pub m_pEdgesRawPtr: [*mut ::std::os::raw::c_void; 3usize],
        pub m_pairCache: *mut root::btOverlappingPairCache,
        /// btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
        pub m_userPairCallback: *mut root::btOverlappingPairCallback,
        pub m_ownsPairCache: bool,
        pub m_invalidPair: ::std::os::raw::c_int,
        /// additional dynamic aabb structure, used to accelerate ray cast queries.
        /// ///can be disabled using a optional argument in the constructor
        pub m_raycastAccelerator: *mut root::btDbvtBroadphase,
        pub m_nullPairCache: *mut root::btOverlappingPairCache,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btAxisSweep3Internal_Edge<BP_FP_INT_TYPE> {
        pub m_pos: BP_FP_INT_TYPE,
        pub m_handle: BP_FP_INT_TYPE,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btAxisSweep3Internal_Handle<BP_FP_INT_TYPE> {
        pub _base: root::btBroadphaseProxy,
        pub m_minEdges: [BP_FP_INT_TYPE; 3usize],
        pub m_maxEdges: [BP_FP_INT_TYPE; 3usize],
        pub m_dbvtProxy: *mut root::btBroadphaseProxy,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
    }
    /// The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
    /// It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
    /// For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btAxisSweep3 {
        pub _base: root::btAxisSweep3Internal<::std::os::raw::c_ushort>,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb"]
        pub fn btAxisSweep3_btAxisSweep3(
            this: *mut root::btAxisSweep3,
            worldAabbMin: *const root::btVector3,
            worldAabbMax: *const root::btVector3,
            maxHandles: ::std::os::raw::c_ushort,
            pairCache: *mut root::btOverlappingPairCache,
            disableRaycastAccelerator: bool,
        );
    }
    impl btAxisSweep3 {
        #[inline]
        pub unsafe fn new(
            worldAabbMin: *const root::btVector3,
            worldAabbMax: *const root::btVector3,
            maxHandles: ::std::os::raw::c_ushort,
            pairCache: *mut root::btOverlappingPairCache,
            disableRaycastAccelerator: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btAxisSweep3_btAxisSweep3(
                &mut __bindgen_tmp,
                worldAabbMin,
                worldAabbMax,
                maxHandles,
                pairCache,
                disableRaycastAccelerator,
            );
            __bindgen_tmp
        }
    }
    /// The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
    /// This comes at the cost of more memory per handle, and a bit slower performance.
    /// It uses arrays rather then lists for storage of the 3 axis.
    #[repr(C)]
    #[derive(Debug)]
    pub struct bt32BitAxisSweep3 {
        pub _base: root::btAxisSweep3Internal<::std::os::raw::c_uint>,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17bt32BitAxisSweep3C1ERK9btVector3S2_jP22btOverlappingPairCacheb"]
        pub fn bt32BitAxisSweep3_bt32BitAxisSweep3(
            this: *mut root::bt32BitAxisSweep3,
            worldAabbMin: *const root::btVector3,
            worldAabbMax: *const root::btVector3,
            maxHandles: ::std::os::raw::c_uint,
            pairCache: *mut root::btOverlappingPairCache,
            disableRaycastAccelerator: bool,
        );
    }
    impl bt32BitAxisSweep3 {
        #[inline]
        pub unsafe fn new(
            worldAabbMin: *const root::btVector3,
            worldAabbMax: *const root::btVector3,
            maxHandles: ::std::os::raw::c_uint,
            pairCache: *mut root::btOverlappingPairCache,
            disableRaycastAccelerator: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            bt32BitAxisSweep3_bt32BitAxisSweep3(
                &mut __bindgen_tmp,
                worldAabbMin,
                worldAabbMax,
                maxHandles,
                pairCache,
                disableRaycastAccelerator,
            );
            __bindgen_tmp
        }
    }
    /// The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDefaultMotionState {
        pub _base: root::btMotionState,
        pub m_graphicsWorldTrans: root::btTransform,
        pub m_centerOfMassOffset: root::btTransform,
        pub m_startWorldTrans: root::btTransform,
        pub m_userPointer: *mut ::std::os::raw::c_void,
    }
    /// The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btClock {
        pub m_data: *mut root::btClockData,
    }
    extern "C" {
        /// Resets the initial reference time.
        #[link_name = "\u{1}_ZN7btClock5resetEv"]
        pub fn btClock_reset(this: *mut root::btClock);
    }
    extern "C" {
        /// Returns the time in ms since the last call to reset or since
        /// /// the btClock was created.
        #[link_name = "\u{1}_ZN7btClock19getTimeMillisecondsEv"]
        pub fn btClock_getTimeMilliseconds(this: *mut root::btClock)
            -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        /// Returns the time in us since the last call to reset or since
        /// /// the Clock was created.
        #[link_name = "\u{1}_ZN7btClock19getTimeMicrosecondsEv"]
        pub fn btClock_getTimeMicroseconds(this: *mut root::btClock)
            -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7btClock18getTimeNanosecondsEv"]
        pub fn btClock_getTimeNanoseconds(this: *mut root::btClock) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        /// Returns the time in s since the last call to reset or since
        /// /// the Clock was created.
        #[link_name = "\u{1}_ZN7btClock14getTimeSecondsEv"]
        pub fn btClock_getTimeSeconds(this: *mut root::btClock) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7btClockC1Ev"]
        pub fn btClock_btClock(this: *mut root::btClock);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7btClockC1ERKS_"]
        pub fn btClock_btClock1(this: *mut root::btClock, other: *const root::btClock);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN7btClockD1Ev"]
        pub fn btClock_btClock_destructor(this: *mut root::btClock);
    }
    impl btClock {
        #[inline]
        pub unsafe fn reset(&mut self) {
            btClock_reset(self)
        }
        #[inline]
        pub unsafe fn getTimeMilliseconds(&mut self) -> ::std::os::raw::c_ulonglong {
            btClock_getTimeMilliseconds(self)
        }
        #[inline]
        pub unsafe fn getTimeMicroseconds(&mut self) -> ::std::os::raw::c_ulonglong {
            btClock_getTimeMicroseconds(self)
        }
        #[inline]
        pub unsafe fn getTimeNanoseconds(&mut self) -> ::std::os::raw::c_ulonglong {
            btClock_getTimeNanoseconds(self)
        }
        #[inline]
        pub unsafe fn getTimeSeconds(&mut self) -> root::btScalar {
            btClock_getTimeSeconds(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btClock_btClock(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(other: *const root::btClock) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btClock_btClock1(&mut __bindgen_tmp, other);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            btClock_btClock_destructor(self)
        }
    }
    pub type btEnterProfileZoneFunc =
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
    pub type btLeaveProfileZoneFunc = ::std::option::Option<unsafe extern "C" fn()>;
    extern "C" {
        #[link_name = "\u{1}_Z32btGetCurrentEnterProfileZoneFuncv"]
        pub fn btGetCurrentEnterProfileZoneFunc() -> root::btEnterProfileZoneFunc;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32btGetCurrentLeaveProfileZoneFuncv"]
        pub fn btGetCurrentLeaveProfileZoneFunc() -> root::btLeaveProfileZoneFunc;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31btSetCustomEnterProfileZoneFuncPFvPKcE"]
        pub fn btSetCustomEnterProfileZoneFunc(enterFunc: root::btEnterProfileZoneFunc);
    }
    extern "C" {
        #[link_name = "\u{1}_Z31btSetCustomLeaveProfileZoneFuncPFvvE"]
        pub fn btSetCustomLeaveProfileZoneFunc(leaveFunc: root::btLeaveProfileZoneFunc);
    }
    extern "C" {
        #[link_name = "\u{1}_Z33btQuickprofGetCurrentThreadIndex2v"]
        pub fn btQuickprofGetCurrentThreadIndex2() -> ::std::os::raw::c_uint;
    }
    #[repr(C)]
    pub struct btIDebugDraw__bindgen_vtable(::std::os::raw::c_void);
    /// The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
    /// Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
    /// A class that implements the btIDebugDraw interface has to implement the drawLine method at a minimum.
    /// For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]
    #[repr(C)]
    #[derive(Debug)]
    pub struct btIDebugDraw {
        pub vtable_: *const btIDebugDraw__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btIDebugDraw_DefaultColors {
        pub m_activeObject: root::btVector3,
        pub m_deactivatedObject: root::btVector3,
        pub m_wantsDeactivationObject: root::btVector3,
        pub m_disabledDeactivationObject: root::btVector3,
        pub m_disabledSimulationObject: root::btVector3,
        pub m_aabb: root::btVector3,
        pub m_contactPoint: root::btVector3,
    }
    pub const btIDebugDraw_DebugDrawModes_DBG_NoDebug: root::btIDebugDraw_DebugDrawModes = 0;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawWireframe: root::btIDebugDraw_DebugDrawModes = 1;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawAabb: root::btIDebugDraw_DebugDrawModes = 2;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawFeaturesText: root::btIDebugDraw_DebugDrawModes =
        4;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawContactPoints: root::btIDebugDraw_DebugDrawModes =
        8;
    pub const btIDebugDraw_DebugDrawModes_DBG_NoDeactivation: root::btIDebugDraw_DebugDrawModes =
        16;
    pub const btIDebugDraw_DebugDrawModes_DBG_NoHelpText: root::btIDebugDraw_DebugDrawModes = 32;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawText: root::btIDebugDraw_DebugDrawModes = 64;
    pub const btIDebugDraw_DebugDrawModes_DBG_ProfileTimings: root::btIDebugDraw_DebugDrawModes =
        128;
    pub const btIDebugDraw_DebugDrawModes_DBG_EnableSatComparison:
        root::btIDebugDraw_DebugDrawModes = 256;
    pub const btIDebugDraw_DebugDrawModes_DBG_DisableBulletLCP: root::btIDebugDraw_DebugDrawModes =
        512;
    pub const btIDebugDraw_DebugDrawModes_DBG_EnableCCD: root::btIDebugDraw_DebugDrawModes = 1024;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraints: root::btIDebugDraw_DebugDrawModes =
        2048;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraintLimits:
        root::btIDebugDraw_DebugDrawModes = 4096;
    pub const btIDebugDraw_DebugDrawModes_DBG_FastWireframe: root::btIDebugDraw_DebugDrawModes =
        8192;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawNormals: root::btIDebugDraw_DebugDrawModes =
        16384;
    pub const btIDebugDraw_DebugDrawModes_DBG_DrawFrames: root::btIDebugDraw_DebugDrawModes = 32768;
    pub const btIDebugDraw_DebugDrawModes_DBG_MAX_DEBUG_DRAW_MODE:
        root::btIDebugDraw_DebugDrawModes = 32769;
    pub type btIDebugDraw_DebugDrawModes = u32;
    pub const btSolverMode_SOLVER_RANDMIZE_ORDER: root::btSolverMode = 1;
    pub const btSolverMode_SOLVER_FRICTION_SEPARATE: root::btSolverMode = 2;
    pub const btSolverMode_SOLVER_USE_WARMSTARTING: root::btSolverMode = 4;
    pub const btSolverMode_SOLVER_USE_2_FRICTION_DIRECTIONS: root::btSolverMode = 16;
    pub const btSolverMode_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING: root::btSolverMode = 32;
    pub const btSolverMode_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION:
        root::btSolverMode = 64;
    pub const btSolverMode_SOLVER_CACHE_FRIENDLY: root::btSolverMode = 128;
    pub const btSolverMode_SOLVER_SIMD: root::btSolverMode = 256;
    pub const btSolverMode_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: root::btSolverMode =
        512;
    pub const btSolverMode_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: root::btSolverMode = 1024;
    pub const btSolverMode_SOLVER_DISABLE_IMPLICIT_CONE_FRICTION: root::btSolverMode = 2048;
    pub type btSolverMode = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btContactSolverInfoData {
        pub m_tau: root::btScalar,
        pub m_damping: root::btScalar,
        pub m_friction: root::btScalar,
        pub m_timeStep: root::btScalar,
        pub m_restitution: root::btScalar,
        pub m_numIterations: ::std::os::raw::c_int,
        pub m_maxErrorReduction: root::btScalar,
        pub m_sor: root::btScalar,
        pub m_erp: root::btScalar,
        pub m_erp2: root::btScalar,
        pub m_globalCfm: root::btScalar,
        pub m_frictionERP: root::btScalar,
        pub m_frictionCFM: root::btScalar,
        pub m_splitImpulse: ::std::os::raw::c_int,
        pub m_splitImpulsePenetrationThreshold: root::btScalar,
        pub m_splitImpulseTurnErp: root::btScalar,
        pub m_linearSlop: root::btScalar,
        pub m_warmstartingFactor: root::btScalar,
        pub m_solverMode: ::std::os::raw::c_int,
        pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
        pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
        pub m_maxGyroscopicForce: root::btScalar,
        pub m_singleAxisRollingFrictionThreshold: root::btScalar,
        pub m_leastSquaresResidualThreshold: root::btScalar,
        pub m_restitutionVelocityThreshold: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btContactSolverInfo {
        pub _base: root::btContactSolverInfoData,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btContactSolverInfoDoubleData {
        pub m_tau: f64,
        pub m_damping: f64,
        pub m_friction: f64,
        pub m_timeStep: f64,
        pub m_restitution: f64,
        pub m_maxErrorReduction: f64,
        pub m_sor: f64,
        pub m_erp: f64,
        pub m_erp2: f64,
        pub m_globalCfm: f64,
        pub m_splitImpulsePenetrationThreshold: f64,
        pub m_splitImpulseTurnErp: f64,
        pub m_linearSlop: f64,
        pub m_warmstartingFactor: f64,
        pub m_maxGyroscopicForce: f64,
        /// it is only used for 'explicit' version of gyroscopic force
        pub m_singleAxisRollingFrictionThreshold: f64,
        pub m_numIterations: ::std::os::raw::c_int,
        pub m_solverMode: ::std::os::raw::c_int,
        pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
        pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
        pub m_splitImpulse: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btContactSolverInfoFloatData {
        pub m_tau: f32,
        pub m_damping: f32,
        pub m_friction: f32,
        pub m_timeStep: f32,
        pub m_restitution: f32,
        pub m_maxErrorReduction: f32,
        pub m_sor: f32,
        pub m_erp: f32,
        pub m_erp2: f32,
        pub m_globalCfm: f32,
        pub m_splitImpulsePenetrationThreshold: f32,
        pub m_splitImpulseTurnErp: f32,
        pub m_linearSlop: f32,
        pub m_warmstartingFactor: f32,
        pub m_maxGyroscopicForce: f32,
        pub m_singleAxisRollingFrictionThreshold: f32,
        pub m_numIterations: ::std::os::raw::c_int,
        pub m_solverMode: ::std::os::raw::c_int,
        pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
        pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
        pub m_splitImpulse: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// Type for the callback for each tick
    pub type btInternalTickCallback = ::std::option::Option<
        unsafe extern "C" fn(world: *mut root::btDynamicsWorld, timeStep: root::btScalar),
    >;
    pub const btDynamicsWorldType_BT_SIMPLE_DYNAMICS_WORLD: root::btDynamicsWorldType = 1;
    pub const btDynamicsWorldType_BT_DISCRETE_DYNAMICS_WORLD: root::btDynamicsWorldType = 2;
    pub const btDynamicsWorldType_BT_CONTINUOUS_DYNAMICS_WORLD: root::btDynamicsWorldType = 3;
    pub const btDynamicsWorldType_BT_SOFT_RIGID_DYNAMICS_WORLD: root::btDynamicsWorldType = 4;
    pub const btDynamicsWorldType_BT_GPU_DYNAMICS_WORLD: root::btDynamicsWorldType = 5;
    pub const btDynamicsWorldType_BT_SOFT_MULTIBODY_DYNAMICS_WORLD: root::btDynamicsWorldType = 6;
    pub type btDynamicsWorldType = u32;
    /// The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDynamicsWorld {
        pub _base: root::btCollisionWorld,
        pub m_internalTickCallback: root::btInternalTickCallback,
        pub m_internalPreTickCallback: root::btInternalTickCallback,
        pub m_worldUserInfo: *mut ::std::os::raw::c_void,
        pub m_solverInfo: root::btContactSolverInfo,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDynamicsWorldDoubleData {
        pub m_solverInfo: root::btContactSolverInfoDoubleData,
        pub m_gravity: root::btVector3DoubleData,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btDynamicsWorldFloatData {
        pub m_solverInfo: root::btContactSolverInfoFloatData,
        pub m_gravity: root::btVector3FloatData,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSimulationIslandManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct InplaceSolverIslandCallback {
        _unused: [u8; 0],
    }
    extern "C" {
        #[link_name = "\u{1}_Z14btIsMainThreadv"]
        pub fn btIsMainThread() -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19btThreadsAreRunningv"]
        pub fn btThreadsAreRunning() -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23btGetCurrentThreadIndexv"]
        pub fn btGetCurrentThreadIndex() -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25btResetThreadIndexCounterv"]
        pub fn btResetThreadIndexCounter();
    }
    ///
    /// btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
    /// a thread to sleep because it is designed to be used with a task scheduler
    /// which has one thread per core and the threads don't sleep until they
    /// run out of tasks. Not good for general purpose use.
    ///
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSpinMutex {
        pub mLock: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btSpinMutex4lockEv"]
        pub fn btSpinMutex_lock(this: *mut root::btSpinMutex);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btSpinMutex6unlockEv"]
        pub fn btSpinMutex_unlock(this: *mut root::btSpinMutex);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btSpinMutex7tryLockEv"]
        pub fn btSpinMutex_tryLock(this: *mut root::btSpinMutex) -> bool;
    }
    impl btSpinMutex {
        #[inline]
        pub unsafe fn lock(&mut self) {
            btSpinMutex_lock(self)
        }
        #[inline]
        pub unsafe fn unlock(&mut self) {
            btSpinMutex_unlock(self)
        }
        #[inline]
        pub unsafe fn tryLock(&mut self) -> bool {
            btSpinMutex_tryLock(self)
        }
    }
    #[repr(C)]
    pub struct btIParallelForBody__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btIParallelForBody {
        pub vtable_: *const btIParallelForBody__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btIParallelSumBody__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btIParallelSumBody {
        pub vtable_: *const btIParallelSumBody__bindgen_vtable,
    }
    #[repr(C)]
    pub struct btITaskScheduler__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btITaskScheduler {
        pub vtable_: *const btITaskScheduler__bindgen_vtable,
        pub m_name: *const ::std::os::raw::c_char,
        pub m_savedThreadCounter: ::std::os::raw::c_uint,
        pub m_isActive: bool,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btITaskSchedulerC2EPKc"]
        pub fn btITaskScheduler_btITaskScheduler(
            this: *mut root::btITaskScheduler,
            name: *const ::std::os::raw::c_char,
        );
    }
    impl btITaskScheduler {
        #[inline]
        pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btITaskScheduler_btITaskScheduler(&mut __bindgen_tmp, name);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btITaskScheduler8activateEv"]
        pub fn btITaskScheduler_activate(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btITaskScheduler10deactivateEv"]
        pub fn btITaskScheduler_deactivate(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18btSetTaskSchedulerP16btITaskScheduler"]
        pub fn btSetTaskScheduler(ts: *mut root::btITaskScheduler);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18btGetTaskSchedulerv"]
        pub fn btGetTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28btGetSequentialTaskSchedulerv"]
        pub fn btGetSequentialTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28btCreateDefaultTaskSchedulerv"]
        pub fn btCreateDefaultTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24btGetOpenMPTaskSchedulerv"]
        pub fn btGetOpenMPTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21btGetTBBTaskSchedulerv"]
        pub fn btGetTBBTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21btGetPPLTaskSchedulerv"]
        pub fn btGetPPLTaskScheduler() -> *mut root::btITaskScheduler;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13btParallelForiiiRK18btIParallelForBody"]
        pub fn btParallelFor(
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            grainSize: ::std::os::raw::c_int,
            body: *const root::btIParallelForBody,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z13btParallelSumiiiRK18btIParallelSumBody"]
        pub fn btParallelSum(
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            grainSize: ::std::os::raw::c_int,
            body: *const root::btIParallelSumBody,
        ) -> root::btScalar;
    }
    /// btDiscreteDynamicsWorld provides discrete rigid body simulation
    /// those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDiscreteDynamicsWorld {
        pub _base: root::btDynamicsWorld,
        pub m_sortedConstraints: root::btAlignedObjectArray<*mut root::btTypedConstraint>,
        pub m_solverIslandCallback: *mut root::InplaceSolverIslandCallback,
        pub m_constraintSolver: *mut root::btConstraintSolver,
        pub m_islandManager: *mut root::btSimulationIslandManager,
        pub m_constraints: root::btAlignedObjectArray<*mut root::btTypedConstraint>,
        pub m_nonStaticRigidBodies: root::btAlignedObjectArray<*mut root::btRigidBody>,
        pub m_gravity: root::btVector3,
        pub m_localTime: root::btScalar,
        pub m_fixedTimeStep: root::btScalar,
        pub m_ownsIslandManager: bool,
        pub m_ownsConstraintSolver: bool,
        pub m_synchronizeAllMotionStates: bool,
        pub m_applySpeculativeContactRestitution: bool,
        pub m_actions: root::btAlignedObjectArray<*mut root::btActionInterface>,
        pub m_profileTimings: ::std::os::raw::c_int,
        pub m_latencyMotionStateInterpolation: bool,
        pub m_predictiveManifolds: root::btAlignedObjectArray<*mut root::btPersistentManifold>,
        pub m_predictiveManifoldsMutex: root::btSpinMutex,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld27integrateTransformsInternalEPP11btRigidBodyif"]
        pub fn btDiscreteDynamicsWorld_integrateTransformsInternal(
            this: *mut root::btDiscreteDynamicsWorld,
            bodies: *mut *mut root::btRigidBody,
            numBodies: ::std::os::raw::c_int,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13updateActionsEf"]
        pub fn btDiscreteDynamicsWorld_updateActions(
            this: *mut root::btDiscreteDynamicsWorld,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14startProfilingEf"]
        pub fn btDiscreteDynamicsWorld_startProfiling(
            this: *mut root::btDiscreteDynamicsWorld,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld25releasePredictiveContactsEv"]
        pub fn btDiscreteDynamicsWorld_releasePredictiveContacts(
            this: *mut root::btDiscreteDynamicsWorld,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld32createPredictiveContactsInternalEPP11btRigidBodyif"]
        pub fn btDiscreteDynamicsWorld_createPredictiveContactsInternal(
            this: *mut root::btDiscreteDynamicsWorld,
            bodies: *mut *mut root::btRigidBody,
            numBodies: ::std::os::raw::c_int,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld20serializeRigidBodiesEP12btSerializer"]
        pub fn btDiscreteDynamicsWorld_serializeRigidBodies(
            this: *mut root::btDiscreteDynamicsWorld,
            serializer: *mut root::btSerializer,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld26serializeDynamicsWorldInfoEP12btSerializer"]
        pub fn btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(
            this: *mut root::btDiscreteDynamicsWorld,
            serializer: *mut root::btSerializer,
        );
    }
    extern "C" {
        /// this can be useful to synchronize a single rigid body -> graphics object
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld28synchronizeSingleMotionStateEP11btRigidBody"]
        pub fn btDiscreteDynamicsWorld_synchronizeSingleMotionState(
            this: *mut root::btDiscreteDynamicsWorld,
            body: *mut root::btRigidBody,
        );
    }
    extern "C" {
        /// this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration"]
        pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
            this: *mut root::btDiscreteDynamicsWorld,
            dispatcher: *mut root::btDispatcher,
            pairCache: *mut root::btBroadphaseInterface,
            constraintSolver: *mut root::btConstraintSolver,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        );
    }
    impl btDiscreteDynamicsWorld {
        #[inline]
        pub unsafe fn integrateTransformsInternal(
            &mut self,
            bodies: *mut *mut root::btRigidBody,
            numBodies: ::std::os::raw::c_int,
            timeStep: root::btScalar,
        ) {
            btDiscreteDynamicsWorld_integrateTransformsInternal(self, bodies, numBodies, timeStep)
        }
        #[inline]
        pub unsafe fn updateActions(&mut self, timeStep: root::btScalar) {
            btDiscreteDynamicsWorld_updateActions(self, timeStep)
        }
        #[inline]
        pub unsafe fn startProfiling(&mut self, timeStep: root::btScalar) {
            btDiscreteDynamicsWorld_startProfiling(self, timeStep)
        }
        #[inline]
        pub unsafe fn releasePredictiveContacts(&mut self) {
            btDiscreteDynamicsWorld_releasePredictiveContacts(self)
        }
        #[inline]
        pub unsafe fn createPredictiveContactsInternal(
            &mut self,
            bodies: *mut *mut root::btRigidBody,
            numBodies: ::std::os::raw::c_int,
            timeStep: root::btScalar,
        ) {
            btDiscreteDynamicsWorld_createPredictiveContactsInternal(
                self, bodies, numBodies, timeStep,
            )
        }
        #[inline]
        pub unsafe fn serializeRigidBodies(&mut self, serializer: *mut root::btSerializer) {
            btDiscreteDynamicsWorld_serializeRigidBodies(self, serializer)
        }
        #[inline]
        pub unsafe fn serializeDynamicsWorldInfo(&mut self, serializer: *mut root::btSerializer) {
            btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(self, serializer)
        }
        #[inline]
        pub unsafe fn synchronizeSingleMotionState(&mut self, body: *mut root::btRigidBody) {
            btDiscreteDynamicsWorld_synchronizeSingleMotionState(self, body)
        }
        #[inline]
        pub unsafe fn new(
            dispatcher: *mut root::btDispatcher,
            pairCache: *mut root::btBroadphaseInterface,
            constraintSolver: *mut root::btConstraintSolver,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
                &mut __bindgen_tmp,
                dispatcher,
                pairCache,
                constraintSolver,
                collisionConfiguration,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld25predictUnconstraintMotionEf"]
        pub fn btDiscreteDynamicsWorld_predictUnconstraintMotion(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19integrateTransformsEf"]
        pub fn btDiscreteDynamicsWorld_integrateTransforms(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld26calculateSimulationIslandsEv"]
        pub fn btDiscreteDynamicsWorld_calculateSimulationIslands(
            this: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld16solveConstraintsER19btContactSolverInfo"]
        pub fn btDiscreteDynamicsWorld_solveConstraints(
            this: *mut ::std::os::raw::c_void,
            solverInfo: *mut root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld21updateActivationStateEf"]
        pub fn btDiscreteDynamicsWorld_updateActivationState(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld28internalSingleStepSimulationEf"]
        pub fn btDiscreteDynamicsWorld_internalSingleStepSimulation(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld24createPredictiveContactsEf"]
        pub fn btDiscreteDynamicsWorld_createPredictiveContacts(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld18saveKinematicStateEf"]
        pub fn btDiscreteDynamicsWorld_saveKinematicState(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorldD1Ev"]
        pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_destructor(
            this: *mut root::btDiscreteDynamicsWorld,
        );
    }
    extern "C" {
        /// if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14stepSimulationEfif"]
        pub fn btDiscreteDynamicsWorld_stepSimulation(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
            maxSubSteps: ::std::os::raw::c_int,
            fixedTimeStep: root::btScalar,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld23synchronizeMotionStatesEv"]
        pub fn btDiscreteDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13addConstraintEP17btTypedConstraintb"]
        pub fn btDiscreteDynamicsWorld_addConstraint(
            this: *mut ::std::os::raw::c_void,
            constraint: *mut root::btTypedConstraint,
            disableCollisionsBetweenLinkedBodies: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld16removeConstraintEP17btTypedConstraint"]
        pub fn btDiscreteDynamicsWorld_removeConstraint(
            this: *mut ::std::os::raw::c_void,
            constraint: *mut root::btTypedConstraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld9addActionEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_addAction(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::btActionInterface,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12removeActionEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_removeAction(
            this: *mut ::std::os::raw::c_void,
            arg1: *mut root::btActionInterface,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld10setGravityERK9btVector3"]
        pub fn btDiscreteDynamicsWorld_setGravity(
            this: *mut ::std::os::raw::c_void,
            gravity: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld10getGravityEv"]
        pub fn btDiscreteDynamicsWorld_getGravity(
            this: *mut ::std::os::raw::c_void,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld18addCollisionObjectEP17btCollisionObjectii"]
        pub fn btDiscreteDynamicsWorld_addCollisionObject(
            this: *mut ::std::os::raw::c_void,
            collisionObject: *mut root::btCollisionObject,
            collisionFilterGroup: ::std::os::raw::c_int,
            collisionFilterMask: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addRigidBodyEP11btRigidBody"]
        pub fn btDiscreteDynamicsWorld_addRigidBody(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addRigidBodyEP11btRigidBodyii"]
        pub fn btDiscreteDynamicsWorld_addRigidBody1(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
            group: ::std::os::raw::c_int,
            mask: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld15removeRigidBodyEP11btRigidBody"]
        pub fn btDiscreteDynamicsWorld_removeRigidBody(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
        );
    }
    extern "C" {
        /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld21removeCollisionObjectEP17btCollisionObject"]
        pub fn btDiscreteDynamicsWorld_removeCollisionObject(
            this: *mut ::std::os::raw::c_void,
            collisionObject: *mut root::btCollisionObject,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19debugDrawConstraintEP17btTypedConstraint"]
        pub fn btDiscreteDynamicsWorld_debugDrawConstraint(
            this: *mut ::std::os::raw::c_void,
            constraint: *mut root::btTypedConstraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14debugDrawWorldEv"]
        pub fn btDiscreteDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19setConstraintSolverEP18btConstraintSolver"]
        pub fn btDiscreteDynamicsWorld_setConstraintSolver(
            this: *mut ::std::os::raw::c_void,
            solver: *mut root::btConstraintSolver,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19getConstraintSolverEv"]
        pub fn btDiscreteDynamicsWorld_getConstraintSolver(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::btConstraintSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld17getNumConstraintsEv"]
        pub fn btDiscreteDynamicsWorld_getNumConstraints(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13getConstraintEi"]
        pub fn btDiscreteDynamicsWorld_getConstraint(
            this: *mut ::std::os::raw::c_void,
            index: ::std::os::raw::c_int,
        ) -> *mut root::btTypedConstraint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld13getConstraintEi"]
        pub fn btDiscreteDynamicsWorld_getConstraint1(
            this: *mut ::std::os::raw::c_void,
            index: ::std::os::raw::c_int,
        ) -> *const root::btTypedConstraint;
    }
    extern "C" {
        /// the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld11clearForcesEv"]
        pub fn btDiscreteDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        /// apply gravity, call this once per timestep
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12applyGravityEv"]
        pub fn btDiscreteDynamicsWorld_applyGravity(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        /// obsolete, use addAction instead
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld10addVehicleEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_addVehicle(
            this: *mut ::std::os::raw::c_void,
            vehicle: *mut root::btActionInterface,
        );
    }
    extern "C" {
        /// obsolete, use removeAction instead
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13removeVehicleEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_removeVehicle(
            this: *mut ::std::os::raw::c_void,
            vehicle: *mut root::btActionInterface,
        );
    }
    extern "C" {
        /// obsolete, use addAction instead
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addCharacterEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_addCharacter(
            this: *mut ::std::os::raw::c_void,
            character: *mut root::btActionInterface,
        );
    }
    extern "C" {
        /// obsolete, use removeAction instead
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld15removeCharacterEP17btActionInterface"]
        pub fn btDiscreteDynamicsWorld_removeCharacter(
            this: *mut ::std::os::raw::c_void,
            character: *mut root::btActionInterface,
        );
    }
    extern "C" {
        /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
        #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld9serializeEP12btSerializer"]
        pub fn btDiscreteDynamicsWorld_serialize(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    /// The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
    /// Please use btDiscreteDynamicsWorld instead
    #[repr(C)]
    #[derive(Debug)]
    pub struct btSimpleDynamicsWorld {
        pub _base: root::btDynamicsWorld,
        pub m_constraintSolver: *mut root::btConstraintSolver,
        pub m_ownsConstraintSolver: bool,
        pub m_gravity: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld25predictUnconstraintMotionEf"]
        pub fn btSimpleDynamicsWorld_predictUnconstraintMotion(
            this: *mut root::btSimpleDynamicsWorld,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19integrateTransformsEf"]
        pub fn btSimpleDynamicsWorld_integrateTransforms(
            this: *mut root::btSimpleDynamicsWorld,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        /// this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration"]
        pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld(
            this: *mut root::btSimpleDynamicsWorld,
            dispatcher: *mut root::btDispatcher,
            pairCache: *mut root::btBroadphaseInterface,
            constraintSolver: *mut root::btConstraintSolver,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        );
    }
    impl btSimpleDynamicsWorld {
        #[inline]
        pub unsafe fn predictUnconstraintMotion(&mut self, timeStep: root::btScalar) {
            btSimpleDynamicsWorld_predictUnconstraintMotion(self, timeStep)
        }
        #[inline]
        pub unsafe fn integrateTransforms(&mut self, timeStep: root::btScalar) {
            btSimpleDynamicsWorld_integrateTransforms(self, timeStep)
        }
        #[inline]
        pub unsafe fn new(
            dispatcher: *mut root::btDispatcher,
            pairCache: *mut root::btBroadphaseInterface,
            constraintSolver: *mut root::btConstraintSolver,
            collisionConfiguration: *mut root::btCollisionConfiguration,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSimpleDynamicsWorld_btSimpleDynamicsWorld(
                &mut __bindgen_tmp,
                dispatcher,
                pairCache,
                constraintSolver,
                collisionConfiguration,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorldD1Ev"]
        pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld_destructor(
            this: *mut root::btSimpleDynamicsWorld,
        );
    }
    extern "C" {
        /// maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld14stepSimulationEfif"]
        pub fn btSimpleDynamicsWorld_stepSimulation(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
            maxSubSteps: ::std::os::raw::c_int,
            fixedTimeStep: root::btScalar,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld10setGravityERK9btVector3"]
        pub fn btSimpleDynamicsWorld_setGravity(
            this: *mut ::std::os::raw::c_void,
            gravity: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btSimpleDynamicsWorld10getGravityEv"]
        pub fn btSimpleDynamicsWorld_getGravity(
            this: *mut ::std::os::raw::c_void,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12addRigidBodyEP11btRigidBody"]
        pub fn btSimpleDynamicsWorld_addRigidBody(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12addRigidBodyEP11btRigidBodyii"]
        pub fn btSimpleDynamicsWorld_addRigidBody1(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
            group: ::std::os::raw::c_int,
            mask: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld15removeRigidBodyEP11btRigidBody"]
        pub fn btSimpleDynamicsWorld_removeRigidBody(
            this: *mut ::std::os::raw::c_void,
            body: *mut root::btRigidBody,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld14debugDrawWorldEv"]
        pub fn btSimpleDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld9addActionEP17btActionInterface"]
        pub fn btSimpleDynamicsWorld_addAction(
            this: *mut ::std::os::raw::c_void,
            action: *mut root::btActionInterface,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12removeActionEP17btActionInterface"]
        pub fn btSimpleDynamicsWorld_removeAction(
            this: *mut ::std::os::raw::c_void,
            action: *mut root::btActionInterface,
        );
    }
    extern "C" {
        /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld21removeCollisionObjectEP17btCollisionObject"]
        pub fn btSimpleDynamicsWorld_removeCollisionObject(
            this: *mut ::std::os::raw::c_void,
            collisionObject: *mut root::btCollisionObject,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld11updateAabbsEv"]
        pub fn btSimpleDynamicsWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld23synchronizeMotionStatesEv"]
        pub fn btSimpleDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19setConstraintSolverEP18btConstraintSolver"]
        pub fn btSimpleDynamicsWorld_setConstraintSolver(
            this: *mut ::std::os::raw::c_void,
            solver: *mut root::btConstraintSolver,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19getConstraintSolverEv"]
        pub fn btSimpleDynamicsWorld_getConstraintSolver(
            this: *mut ::std::os::raw::c_void,
        ) -> *mut root::btConstraintSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld11clearForcesEv"]
        pub fn btSimpleDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
    }
    pub const btRigidBodyFlags_BT_DISABLE_WORLD_GRAVITY: root::btRigidBodyFlags = 1;
    /// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
    /// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
    /// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
    pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT: root::btRigidBodyFlags = 2;
    /// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
    /// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
    /// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
    pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD: root::btRigidBodyFlags =
        4;
    /// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
    /// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
    /// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
    pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY: root::btRigidBodyFlags = 8;
    /// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
    /// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
    /// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
    pub const btRigidBodyFlags_BT_ENABLE_GYROPSCOPIC_FORCE: root::btRigidBodyFlags = 8;
    pub type btRigidBodyFlags = u32;
    /// The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
    /// It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
    /// There are 3 types of rigid bodies:
    /// - A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
    /// - B) Fixed objects with zero mass. They are not moving (basically collision objects)
    /// - C) Kinematic objects, which are objects without mass, but the user can move them. There is on-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
    /// Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
    /// Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
    #[repr(C)]
    #[derive(Debug)]
    pub struct btRigidBody {
        pub _base: root::btCollisionObject,
        pub m_invInertiaTensorWorld: root::btMatrix3x3,
        pub m_linearVelocity: root::btVector3,
        pub m_angularVelocity: root::btVector3,
        pub m_inverseMass: root::btScalar,
        pub m_linearFactor: root::btVector3,
        pub m_gravity: root::btVector3,
        pub m_gravity_acceleration: root::btVector3,
        pub m_invInertiaLocal: root::btVector3,
        pub m_totalForce: root::btVector3,
        pub m_totalTorque: root::btVector3,
        pub m_linearDamping: root::btScalar,
        pub m_angularDamping: root::btScalar,
        pub m_additionalDamping: bool,
        pub m_additionalDampingFactor: root::btScalar,
        pub m_additionalLinearDampingThresholdSqr: root::btScalar,
        pub m_additionalAngularDampingThresholdSqr: root::btScalar,
        pub m_additionalAngularDampingFactor: root::btScalar,
        pub m_linearSleepingThreshold: root::btScalar,
        pub m_angularSleepingThreshold: root::btScalar,
        pub m_optionalMotionState: *mut root::btMotionState,
        pub m_constraintRefs: root::btAlignedObjectArray<*mut root::btTypedConstraint>,
        pub m_rigidbodyFlags: ::std::os::raw::c_int,
        pub m_debugBodyId: ::std::os::raw::c_int,
        pub m_deltaLinearVelocity: root::btVector3,
        pub m_deltaAngularVelocity: root::btVector3,
        pub m_angularFactor: root::btVector3,
        pub m_invMass: root::btVector3,
        pub m_pushVelocity: root::btVector3,
        pub m_turnVelocity: root::btVector3,
        pub m_contactSolverType: ::std::os::raw::c_int,
        pub m_frictionSolverType: ::std::os::raw::c_int,
    }
    /// The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
    /// ///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
    /// ///You can use the motion state to synchronize the world transform between physics and graphics objects.
    /// ///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
    /// ///m_startWorldTransform is only used when you don't provide a motion state.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRigidBody_btRigidBodyConstructionInfo {
        pub m_mass: root::btScalar,
        /// When a motionState is provided, the rigid body will initialize its world transform from the motion state
        /// ///In this case, m_startWorldTransform is ignored.
        pub m_motionState: *mut root::btMotionState,
        pub m_startWorldTransform: root::btTransform,
        pub m_collisionShape: *mut root::btCollisionShape,
        pub m_localInertia: root::btVector3,
        pub m_linearDamping: root::btScalar,
        pub m_angularDamping: root::btScalar,
        /// best simulation results when friction is non-zero
        pub m_friction: root::btScalar,
        /// the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
        /// ///See Bullet/Demos/RollingFrictionDemo for usage
        pub m_rollingFriction: root::btScalar,
        pub m_spinningFriction: root::btScalar,
        /// best simulation results using zero restitution.
        pub m_restitution: root::btScalar,
        pub m_linearSleepingThreshold: root::btScalar,
        pub m_angularSleepingThreshold: root::btScalar,
        pub m_additionalDamping: bool,
        pub m_additionalDampingFactor: root::btScalar,
        pub m_additionalLinearDampingThresholdSqr: root::btScalar,
        pub m_additionalAngularDampingThresholdSqr: root::btScalar,
        pub m_additionalAngularDampingFactor: root::btScalar,
    }
    extern "C" {
        /// setupRigidBody is only used internally by the constructor
        #[link_name = "\u{1}_ZN11btRigidBody14setupRigidBodyERKNS_27btRigidBodyConstructionInfoE"]
        pub fn btRigidBody_setupRigidBody(
            this: *mut root::btRigidBody,
            constructionInfo: *const root::btRigidBody_btRigidBodyConstructionInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody18proceedToTransformERK11btTransform"]
        pub fn btRigidBody_proceedToTransform(
            this: *mut root::btRigidBody,
            newTrans: *const root::btTransform,
        );
    }
    extern "C" {
        /// continuous collision detection needs prediction
        #[link_name = "\u{1}_ZN11btRigidBody26predictIntegratedTransformEfR11btTransform"]
        pub fn btRigidBody_predictIntegratedTransform(
            this: *mut root::btRigidBody,
            step: root::btScalar,
            predictedTransform: *mut root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody18saveKinematicStateEf"]
        pub fn btRigidBody_saveKinematicState(this: *mut root::btRigidBody, step: root::btScalar);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody12applyGravityEv"]
        pub fn btRigidBody_applyGravity(this: *mut root::btRigidBody);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody10setGravityERK9btVector3"]
        pub fn btRigidBody_setGravity(
            this: *mut root::btRigidBody,
            acceleration: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody10setDampingEff"]
        pub fn btRigidBody_setDamping(
            this: *mut root::btRigidBody,
            lin_damping: root::btScalar,
            ang_damping: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody12applyDampingEf"]
        pub fn btRigidBody_applyDamping(this: *mut root::btRigidBody, timeStep: root::btScalar);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody12setMassPropsEfRK9btVector3"]
        pub fn btRigidBody_setMassProps(
            this: *mut root::btRigidBody,
            mass: root::btScalar,
            inertia: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody19integrateVelocitiesEf"]
        pub fn btRigidBody_integrateVelocities(this: *mut root::btRigidBody, step: root::btScalar);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody24setCenterOfMassTransformERK11btTransform"]
        pub fn btRigidBody_setCenterOfMassTransform(
            this: *mut root::btRigidBody,
            xform: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody19updateInertiaTensorEv"]
        pub fn btRigidBody_updateInertiaTensor(this: *mut root::btRigidBody);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btRigidBody14getOrientationEv"]
        pub fn btRigidBody_getOrientation(this: *const root::btRigidBody) -> root::btQuaternion;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btRigidBody7getAabbER9btVector3S1_"]
        pub fn btRigidBody_getAabb(
            this: *const root::btRigidBody,
            aabbMin: *mut root::btVector3,
            aabbMax: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody16addConstraintRefEP17btTypedConstraint"]
        pub fn btRigidBody_addConstraintRef(
            this: *mut root::btRigidBody,
            c: *mut root::btTypedConstraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btRigidBody19removeConstraintRefEP17btTypedConstraint"]
        pub fn btRigidBody_removeConstraintRef(
            this: *mut root::btRigidBody,
            c: *mut root::btTypedConstraint,
        );
    }
    extern "C" {
        /// perform implicit force computation in world space
        #[link_name = "\u{1}_ZNK11btRigidBody38computeGyroscopicImpulseImplicit_WorldEf"]
        pub fn btRigidBody_computeGyroscopicImpulseImplicit_World(
            this: *const root::btRigidBody,
            dt: root::btScalar,
        ) -> root::btVector3;
    }
    extern "C" {
        /// perform implicit force computation in body space (inertial frame)
        #[link_name = "\u{1}_ZNK11btRigidBody37computeGyroscopicImpulseImplicit_BodyEf"]
        pub fn btRigidBody_computeGyroscopicImpulseImplicit_Body(
            this: *const root::btRigidBody,
            step: root::btScalar,
        ) -> root::btVector3;
    }
    extern "C" {
        /// explicit version is best avoided, it gains energy
        #[link_name = "\u{1}_ZNK11btRigidBody30computeGyroscopicForceExplicitEf"]
        pub fn btRigidBody_computeGyroscopicForceExplicit(
            this: *const root::btRigidBody,
            maxGyroscopicForce: root::btScalar,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btRigidBody15getLocalInertiaEv"]
        pub fn btRigidBody_getLocalInertia(this: *const root::btRigidBody) -> root::btVector3;
    }
    extern "C" {
        /// btRigidBody constructor using construction info
        #[link_name = "\u{1}_ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE"]
        pub fn btRigidBody_btRigidBody(
            this: *mut root::btRigidBody,
            constructionInfo: *const root::btRigidBody_btRigidBodyConstructionInfo,
        );
    }
    extern "C" {
        /// btRigidBody constructor for backwards compatibility.
        /// ///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
        #[link_name = "\u{1}_ZN11btRigidBodyC1EfP13btMotionStateP16btCollisionShapeRK9btVector3"]
        pub fn btRigidBody_btRigidBody1(
            this: *mut root::btRigidBody,
            mass: root::btScalar,
            motionState: *mut root::btMotionState,
            collisionShape: *mut root::btCollisionShape,
            localInertia: *const root::btVector3,
        );
    }
    impl btRigidBody {
        #[inline]
        pub unsafe fn setupRigidBody(
            &mut self,
            constructionInfo: *const root::btRigidBody_btRigidBodyConstructionInfo,
        ) {
            btRigidBody_setupRigidBody(self, constructionInfo)
        }
        #[inline]
        pub unsafe fn proceedToTransform(&mut self, newTrans: *const root::btTransform) {
            btRigidBody_proceedToTransform(self, newTrans)
        }
        #[inline]
        pub unsafe fn predictIntegratedTransform(
            &mut self,
            step: root::btScalar,
            predictedTransform: *mut root::btTransform,
        ) {
            btRigidBody_predictIntegratedTransform(self, step, predictedTransform)
        }
        #[inline]
        pub unsafe fn saveKinematicState(&mut self, step: root::btScalar) {
            btRigidBody_saveKinematicState(self, step)
        }
        #[inline]
        pub unsafe fn applyGravity(&mut self) {
            btRigidBody_applyGravity(self)
        }
        #[inline]
        pub unsafe fn setGravity(&mut self, acceleration: *const root::btVector3) {
            btRigidBody_setGravity(self, acceleration)
        }
        #[inline]
        pub unsafe fn setDamping(
            &mut self,
            lin_damping: root::btScalar,
            ang_damping: root::btScalar,
        ) {
            btRigidBody_setDamping(self, lin_damping, ang_damping)
        }
        #[inline]
        pub unsafe fn applyDamping(&mut self, timeStep: root::btScalar) {
            btRigidBody_applyDamping(self, timeStep)
        }
        #[inline]
        pub unsafe fn setMassProps(
            &mut self,
            mass: root::btScalar,
            inertia: *const root::btVector3,
        ) {
            btRigidBody_setMassProps(self, mass, inertia)
        }
        #[inline]
        pub unsafe fn integrateVelocities(&mut self, step: root::btScalar) {
            btRigidBody_integrateVelocities(self, step)
        }
        #[inline]
        pub unsafe fn setCenterOfMassTransform(&mut self, xform: *const root::btTransform) {
            btRigidBody_setCenterOfMassTransform(self, xform)
        }
        #[inline]
        pub unsafe fn updateInertiaTensor(&mut self) {
            btRigidBody_updateInertiaTensor(self)
        }
        #[inline]
        pub unsafe fn getOrientation(&self) -> root::btQuaternion {
            btRigidBody_getOrientation(self)
        }
        #[inline]
        pub unsafe fn getAabb(&self, aabbMin: *mut root::btVector3, aabbMax: *mut root::btVector3) {
            btRigidBody_getAabb(self, aabbMin, aabbMax)
        }
        #[inline]
        pub unsafe fn addConstraintRef(&mut self, c: *mut root::btTypedConstraint) {
            btRigidBody_addConstraintRef(self, c)
        }
        #[inline]
        pub unsafe fn removeConstraintRef(&mut self, c: *mut root::btTypedConstraint) {
            btRigidBody_removeConstraintRef(self, c)
        }
        #[inline]
        pub unsafe fn computeGyroscopicImpulseImplicit_World(
            &self,
            dt: root::btScalar,
        ) -> root::btVector3 {
            btRigidBody_computeGyroscopicImpulseImplicit_World(self, dt)
        }
        #[inline]
        pub unsafe fn computeGyroscopicImpulseImplicit_Body(
            &self,
            step: root::btScalar,
        ) -> root::btVector3 {
            btRigidBody_computeGyroscopicImpulseImplicit_Body(self, step)
        }
        #[inline]
        pub unsafe fn computeGyroscopicForceExplicit(
            &self,
            maxGyroscopicForce: root::btScalar,
        ) -> root::btVector3 {
            btRigidBody_computeGyroscopicForceExplicit(self, maxGyroscopicForce)
        }
        #[inline]
        pub unsafe fn getLocalInertia(&self) -> root::btVector3 {
            btRigidBody_getLocalInertia(self)
        }
        #[inline]
        pub unsafe fn new(
            constructionInfo: *const root::btRigidBody_btRigidBodyConstructionInfo,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btRigidBody_btRigidBody(&mut __bindgen_tmp, constructionInfo);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            mass: root::btScalar,
            motionState: *mut root::btMotionState,
            collisionShape: *mut root::btCollisionShape,
            localInertia: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btRigidBody_btRigidBody1(
                &mut __bindgen_tmp,
                mass,
                motionState,
                collisionShape,
                localInertia,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        ///
        #[link_name = "\u{1}_ZNK11btRigidBody28calculateSerializeBufferSizeEv"]
        pub fn btRigidBody_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK11btRigidBody9serializeEPvP12btSerializer"]
        pub fn btRigidBody_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btRigidBody21serializeSingleObjectEP12btSerializer"]
        pub fn btRigidBody_serializeSingleObject(
            this: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        );
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRigidBodyFloatData {
        pub m_collisionObjectData: root::btCollisionObjectFloatData,
        pub m_invInertiaTensorWorld: root::btMatrix3x3FloatData,
        pub m_linearVelocity: root::btVector3FloatData,
        pub m_angularVelocity: root::btVector3FloatData,
        pub m_angularFactor: root::btVector3FloatData,
        pub m_linearFactor: root::btVector3FloatData,
        pub m_gravity: root::btVector3FloatData,
        pub m_gravity_acceleration: root::btVector3FloatData,
        pub m_invInertiaLocal: root::btVector3FloatData,
        pub m_totalForce: root::btVector3FloatData,
        pub m_totalTorque: root::btVector3FloatData,
        pub m_inverseMass: f32,
        pub m_linearDamping: f32,
        pub m_angularDamping: f32,
        pub m_additionalDampingFactor: f32,
        pub m_additionalLinearDampingThresholdSqr: f32,
        pub m_additionalAngularDampingThresholdSqr: f32,
        pub m_additionalAngularDampingFactor: f32,
        pub m_linearSleepingThreshold: f32,
        pub m_angularSleepingThreshold: f32,
        pub m_additionalDamping: ::std::os::raw::c_int,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRigidBodyDoubleData {
        pub m_collisionObjectData: root::btCollisionObjectDoubleData,
        pub m_invInertiaTensorWorld: root::btMatrix3x3DoubleData,
        pub m_linearVelocity: root::btVector3DoubleData,
        pub m_angularVelocity: root::btVector3DoubleData,
        pub m_angularFactor: root::btVector3DoubleData,
        pub m_linearFactor: root::btVector3DoubleData,
        pub m_gravity: root::btVector3DoubleData,
        pub m_gravity_acceleration: root::btVector3DoubleData,
        pub m_invInertiaLocal: root::btVector3DoubleData,
        pub m_totalForce: root::btVector3DoubleData,
        pub m_totalTorque: root::btVector3DoubleData,
        pub m_inverseMass: f64,
        pub m_linearDamping: f64,
        pub m_angularDamping: f64,
        pub m_additionalDampingFactor: f64,
        pub m_additionalLinearDampingThresholdSqr: f64,
        pub m_additionalAngularDampingThresholdSqr: f64,
        pub m_additionalAngularDampingFactor: f64,
        pub m_linearSleepingThreshold: f64,
        pub m_angularSleepingThreshold: f64,
        pub m_additionalDamping: ::std::os::raw::c_int,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    /// Jacobian entry is an abstraction that allows to describe constraints
    /// it can be used in combination with a constraint solver
    /// Can be used to relate the effect of an impulse to the constraint error
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btJacobianEntry {
        pub m_linearJointAxis: root::btVector3,
        pub m_aJ: root::btVector3,
        pub m_bJ: root::btVector3,
        pub m_0MinvJt: root::btVector3,
        pub m_1MinvJt: root::btVector3,
        pub m_Adiag: root::btScalar,
    }
    /// The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSolverBody {
        pub m_worldTransform: root::btTransform,
        pub m_deltaLinearVelocity: root::btVector3,
        pub m_deltaAngularVelocity: root::btVector3,
        pub m_angularFactor: root::btVector3,
        pub m_linearFactor: root::btVector3,
        pub m_invMass: root::btVector3,
        pub m_pushVelocity: root::btVector3,
        pub m_turnVelocity: root::btVector3,
        pub m_linearVelocity: root::btVector3,
        pub m_angularVelocity: root::btVector3,
        pub m_externalForceImpulse: root::btVector3,
        pub m_externalTorqueImpulse: root::btVector3,
        pub m_originalBody: *mut root::btRigidBody,
    }
    /// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct btSolverConstraint {
        pub m_relpos1CrossNormal: root::btVector3,
        pub m_contactNormal1: root::btVector3,
        pub m_relpos2CrossNormal: root::btVector3,
        pub m_contactNormal2: root::btVector3,
        pub m_angularComponentA: root::btVector3,
        pub m_angularComponentB: root::btVector3,
        pub m_appliedPushImpulse: root::btScalar,
        pub m_appliedImpulse: root::btScalar,
        pub m_friction: root::btScalar,
        pub m_jacDiagABInv: root::btScalar,
        pub m_rhs: root::btScalar,
        pub m_cfm: root::btScalar,
        pub m_lowerLimit: root::btScalar,
        pub m_upperLimit: root::btScalar,
        pub m_rhsPenetration: root::btScalar,
        pub __bindgen_anon_1: root::btSolverConstraint__bindgen_ty_1,
        pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_frictionIndex: ::std::os::raw::c_int,
        pub m_solverBodyIdA: ::std::os::raw::c_int,
        pub m_solverBodyIdB: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btSolverConstraint__bindgen_ty_1 {
        pub m_originalContactPoint: *mut ::std::os::raw::c_void,
        pub m_unusedPadding4: root::btScalar,
        pub m_numRowsForNonContactConstraint: ::std::os::raw::c_int,
        _bindgen_union_align: u64,
    }
    pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_CONTACT_1D:
        root::btSolverConstraint_btSolverConstraintType = 0;
    pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_FRICTION_1D:
        root::btSolverConstraint_btSolverConstraintType = 1;
    pub type btSolverConstraint_btSolverConstraintType = u32;
    pub type btConstraintArray = root::btAlignedObjectArray<root::btSolverConstraint>;
    pub const btTypedConstraintType_POINT2POINT_CONSTRAINT_TYPE: root::btTypedConstraintType = 3;
    pub const btTypedConstraintType_HINGE_CONSTRAINT_TYPE: root::btTypedConstraintType = 4;
    pub const btTypedConstraintType_CONETWIST_CONSTRAINT_TYPE: root::btTypedConstraintType = 5;
    pub const btTypedConstraintType_D6_CONSTRAINT_TYPE: root::btTypedConstraintType = 6;
    pub const btTypedConstraintType_SLIDER_CONSTRAINT_TYPE: root::btTypedConstraintType = 7;
    pub const btTypedConstraintType_CONTACT_CONSTRAINT_TYPE: root::btTypedConstraintType = 8;
    pub const btTypedConstraintType_D6_SPRING_CONSTRAINT_TYPE: root::btTypedConstraintType = 9;
    pub const btTypedConstraintType_GEAR_CONSTRAINT_TYPE: root::btTypedConstraintType = 10;
    pub const btTypedConstraintType_FIXED_CONSTRAINT_TYPE: root::btTypedConstraintType = 11;
    pub const btTypedConstraintType_D6_SPRING_2_CONSTRAINT_TYPE: root::btTypedConstraintType = 12;
    pub const btTypedConstraintType_MAX_CONSTRAINT_TYPE: root::btTypedConstraintType = 13;
    pub type btTypedConstraintType = u32;
    pub const btConstraintParams_BT_CONSTRAINT_ERP: root::btConstraintParams = 1;
    pub const btConstraintParams_BT_CONSTRAINT_STOP_ERP: root::btConstraintParams = 2;
    pub const btConstraintParams_BT_CONSTRAINT_CFM: root::btConstraintParams = 3;
    pub const btConstraintParams_BT_CONSTRAINT_STOP_CFM: root::btConstraintParams = 4;
    pub type btConstraintParams = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btJointFeedback {
        pub m_appliedForceBodyA: root::btVector3,
        pub m_appliedTorqueBodyA: root::btVector3,
        pub m_appliedForceBodyB: root::btVector3,
        pub m_appliedTorqueBodyB: root::btVector3,
    }
    #[repr(C)]
    pub struct btTypedConstraint__bindgen_vtable(::std::os::raw::c_void);
    /// TypedConstraint is the baseclass for Bullet constraints and vehicles
    #[repr(C)]
    pub struct btTypedConstraint {
        pub vtable_: *const btTypedConstraint__bindgen_vtable,
        pub _base: root::btTypedObject,
        pub m_userConstraintType: ::std::os::raw::c_int,
        pub __bindgen_anon_1: root::btTypedConstraint__bindgen_ty_1,
        pub m_breakingImpulseThreshold: root::btScalar,
        pub m_isEnabled: bool,
        pub m_needsFeedback: bool,
        pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_rbA: *mut root::btRigidBody,
        pub m_rbB: *mut root::btRigidBody,
        pub m_appliedImpulse: root::btScalar,
        pub m_dbgDrawSize: root::btScalar,
        pub m_jointFeedback: *mut root::btJointFeedback,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union btTypedConstraint__bindgen_ty_1 {
        pub m_userConstraintId: ::std::os::raw::c_int,
        pub m_userConstraintPtr: *mut ::std::os::raw::c_void,
        _bindgen_union_align: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedConstraint_btConstraintInfo1 {
        pub m_numConstraintRows: ::std::os::raw::c_int,
        pub nub: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedConstraint_btConstraintInfo2 {
        pub fps: root::btScalar,
        pub erp: root::btScalar,
        pub m_J1linearAxis: *mut root::btScalar,
        pub m_J1angularAxis: *mut root::btScalar,
        pub m_J2linearAxis: *mut root::btScalar,
        pub m_J2angularAxis: *mut root::btScalar,
        pub rowskip: ::std::os::raw::c_int,
        pub m_constraintError: *mut root::btScalar,
        pub cfm: *mut root::btScalar,
        pub m_lowerLimit: *mut root::btScalar,
        pub m_upperLimit: *mut root::btScalar,
        pub m_numIterations: ::std::os::raw::c_int,
        pub m_damping: root::btScalar,
    }
    extern "C" {
        /// internal method used by the constraint solver, don't use them directly
        #[link_name = "\u{1}_ZN17btTypedConstraint14getMotorFactorEfffff"]
        pub fn btTypedConstraint_getMotorFactor(
            this: *mut root::btTypedConstraint,
            pos: root::btScalar,
            lowLim: root::btScalar,
            uppLim: root::btScalar,
            vel: root::btScalar,
            timeFact: root::btScalar,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btTypedConstraint12getFixedBodyEv"]
        pub fn btTypedConstraint_getFixedBody() -> *mut root::btRigidBody;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btTypedConstraintC2E21btTypedConstraintTypeR11btRigidBody"]
        pub fn btTypedConstraint_btTypedConstraint(
            this: *mut root::btTypedConstraint,
            type_: root::btTypedConstraintType,
            rbA: *mut root::btRigidBody,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btTypedConstraintC2E21btTypedConstraintTypeR11btRigidBodyS2_"]
        pub fn btTypedConstraint_btTypedConstraint1(
            this: *mut root::btTypedConstraint,
            type_: root::btTypedConstraintType,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
        );
    }
    impl btTypedConstraint {
        #[inline]
        pub unsafe fn getMotorFactor(
            &mut self,
            pos: root::btScalar,
            lowLim: root::btScalar,
            uppLim: root::btScalar,
            vel: root::btScalar,
            timeFact: root::btScalar,
        ) -> root::btScalar {
            btTypedConstraint_getMotorFactor(self, pos, lowLim, uppLim, vel, timeFact)
        }
        #[inline]
        pub unsafe fn getFixedBody() -> *mut root::btRigidBody {
            btTypedConstraint_getFixedBody()
        }
        #[inline]
        pub unsafe fn new(type_: root::btTypedConstraintType, rbA: *mut root::btRigidBody) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btTypedConstraint_btTypedConstraint(&mut __bindgen_tmp, type_, rbA);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            type_: root::btTypedConstraintType,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btTypedConstraint_btTypedConstraint1(&mut __bindgen_tmp, type_, rbA, rbB);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btTypedConstraint28calculateSerializeBufferSizeEv"]
        pub fn btTypedConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK17btTypedConstraint9serializeEPvP12btSerializer"]
        pub fn btTypedConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedConstraintFloatData {
        pub m_rbA: *mut root::btRigidBodyFloatData,
        pub m_rbB: *mut root::btRigidBodyFloatData,
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_objectType: ::std::os::raw::c_int,
        pub m_userConstraintType: ::std::os::raw::c_int,
        pub m_userConstraintId: ::std::os::raw::c_int,
        pub m_needsFeedback: ::std::os::raw::c_int,
        pub m_appliedImpulse: f32,
        pub m_dbgDrawSize: f32,
        pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
        pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_breakingImpulseThreshold: f32,
        pub m_isEnabled: ::std::os::raw::c_int,
    }
    /// this structure is not used, except for loading pre-2.82 .bullet files
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedConstraintData {
        pub m_rbA: *mut root::btRigidBodyFloatData,
        pub m_rbB: *mut root::btRigidBodyFloatData,
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_objectType: ::std::os::raw::c_int,
        pub m_userConstraintType: ::std::os::raw::c_int,
        pub m_userConstraintId: ::std::os::raw::c_int,
        pub m_needsFeedback: ::std::os::raw::c_int,
        pub m_appliedImpulse: f32,
        pub m_dbgDrawSize: f32,
        pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
        pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_breakingImpulseThreshold: f32,
        pub m_isEnabled: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTypedConstraintDoubleData {
        pub m_rbA: *mut root::btRigidBodyDoubleData,
        pub m_rbB: *mut root::btRigidBodyDoubleData,
        pub m_name: *mut ::std::os::raw::c_char,
        pub m_objectType: ::std::os::raw::c_int,
        pub m_userConstraintType: ::std::os::raw::c_int,
        pub m_userConstraintId: ::std::os::raw::c_int,
        pub m_needsFeedback: ::std::os::raw::c_int,
        pub m_appliedImpulse: f64,
        pub m_dbgDrawSize: f64,
        pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
        pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_breakingImpulseThreshold: f64,
        pub m_isEnabled: ::std::os::raw::c_int,
        pub padding: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btAngularLimit {
        pub m_center: root::btScalar,
        pub m_halfRange: root::btScalar,
        pub m_softness: root::btScalar,
        pub m_biasFactor: root::btScalar,
        pub m_relaxationFactor: root::btScalar,
        pub m_correction: root::btScalar,
        pub m_sign: root::btScalar,
        pub m_solveLimit: bool,
    }
    extern "C" {
        /// Sets all limit's parameters.
        /// /// When low > high limit becomes inactive.
        /// /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
        #[link_name = "\u{1}_ZN14btAngularLimit3setEfffff"]
        pub fn btAngularLimit_set(
            this: *mut root::btAngularLimit,
            low: root::btScalar,
            high: root::btScalar,
            _softness: root::btScalar,
            _biasFactor: root::btScalar,
            _relaxationFactor: root::btScalar,
        );
    }
    extern "C" {
        /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
        /// /// correction is calculated.
        #[link_name = "\u{1}_ZN14btAngularLimit4testEf"]
        pub fn btAngularLimit_test(this: *mut root::btAngularLimit, angle: root::btScalar);
    }
    extern "C" {
        /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
        /// /// returned is modified so it equals to the limit closest to given angle.
        #[link_name = "\u{1}_ZNK14btAngularLimit3fitERf"]
        pub fn btAngularLimit_fit(this: *const root::btAngularLimit, angle: *mut root::btScalar);
    }
    extern "C" {
        /// Returns correction value multiplied by sign value
        #[link_name = "\u{1}_ZNK14btAngularLimit8getErrorEv"]
        pub fn btAngularLimit_getError(this: *const root::btAngularLimit) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btAngularLimit6getLowEv"]
        pub fn btAngularLimit_getLow(this: *const root::btAngularLimit) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK14btAngularLimit7getHighEv"]
        pub fn btAngularLimit_getHigh(this: *const root::btAngularLimit) -> root::btScalar;
    }
    impl btAngularLimit {
        #[inline]
        pub unsafe fn set(
            &mut self,
            low: root::btScalar,
            high: root::btScalar,
            _softness: root::btScalar,
            _biasFactor: root::btScalar,
            _relaxationFactor: root::btScalar,
        ) {
            btAngularLimit_set(self, low, high, _softness, _biasFactor, _relaxationFactor)
        }
        #[inline]
        pub unsafe fn test(&mut self, angle: root::btScalar) {
            btAngularLimit_test(self, angle)
        }
        #[inline]
        pub unsafe fn fit(&self, angle: *mut root::btScalar) {
            btAngularLimit_fit(self, angle)
        }
        #[inline]
        pub unsafe fn getError(&self) -> root::btScalar {
            btAngularLimit_getError(self)
        }
        #[inline]
        pub unsafe fn getLow(&self) -> root::btScalar {
            btAngularLimit_getLow(self)
        }
        #[inline]
        pub unsafe fn getHigh(&self) -> root::btScalar {
            btAngularLimit_getHigh(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConstraintSetting {
        pub m_tau: root::btScalar,
        pub m_damping: root::btScalar,
        pub m_impulseClamp: root::btScalar,
    }
    pub const btPoint2PointFlags_BT_P2P_FLAGS_ERP: root::btPoint2PointFlags = 1;
    pub const btPoint2PointFlags_BT_P2P_FLAGS_CFM: root::btPoint2PointFlags = 2;
    pub type btPoint2PointFlags = u32;
    /// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
    #[repr(C)]
    pub struct btPoint2PointConstraint {
        pub _base: root::btTypedConstraint,
        pub m_jac: [root::btJacobianEntry; 3usize],
        pub m_pivotInA: root::btVector3,
        pub m_pivotInB: root::btVector3,
        pub m_flags: ::std::os::raw::c_int,
        pub m_erp: root::btScalar,
        pub m_cfm: root::btScalar,
        /// for backwards compatibility during the transition to 'getInfo/getInfo2'
        pub m_useSolveConstraintObsolete: bool,
        pub m_setting: root::btConstraintSetting,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btPoint2PointConstraint_getInfo1NonVirtual(
            this: *mut root::btPoint2PointConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_"]
        pub fn btPoint2PointConstraint_getInfo2NonVirtual(
            this: *mut root::btPoint2PointConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            body0_trans: *const root::btTransform,
            body1_trans: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint9updateRHSEf"]
        pub fn btPoint2PointConstraint_updateRHS(
            this: *mut root::btPoint2PointConstraint,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_"]
        pub fn btPoint2PointConstraint_btPoint2PointConstraint(
            this: *mut root::btPoint2PointConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            pivotInB: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3"]
        pub fn btPoint2PointConstraint_btPoint2PointConstraint1(
            this: *mut root::btPoint2PointConstraint,
            rbA: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
        );
    }
    impl btPoint2PointConstraint {
        #[inline]
        pub unsafe fn getInfo1NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        ) {
            btPoint2PointConstraint_getInfo1NonVirtual(self, info)
        }
        #[inline]
        pub unsafe fn getInfo2NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            body0_trans: *const root::btTransform,
            body1_trans: *const root::btTransform,
        ) {
            btPoint2PointConstraint_getInfo2NonVirtual(self, info, body0_trans, body1_trans)
        }
        #[inline]
        pub unsafe fn updateRHS(&mut self, timeStep: root::btScalar) {
            btPoint2PointConstraint_updateRHS(self, timeStep)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            pivotInB: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btPoint2PointConstraint_btPoint2PointConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                pivotInA,
                pivotInB,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(rbA: *mut root::btRigidBody, pivotInA: *const root::btVector3) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btPoint2PointConstraint_btPoint2PointConstraint1(&mut __bindgen_tmp, rbA, pivotInA);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint13buildJacobianEv"]
        pub fn btPoint2PointConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btPoint2PointConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btPoint2PointConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
        /// ///If no axis is provided, it uses the default axis for this constraint.
        #[link_name = "\u{1}_ZN23btPoint2PointConstraint8setParamEifi"]
        pub fn btPoint2PointConstraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// return the local value of parameter
        #[link_name = "\u{1}_ZNK23btPoint2PointConstraint8getParamEii"]
        pub fn btPoint2PointConstraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btPoint2PointConstraint28calculateSerializeBufferSizeEv"]
        pub fn btPoint2PointConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK23btPoint2PointConstraint9serializeEPvP12btSerializer"]
        pub fn btPoint2PointConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPoint2PointConstraintFloatData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_pivotInA: root::btVector3FloatData,
        pub m_pivotInB: root::btVector3FloatData,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPoint2PointConstraintDoubleData2 {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_pivotInA: root::btVector3DoubleData,
        pub m_pivotInB: root::btVector3DoubleData,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    /// this structure is not used, except for loading pre-2.82 .bullet files
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btPoint2PointConstraintDoubleData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_pivotInA: root::btVector3DoubleData,
        pub m_pivotInB: root::btVector3DoubleData,
    }
    pub const btHingeFlags_BT_HINGE_FLAGS_CFM_STOP: root::btHingeFlags = 1;
    pub const btHingeFlags_BT_HINGE_FLAGS_ERP_STOP: root::btHingeFlags = 2;
    pub const btHingeFlags_BT_HINGE_FLAGS_CFM_NORM: root::btHingeFlags = 4;
    pub const btHingeFlags_BT_HINGE_FLAGS_ERP_NORM: root::btHingeFlags = 8;
    pub type btHingeFlags = u32;
    /// hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
    /// axis defines the orientation of the hinge axis
    #[repr(C)]
    pub struct btHingeConstraint {
        pub _base: root::btTypedConstraint,
        pub m_jac: [root::btJacobianEntry; 3usize],
        pub m_jacAng: [root::btJacobianEntry; 3usize],
        pub m_rbAFrame: root::btTransform,
        pub m_rbBFrame: root::btTransform,
        pub m_motorTargetVelocity: root::btScalar,
        pub m_maxMotorImpulse: root::btScalar,
        pub m_limit: root::btAngularLimit,
        pub m_kHinge: root::btScalar,
        pub m_accLimitImpulse: root::btScalar,
        pub m_hingeAngle: root::btScalar,
        pub m_referenceSign: root::btScalar,
        pub m_angularOnly: bool,
        pub m_enableAngularMotor: bool,
        pub m_useSolveConstraintObsolete: bool,
        pub m_useOffsetForConstraintFrame: bool,
        pub m_useReferenceFrameA: bool,
        pub m_accMotorImpulse: root::btScalar,
        pub m_flags: ::std::os::raw::c_int,
        pub m_normalCFM: root::btScalar,
        pub m_normalERP: root::btScalar,
        pub m_stopCFM: root::btScalar,
        pub m_stopERP: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btHingeConstraint_getInfo1NonVirtual(
            this: *mut root::btHingeConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
        pub fn btHingeConstraint_getInfo2NonVirtual(
            this: *mut root::btHingeConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint16getInfo2InternalEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
        pub fn btHingeConstraint_getInfo2Internal(
            this: *mut root::btHingeConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint32getInfo2InternalUsingFrameOffsetEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
        pub fn btHingeConstraint_getInfo2InternalUsingFrameOffset(
            this: *mut root::btHingeConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint9updateRHSEf"]
        pub fn btHingeConstraint_updateRHS(
            this: *mut root::btHingeConstraint,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint9setFramesERK11btTransformS2_"]
        pub fn btHingeConstraint_setFrames(
            this: *mut root::btHingeConstraint,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint14setMotorTargetERK12btQuaternionf"]
        pub fn btHingeConstraint_setMotorTarget(
            this: *mut root::btHingeConstraint,
            qAinB: *const root::btQuaternion,
            dt: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint14setMotorTargetEff"]
        pub fn btHingeConstraint_setMotorTarget1(
            this: *mut root::btHingeConstraint,
            targetAngle: root::btScalar,
            dt: root::btScalar,
        );
    }
    extern "C" {
        /// The getHingeAngle gives the hinge angle in range [-PI,PI]
        #[link_name = "\u{1}_ZN17btHingeConstraint13getHingeAngleEv"]
        pub fn btHingeConstraint_getHingeAngle(
            this: *mut root::btHingeConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint13getHingeAngleERK11btTransformS2_"]
        pub fn btHingeConstraint_getHingeAngle1(
            this: *mut root::btHingeConstraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint9testLimitERK11btTransformS2_"]
        pub fn btHingeConstraint_testLimit(
            this: *mut root::btHingeConstraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b"]
        pub fn btHingeConstraint_btHingeConstraint(
            this: *mut root::btHingeConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            pivotInB: *const root::btVector3,
            axisInA: *const root::btVector3,
            axisInB: *const root::btVector3,
            useReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyRK9btVector3S4_b"]
        pub fn btHingeConstraint_btHingeConstraint1(
            this: *mut root::btHingeConstraint,
            rbA: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            axisInA: *const root::btVector3,
            useReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
        pub fn btHingeConstraint_btHingeConstraint2(
            this: *mut root::btHingeConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            rbBFrame: *const root::btTransform,
            useReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb"]
        pub fn btHingeConstraint_btHingeConstraint3(
            this: *mut root::btHingeConstraint,
            rbA: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            useReferenceFrameA: bool,
        );
    }
    impl btHingeConstraint {
        #[inline]
        pub unsafe fn getInfo1NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        ) {
            btHingeConstraint_getInfo1NonVirtual(self, info)
        }
        #[inline]
        pub unsafe fn getInfo2NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) {
            btHingeConstraint_getInfo2NonVirtual(self, info, transA, transB, angVelA, angVelB)
        }
        #[inline]
        pub unsafe fn getInfo2Internal(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) {
            btHingeConstraint_getInfo2Internal(self, info, transA, transB, angVelA, angVelB)
        }
        #[inline]
        pub unsafe fn getInfo2InternalUsingFrameOffset(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) {
            btHingeConstraint_getInfo2InternalUsingFrameOffset(
                self, info, transA, transB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn updateRHS(&mut self, timeStep: root::btScalar) {
            btHingeConstraint_updateRHS(self, timeStep)
        }
        #[inline]
        pub unsafe fn setFrames(
            &mut self,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        ) {
            btHingeConstraint_setFrames(self, frameA, frameB)
        }
        #[inline]
        pub unsafe fn setMotorTarget(
            &mut self,
            qAinB: *const root::btQuaternion,
            dt: root::btScalar,
        ) {
            btHingeConstraint_setMotorTarget(self, qAinB, dt)
        }
        #[inline]
        pub unsafe fn setMotorTarget1(&mut self, targetAngle: root::btScalar, dt: root::btScalar) {
            btHingeConstraint_setMotorTarget1(self, targetAngle, dt)
        }
        #[inline]
        pub unsafe fn getHingeAngle(&mut self) -> root::btScalar {
            btHingeConstraint_getHingeAngle(self)
        }
        #[inline]
        pub unsafe fn getHingeAngle1(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) -> root::btScalar {
            btHingeConstraint_getHingeAngle1(self, transA, transB)
        }
        #[inline]
        pub unsafe fn testLimit(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) {
            btHingeConstraint_testLimit(self, transA, transB)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            pivotInB: *const root::btVector3,
            axisInA: *const root::btVector3,
            axisInB: *const root::btVector3,
            useReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHingeConstraint_btHingeConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                pivotInA,
                pivotInB,
                axisInA,
                axisInB,
                useReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbA: *mut root::btRigidBody,
            pivotInA: *const root::btVector3,
            axisInA: *const root::btVector3,
            useReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHingeConstraint_btHingeConstraint1(
                &mut __bindgen_tmp,
                rbA,
                pivotInA,
                axisInA,
                useReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            rbBFrame: *const root::btTransform,
            useReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHingeConstraint_btHingeConstraint2(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                rbAFrame,
                rbBFrame,
                useReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(
            rbA: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            useReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHingeConstraint_btHingeConstraint3(
                &mut __bindgen_tmp,
                rbA,
                rbAFrame,
                useReferenceFrameA,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint13buildJacobianEv"]
        pub fn btHingeConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btHingeConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btHingeConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btHingeConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
        /// ///If no axis is provided, it uses the default axis for this constraint.
        #[link_name = "\u{1}_ZN17btHingeConstraint8setParamEifi"]
        pub fn btHingeConstraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// return the local value of parameter
        #[link_name = "\u{1}_ZNK17btHingeConstraint8getParamEii"]
        pub fn btHingeConstraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK17btHingeConstraint28calculateSerializeBufferSizeEv"]
        pub fn btHingeConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK17btHingeConstraint9serializeEPvP12btSerializer"]
        pub fn btHingeConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// this structure is not used, except for loading pre-2.82 .bullet files
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHingeConstraintDoubleData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_useReferenceFrameA: ::std::os::raw::c_int,
        pub m_angularOnly: ::std::os::raw::c_int,
        pub m_enableAngularMotor: ::std::os::raw::c_int,
        pub m_motorTargetVelocity: f32,
        pub m_maxMotorImpulse: f32,
        pub m_lowerLimit: f32,
        pub m_upperLimit: f32,
        pub m_limitSoftness: f32,
        pub m_biasFactor: f32,
        pub m_relaxationFactor: f32,
    }
    /// The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account
    #[repr(C)]
    pub struct btHingeAccumulatedAngleConstraint {
        pub _base: root::btHingeConstraint,
        pub m_accumulatedAngle: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint24getAccumulatedHingeAngleEv"]
        pub fn btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(
            this: *mut root::btHingeAccumulatedAngleConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint24setAccumulatedHingeAngleEf"]
        pub fn btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(
            this: *mut root::btHingeAccumulatedAngleConstraint,
            accAngle: root::btScalar,
        );
    }
    impl btHingeAccumulatedAngleConstraint {
        #[inline]
        pub unsafe fn getAccumulatedHingeAngle(&mut self) -> root::btScalar {
            btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(self)
        }
        #[inline]
        pub unsafe fn setAccumulatedHingeAngle(&mut self, accAngle: root::btScalar) {
            btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(self, accAngle)
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btHingeAccumulatedAngleConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHingeConstraintFloatData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformFloatData,
        pub m_rbBFrame: root::btTransformFloatData,
        pub m_useReferenceFrameA: ::std::os::raw::c_int,
        pub m_angularOnly: ::std::os::raw::c_int,
        pub m_enableAngularMotor: ::std::os::raw::c_int,
        pub m_motorTargetVelocity: f32,
        pub m_maxMotorImpulse: f32,
        pub m_lowerLimit: f32,
        pub m_upperLimit: f32,
        pub m_limitSoftness: f32,
        pub m_biasFactor: f32,
        pub m_relaxationFactor: f32,
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btHingeConstraintDoubleData2 {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_useReferenceFrameA: ::std::os::raw::c_int,
        pub m_angularOnly: ::std::os::raw::c_int,
        pub m_enableAngularMotor: ::std::os::raw::c_int,
        pub m_motorTargetVelocity: f64,
        pub m_maxMotorImpulse: f64,
        pub m_lowerLimit: f64,
        pub m_upperLimit: f64,
        pub m_limitSoftness: f64,
        pub m_biasFactor: f64,
        pub m_relaxationFactor: f64,
        pub m_padding1: [::std::os::raw::c_char; 4usize],
    }
    pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_CFM: root::btConeTwistFlags = 1;
    pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_ERP: root::btConeTwistFlags = 2;
    pub const btConeTwistFlags_BT_CONETWIST_FLAGS_ANG_CFM: root::btConeTwistFlags = 4;
    pub type btConeTwistFlags = u32;
    /// btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
    #[repr(C)]
    pub struct btConeTwistConstraint {
        pub _base: root::btTypedConstraint,
        pub m_jac: [root::btJacobianEntry; 3usize],
        pub m_rbAFrame: root::btTransform,
        pub m_rbBFrame: root::btTransform,
        pub m_limitSoftness: root::btScalar,
        pub m_biasFactor: root::btScalar,
        pub m_relaxationFactor: root::btScalar,
        pub m_damping: root::btScalar,
        pub m_swingSpan1: root::btScalar,
        pub m_swingSpan2: root::btScalar,
        pub m_twistSpan: root::btScalar,
        pub m_fixThresh: root::btScalar,
        pub m_swingAxis: root::btVector3,
        pub m_twistAxis: root::btVector3,
        pub m_kSwing: root::btScalar,
        pub m_kTwist: root::btScalar,
        pub m_twistLimitSign: root::btScalar,
        pub m_swingCorrection: root::btScalar,
        pub m_twistCorrection: root::btScalar,
        pub m_twistAngle: root::btScalar,
        pub m_accSwingLimitImpulse: root::btScalar,
        pub m_accTwistLimitImpulse: root::btScalar,
        pub m_angularOnly: bool,
        pub m_solveTwistLimit: bool,
        pub m_solveSwingLimit: bool,
        pub m_useSolveConstraintObsolete: bool,
        pub m_swingLimitRatio: root::btScalar,
        pub m_twistLimitRatio: root::btScalar,
        pub m_twistAxisA: root::btVector3,
        pub m_bMotorEnabled: bool,
        pub m_bNormalizedMotorStrength: bool,
        pub m_qTarget: root::btQuaternion,
        pub m_maxMotorImpulse: root::btScalar,
        pub m_accMotorImpulse: root::btVector3,
        pub m_flags: ::std::os::raw::c_int,
        pub m_linCFM: root::btScalar,
        pub m_linERP: root::btScalar,
        pub m_angCFM: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint4initEv"]
        pub fn btConeTwistConstraint_init(this: *mut root::btConeTwistConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint20computeConeLimitInfoERK12btQuaternionRfR9btVector3S3_"]
        pub fn btConeTwistConstraint_computeConeLimitInfo(
            this: *mut root::btConeTwistConstraint,
            qCone: *const root::btQuaternion,
            swingAngle: *mut root::btScalar,
            vSwingAxis: *mut root::btVector3,
            swingLimit: *mut root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint21computeTwistLimitInfoERK12btQuaternionRfR9btVector3"]
        pub fn btConeTwistConstraint_computeTwistLimitInfo(
            this: *mut root::btConeTwistConstraint,
            qTwist: *const root::btQuaternion,
            twistAngle: *mut root::btScalar,
            vTwistAxis: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConeTwistConstraint33adjustSwingAxisToUseEllipseNormalER9btVector3"]
        pub fn btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(
            this: *const root::btConeTwistConstraint,
            vSwingAxis: *mut root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btConeTwistConstraint_getInfo1NonVirtual(
            this: *mut root::btConeTwistConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK11btMatrix3x3S8_"]
        pub fn btConeTwistConstraint_getInfo2NonVirtual(
            this: *mut root::btConeTwistConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            invInertiaWorldA: *const root::btMatrix3x3,
            invInertiaWorldB: *const root::btMatrix3x3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint9updateRHSEf"]
        pub fn btConeTwistConstraint_updateRHS(
            this: *mut root::btConeTwistConstraint,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint13calcAngleInfoEv"]
        pub fn btConeTwistConstraint_calcAngleInfo(this: *mut root::btConeTwistConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint14calcAngleInfo2ERK11btTransformS2_RK11btMatrix3x3S5_"]
        pub fn btConeTwistConstraint_calcAngleInfo2(
            this: *mut root::btConeTwistConstraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            invInertiaWorldA: *const root::btMatrix3x3,
            invInertiaWorldB: *const root::btMatrix3x3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion"]
        pub fn btConeTwistConstraint_setMotorTarget(
            this: *mut root::btConeTwistConstraint,
            q: *const root::btQuaternion,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion"]
        pub fn btConeTwistConstraint_setMotorTargetInConstraintSpace(
            this: *mut root::btConeTwistConstraint,
            q: *const root::btQuaternion,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConeTwistConstraint16GetPointForAngleEff"]
        pub fn btConeTwistConstraint_GetPointForAngle(
            this: *const root::btConeTwistConstraint,
            fAngleInRadians: root::btScalar,
            fLength: root::btScalar,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_"]
        pub fn btConeTwistConstraint_btConeTwistConstraint(
            this: *mut root::btConeTwistConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            rbBFrame: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform"]
        pub fn btConeTwistConstraint_btConeTwistConstraint1(
            this: *mut root::btConeTwistConstraint,
            rbA: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
        );
    }
    impl btConeTwistConstraint {
        #[inline]
        pub unsafe fn init(&mut self) {
            btConeTwistConstraint_init(self)
        }
        #[inline]
        pub unsafe fn computeConeLimitInfo(
            &mut self,
            qCone: *const root::btQuaternion,
            swingAngle: *mut root::btScalar,
            vSwingAxis: *mut root::btVector3,
            swingLimit: *mut root::btScalar,
        ) {
            btConeTwistConstraint_computeConeLimitInfo(
                self, qCone, swingAngle, vSwingAxis, swingLimit,
            )
        }
        #[inline]
        pub unsafe fn computeTwistLimitInfo(
            &mut self,
            qTwist: *const root::btQuaternion,
            twistAngle: *mut root::btScalar,
            vTwistAxis: *mut root::btVector3,
        ) {
            btConeTwistConstraint_computeTwistLimitInfo(self, qTwist, twistAngle, vTwistAxis)
        }
        #[inline]
        pub unsafe fn adjustSwingAxisToUseEllipseNormal(&self, vSwingAxis: *mut root::btVector3) {
            btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(self, vSwingAxis)
        }
        #[inline]
        pub unsafe fn getInfo1NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        ) {
            btConeTwistConstraint_getInfo1NonVirtual(self, info)
        }
        #[inline]
        pub unsafe fn getInfo2NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            invInertiaWorldA: *const root::btMatrix3x3,
            invInertiaWorldB: *const root::btMatrix3x3,
        ) {
            btConeTwistConstraint_getInfo2NonVirtual(
                self,
                info,
                transA,
                transB,
                invInertiaWorldA,
                invInertiaWorldB,
            )
        }
        #[inline]
        pub unsafe fn updateRHS(&mut self, timeStep: root::btScalar) {
            btConeTwistConstraint_updateRHS(self, timeStep)
        }
        #[inline]
        pub unsafe fn calcAngleInfo(&mut self) {
            btConeTwistConstraint_calcAngleInfo(self)
        }
        #[inline]
        pub unsafe fn calcAngleInfo2(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            invInertiaWorldA: *const root::btMatrix3x3,
            invInertiaWorldB: *const root::btMatrix3x3,
        ) {
            btConeTwistConstraint_calcAngleInfo2(
                self,
                transA,
                transB,
                invInertiaWorldA,
                invInertiaWorldB,
            )
        }
        #[inline]
        pub unsafe fn setMotorTarget(&mut self, q: *const root::btQuaternion) {
            btConeTwistConstraint_setMotorTarget(self, q)
        }
        #[inline]
        pub unsafe fn setMotorTargetInConstraintSpace(&mut self, q: *const root::btQuaternion) {
            btConeTwistConstraint_setMotorTargetInConstraintSpace(self, q)
        }
        #[inline]
        pub unsafe fn GetPointForAngle(
            &self,
            fAngleInRadians: root::btScalar,
            fLength: root::btScalar,
        ) -> root::btVector3 {
            btConeTwistConstraint_GetPointForAngle(self, fAngleInRadians, fLength)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
            rbBFrame: *const root::btTransform,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConeTwistConstraint_btConeTwistConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                rbAFrame,
                rbBFrame,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbA: *mut root::btRigidBody,
            rbAFrame: *const root::btTransform,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btConeTwistConstraint_btConeTwistConstraint1(&mut __bindgen_tmp, rbA, rbAFrame);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint13buildJacobianEv"]
        pub fn btConeTwistConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btConeTwistConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btConeTwistConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint23solveConstraintObsoleteER12btSolverBodyS1_f"]
        pub fn btConeTwistConstraint_solveConstraintObsolete(
            this: *mut ::std::os::raw::c_void,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
        /// ///If no axis is provided, it uses the default axis for this constraint.
        #[link_name = "\u{1}_ZN21btConeTwistConstraint8setParamEifi"]
        pub fn btConeTwistConstraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btConeTwistConstraint9setFramesERK11btTransformS2_"]
        pub fn btConeTwistConstraint_setFrames(
            this: *mut ::std::os::raw::c_void,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        );
    }
    extern "C" {
        /// return the local value of parameter
        #[link_name = "\u{1}_ZNK21btConeTwistConstraint8getParamEii"]
        pub fn btConeTwistConstraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK21btConeTwistConstraint28calculateSerializeBufferSizeEv"]
        pub fn btConeTwistConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK21btConeTwistConstraint9serializeEPvP12btSerializer"]
        pub fn btConeTwistConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConeTwistConstraintDoubleData {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_swingSpan1: f64,
        pub m_swingSpan2: f64,
        pub m_twistSpan: f64,
        pub m_limitSoftness: f64,
        pub m_biasFactor: f64,
        pub m_relaxationFactor: f64,
        pub m_damping: f64,
    }
    /// this structure is not used, except for loading pre-2.82 .bullet files
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btConeTwistConstraintData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformFloatData,
        pub m_rbBFrame: root::btTransformFloatData,
        pub m_swingSpan1: f32,
        pub m_swingSpan2: f32,
        pub m_twistSpan: f32,
        pub m_limitSoftness: f32,
        pub m_biasFactor: f32,
        pub m_relaxationFactor: f32,
        pub m_damping: f32,
        pub m_pad: [::std::os::raw::c_char; 4usize],
    }
    /// ! Rotation Limit structure for generic joints
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRotationalLimitMotor {
        /// !< joint limit
        pub m_loLimit: root::btScalar,
        /// !< joint limit
        pub m_hiLimit: root::btScalar,
        /// !< target motor velocity
        pub m_targetVelocity: root::btScalar,
        /// !< max force on motor
        pub m_maxMotorForce: root::btScalar,
        /// !< max force on limit
        pub m_maxLimitForce: root::btScalar,
        /// !< Damping.
        pub m_damping: root::btScalar,
        pub m_limitSoftness: root::btScalar,
        /// !< Constraint force mixing factor
        pub m_normalCFM: root::btScalar,
        /// !< Error tolerance factor when joint is at limit
        pub m_stopERP: root::btScalar,
        /// !< Constraint force mixing factor when joint is at limit
        pub m_stopCFM: root::btScalar,
        /// !< restitution factor
        pub m_bounce: root::btScalar,
        pub m_enableMotor: bool,
        /// ! temp_variables
        /// //!@{
        pub m_currentLimitError: root::btScalar,
        /// !  How much is violated this limit
        pub m_currentPosition: root::btScalar,
        /// !< 0=free, 1=at lo limit, 2=at hi limit
        pub m_currentLimit: ::std::os::raw::c_int,
        pub m_accumulatedImpulse: root::btScalar,
    }
    extern "C" {
        /// ! calculates  error
        /// /*!
        /// calculates m_currentLimit and m_currentLimitError.
        /// */
        #[link_name = "\u{1}_ZN22btRotationalLimitMotor14testLimitValueEf"]
        pub fn btRotationalLimitMotor_testLimitValue(
            this: *mut root::btRotationalLimitMotor,
            test_value: root::btScalar,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// ! apply the correction impulses for two bodies
        #[link_name = "\u{1}_ZN22btRotationalLimitMotor18solveAngularLimitsEfR9btVector3fP11btRigidBodyS3_"]
        pub fn btRotationalLimitMotor_solveAngularLimits(
            this: *mut root::btRotationalLimitMotor,
            timeStep: root::btScalar,
            axis: *mut root::btVector3,
            jacDiagABInv: root::btScalar,
            body0: *mut root::btRigidBody,
            body1: *mut root::btRigidBody,
        ) -> root::btScalar;
    }
    impl btRotationalLimitMotor {
        #[inline]
        pub unsafe fn testLimitValue(
            &mut self,
            test_value: root::btScalar,
        ) -> ::std::os::raw::c_int {
            btRotationalLimitMotor_testLimitValue(self, test_value)
        }
        #[inline]
        pub unsafe fn solveAngularLimits(
            &mut self,
            timeStep: root::btScalar,
            axis: *mut root::btVector3,
            jacDiagABInv: root::btScalar,
            body0: *mut root::btRigidBody,
            body1: *mut root::btRigidBody,
        ) -> root::btScalar {
            btRotationalLimitMotor_solveAngularLimits(
                self,
                timeStep,
                axis,
                jacDiagABInv,
                body0,
                body1,
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTranslationalLimitMotor {
        /// !< the constraint lower limits
        pub m_lowerLimit: root::btVector3,
        /// !< the constraint upper limits
        pub m_upperLimit: root::btVector3,
        pub m_accumulatedImpulse: root::btVector3,
        /// !< Softness for linear limit
        pub m_limitSoftness: root::btScalar,
        /// !< Damping for linear limit
        pub m_damping: root::btScalar,
        pub m_restitution: root::btScalar,
        /// !< Constraint force mixing factor
        pub m_normalCFM: root::btVector3,
        /// !< Error tolerance factor when joint is at limit
        pub m_stopERP: root::btVector3,
        /// !< Constraint force mixing factor when joint is at limit
        pub m_stopCFM: root::btVector3,
        /// !@}
        pub m_enableMotor: [bool; 3usize],
        /// !< target motor velocity
        pub m_targetVelocity: root::btVector3,
        /// !< max force on motor
        pub m_maxMotorForce: root::btVector3,
        pub m_currentLimitError: root::btVector3,
        /// !  How much is violated this limit
        pub m_currentLinearDiff: root::btVector3,
        /// !< 0=free, 1=at lower limit, 2=at upper limit
        pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    }
    extern "C" {
        #[link_name = "\u{1}_ZN25btTranslationalLimitMotor14testLimitValueEif"]
        pub fn btTranslationalLimitMotor_testLimitValue(
            this: *mut root::btTranslationalLimitMotor,
            limitIndex: ::std::os::raw::c_int,
            test_value: root::btScalar,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN25btTranslationalLimitMotor15solveLinearAxisEffR11btRigidBodyRK9btVector3S1_S4_iS4_S4_"]
        pub fn btTranslationalLimitMotor_solveLinearAxis(
            this: *mut root::btTranslationalLimitMotor,
            timeStep: root::btScalar,
            jacDiagABInv: root::btScalar,
            body1: *mut root::btRigidBody,
            pointInA: *const root::btVector3,
            body2: *mut root::btRigidBody,
            pointInB: *const root::btVector3,
            limit_index: ::std::os::raw::c_int,
            axis_normal_on_a: *const root::btVector3,
            anchorPos: *const root::btVector3,
        ) -> root::btScalar;
    }
    impl btTranslationalLimitMotor {
        #[inline]
        pub unsafe fn testLimitValue(
            &mut self,
            limitIndex: ::std::os::raw::c_int,
            test_value: root::btScalar,
        ) -> ::std::os::raw::c_int {
            btTranslationalLimitMotor_testLimitValue(self, limitIndex, test_value)
        }
        #[inline]
        pub unsafe fn solveLinearAxis(
            &mut self,
            timeStep: root::btScalar,
            jacDiagABInv: root::btScalar,
            body1: *mut root::btRigidBody,
            pointInA: *const root::btVector3,
            body2: *mut root::btRigidBody,
            pointInB: *const root::btVector3,
            limit_index: ::std::os::raw::c_int,
            axis_normal_on_a: *const root::btVector3,
            anchorPos: *const root::btVector3,
        ) -> root::btScalar {
            btTranslationalLimitMotor_solveLinearAxis(
                self,
                timeStep,
                jacDiagABInv,
                body1,
                pointInA,
                body2,
                pointInB,
                limit_index,
                axis_normal_on_a,
                anchorPos,
            )
        }
    }
    pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_NORM: root::bt6DofFlags = 1;
    pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_STOP: root::bt6DofFlags = 2;
    pub const bt6DofFlags_BT_6DOF_FLAGS_ERP_STOP: root::bt6DofFlags = 4;
    pub type bt6DofFlags = u32;
    /// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
    /// *!
    /// btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
    /// currently this limit supports rotational motors<br>
    /// <ul>
    /// <li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
    /// At this moment translational motors are not supported. May be in the future. </li>
    ///
    /// <li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
    /// This is accessible through btGeneric6DofConstraint.getLimitMotor method,
    /// This brings support for limit parameters and motors. </li>
    ///
    /// <li> Angulars limits have these possible ranges:
    /// <table border=1 >
    /// <tr>
    /// <td><b>AXIS</b></td>
    /// <td><b>MIN ANGLE</b></td>
    /// <td><b>MAX ANGLE</b></td>
    /// </tr><tr>
    /// <td>X</td>
    /// <td>-PI</td>
    /// <td>PI</td>
    /// </tr><tr>
    /// <td>Y</td>
    /// <td>-PI/2</td>
    /// <td>PI/2</td>
    /// </tr><tr>
    /// <td>Z</td>
    /// <td>-PI</td>
    /// <td>PI</td>
    /// </tr>
    /// </table>
    /// </li>
    /// </ul>
    ///
    /// */
    #[repr(C)]
    pub struct btGeneric6DofConstraint {
        pub _base: root::btTypedConstraint,
        /// !< the constraint space w.r.t body A
        pub m_frameInA: root::btTransform,
        /// !< the constraint space w.r.t body B
        pub m_frameInB: root::btTransform,
        /// !< 3 orthogonal linear constraints
        pub m_jacLinear: [root::btJacobianEntry; 3usize],
        /// !< 3 orthogonal angular constraints
        pub m_jacAng: [root::btJacobianEntry; 3usize],
        /// ! Linear_Limit_parameters
        /// //!@{
        pub m_linearLimits: root::btTranslationalLimitMotor,
        /// ! hinge_parameters
        /// //!@{
        pub m_angularLimits: [root::btRotationalLimitMotor; 3usize],
        /// ! temporal variables
        /// //!@{
        pub m_timeStep: root::btScalar,
        pub m_calculatedTransformA: root::btTransform,
        pub m_calculatedTransformB: root::btTransform,
        pub m_calculatedAxisAngleDiff: root::btVector3,
        pub m_calculatedAxis: [root::btVector3; 3usize],
        pub m_calculatedLinearDiff: root::btVector3,
        pub m_factA: root::btScalar,
        pub m_factB: root::btScalar,
        pub m_hasStaticBody: bool,
        pub m_AnchorPos: root::btVector3,
        pub m_useLinearReferenceFrameA: bool,
        pub m_useOffsetForConstraintFrame: bool,
        pub m_flags: ::std::os::raw::c_int,
        /// for backwards compatibility during the transition to 'getInfo/getInfo2'
        pub m_useSolveConstraintObsolete: bool,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint16setAngularLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
        pub fn btGeneric6DofConstraint_setAngularLimits(
            this: *mut root::btGeneric6DofConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row_offset: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint15setLinearLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
        pub fn btGeneric6DofConstraint_setLinearLimits(
            this: *mut root::btGeneric6DofConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19buildLinearJacobianER15btJacobianEntryRK9btVector3S4_S4_"]
        pub fn btGeneric6DofConstraint_buildLinearJacobian(
            this: *mut root::btGeneric6DofConstraint,
            jacLinear: *mut root::btJacobianEntry,
            normalWorld: *const root::btVector3,
            pivotAInW: *const root::btVector3,
            pivotBInW: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint20buildAngularJacobianER15btJacobianEntryRK9btVector3"]
        pub fn btGeneric6DofConstraint_buildAngularJacobian(
            this: *mut root::btGeneric6DofConstraint,
            jacAngular: *mut root::btJacobianEntry,
            jointAxisW: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateLinearInfoEv"]
        pub fn btGeneric6DofConstraint_calculateLinearInfo(
            this: *mut root::btGeneric6DofConstraint,
        );
    }
    extern "C" {
        /// ! calcs the euler angles between the two bodies.
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18calculateAngleInfoEv"]
        pub fn btGeneric6DofConstraint_calculateAngleInfo(this: *mut root::btGeneric6DofConstraint);
    }
    extern "C" {
        /// ! Calcs global transform of the offsets
        /// /*!
        /// Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
        /// \sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
        /// */
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateTransformsERK11btTransformS2_"]
        pub fn btGeneric6DofConstraint_calculateTransforms(
            this: *mut root::btGeneric6DofConstraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateTransformsEv"]
        pub fn btGeneric6DofConstraint_calculateTransforms1(
            this: *mut root::btGeneric6DofConstraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btGeneric6DofConstraint_getInfo1NonVirtual(
            this: *mut root::btGeneric6DofConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_S8_S8_"]
        pub fn btGeneric6DofConstraint_getInfo2NonVirtual(
            this: *mut root::btGeneric6DofConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint9updateRHSEf"]
        pub fn btGeneric6DofConstraint_updateRHS(
            this: *mut root::btGeneric6DofConstraint,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        /// ! Get the rotation axis in global coordinates
        /// /*!
        /// \pre btGeneric6DofConstraint.buildJacobian must be called previously.
        /// */
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint7getAxisEi"]
        pub fn btGeneric6DofConstraint_getAxis(
            this: *const root::btGeneric6DofConstraint,
            axis_index: ::std::os::raw::c_int,
        ) -> root::btVector3;
    }
    extern "C" {
        /// ! Get the relative Euler angle
        /// /*!
        /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
        /// */
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint8getAngleEi"]
        pub fn btGeneric6DofConstraint_getAngle(
            this: *const root::btGeneric6DofConstraint,
            axis_index: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        /// ! Get the relative position of the constraint pivot
        /// /*!
        /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
        /// */
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint24getRelativePivotPositionEi"]
        pub fn btGeneric6DofConstraint_getRelativePivotPosition(
            this: *const root::btGeneric6DofConstraint,
            axis_index: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint9setFramesERK11btTransformS2_"]
        pub fn btGeneric6DofConstraint_setFrames(
            this: *mut root::btGeneric6DofConstraint,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        );
    }
    extern "C" {
        /// ! Test angular limit.
        /// /*!
        /// Calculates angular correction and returns true if limit needs to be corrected.
        /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
        /// */
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint21testAngularLimitMotorEi"]
        pub fn btGeneric6DofConstraint_testAngularLimitMotor(
            this: *mut root::btGeneric6DofConstraint,
            axis_index: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint21get_limit_motor_info2EP22btRotationalLimitMotorRK11btTransformS4_RK9btVector3S7_S7_S7_PN17btTypedConstraint17btConstraintInfo2EiRS5_ii"]
        pub fn btGeneric6DofConstraint_get_limit_motor_info2(
            this: *mut root::btGeneric6DofConstraint,
            limot: *mut root::btRotationalLimitMotor,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint7setAxisERK9btVector3S2_"]
        pub fn btGeneric6DofConstraint_setAxis(
            this: *mut root::btGeneric6DofConstraint,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
        pub fn btGeneric6DofConstraint_btGeneric6DofConstraint(
            this: *mut root::btGeneric6DofConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb"]
        pub fn btGeneric6DofConstraint_btGeneric6DofConstraint1(
            this: *mut root::btGeneric6DofConstraint,
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameB: bool,
        );
    }
    impl btGeneric6DofConstraint {
        #[inline]
        pub unsafe fn setAngularLimits(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row_offset: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofConstraint_setAngularLimits(
                self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn setLinearLimits(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofConstraint_setLinearLimits(
                self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn buildLinearJacobian(
            &mut self,
            jacLinear: *mut root::btJacobianEntry,
            normalWorld: *const root::btVector3,
            pivotAInW: *const root::btVector3,
            pivotBInW: *const root::btVector3,
        ) {
            btGeneric6DofConstraint_buildLinearJacobian(
                self,
                jacLinear,
                normalWorld,
                pivotAInW,
                pivotBInW,
            )
        }
        #[inline]
        pub unsafe fn buildAngularJacobian(
            &mut self,
            jacAngular: *mut root::btJacobianEntry,
            jointAxisW: *const root::btVector3,
        ) {
            btGeneric6DofConstraint_buildAngularJacobian(self, jacAngular, jointAxisW)
        }
        #[inline]
        pub unsafe fn calculateLinearInfo(&mut self) {
            btGeneric6DofConstraint_calculateLinearInfo(self)
        }
        #[inline]
        pub unsafe fn calculateAngleInfo(&mut self) {
            btGeneric6DofConstraint_calculateAngleInfo(self)
        }
        #[inline]
        pub unsafe fn calculateTransforms(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) {
            btGeneric6DofConstraint_calculateTransforms(self, transA, transB)
        }
        #[inline]
        pub unsafe fn calculateTransforms1(&mut self) {
            btGeneric6DofConstraint_calculateTransforms1(self)
        }
        #[inline]
        pub unsafe fn getInfo1NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        ) {
            btGeneric6DofConstraint_getInfo1NonVirtual(self, info)
        }
        #[inline]
        pub unsafe fn getInfo2NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) {
            btGeneric6DofConstraint_getInfo2NonVirtual(
                self, info, transA, transB, linVelA, linVelB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn updateRHS(&mut self, timeStep: root::btScalar) {
            btGeneric6DofConstraint_updateRHS(self, timeStep)
        }
        #[inline]
        pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> root::btVector3 {
            btGeneric6DofConstraint_getAxis(self, axis_index)
        }
        #[inline]
        pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> root::btScalar {
            btGeneric6DofConstraint_getAngle(self, axis_index)
        }
        #[inline]
        pub unsafe fn getRelativePivotPosition(
            &self,
            axis_index: ::std::os::raw::c_int,
        ) -> root::btScalar {
            btGeneric6DofConstraint_getRelativePivotPosition(self, axis_index)
        }
        #[inline]
        pub unsafe fn setFrames(
            &mut self,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        ) {
            btGeneric6DofConstraint_setFrames(self, frameA, frameB)
        }
        #[inline]
        pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) -> bool {
            btGeneric6DofConstraint_testAngularLimitMotor(self, axis_index)
        }
        #[inline]
        pub unsafe fn get_limit_motor_info2(
            &mut self,
            limot: *mut root::btRotationalLimitMotor,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofConstraint_get_limit_motor_info2(
                self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
                rotational, rotAllowed,
            )
        }
        #[inline]
        pub unsafe fn setAxis(
            &mut self,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        ) {
            btGeneric6DofConstraint_setAxis(self, axis1, axis2)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofConstraint_btGeneric6DofConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                frameInA,
                frameInB,
                useLinearReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameB: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofConstraint_btGeneric6DofConstraint1(
                &mut __bindgen_tmp,
                rbB,
                frameInB,
                useLinearReferenceFrameB,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        /// ! performs Jacobian calculation, and also calculates angle differences and axis
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint13buildJacobianEv"]
        pub fn btGeneric6DofConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btGeneric6DofConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btGeneric6DofConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint13calcAnchorPosEv"]
        pub fn btGeneric6DofConstraint_calcAnchorPos(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
        /// ///If no axis is provided, it uses the default axis for this constraint.
        #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8setParamEifi"]
        pub fn btGeneric6DofConstraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// return the local value of parameter
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint8getParamEii"]
        pub fn btGeneric6DofConstraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint28calculateSerializeBufferSizeEv"]
        pub fn btGeneric6DofConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint9serializeEPvP12btSerializer"]
        pub fn btGeneric6DofConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofConstraintData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformFloatData,
        pub m_rbBFrame: root::btTransformFloatData,
        pub m_linearUpperLimit: root::btVector3FloatData,
        pub m_linearLowerLimit: root::btVector3FloatData,
        pub m_angularUpperLimit: root::btVector3FloatData,
        pub m_angularLowerLimit: root::btVector3FloatData,
        pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
        pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofConstraintDoubleData2 {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_linearUpperLimit: root::btVector3DoubleData,
        pub m_linearLowerLimit: root::btVector3DoubleData,
        pub m_angularUpperLimit: root::btVector3DoubleData,
        pub m_angularLowerLimit: root::btVector3DoubleData,
        pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
        pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
    }
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRLIN: root::btSliderFlags = 1;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRLIN: root::btSliderFlags = 2;
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRANG: root::btSliderFlags = 4;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRANG: root::btSliderFlags = 8;
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTLIN: root::btSliderFlags = 16;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTLIN: root::btSliderFlags = 32;
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTANG: root::btSliderFlags = 64;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTANG: root::btSliderFlags = 128;
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMLIN: root::btSliderFlags = 256;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMLIN: root::btSliderFlags = 512;
    pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMANG: root::btSliderFlags = 1024;
    pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMANG: root::btSliderFlags = 2048;
    pub type btSliderFlags = u32;
    #[repr(C)]
    pub struct btSliderConstraint {
        pub _base: root::btTypedConstraint,
        /// for backwards compatibility during the transition to 'getInfo/getInfo2'
        pub m_useSolveConstraintObsolete: bool,
        pub m_useOffsetForConstraintFrame: bool,
        pub m_frameInA: root::btTransform,
        pub m_frameInB: root::btTransform,
        pub m_useLinearReferenceFrameA: bool,
        pub m_lowerLinLimit: root::btScalar,
        pub m_upperLinLimit: root::btScalar,
        pub m_lowerAngLimit: root::btScalar,
        pub m_upperAngLimit: root::btScalar,
        pub m_softnessDirLin: root::btScalar,
        pub m_restitutionDirLin: root::btScalar,
        pub m_dampingDirLin: root::btScalar,
        pub m_cfmDirLin: root::btScalar,
        pub m_softnessDirAng: root::btScalar,
        pub m_restitutionDirAng: root::btScalar,
        pub m_dampingDirAng: root::btScalar,
        pub m_cfmDirAng: root::btScalar,
        pub m_softnessLimLin: root::btScalar,
        pub m_restitutionLimLin: root::btScalar,
        pub m_dampingLimLin: root::btScalar,
        pub m_cfmLimLin: root::btScalar,
        pub m_softnessLimAng: root::btScalar,
        pub m_restitutionLimAng: root::btScalar,
        pub m_dampingLimAng: root::btScalar,
        pub m_cfmLimAng: root::btScalar,
        pub m_softnessOrthoLin: root::btScalar,
        pub m_restitutionOrthoLin: root::btScalar,
        pub m_dampingOrthoLin: root::btScalar,
        pub m_cfmOrthoLin: root::btScalar,
        pub m_softnessOrthoAng: root::btScalar,
        pub m_restitutionOrthoAng: root::btScalar,
        pub m_dampingOrthoAng: root::btScalar,
        pub m_cfmOrthoAng: root::btScalar,
        pub m_solveLinLim: bool,
        pub m_solveAngLim: bool,
        pub m_flags: ::std::os::raw::c_int,
        pub m_jacLin: [root::btJacobianEntry; 3usize],
        pub m_jacLinDiagABInv: [root::btScalar; 3usize],
        pub m_jacAng: [root::btJacobianEntry; 3usize],
        pub m_timeStep: root::btScalar,
        pub m_calculatedTransformA: root::btTransform,
        pub m_calculatedTransformB: root::btTransform,
        pub m_sliderAxis: root::btVector3,
        pub m_realPivotAInW: root::btVector3,
        pub m_realPivotBInW: root::btVector3,
        pub m_projPivotInW: root::btVector3,
        pub m_delta: root::btVector3,
        pub m_depth: root::btVector3,
        pub m_relPosA: root::btVector3,
        pub m_relPosB: root::btVector3,
        pub m_linPos: root::btScalar,
        pub m_angPos: root::btScalar,
        pub m_angDepth: root::btScalar,
        pub m_kAngle: root::btScalar,
        pub m_poweredLinMotor: bool,
        pub m_targetLinMotorVelocity: root::btScalar,
        pub m_maxLinMotorForce: root::btScalar,
        pub m_accumulatedLinMotorImpulse: root::btScalar,
        pub m_poweredAngMotor: bool,
        pub m_targetAngMotorVelocity: root::btScalar,
        pub m_maxAngMotorForce: root::btScalar,
        pub m_accumulatedAngMotorImpulse: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint10initParamsEv"]
        pub fn btSliderConstraint_initParams(this: *mut root::btSliderConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btSliderConstraint_getInfo1NonVirtual(
            this: *mut root::btSliderConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_ff"]
        pub fn btSliderConstraint_getInfo2NonVirtual(
            this: *mut root::btSliderConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            rbAinvMass: root::btScalar,
            rbBinvMass: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint19calculateTransformsERK11btTransformS2_"]
        pub fn btSliderConstraint_calculateTransforms(
            this: *mut root::btSliderConstraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint13testLinLimitsEv"]
        pub fn btSliderConstraint_testLinLimits(this: *mut root::btSliderConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint13testAngLimitsEv"]
        pub fn btSliderConstraint_testAngLimits(this: *mut root::btSliderConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint11getAncorInAEv"]
        pub fn btSliderConstraint_getAncorInA(
            this: *mut root::btSliderConstraint,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint11getAncorInBEv"]
        pub fn btSliderConstraint_getAncorInB(
            this: *mut root::btSliderConstraint,
        ) -> root::btVector3;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
        pub fn btSliderConstraint_btSliderConstraint(
            this: *mut root::btSliderConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb"]
        pub fn btSliderConstraint_btSliderConstraint1(
            this: *mut root::btSliderConstraint,
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        );
    }
    impl btSliderConstraint {
        #[inline]
        pub unsafe fn initParams(&mut self) {
            btSliderConstraint_initParams(self)
        }
        #[inline]
        pub unsafe fn getInfo1NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        ) {
            btSliderConstraint_getInfo1NonVirtual(self, info)
        }
        #[inline]
        pub unsafe fn getInfo2NonVirtual(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            rbAinvMass: root::btScalar,
            rbBinvMass: root::btScalar,
        ) {
            btSliderConstraint_getInfo2NonVirtual(
                self, info, transA, transB, linVelA, linVelB, rbAinvMass, rbBinvMass,
            )
        }
        #[inline]
        pub unsafe fn calculateTransforms(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) {
            btSliderConstraint_calculateTransforms(self, transA, transB)
        }
        #[inline]
        pub unsafe fn testLinLimits(&mut self) {
            btSliderConstraint_testLinLimits(self)
        }
        #[inline]
        pub unsafe fn testAngLimits(&mut self) {
            btSliderConstraint_testAngLimits(self)
        }
        #[inline]
        pub unsafe fn getAncorInA(&mut self) -> root::btVector3 {
            btSliderConstraint_getAncorInA(self)
        }
        #[inline]
        pub unsafe fn getAncorInB(&mut self) -> root::btVector3 {
            btSliderConstraint_getAncorInB(self)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSliderConstraint_btSliderConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                frameInA,
                frameInB,
                useLinearReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSliderConstraint_btSliderConstraint1(
                &mut __bindgen_tmp,
                rbB,
                frameInB,
                useLinearReferenceFrameA,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btSliderConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btSliderConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btSliderConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
        /// ///If no axis is provided, it uses the default axis for this constraint.
        #[link_name = "\u{1}_ZN18btSliderConstraint8setParamEifi"]
        pub fn btSliderConstraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        /// return the local value of parameter
        #[link_name = "\u{1}_ZNK18btSliderConstraint8getParamEii"]
        pub fn btSliderConstraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK18btSliderConstraint28calculateSerializeBufferSizeEv"]
        pub fn btSliderConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK18btSliderConstraint9serializeEPvP12btSerializer"]
        pub fn btSliderConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSliderConstraintData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformFloatData,
        pub m_rbBFrame: root::btTransformFloatData,
        pub m_linearUpperLimit: f32,
        pub m_linearLowerLimit: f32,
        pub m_angularUpperLimit: f32,
        pub m_angularLowerLimit: f32,
        pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
        pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSliderConstraintDoubleData {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_linearUpperLimit: f64,
        pub m_linearLowerLimit: f64,
        pub m_angularUpperLimit: f64,
        pub m_angularLowerLimit: f64,
        pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
        pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
    }
    /// DOF index used in enableSpring() and setStiffness() means:
    /// 0 : translation X
    /// 1 : translation Y
    /// 2 : translation Z
    /// 3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
    /// 4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
    /// 5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] )
    #[repr(C)]
    pub struct btGeneric6DofSpringConstraint {
        pub _base: root::btGeneric6DofConstraint,
        pub m_springEnabled: [bool; 6usize],
        pub m_equilibriumPoint: [root::btScalar; 6usize],
        pub m_springStiffness: [root::btScalar; 6usize],
        pub m_springDamping: [root::btScalar; 6usize],
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint4initEv"]
        pub fn btGeneric6DofSpringConstraint_init(this: *mut root::btGeneric6DofSpringConstraint);
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint21internalUpdateSpringsEPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btGeneric6DofSpringConstraint_internalUpdateSprings(
            this: *mut root::btGeneric6DofSpringConstraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint12enableSpringEib"]
        pub fn btGeneric6DofSpringConstraint_enableSpring(
            this: *mut root::btGeneric6DofSpringConstraint,
            index: ::std::os::raw::c_int,
            onOff: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint12setStiffnessEif"]
        pub fn btGeneric6DofSpringConstraint_setStiffness(
            this: *mut root::btGeneric6DofSpringConstraint,
            index: ::std::os::raw::c_int,
            stiffness: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint10setDampingEif"]
        pub fn btGeneric6DofSpringConstraint_setDamping(
            this: *mut root::btGeneric6DofSpringConstraint,
            index: ::std::os::raw::c_int,
            damping: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEv"]
        pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint(
            this: *mut root::btGeneric6DofSpringConstraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEi"]
        pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint1(
            this: *mut root::btGeneric6DofSpringConstraint,
            index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEif"]
        pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint2(
            this: *mut root::btGeneric6DofSpringConstraint,
            index: ::std::os::raw::c_int,
            val: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
        pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
            this: *mut root::btGeneric6DofSpringConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb"]
        pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
            this: *mut root::btGeneric6DofSpringConstraint,
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameB: bool,
        );
    }
    impl btGeneric6DofSpringConstraint {
        #[inline]
        pub unsafe fn init(&mut self) {
            btGeneric6DofSpringConstraint_init(self)
        }
        #[inline]
        pub unsafe fn internalUpdateSprings(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        ) {
            btGeneric6DofSpringConstraint_internalUpdateSprings(self, info)
        }
        #[inline]
        pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
            btGeneric6DofSpringConstraint_enableSpring(self, index, onOff)
        }
        #[inline]
        pub unsafe fn setStiffness(
            &mut self,
            index: ::std::os::raw::c_int,
            stiffness: root::btScalar,
        ) {
            btGeneric6DofSpringConstraint_setStiffness(self, index, stiffness)
        }
        #[inline]
        pub unsafe fn setDamping(&mut self, index: ::std::os::raw::c_int, damping: root::btScalar) {
            btGeneric6DofSpringConstraint_setDamping(self, index, damping)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint(&mut self) {
            btGeneric6DofSpringConstraint_setEquilibriumPoint(self)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
            btGeneric6DofSpringConstraint_setEquilibriumPoint1(self, index)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint2(
            &mut self,
            index: ::std::os::raw::c_int,
            val: root::btScalar,
        ) {
            btGeneric6DofSpringConstraint_setEquilibriumPoint2(self, index, val)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameA: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                frameInA,
                frameInB,
                useLinearReferenceFrameA,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            useLinearReferenceFrameB: bool,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
                &mut __bindgen_tmp,
                rbB,
                frameInB,
                useLinearReferenceFrameB,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint7setAxisERK9btVector3S2_"]
        pub fn btGeneric6DofSpringConstraint_setAxis(
            this: *mut ::std::os::raw::c_void,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btGeneric6DofSpringConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint28calculateSerializeBufferSizeEv"]
        pub fn btGeneric6DofSpringConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint9serializeEPvP12btSerializer"]
        pub fn btGeneric6DofSpringConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofSpringConstraintData {
        pub m_6dofData: root::btGeneric6DofConstraintData,
        pub m_springEnabled: [::std::os::raw::c_int; 6usize],
        pub m_equilibriumPoint: [f32; 6usize],
        pub m_springStiffness: [f32; 6usize],
        pub m_springDamping: [f32; 6usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofSpringConstraintDoubleData2 {
        pub m_6dofData: root::btGeneric6DofConstraintDoubleData2,
        pub m_springEnabled: [::std::os::raw::c_int; 6usize],
        pub m_equilibriumPoint: [f64; 6usize],
        pub m_springStiffness: [f64; 6usize],
        pub m_springDamping: [f64; 6usize],
    }
    /// Constraint similar to ODE Universal Joint
    /// has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
    /// and Y (axis 2)
    /// Description from ODE manual :
    /// "Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular.
    /// In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal."
    #[repr(C)]
    pub struct btUniversalConstraint {
        pub _base: root::btGeneric6DofConstraint,
        pub m_anchor: root::btVector3,
        pub m_axis1: root::btVector3,
        pub m_axis2: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniversalConstraint7setAxisERK9btVector3S2_"]
        pub fn btUniversalConstraint_setAxis(
            this: *mut root::btUniversalConstraint,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN21btUniversalConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_"]
        pub fn btUniversalConstraint_btUniversalConstraint(
            this: *mut root::btUniversalConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            anchor: *const root::btVector3,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        );
    }
    impl btUniversalConstraint {
        #[inline]
        pub unsafe fn setAxis(
            &mut self,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        ) {
            btUniversalConstraint_setAxis(self, axis1, axis2)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            anchor: *const root::btVector3,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btUniversalConstraint_btUniversalConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                anchor,
                axis1,
                axis2,
            );
            __bindgen_tmp
        }
    }
    pub const RotateOrder_RO_XYZ: root::RotateOrder = 0;
    pub const RotateOrder_RO_XZY: root::RotateOrder = 1;
    pub const RotateOrder_RO_YXZ: root::RotateOrder = 2;
    pub const RotateOrder_RO_YZX: root::RotateOrder = 3;
    pub const RotateOrder_RO_ZXY: root::RotateOrder = 4;
    pub const RotateOrder_RO_ZYX: root::RotateOrder = 5;
    pub type RotateOrder = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRotationalLimitMotor2 {
        pub m_loLimit: root::btScalar,
        pub m_hiLimit: root::btScalar,
        pub m_bounce: root::btScalar,
        pub m_stopERP: root::btScalar,
        pub m_stopCFM: root::btScalar,
        pub m_motorERP: root::btScalar,
        pub m_motorCFM: root::btScalar,
        pub m_enableMotor: bool,
        pub m_targetVelocity: root::btScalar,
        pub m_maxMotorForce: root::btScalar,
        pub m_servoMotor: bool,
        pub m_servoTarget: root::btScalar,
        pub m_enableSpring: bool,
        pub m_springStiffness: root::btScalar,
        pub m_springStiffnessLimited: bool,
        pub m_springDamping: root::btScalar,
        pub m_springDampingLimited: bool,
        pub m_equilibriumPoint: root::btScalar,
        pub m_currentLimitError: root::btScalar,
        pub m_currentLimitErrorHi: root::btScalar,
        pub m_currentPosition: root::btScalar,
        pub m_currentLimit: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN23btRotationalLimitMotor214testLimitValueEf"]
        pub fn btRotationalLimitMotor2_testLimitValue(
            this: *mut root::btRotationalLimitMotor2,
            test_value: root::btScalar,
        );
    }
    impl btRotationalLimitMotor2 {
        #[inline]
        pub unsafe fn testLimitValue(&mut self, test_value: root::btScalar) {
            btRotationalLimitMotor2_testLimitValue(self, test_value)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btTranslationalLimitMotor2 {
        pub m_lowerLimit: root::btVector3,
        pub m_upperLimit: root::btVector3,
        pub m_bounce: root::btVector3,
        pub m_stopERP: root::btVector3,
        pub m_stopCFM: root::btVector3,
        pub m_motorERP: root::btVector3,
        pub m_motorCFM: root::btVector3,
        pub m_enableMotor: [bool; 3usize],
        pub m_servoMotor: [bool; 3usize],
        pub m_enableSpring: [bool; 3usize],
        pub m_servoTarget: root::btVector3,
        pub m_springStiffness: root::btVector3,
        pub m_springStiffnessLimited: [bool; 3usize],
        pub m_springDamping: root::btVector3,
        pub m_springDampingLimited: [bool; 3usize],
        pub m_equilibriumPoint: root::btVector3,
        pub m_targetVelocity: root::btVector3,
        pub m_maxMotorForce: root::btVector3,
        pub m_currentLimitError: root::btVector3,
        pub m_currentLimitErrorHi: root::btVector3,
        pub m_currentLinearDiff: root::btVector3,
        pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    }
    extern "C" {
        #[link_name = "\u{1}_ZN26btTranslationalLimitMotor214testLimitValueEif"]
        pub fn btTranslationalLimitMotor2_testLimitValue(
            this: *mut root::btTranslationalLimitMotor2,
            limitIndex: ::std::os::raw::c_int,
            test_value: root::btScalar,
        );
    }
    impl btTranslationalLimitMotor2 {
        #[inline]
        pub unsafe fn testLimitValue(
            &mut self,
            limitIndex: ::std::os::raw::c_int,
            test_value: root::btScalar,
        ) {
            btTranslationalLimitMotor2_testLimitValue(self, limitIndex, test_value)
        }
    }
    pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_STOP2: root::bt6DofFlags2 = 1;
    pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_STOP2: root::bt6DofFlags2 = 2;
    pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_MOTO2: root::bt6DofFlags2 = 4;
    pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_MOTO2: root::bt6DofFlags2 = 8;
    pub type bt6DofFlags2 = u32;
    #[repr(C)]
    pub struct btGeneric6DofSpring2Constraint {
        pub _base: root::btTypedConstraint,
        pub m_frameInA: root::btTransform,
        pub m_frameInB: root::btTransform,
        pub m_jacLinear: [root::btJacobianEntry; 3usize],
        pub m_jacAng: [root::btJacobianEntry; 3usize],
        pub m_linearLimits: root::btTranslationalLimitMotor2,
        pub m_angularLimits: [root::btRotationalLimitMotor2; 3usize],
        pub m_rotateOrder: root::RotateOrder,
        pub m_calculatedTransformA: root::btTransform,
        pub m_calculatedTransformB: root::btTransform,
        pub m_calculatedAxisAngleDiff: root::btVector3,
        pub m_calculatedAxis: [root::btVector3; 3usize],
        pub m_calculatedLinearDiff: root::btVector3,
        pub m_factA: root::btScalar,
        pub m_factB: root::btScalar,
        pub m_hasStaticBody: bool,
        pub m_flags: ::std::os::raw::c_int,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setAngularLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
        pub fn btGeneric6DofSpring2Constraint_setAngularLimits(
            this: *mut root::btGeneric6DofSpring2Constraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row_offset: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15setLinearLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
        pub fn btGeneric6DofSpring2Constraint_setLinearLimits(
            this: *mut root::btGeneric6DofSpring2Constraint,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateLinearInfoEv"]
        pub fn btGeneric6DofSpring2Constraint_calculateLinearInfo(
            this: *mut root::btGeneric6DofSpring2Constraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint18calculateAngleInfoEv"]
        pub fn btGeneric6DofSpring2Constraint_calculateAngleInfo(
            this: *mut root::btGeneric6DofSpring2Constraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint21testAngularLimitMotorEi"]
        pub fn btGeneric6DofSpring2Constraint_testAngularLimitMotor(
            this: *mut root::btGeneric6DofSpring2Constraint,
            axis_index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15calculateJacobiEP23btRotationalLimitMotor2RK11btTransformS4_PN17btTypedConstraint17btConstraintInfo2EiR9btVector3ii"]
        pub fn btGeneric6DofSpring2Constraint_calculateJacobi(
            this: *mut root::btGeneric6DofSpring2Constraint,
            limot: *mut root::btRotationalLimitMotor2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            srow: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint21get_limit_motor_info2EP23btRotationalLimitMotor2RK11btTransformS4_RK9btVector3S7_S7_S7_PN17btTypedConstraint17btConstraintInfo2EiRS5_ii"]
        pub fn btGeneric6DofSpring2Constraint_get_limit_motor_info2(
            this: *mut root::btGeneric6DofSpring2Constraint,
            limot: *mut root::btRotationalLimitMotor2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateTransformsERK11btTransformS2_"]
        pub fn btGeneric6DofSpring2Constraint_calculateTransforms(
            this: *mut root::btGeneric6DofSpring2Constraint,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateTransformsEv"]
        pub fn btGeneric6DofSpring2Constraint_calculateTransforms1(
            this: *mut root::btGeneric6DofSpring2Constraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint9setFramesERK11btTransformS2_"]
        pub fn btGeneric6DofSpring2Constraint_setFrames(
            this: *mut root::btGeneric6DofSpring2Constraint,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint7setAxisERK9btVector3S2_"]
        pub fn btGeneric6DofSpring2Constraint_setAxis(
            this: *mut root::btGeneric6DofSpring2Constraint,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint9setBounceEif"]
        pub fn btGeneric6DofSpring2Constraint_setBounce(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            bounce: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint11enableMotorEib"]
        pub fn btGeneric6DofSpring2Constraint_enableMotor(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            onOff: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8setServoEib"]
        pub fn btGeneric6DofSpring2Constraint_setServo(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            onOff: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint17setTargetVelocityEif"]
        pub fn btGeneric6DofSpring2Constraint_setTargetVelocity(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            velocity: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint14setServoTargetEif"]
        pub fn btGeneric6DofSpring2Constraint_setServoTarget(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            target: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setMaxMotorForceEif"]
        pub fn btGeneric6DofSpring2Constraint_setMaxMotorForce(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            force: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint12enableSpringEib"]
        pub fn btGeneric6DofSpring2Constraint_enableSpring(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            onOff: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint12setStiffnessEifb"]
        pub fn btGeneric6DofSpring2Constraint_setStiffness(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            stiffness: root::btScalar,
            limitIfNeeded: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint10setDampingEifb"]
        pub fn btGeneric6DofSpring2Constraint_setDamping(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            damping: root::btScalar,
            limitIfNeeded: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEv"]
        pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint(
            this: *mut root::btGeneric6DofSpring2Constraint,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEi"]
        pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint1(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEif"]
        pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint2(
            this: *mut root::btGeneric6DofSpring2Constraint,
            index: ::std::os::raw::c_int,
            val: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15btGetMatrixElemERK11btMatrix3x3i"]
        pub fn btGeneric6DofSpring2Constraint_btGetMatrixElem(
            mat: *const root::btMatrix3x3,
            index: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerXYZERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerXYZ(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerXZYERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerXZY(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerYXZERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerYXZ(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerYZXERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerYZX(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerZXYERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerZXY(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerZYXERK11btMatrix3x3R9btVector3"]
        pub fn btGeneric6DofSpring2Constraint_matrixToEulerZYX(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2ConstraintC1ER11btRigidBodyS1_RK11btTransformS4_11RotateOrder"]
        pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
            this: *mut root::btGeneric6DofSpring2Constraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            rotOrder: root::RotateOrder,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2ConstraintC1ER11btRigidBodyRK11btTransform11RotateOrder"]
        pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
            this: *mut root::btGeneric6DofSpring2Constraint,
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            rotOrder: root::RotateOrder,
        );
    }
    impl btGeneric6DofSpring2Constraint {
        #[inline]
        pub unsafe fn setAngularLimits(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row_offset: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofSpring2Constraint_setAngularLimits(
                self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn setLinearLimits(
            &mut self,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofSpring2Constraint_setLinearLimits(
                self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
            )
        }
        #[inline]
        pub unsafe fn calculateLinearInfo(&mut self) {
            btGeneric6DofSpring2Constraint_calculateLinearInfo(self)
        }
        #[inline]
        pub unsafe fn calculateAngleInfo(&mut self) {
            btGeneric6DofSpring2Constraint_calculateAngleInfo(self)
        }
        #[inline]
        pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) {
            btGeneric6DofSpring2Constraint_testAngularLimitMotor(self, axis_index)
        }
        #[inline]
        pub unsafe fn calculateJacobi(
            &mut self,
            limot: *mut root::btRotationalLimitMotor2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            srow: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        ) {
            btGeneric6DofSpring2Constraint_calculateJacobi(
                self, limot, transA, transB, info, srow, ax1, rotational, rotAllowed,
            )
        }
        #[inline]
        pub unsafe fn get_limit_motor_info2(
            &mut self,
            limot: *mut root::btRotationalLimitMotor2,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
            linVelA: *const root::btVector3,
            linVelB: *const root::btVector3,
            angVelA: *const root::btVector3,
            angVelB: *const root::btVector3,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
            row: ::std::os::raw::c_int,
            ax1: *mut root::btVector3,
            rotational: ::std::os::raw::c_int,
            rotAllowed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            btGeneric6DofSpring2Constraint_get_limit_motor_info2(
                self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
                rotational, rotAllowed,
            )
        }
        #[inline]
        pub unsafe fn calculateTransforms(
            &mut self,
            transA: *const root::btTransform,
            transB: *const root::btTransform,
        ) {
            btGeneric6DofSpring2Constraint_calculateTransforms(self, transA, transB)
        }
        #[inline]
        pub unsafe fn calculateTransforms1(&mut self) {
            btGeneric6DofSpring2Constraint_calculateTransforms1(self)
        }
        #[inline]
        pub unsafe fn setFrames(
            &mut self,
            frameA: *const root::btTransform,
            frameB: *const root::btTransform,
        ) {
            btGeneric6DofSpring2Constraint_setFrames(self, frameA, frameB)
        }
        #[inline]
        pub unsafe fn setAxis(
            &mut self,
            axis1: *const root::btVector3,
            axis2: *const root::btVector3,
        ) {
            btGeneric6DofSpring2Constraint_setAxis(self, axis1, axis2)
        }
        #[inline]
        pub unsafe fn setBounce(&mut self, index: ::std::os::raw::c_int, bounce: root::btScalar) {
            btGeneric6DofSpring2Constraint_setBounce(self, index, bounce)
        }
        #[inline]
        pub unsafe fn enableMotor(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
            btGeneric6DofSpring2Constraint_enableMotor(self, index, onOff)
        }
        #[inline]
        pub unsafe fn setServo(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
            btGeneric6DofSpring2Constraint_setServo(self, index, onOff)
        }
        #[inline]
        pub unsafe fn setTargetVelocity(
            &mut self,
            index: ::std::os::raw::c_int,
            velocity: root::btScalar,
        ) {
            btGeneric6DofSpring2Constraint_setTargetVelocity(self, index, velocity)
        }
        #[inline]
        pub unsafe fn setServoTarget(
            &mut self,
            index: ::std::os::raw::c_int,
            target: root::btScalar,
        ) {
            btGeneric6DofSpring2Constraint_setServoTarget(self, index, target)
        }
        #[inline]
        pub unsafe fn setMaxMotorForce(
            &mut self,
            index: ::std::os::raw::c_int,
            force: root::btScalar,
        ) {
            btGeneric6DofSpring2Constraint_setMaxMotorForce(self, index, force)
        }
        #[inline]
        pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
            btGeneric6DofSpring2Constraint_enableSpring(self, index, onOff)
        }
        #[inline]
        pub unsafe fn setStiffness(
            &mut self,
            index: ::std::os::raw::c_int,
            stiffness: root::btScalar,
            limitIfNeeded: bool,
        ) {
            btGeneric6DofSpring2Constraint_setStiffness(self, index, stiffness, limitIfNeeded)
        }
        #[inline]
        pub unsafe fn setDamping(
            &mut self,
            index: ::std::os::raw::c_int,
            damping: root::btScalar,
            limitIfNeeded: bool,
        ) {
            btGeneric6DofSpring2Constraint_setDamping(self, index, damping, limitIfNeeded)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint(&mut self) {
            btGeneric6DofSpring2Constraint_setEquilibriumPoint(self)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
            btGeneric6DofSpring2Constraint_setEquilibriumPoint1(self, index)
        }
        #[inline]
        pub unsafe fn setEquilibriumPoint2(
            &mut self,
            index: ::std::os::raw::c_int,
            val: root::btScalar,
        ) {
            btGeneric6DofSpring2Constraint_setEquilibriumPoint2(self, index, val)
        }
        #[inline]
        pub unsafe fn btGetMatrixElem(
            mat: *const root::btMatrix3x3,
            index: ::std::os::raw::c_int,
        ) -> root::btScalar {
            btGeneric6DofSpring2Constraint_btGetMatrixElem(mat, index)
        }
        #[inline]
        pub unsafe fn matrixToEulerXYZ(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerXYZ(mat, xyz)
        }
        #[inline]
        pub unsafe fn matrixToEulerXZY(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerXZY(mat, xyz)
        }
        #[inline]
        pub unsafe fn matrixToEulerYXZ(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerYXZ(mat, xyz)
        }
        #[inline]
        pub unsafe fn matrixToEulerYZX(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerYZX(mat, xyz)
        }
        #[inline]
        pub unsafe fn matrixToEulerZXY(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerZXY(mat, xyz)
        }
        #[inline]
        pub unsafe fn matrixToEulerZYX(
            mat: *const root::btMatrix3x3,
            xyz: *mut root::btVector3,
        ) -> bool {
            btGeneric6DofSpring2Constraint_matrixToEulerZYX(mat, xyz)
        }
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
            rotOrder: root::RotateOrder,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                frameInA,
                frameInB,
                rotOrder,
            );
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            rbB: *mut root::btRigidBody,
            frameInB: *const root::btTransform,
            rotOrder: root::RotateOrder,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
                &mut __bindgen_tmp,
                rbB,
                frameInB,
                rotOrder,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btGeneric6DofSpring2Constraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btGeneric6DofSpring2Constraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint28calculateSerializeBufferSizeEv"]
        pub fn btGeneric6DofSpring2Constraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint9serializeEPvP12btSerializer"]
        pub fn btGeneric6DofSpring2Constraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8setParamEifi"]
        pub fn btGeneric6DofSpring2Constraint_setParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            value: root::btScalar,
            axis: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint8getParamEii"]
        pub fn btGeneric6DofSpring2Constraint_getParam(
            this: *mut ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            axis: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofSpring2ConstraintData {
        pub m_typeConstraintData: root::btTypedConstraintData,
        pub m_rbAFrame: root::btTransformFloatData,
        pub m_rbBFrame: root::btTransformFloatData,
        pub m_linearUpperLimit: root::btVector3FloatData,
        pub m_linearLowerLimit: root::btVector3FloatData,
        pub m_linearBounce: root::btVector3FloatData,
        pub m_linearStopERP: root::btVector3FloatData,
        pub m_linearStopCFM: root::btVector3FloatData,
        pub m_linearMotorERP: root::btVector3FloatData,
        pub m_linearMotorCFM: root::btVector3FloatData,
        pub m_linearTargetVelocity: root::btVector3FloatData,
        pub m_linearMaxMotorForce: root::btVector3FloatData,
        pub m_linearServoTarget: root::btVector3FloatData,
        pub m_linearSpringStiffness: root::btVector3FloatData,
        pub m_linearSpringDamping: root::btVector3FloatData,
        pub m_linearEquilibriumPoint: root::btVector3FloatData,
        pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
        pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
        pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
        pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
        pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
        pub m_padding1: [::std::os::raw::c_char; 4usize],
        pub m_angularUpperLimit: root::btVector3FloatData,
        pub m_angularLowerLimit: root::btVector3FloatData,
        pub m_angularBounce: root::btVector3FloatData,
        pub m_angularStopERP: root::btVector3FloatData,
        pub m_angularStopCFM: root::btVector3FloatData,
        pub m_angularMotorERP: root::btVector3FloatData,
        pub m_angularMotorCFM: root::btVector3FloatData,
        pub m_angularTargetVelocity: root::btVector3FloatData,
        pub m_angularMaxMotorForce: root::btVector3FloatData,
        pub m_angularServoTarget: root::btVector3FloatData,
        pub m_angularSpringStiffness: root::btVector3FloatData,
        pub m_angularSpringDamping: root::btVector3FloatData,
        pub m_angularEquilibriumPoint: root::btVector3FloatData,
        pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
        pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
        pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
        pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
        pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
        pub m_rotateOrder: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGeneric6DofSpring2ConstraintDoubleData2 {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_rbAFrame: root::btTransformDoubleData,
        pub m_rbBFrame: root::btTransformDoubleData,
        pub m_linearUpperLimit: root::btVector3DoubleData,
        pub m_linearLowerLimit: root::btVector3DoubleData,
        pub m_linearBounce: root::btVector3DoubleData,
        pub m_linearStopERP: root::btVector3DoubleData,
        pub m_linearStopCFM: root::btVector3DoubleData,
        pub m_linearMotorERP: root::btVector3DoubleData,
        pub m_linearMotorCFM: root::btVector3DoubleData,
        pub m_linearTargetVelocity: root::btVector3DoubleData,
        pub m_linearMaxMotorForce: root::btVector3DoubleData,
        pub m_linearServoTarget: root::btVector3DoubleData,
        pub m_linearSpringStiffness: root::btVector3DoubleData,
        pub m_linearSpringDamping: root::btVector3DoubleData,
        pub m_linearEquilibriumPoint: root::btVector3DoubleData,
        pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
        pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
        pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
        pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
        pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
        pub m_padding1: [::std::os::raw::c_char; 4usize],
        pub m_angularUpperLimit: root::btVector3DoubleData,
        pub m_angularLowerLimit: root::btVector3DoubleData,
        pub m_angularBounce: root::btVector3DoubleData,
        pub m_angularStopERP: root::btVector3DoubleData,
        pub m_angularStopCFM: root::btVector3DoubleData,
        pub m_angularMotorERP: root::btVector3DoubleData,
        pub m_angularMotorCFM: root::btVector3DoubleData,
        pub m_angularTargetVelocity: root::btVector3DoubleData,
        pub m_angularMaxMotorForce: root::btVector3DoubleData,
        pub m_angularServoTarget: root::btVector3DoubleData,
        pub m_angularSpringStiffness: root::btVector3DoubleData,
        pub m_angularSpringDamping: root::btVector3DoubleData,
        pub m_angularEquilibriumPoint: root::btVector3DoubleData,
        pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
        pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
        pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
        pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
        pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
        pub m_rotateOrder: ::std::os::raw::c_int,
    }
    #[repr(C)]
    pub struct btHinge2Constraint {
        pub _base: root::btGeneric6DofSpring2Constraint,
        pub m_anchor: root::btVector3,
        pub m_axis1: root::btVector3,
        pub m_axis2: root::btVector3,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN18btHinge2ConstraintC1ER11btRigidBodyS1_R9btVector3S3_S3_"]
        pub fn btHinge2Constraint_btHinge2Constraint(
            this: *mut root::btHinge2Constraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            anchor: *mut root::btVector3,
            axis1: *mut root::btVector3,
            axis2: *mut root::btVector3,
        );
    }
    impl btHinge2Constraint {
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            anchor: *mut root::btVector3,
            axis1: *mut root::btVector3,
            axis2: *mut root::btVector3,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btHinge2Constraint_btHinge2Constraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                anchor,
                axis1,
                axis2,
            );
            __bindgen_tmp
        }
    }
    /// The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
    /// See Bullet/Demos/ConstraintDemo for an example use.
    #[repr(C)]
    pub struct btGearConstraint {
        pub _base: root::btTypedConstraint,
        pub m_axisInA: root::btVector3,
        pub m_axisInB: root::btVector3,
        pub m_useFrameA: bool,
        pub m_ratio: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btGearConstraintC1ER11btRigidBodyS1_RK9btVector3S4_f"]
        pub fn btGearConstraint_btGearConstraint(
            this: *mut root::btGearConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            axisInA: *const root::btVector3,
            axisInB: *const root::btVector3,
            ratio: root::btScalar,
        );
    }
    impl btGearConstraint {
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            axisInA: *const root::btVector3,
            axisInB: *const root::btVector3,
            ratio: root::btScalar,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btGearConstraint_btGearConstraint(
                &mut __bindgen_tmp,
                rbA,
                rbB,
                axisInA,
                axisInB,
                ratio,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btGearConstraintD1Ev"]
        pub fn btGearConstraint_btGearConstraint_destructor(this: *mut root::btGearConstraint);
    }
    extern "C" {
        /// internal method used by the constraint solver, don't use them directly
        #[link_name = "\u{1}_ZN16btGearConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
        pub fn btGearConstraint_getInfo1(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo1,
        );
    }
    extern "C" {
        /// internal method used by the constraint solver, don't use them directly
        #[link_name = "\u{1}_ZN16btGearConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
        pub fn btGearConstraint_getInfo2(
            this: *mut ::std::os::raw::c_void,
            info: *mut root::btTypedConstraint_btConstraintInfo2,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btGearConstraint28calculateSerializeBufferSizeEv"]
        pub fn btGearConstraint_calculateSerializeBufferSize(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// fills the dataBuffer and returns the struct name (and 0 on failure)
        #[link_name = "\u{1}_ZNK16btGearConstraint9serializeEPvP12btSerializer"]
        pub fn btGearConstraint_serialize(
            this: *mut ::std::os::raw::c_void,
            dataBuffer: *mut ::std::os::raw::c_void,
            serializer: *mut root::btSerializer,
        ) -> *const ::std::os::raw::c_char;
    }
    /// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGearConstraintFloatData {
        pub m_typeConstraintData: root::btTypedConstraintFloatData,
        pub m_axisInA: root::btVector3FloatData,
        pub m_axisInB: root::btVector3FloatData,
        pub m_ratio: f32,
        pub m_padding: [::std::os::raw::c_char; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btGearConstraintDoubleData {
        pub m_typeConstraintData: root::btTypedConstraintDoubleData,
        pub m_axisInA: root::btVector3DoubleData,
        pub m_axisInB: root::btVector3DoubleData,
        pub m_ratio: f64,
    }
    #[repr(C)]
    pub struct btFixedConstraint {
        pub _base: root::btGeneric6DofSpring2Constraint,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btFixedConstraintC1ER11btRigidBodyS1_RK11btTransformS4_"]
        pub fn btFixedConstraint_btFixedConstraint(
            this: *mut root::btFixedConstraint,
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
        );
    }
    impl btFixedConstraint {
        #[inline]
        pub unsafe fn new(
            rbA: *mut root::btRigidBody,
            rbB: *mut root::btRigidBody,
            frameInA: *const root::btTransform,
            frameInB: *const root::btTransform,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btFixedConstraint_btFixedConstraint(&mut __bindgen_tmp, rbA, rbB, frameInA, frameInB);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btFixedConstraintD1Ev"]
        pub fn btFixedConstraint_btFixedConstraint_destructor(this: *mut root::btFixedConstraint);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btStackAlloc {
        _unused: [u8; 0],
    }
    pub const btConstraintSolverType_BT_SEQUENTIAL_IMPULSE_SOLVER: root::btConstraintSolverType = 1;
    pub const btConstraintSolverType_BT_MLCP_SOLVER: root::btConstraintSolverType = 2;
    pub const btConstraintSolverType_BT_NNCG_SOLVER: root::btConstraintSolverType = 4;
    /// btConstraintSolver provides solver interface
    pub type btConstraintSolverType = u32;
    #[repr(C)]
    pub struct btConstraintSolver__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct btConstraintSolver {
        pub vtable_: *const btConstraintSolver__bindgen_vtable,
    }
    pub type btSingleConstraintRowSolver = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::btSolverBody,
            arg2: *mut root::btSolverBody,
            arg3: *const root::btSolverConstraint,
        ) -> root::btScalar,
    >;
    /// The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
    #[repr(C)]
    pub struct btSequentialImpulseConstraintSolver {
        pub _base: root::btConstraintSolver,
        pub m_tmpSolverBodyPool: root::btAlignedObjectArray<root::btSolverBody>,
        pub m_tmpSolverContactConstraintPool: root::btConstraintArray,
        pub m_tmpSolverNonContactConstraintPool: root::btConstraintArray,
        pub m_tmpSolverContactFrictionConstraintPool: root::btConstraintArray,
        pub m_tmpSolverContactRollingFrictionConstraintPool: root::btConstraintArray,
        pub m_orderTmpConstraintPool: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_orderNonContactConstraintPool: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_orderFrictionConstraintPool: root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_tmpConstraintSizesPool:
            root::btAlignedObjectArray<root::btTypedConstraint_btConstraintInfo1>,
        pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
        pub m_fixedBodyId: ::std::os::raw::c_int,
        pub m_kinematicBodyUniqueIdToSolverBodyTable:
            root::btAlignedObjectArray<::std::os::raw::c_int>,
        pub m_resolveSingleConstraintRowGeneric: root::btSingleConstraintRowSolver,
        pub m_resolveSingleConstraintRowLowerLimit: root::btSingleConstraintRowSolver,
        pub m_resolveSplitPenetrationImpulse: root::btSingleConstraintRowSolver,
        pub m_cachedSolverMode: ::std::os::raw::c_int,
        pub m_leastSquaresResidual: root::btScalar,
        /// m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
        pub m_btSeed2: ::std::os::raw::c_ulong,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver20setupSolverFunctionsEb"]
        pub fn btSequentialImpulseConstraintSolver_setupSolverFunctions(
            this: *mut root::btSequentialImpulseConstraintSolver,
            useSimd: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver23setupFrictionConstraintER18btSolverConstraintRK9btVector3iiR15btManifoldPointS4_S4_P17btCollisionObjectS8_fRK19btContactSolverInfoff"]
        pub fn btSequentialImpulseConstraintSolver_setupFrictionConstraint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            solverConstraint: *mut root::btSolverConstraint,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            infoGlobal: *const root::btContactSolverInfo,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver32setupTorsionalFrictionConstraintER18btSolverConstraintRK9btVector3iiR15btManifoldPointfS4_S4_P17btCollisionObjectS8_fff"]
        pub fn btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            solverConstraint: *mut root::btSolverConstraint,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            combinedTorsionalFriction: root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver21addFrictionConstraintERK9btVector3iiiR15btManifoldPointS2_S2_P17btCollisionObjectS6_fRK19btContactSolverInfoff"]
        pub fn btSequentialImpulseConstraintSolver_addFrictionConstraint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            frictionIndex: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            infoGlobal: *const root::btContactSolverInfo,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) -> *mut root::btSolverConstraint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver30addTorsionalFrictionConstraintERK9btVector3iiiR15btManifoldPointfS2_S2_P17btCollisionObjectS6_fff"]
        pub fn btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            frictionIndex: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            torsionalFriction: root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) -> *mut root::btSolverConstraint;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver22setupContactConstraintER18btSolverConstraintiiR15btManifoldPointRK19btContactSolverInfoRfRK9btVector3SA_"]
        pub fn btSequentialImpulseConstraintSolver_setupContactConstraint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            solverConstraint: *mut root::btSolverConstraint,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            infoGlobal: *const root::btContactSolverInfo,
            relaxation: *mut root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver24applyAnisotropicFrictionEP17btCollisionObjectR9btVector3i"]
        pub fn btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
            colObj: *mut root::btCollisionObject,
            frictionDirection: *mut root::btVector3,
            frictionMode: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver28setFrictionConstraintImpulseER18btSolverConstraintiiR15btManifoldPointRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
            this: *mut root::btSequentialImpulseConstraintSolver,
            solverConstraint: *mut root::btSolverConstraint,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver16restitutionCurveEfff"]
        pub fn btSequentialImpulseConstraintSolver_restitutionCurve(
            this: *mut root::btSequentialImpulseConstraintSolver,
            rel_vel: root::btScalar,
            restitution: root::btScalar,
            velocityThreshold: root::btScalar,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver14convertContactEP20btPersistentManifoldRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_convertContact(
            this: *mut root::btSequentialImpulseConstraintSolver,
            manifold: *mut root::btPersistentManifold,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver12convertJointEP18btSolverConstraintP17btTypedConstraintRKNS2_17btConstraintInfo1EiiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_convertJoint(
            this: *mut root::btSequentialImpulseConstraintSolver,
            currentConstraintRow: *mut root::btSolverConstraint,
            constraint: *mut root::btTypedConstraint,
            info1: *const root::btTypedConstraint_btConstraintInfo1,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver19getOrInitSolverBodyER17btCollisionObjectf"]
        pub fn btSequentialImpulseConstraintSolver_getOrInitSolverBody(
            this: *mut root::btSequentialImpulseConstraintSolver,
            body: *mut root::btCollisionObject,
            timeStep: root::btScalar,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver14initSolverBodyEP12btSolverBodyP17btCollisionObjectf"]
        pub fn btSequentialImpulseConstraintSolver_initSolverBody(
            this: *mut root::btSequentialImpulseConstraintSolver,
            solverBody: *mut root::btSolverBody,
            collisionObject: *mut root::btCollisionObject,
            timeStep: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33resolveSingleConstraintRowGenericER12btSolverBodyS1_RK18btSolverConstraint"]
        pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
            this: *mut root::btSequentialImpulseConstraintSolver,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver37resolveSingleConstraintRowGenericSIMDER12btSolverBodyS1_RK18btSolverConstraint"]
        pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
            this: *mut root::btSequentialImpulseConstraintSolver,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver36resolveSingleConstraintRowLowerLimitER12btSolverBodyS1_RK18btSolverConstraint"]
        pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
            this: *mut root::btSequentialImpulseConstraintSolver,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver40resolveSingleConstraintRowLowerLimitSIMDER12btSolverBodyS1_RK18btSolverConstraint"]
        pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
            this: *mut root::btSequentialImpulseConstraintSolver,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver17writeBackContactsEiiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_writeBackContacts(
            this: *mut root::btSequentialImpulseConstraintSolver,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver15writeBackJointsEiiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_writeBackJoints(
            this: *mut root::btSequentialImpulseConstraintSolver,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver15writeBackBodiesEiiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_writeBackBodies(
            this: *mut root::btSequentialImpulseConstraintSolver,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver7btRand2Ev"]
        pub fn btSequentialImpulseConstraintSolver_btRand2(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver10btRandInt2Ei"]
        pub fn btSequentialImpulseConstraintSolver_btRandInt2(
            this: *mut root::btSequentialImpulseConstraintSolver,
            n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        /// Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver35getScalarConstraintRowSolverGenericEv"]
        pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33getSSE2ConstraintRowSolverGenericEv"]
        pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver35getSSE4_1ConstraintRowSolverGenericEv"]
        pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        /// Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver38getScalarConstraintRowSolverLowerLimitEv"]
        pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver36getSSE2ConstraintRowSolverLowerLimitEv"]
        pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver38getSSE4_1ConstraintRowSolverLowerLimitEv"]
        pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(
            this: *mut root::btSequentialImpulseConstraintSolver,
        ) -> root::btSingleConstraintRowSolver;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolverC1Ev"]
        pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(
            this: *mut root::btSequentialImpulseConstraintSolver,
        );
    }
    impl btSequentialImpulseConstraintSolver {
        #[inline]
        pub unsafe fn setupSolverFunctions(&mut self, useSimd: bool) {
            btSequentialImpulseConstraintSolver_setupSolverFunctions(self, useSimd)
        }
        #[inline]
        pub unsafe fn setupFrictionConstraint(
            &mut self,
            solverConstraint: *mut root::btSolverConstraint,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            infoGlobal: *const root::btContactSolverInfo,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) {
            btSequentialImpulseConstraintSolver_setupFrictionConstraint(
                self,
                solverConstraint,
                normalAxis,
                solverBodyIdA,
                solverBodyIdB,
                cp,
                rel_pos1,
                rel_pos2,
                colObj0,
                colObj1,
                relaxation,
                infoGlobal,
                desiredVelocity,
                cfmSlip,
            )
        }
        #[inline]
        pub unsafe fn setupTorsionalFrictionConstraint(
            &mut self,
            solverConstraint: *mut root::btSolverConstraint,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            combinedTorsionalFriction: root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) {
            btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
                self,
                solverConstraint,
                normalAxis,
                solverBodyIdA,
                solverBodyIdB,
                cp,
                combinedTorsionalFriction,
                rel_pos1,
                rel_pos2,
                colObj0,
                colObj1,
                relaxation,
                desiredVelocity,
                cfmSlip,
            )
        }
        #[inline]
        pub unsafe fn addFrictionConstraint(
            &mut self,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            frictionIndex: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            infoGlobal: *const root::btContactSolverInfo,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) -> *mut root::btSolverConstraint {
            btSequentialImpulseConstraintSolver_addFrictionConstraint(
                self,
                normalAxis,
                solverBodyIdA,
                solverBodyIdB,
                frictionIndex,
                cp,
                rel_pos1,
                rel_pos2,
                colObj0,
                colObj1,
                relaxation,
                infoGlobal,
                desiredVelocity,
                cfmSlip,
            )
        }
        #[inline]
        pub unsafe fn addTorsionalFrictionConstraint(
            &mut self,
            normalAxis: *const root::btVector3,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            frictionIndex: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            torsionalFriction: root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
            colObj0: *mut root::btCollisionObject,
            colObj1: *mut root::btCollisionObject,
            relaxation: root::btScalar,
            desiredVelocity: root::btScalar,
            cfmSlip: root::btScalar,
        ) -> *mut root::btSolverConstraint {
            btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
                self,
                normalAxis,
                solverBodyIdA,
                solverBodyIdB,
                frictionIndex,
                cp,
                torsionalFriction,
                rel_pos1,
                rel_pos2,
                colObj0,
                colObj1,
                relaxation,
                desiredVelocity,
                cfmSlip,
            )
        }
        #[inline]
        pub unsafe fn setupContactConstraint(
            &mut self,
            solverConstraint: *mut root::btSolverConstraint,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            infoGlobal: *const root::btContactSolverInfo,
            relaxation: *mut root::btScalar,
            rel_pos1: *const root::btVector3,
            rel_pos2: *const root::btVector3,
        ) {
            btSequentialImpulseConstraintSolver_setupContactConstraint(
                self,
                solverConstraint,
                solverBodyIdA,
                solverBodyIdB,
                cp,
                infoGlobal,
                relaxation,
                rel_pos1,
                rel_pos2,
            )
        }
        #[inline]
        pub unsafe fn applyAnisotropicFriction(
            colObj: *mut root::btCollisionObject,
            frictionDirection: *mut root::btVector3,
            frictionMode: ::std::os::raw::c_int,
        ) {
            btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
                colObj,
                frictionDirection,
                frictionMode,
            )
        }
        #[inline]
        pub unsafe fn setFrictionConstraintImpulse(
            &mut self,
            solverConstraint: *mut root::btSolverConstraint,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            cp: *mut root::btManifoldPoint,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
                self,
                solverConstraint,
                solverBodyIdA,
                solverBodyIdB,
                cp,
                infoGlobal,
            )
        }
        #[inline]
        pub unsafe fn restitutionCurve(
            &mut self,
            rel_vel: root::btScalar,
            restitution: root::btScalar,
            velocityThreshold: root::btScalar,
        ) -> root::btScalar {
            btSequentialImpulseConstraintSolver_restitutionCurve(
                self,
                rel_vel,
                restitution,
                velocityThreshold,
            )
        }
        #[inline]
        pub unsafe fn convertContact(
            &mut self,
            manifold: *mut root::btPersistentManifold,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_convertContact(self, manifold, infoGlobal)
        }
        #[inline]
        pub unsafe fn convertJoint(
            &mut self,
            currentConstraintRow: *mut root::btSolverConstraint,
            constraint: *mut root::btTypedConstraint,
            info1: *const root::btTypedConstraint_btConstraintInfo1,
            solverBodyIdA: ::std::os::raw::c_int,
            solverBodyIdB: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_convertJoint(
                self,
                currentConstraintRow,
                constraint,
                info1,
                solverBodyIdA,
                solverBodyIdB,
                infoGlobal,
            )
        }
        #[inline]
        pub unsafe fn getOrInitSolverBody(
            &mut self,
            body: *mut root::btCollisionObject,
            timeStep: root::btScalar,
        ) -> ::std::os::raw::c_int {
            btSequentialImpulseConstraintSolver_getOrInitSolverBody(self, body, timeStep)
        }
        #[inline]
        pub unsafe fn initSolverBody(
            &mut self,
            solverBody: *mut root::btSolverBody,
            collisionObject: *mut root::btCollisionObject,
            timeStep: root::btScalar,
        ) {
            btSequentialImpulseConstraintSolver_initSolverBody(
                self,
                solverBody,
                collisionObject,
                timeStep,
            )
        }
        #[inline]
        pub unsafe fn resolveSingleConstraintRowGeneric(
            &mut self,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar {
            btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
                self,
                bodyA,
                bodyB,
                contactConstraint,
            )
        }
        #[inline]
        pub unsafe fn resolveSingleConstraintRowGenericSIMD(
            &mut self,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar {
            btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
                self,
                bodyA,
                bodyB,
                contactConstraint,
            )
        }
        #[inline]
        pub unsafe fn resolveSingleConstraintRowLowerLimit(
            &mut self,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar {
            btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
                self,
                bodyA,
                bodyB,
                contactConstraint,
            )
        }
        #[inline]
        pub unsafe fn resolveSingleConstraintRowLowerLimitSIMD(
            &mut self,
            bodyA: *mut root::btSolverBody,
            bodyB: *mut root::btSolverBody,
            contactConstraint: *const root::btSolverConstraint,
        ) -> root::btScalar {
            btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
                self,
                bodyA,
                bodyB,
                contactConstraint,
            )
        }
        #[inline]
        pub unsafe fn writeBackContacts(
            &mut self,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_writeBackContacts(self, iBegin, iEnd, infoGlobal)
        }
        #[inline]
        pub unsafe fn writeBackJoints(
            &mut self,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_writeBackJoints(self, iBegin, iEnd, infoGlobal)
        }
        #[inline]
        pub unsafe fn writeBackBodies(
            &mut self,
            iBegin: ::std::os::raw::c_int,
            iEnd: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        ) {
            btSequentialImpulseConstraintSolver_writeBackBodies(self, iBegin, iEnd, infoGlobal)
        }
        #[inline]
        pub unsafe fn btRand2(&mut self) -> ::std::os::raw::c_ulong {
            btSequentialImpulseConstraintSolver_btRand2(self)
        }
        #[inline]
        pub unsafe fn btRandInt2(&mut self, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
            btSequentialImpulseConstraintSolver_btRandInt2(self, n)
        }
        #[inline]
        pub unsafe fn getScalarConstraintRowSolverGeneric(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(self)
        }
        #[inline]
        pub unsafe fn getSSE2ConstraintRowSolverGeneric(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(self)
        }
        #[inline]
        pub unsafe fn getSSE4_1ConstraintRowSolverGeneric(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(self)
        }
        #[inline]
        pub unsafe fn getScalarConstraintRowSolverLowerLimit(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(self)
        }
        #[inline]
        pub unsafe fn getSSE2ConstraintRowSolverLowerLimit(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(self)
        }
        #[inline]
        pub unsafe fn getSSE4_1ConstraintRowSolverLowerLimit(
            &mut self,
        ) -> root::btSingleConstraintRowSolver {
            btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(
                &mut __bindgen_tmp,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver15convertContactsEPP20btPersistentManifoldiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_convertContacts(
            this: *mut ::std::os::raw::c_void,
            manifoldPtr: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver13convertJointsEPP17btTypedConstraintiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_convertJoints(
            this: *mut ::std::os::raw::c_void,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver13convertBodiesEPP17btCollisionObjectiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_convertBodies(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver45solveGroupCacheFriendlySplitImpulseIterationsEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
        pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySplitImpulseIterations(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            manifoldPtr: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
            debugDrawer: *mut root::btIDebugDraw,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver29solveGroupCacheFriendlyFinishEPP17btCollisionObjectiRK19btContactSolverInfo"]
        pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyFinish(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver20solveSingleIterationEiPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
        pub fn btSequentialImpulseConstraintSolver_solveSingleIteration(
            this: *mut ::std::os::raw::c_void,
            iteration: ::std::os::raw::c_int,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            manifoldPtr: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
            debugDrawer: *mut root::btIDebugDraw,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver28solveGroupCacheFriendlySetupEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
        pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySetup(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            manifoldPtr: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
            debugDrawer: *mut root::btIDebugDraw,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33solveGroupCacheFriendlyIterationsEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
        pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyIterations(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            manifoldPtr: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            infoGlobal: *const root::btContactSolverInfo,
            debugDrawer: *mut root::btIDebugDraw,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolverD1Ev"]
        pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_destructor(
            this: *mut root::btSequentialImpulseConstraintSolver,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver10solveGroupEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDrawP12btDispatcher"]
        pub fn btSequentialImpulseConstraintSolver_solveGroup(
            this: *mut ::std::os::raw::c_void,
            bodies: *mut *mut root::btCollisionObject,
            numBodies: ::std::os::raw::c_int,
            manifold: *mut *mut root::btPersistentManifold,
            numManifolds: ::std::os::raw::c_int,
            constraints: *mut *mut root::btTypedConstraint,
            numConstraints: ::std::os::raw::c_int,
            info: *const root::btContactSolverInfo,
            debugDrawer: *mut root::btIDebugDraw,
            dispatcher: *mut root::btDispatcher,
        ) -> root::btScalar;
    }
    extern "C" {
        /// clear internal cached data and reset random seed
        #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver5resetEv"]
        pub fn btSequentialImpulseConstraintSolver_reset(this: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    pub struct btVehicleRaycaster__bindgen_vtable(::std::os::raw::c_void);
    /// btVehicleRaycaster is provides interface for between vehicle simulation and raycasting
    #[repr(C)]
    #[derive(Debug)]
    pub struct btVehicleRaycaster {
        pub vtable_: *const btVehicleRaycaster__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btVehicleRaycaster_btVehicleRaycasterResult {
        pub m_hitPointInWorld: root::btVector3,
        pub m_hitNormalInWorld: root::btVector3,
        pub m_distFraction: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btWheelInfoConstructionInfo {
        pub m_chassisConnectionCS: root::btVector3,
        pub m_wheelDirectionCS: root::btVector3,
        pub m_wheelAxleCS: root::btVector3,
        pub m_suspensionRestLength: root::btScalar,
        pub m_maxSuspensionTravelCm: root::btScalar,
        pub m_wheelRadius: root::btScalar,
        pub m_suspensionStiffness: root::btScalar,
        pub m_wheelsDampingCompression: root::btScalar,
        pub m_wheelsDampingRelaxation: root::btScalar,
        pub m_frictionSlip: root::btScalar,
        pub m_maxSuspensionForce: root::btScalar,
        pub m_bIsFrontWheel: bool,
    }
    /// btWheelInfo contains information per wheel about friction and suspension.
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btWheelInfo {
        pub m_raycastInfo: root::btWheelInfo_RaycastInfo,
        pub m_worldTransform: root::btTransform,
        pub m_chassisConnectionPointCS: root::btVector3,
        pub m_wheelDirectionCS: root::btVector3,
        pub m_wheelAxleCS: root::btVector3,
        pub m_suspensionRestLength1: root::btScalar,
        pub m_maxSuspensionTravelCm: root::btScalar,
        pub m_wheelsRadius: root::btScalar,
        pub m_suspensionStiffness: root::btScalar,
        pub m_wheelsDampingCompression: root::btScalar,
        pub m_wheelsDampingRelaxation: root::btScalar,
        pub m_frictionSlip: root::btScalar,
        pub m_steering: root::btScalar,
        pub m_rotation: root::btScalar,
        pub m_deltaRotation: root::btScalar,
        pub m_rollInfluence: root::btScalar,
        pub m_maxSuspensionForce: root::btScalar,
        pub m_engineForce: root::btScalar,
        pub m_brake: root::btScalar,
        pub m_bIsFrontWheel: bool,
        pub m_clientInfo: *mut ::std::os::raw::c_void,
        pub m_clippedInvContactDotSuspension: root::btScalar,
        pub m_suspensionRelativeVelocity: root::btScalar,
        pub m_wheelsSuspensionForce: root::btScalar,
        pub m_skidInfo: root::btScalar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btWheelInfo_RaycastInfo {
        pub m_contactNormalWS: root::btVector3,
        pub m_contactPointWS: root::btVector3,
        pub m_suspensionLength: root::btScalar,
        pub m_hardPointWS: root::btVector3,
        pub m_wheelDirectionWS: root::btVector3,
        pub m_wheelAxleWS: root::btVector3,
        pub m_isInContact: bool,
        pub m_groundObject: *mut ::std::os::raw::c_void,
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK11btWheelInfo23getSuspensionRestLengthEv"]
        pub fn btWheelInfo_getSuspensionRestLength(
            this: *const root::btWheelInfo,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN11btWheelInfo11updateWheelERK11btRigidBodyRNS_11RaycastInfoE"]
        pub fn btWheelInfo_updateWheel(
            this: *mut root::btWheelInfo,
            chassis: *const root::btRigidBody,
            raycastInfo: *mut root::btWheelInfo_RaycastInfo,
        );
    }
    impl btWheelInfo {
        #[inline]
        pub unsafe fn getSuspensionRestLength(&self) -> root::btScalar {
            btWheelInfo_getSuspensionRestLength(self)
        }
        #[inline]
        pub unsafe fn updateWheel(
            &mut self,
            chassis: *const root::btRigidBody,
            raycastInfo: *mut root::btWheelInfo_RaycastInfo,
        ) {
            btWheelInfo_updateWheel(self, chassis, raycastInfo)
        }
    }
    #[repr(C)]
    pub struct btActionInterface__bindgen_vtable(::std::os::raw::c_void);
    /// Basic interface to allow actions such as vehicles and characters to be updated inside a btDynamicsWorld
    #[repr(C)]
    #[derive(Debug)]
    pub struct btActionInterface {
        pub vtable_: *const btActionInterface__bindgen_vtable,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN17btActionInterface12getFixedBodyEv"]
        pub fn btActionInterface_getFixedBody() -> *mut root::btRigidBody;
    }
    impl btActionInterface {
        #[inline]
        pub unsafe fn getFixedBody() -> *mut root::btRigidBody {
            btActionInterface_getFixedBody()
        }
    }
    /// rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
    #[repr(C)]
    #[derive(Debug)]
    pub struct btRaycastVehicle {
        pub _base: root::btActionInterface,
        pub m_forwardWS: root::btAlignedObjectArray<root::btVector3>,
        pub m_axle: root::btAlignedObjectArray<root::btVector3>,
        pub m_forwardImpulse: root::btAlignedObjectArray<root::btScalar>,
        pub m_sideImpulse: root::btAlignedObjectArray<root::btScalar>,
        /// backwards compatibility
        pub m_userConstraintType: ::std::os::raw::c_int,
        pub m_userConstraintId: ::std::os::raw::c_int,
        pub m_vehicleRaycaster: *mut root::btVehicleRaycaster,
        pub m_pitchControl: root::btScalar,
        pub m_steeringValue: root::btScalar,
        pub m_currentVehicleSpeedKmHour: root::btScalar,
        pub m_chassisBody: *mut root::btRigidBody,
        pub m_indexRightAxis: ::std::os::raw::c_int,
        pub m_indexUpAxis: ::std::os::raw::c_int,
        pub m_indexForwardAxis: ::std::os::raw::c_int,
        pub m_wheelInfo: root::btAlignedObjectArray<root::btWheelInfo>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btRaycastVehicle_btVehicleTuning {
        pub m_suspensionStiffness: root::btScalar,
        pub m_suspensionCompression: root::btScalar,
        pub m_suspensionDamping: root::btScalar,
        pub m_maxSuspensionTravelCm: root::btScalar,
        pub m_frictionSlip: root::btScalar,
        pub m_maxSuspensionForce: root::btScalar,
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btRaycastVehicle24getChassisWorldTransformEv"]
        pub fn btRaycastVehicle_getChassisWorldTransform(
            this: *const root::btRaycastVehicle,
        ) -> *const root::btTransform;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle7rayCastER11btWheelInfo"]
        pub fn btRaycastVehicle_rayCast(
            this: *mut root::btRaycastVehicle,
            wheel: *mut root::btWheelInfo,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle15resetSuspensionEv"]
        pub fn btRaycastVehicle_resetSuspension(this: *mut root::btRaycastVehicle);
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btRaycastVehicle16getSteeringValueEi"]
        pub fn btRaycastVehicle_getSteeringValue(
            this: *const root::btRaycastVehicle,
            wheel: ::std::os::raw::c_int,
        ) -> root::btScalar;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle16setSteeringValueEfi"]
        pub fn btRaycastVehicle_setSteeringValue(
            this: *mut root::btRaycastVehicle,
            steering: root::btScalar,
            wheel: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle16applyEngineForceEfi"]
        pub fn btRaycastVehicle_applyEngineForce(
            this: *mut root::btRaycastVehicle,
            force: root::btScalar,
            wheel: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btRaycastVehicle19getWheelTransformWSEi"]
        pub fn btRaycastVehicle_getWheelTransformWS(
            this: *const root::btRaycastVehicle,
            wheelIndex: ::std::os::raw::c_int,
        ) -> *const root::btTransform;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle20updateWheelTransformEib"]
        pub fn btRaycastVehicle_updateWheelTransform(
            this: *mut root::btRaycastVehicle,
            wheelIndex: ::std::os::raw::c_int,
            interpolatedTransform: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb"]
        pub fn btRaycastVehicle_addWheel(
            this: *mut root::btRaycastVehicle,
            connectionPointCS0: *const root::btVector3,
            wheelDirectionCS0: *const root::btVector3,
            wheelAxleCS: *const root::btVector3,
            suspensionRestLength: root::btScalar,
            wheelRadius: root::btScalar,
            tuning: *const root::btRaycastVehicle_btVehicleTuning,
            isFrontWheel: bool,
        ) -> *mut root::btWheelInfo;
    }
    extern "C" {
        #[link_name = "\u{1}_ZNK16btRaycastVehicle12getWheelInfoEi"]
        pub fn btRaycastVehicle_getWheelInfo(
            this: *const root::btRaycastVehicle,
            index: ::std::os::raw::c_int,
        ) -> *const root::btWheelInfo;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle12getWheelInfoEi"]
        pub fn btRaycastVehicle_getWheelInfo1(
            this: *mut root::btRaycastVehicle,
            index: ::std::os::raw::c_int,
        ) -> *mut root::btWheelInfo;
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle23updateWheelTransformsWSER11btWheelInfob"]
        pub fn btRaycastVehicle_updateWheelTransformsWS(
            this: *mut root::btRaycastVehicle,
            wheel: *mut root::btWheelInfo,
            interpolatedTransform: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle8setBrakeEfi"]
        pub fn btRaycastVehicle_setBrake(
            this: *mut root::btRaycastVehicle,
            brake: root::btScalar,
            wheelIndex: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle16updateSuspensionEf"]
        pub fn btRaycastVehicle_updateSuspension(
            this: *mut root::btRaycastVehicle,
            deltaTime: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster"]
        pub fn btRaycastVehicle_btRaycastVehicle(
            this: *mut root::btRaycastVehicle,
            tuning: *const root::btRaycastVehicle_btVehicleTuning,
            chassis: *mut root::btRigidBody,
            raycaster: *mut root::btVehicleRaycaster,
        );
    }
    impl btRaycastVehicle {
        #[inline]
        pub unsafe fn getChassisWorldTransform(&self) -> *const root::btTransform {
            btRaycastVehicle_getChassisWorldTransform(self)
        }
        #[inline]
        pub unsafe fn rayCast(&mut self, wheel: *mut root::btWheelInfo) -> root::btScalar {
            btRaycastVehicle_rayCast(self, wheel)
        }
        #[inline]
        pub unsafe fn resetSuspension(&mut self) {
            btRaycastVehicle_resetSuspension(self)
        }
        #[inline]
        pub unsafe fn getSteeringValue(&self, wheel: ::std::os::raw::c_int) -> root::btScalar {
            btRaycastVehicle_getSteeringValue(self, wheel)
        }
        #[inline]
        pub unsafe fn setSteeringValue(
            &mut self,
            steering: root::btScalar,
            wheel: ::std::os::raw::c_int,
        ) {
            btRaycastVehicle_setSteeringValue(self, steering, wheel)
        }
        #[inline]
        pub unsafe fn applyEngineForce(
            &mut self,
            force: root::btScalar,
            wheel: ::std::os::raw::c_int,
        ) {
            btRaycastVehicle_applyEngineForce(self, force, wheel)
        }
        #[inline]
        pub unsafe fn getWheelTransformWS(
            &self,
            wheelIndex: ::std::os::raw::c_int,
        ) -> *const root::btTransform {
            btRaycastVehicle_getWheelTransformWS(self, wheelIndex)
        }
        #[inline]
        pub unsafe fn updateWheelTransform(
            &mut self,
            wheelIndex: ::std::os::raw::c_int,
            interpolatedTransform: bool,
        ) {
            btRaycastVehicle_updateWheelTransform(self, wheelIndex, interpolatedTransform)
        }
        #[inline]
        pub unsafe fn addWheel(
            &mut self,
            connectionPointCS0: *const root::btVector3,
            wheelDirectionCS0: *const root::btVector3,
            wheelAxleCS: *const root::btVector3,
            suspensionRestLength: root::btScalar,
            wheelRadius: root::btScalar,
            tuning: *const root::btRaycastVehicle_btVehicleTuning,
            isFrontWheel: bool,
        ) -> *mut root::btWheelInfo {
            btRaycastVehicle_addWheel(
                self,
                connectionPointCS0,
                wheelDirectionCS0,
                wheelAxleCS,
                suspensionRestLength,
                wheelRadius,
                tuning,
                isFrontWheel,
            )
        }
        #[inline]
        pub unsafe fn getWheelInfo(
            &self,
            index: ::std::os::raw::c_int,
        ) -> *const root::btWheelInfo {
            btRaycastVehicle_getWheelInfo(self, index)
        }
        #[inline]
        pub unsafe fn getWheelInfo1(
            &mut self,
            index: ::std::os::raw::c_int,
        ) -> *mut root::btWheelInfo {
            btRaycastVehicle_getWheelInfo1(self, index)
        }
        #[inline]
        pub unsafe fn updateWheelTransformsWS(
            &mut self,
            wheel: *mut root::btWheelInfo,
            interpolatedTransform: bool,
        ) {
            btRaycastVehicle_updateWheelTransformsWS(self, wheel, interpolatedTransform)
        }
        #[inline]
        pub unsafe fn setBrake(
            &mut self,
            brake: root::btScalar,
            wheelIndex: ::std::os::raw::c_int,
        ) {
            btRaycastVehicle_setBrake(self, brake, wheelIndex)
        }
        #[inline]
        pub unsafe fn updateSuspension(&mut self, deltaTime: root::btScalar) {
            btRaycastVehicle_updateSuspension(self, deltaTime)
        }
        #[inline]
        pub unsafe fn new(
            tuning: *const root::btRaycastVehicle_btVehicleTuning,
            chassis: *mut root::btRigidBody,
            raycaster: *mut root::btVehicleRaycaster,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            btRaycastVehicle_btRaycastVehicle(&mut __bindgen_tmp, tuning, chassis, raycaster);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicleD1Ev"]
        pub fn btRaycastVehicle_btRaycastVehicle_destructor(this: *mut root::btRaycastVehicle);
    }
    extern "C" {
        /// btActionInterface interface
        #[link_name = "\u{1}_ZN16btRaycastVehicle9debugDrawEP12btIDebugDraw"]
        pub fn btRaycastVehicle_debugDraw(
            this: *mut ::std::os::raw::c_void,
            debugDrawer: *mut root::btIDebugDraw,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle13updateVehicleEf"]
        pub fn btRaycastVehicle_updateVehicle(
            this: *mut ::std::os::raw::c_void,
            step: root::btScalar,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZN16btRaycastVehicle14updateFrictionEf"]
        pub fn btRaycastVehicle_updateFriction(
            this: *mut ::std::os::raw::c_void,
            timeStep: root::btScalar,
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct btDefaultVehicleRaycaster {
        pub _base: root::btVehicleRaycaster,
        pub m_dynamicsWorld: *mut root::btDynamicsWorld,
    }
    extern "C" {
        #[link_name = "\u{1}_ZN25btDefaultVehicleRaycaster7castRayERK9btVector3S2_RN18btVehicleRaycaster24btVehicleRaycasterResultE"]
        pub fn btDefaultVehicleRaycaster_castRay(
            this: *mut ::std::os::raw::c_void,
            from: *const root::btVector3,
            to: *const root::btVector3,
            result: *mut root::btVehicleRaycaster_btVehicleRaycasterResult,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSoftBodyFloatData {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btSoftBodyDoubleData {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btClockData {
        pub _address: u8,
    }
}
