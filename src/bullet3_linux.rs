/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const b3Vector3DataName: &'static [u8; 19usize] = b"b3Vector3FloatData\0";
pub const b3Point2PointConstraintDataName: &'static [u8; 33usize] =
    b"b3Point2PointConstraintFloatData\0";
pub type std_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = __gnu_cxx___alloc_traits;
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = std_basic_string__Alloc_traits;
pub type std_basic_string_difference_type = std_basic_string__Alloc_traits;
pub type std_basic_string_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_const_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub union std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: *mut _CharT,
    pub _M_allocated_capacity: std_basic_string_size_type,
    _bindgen_union_align: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn b3EnterProfileZone(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn b3LeaveProfileZone();
}
#[repr(C)]
#[derive(Debug)]
pub struct b3ProfileZone {
    pub _address: u8,
}
pub type b3PrintfFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3WarningMessageFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3ErrorMessageFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3EnterProfileZoneFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type b3LeaveProfileZoneFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    /// The developer can route b3Printf output using their own implementation
    pub fn b3SetCustomPrintfFunc(printfFunc: b3PrintfFunc);
}
extern "C" {
    pub fn b3SetCustomWarningMessageFunc(warningMsgFunc: b3WarningMessageFunc);
}
extern "C" {
    pub fn b3SetCustomErrorMessageFunc(errorMsgFunc: b3ErrorMessageFunc);
}
extern "C" {
    /// Set custom profile zone functions (zones can be nested)
    pub fn b3SetCustomEnterProfileZoneFunc(enterFunc: b3EnterProfileZoneFunc);
}
extern "C" {
    pub fn b3SetCustomLeaveProfileZoneFunc(leaveFunc: b3LeaveProfileZoneFunc);
}
extern "C" {
    /// Don't use those internal functions directly, use the b3Printf or b3SetCustomPrintfFunc instead (or warning/error version)
    pub fn b3OutputPrintfVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn b3OutputWarningMessageVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn b3OutputErrorMessageVarArgsInternal(str: *const ::std::os::raw::c_char, ...);
}
pub type b3Scalar = f32;
/// rudimentary class to provide type info
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedObject {
    pub m_objectType: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_Z22b3AlignedAllocInternalmi"]
    pub fn b3AlignedAllocInternal(
        size: usize,
        alignment: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z21b3AlignedFreeInternalPv"]
    pub fn b3AlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
}
pub type b3AlignedAllocFunc = ::std::option::Option<
    unsafe extern "C" fn(size: usize, alignment: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void,
>;
pub type b3AlignedFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
pub type b3AllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type b3FreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// The developer can let all Bullet memory allocations go through a custom memory allocator, using b3AlignedAllocSetCustom
    #[link_name = "\u{1}_Z23b3AlignedAllocSetCustomPFPvmEPFvS_E"]
    pub fn b3AlignedAllocSetCustom(allocFunc: b3AllocFunc, freeFunc: b3FreeFunc);
}
extern "C" {
    /// If the developer has already an custom aligned allocator, then b3AlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
    #[link_name = "\u{1}_Z30b3AlignedAllocSetCustomAlignedPFPvmiEPFvS_E"]
    pub fn b3AlignedAllocSetCustomAligned(
        allocFunc: b3AlignedAllocFunc,
        freeFunc: b3AlignedFreeFunc,
    );
}
pub type b3AlignedAllocator_self_type = u8;
pub type b3AlignedAllocator_const_pointer<T> = *const T;
pub type b3AlignedAllocator_const_reference<T> = *const T;
pub type b3AlignedAllocator_pointer<T> = *mut T;
pub type b3AlignedAllocator_reference<T> = *mut T;
pub type b3AlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedAllocator_rebind {
    pub _address: u8,
}
pub type b3AlignedAllocator_rebind_other = u8;
/// The b3AlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct b3AlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedObjectArray_less {
    pub _address: u8,
}
/// @brief b3Vector3 can be used to represent 3D points and vectors.
/// It has an un-used w component to suit 16-byte alignment when b3Vector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
/// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Vector3 {
    pub __bindgen_anon_1: b3Vector3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Vector3__bindgen_ty_1 {
    pub m_floats: [f32; 4usize],
    pub __bindgen_anon_1: b3Vector3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Vector4 {
    pub _base: b3Vector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3FloatData {
    pub m_floats: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Vector3DoubleData {
    pub m_floats: [f64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3QuadWord {
    pub __bindgen_anon_1: b3QuadWord__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3QuadWord__bindgen_ty_1 {
    pub m_floats: [b3Scalar; 4usize],
    pub __bindgen_anon_1: b3QuadWord__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3QuadWord__bindgen_ty_1__bindgen_ty_1 {
    pub x: b3Scalar,
    pub y: b3Scalar,
    pub z: b3Scalar,
    pub w: b3Scalar,
}
/// @brief The b3Quaternion implements quaternion to perform linear algebra rotations in combination with b3Matrix3x3, b3Vector3 and b3Transform.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Quaternion {
    pub _base: b3QuadWord,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
/// @brief The b3Matrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with b3Quaternion, b3Transform and b3Vector3.
/// Make sure to only include a pure orthogonal matrix without scaling.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Matrix3x3 {
    /// Data storage for the matrix, each vector is a row of the matrix
    pub m_el: [b3Vector3; 3usize],
}
extern "C" {
    /// @brief Return the determinant of the matrix
    #[link_name = "\u{1}_ZNK11b3Matrix3x311determinantEv"]
    pub fn b3Matrix3x3_determinant(this: *const b3Matrix3x3) -> b3Scalar;
}
extern "C" {
    /// @brief Return the adjoint of the matrix
    #[link_name = "\u{1}_ZNK11b3Matrix3x37adjointEv"]
    pub fn b3Matrix3x3_adjoint(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the matrix with all values non negative
    #[link_name = "\u{1}_ZNK11b3Matrix3x38absoluteEv"]
    pub fn b3Matrix3x3_absolute(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the transpose of the matrix
    #[link_name = "\u{1}_ZNK11b3Matrix3x39transposeEv"]
    pub fn b3Matrix3x3_transpose(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    /// @brief Return the inverse of the matrix
    #[link_name = "\u{1}_ZNK11b3Matrix3x37inverseEv"]
    pub fn b3Matrix3x3_inverse(this: *const b3Matrix3x3) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Matrix3x314transposeTimesERKS_"]
    pub fn b3Matrix3x3_transposeTimes(
        this: *const b3Matrix3x3,
        m: *const b3Matrix3x3,
    ) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Matrix3x314timesTransposeERKS_"]
    pub fn b3Matrix3x3_timesTranspose(
        this: *const b3Matrix3x3,
        m: *const b3Matrix3x3,
    ) -> b3Matrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Matrix3x39serializeER20b3Matrix3x3FloatData"]
    pub fn b3Matrix3x3_serialize(this: *const b3Matrix3x3, dataOut: *mut b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Matrix3x314serializeFloatER20b3Matrix3x3FloatData"]
    pub fn b3Matrix3x3_serializeFloat(this: *const b3Matrix3x3, dataOut: *mut b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Matrix3x311deSerializeERK20b3Matrix3x3FloatData"]
    pub fn b3Matrix3x3_deSerialize(this: *mut b3Matrix3x3, dataIn: *const b3Matrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Matrix3x316deSerializeFloatERK20b3Matrix3x3FloatData"]
    pub fn b3Matrix3x3_deSerializeFloat(
        this: *mut b3Matrix3x3,
        dataIn: *const b3Matrix3x3FloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Matrix3x317deSerializeDoubleERK21b3Matrix3x3DoubleData"]
    pub fn b3Matrix3x3_deSerializeDouble(
        this: *mut b3Matrix3x3,
        dataIn: *const b3Matrix3x3DoubleData,
    );
}
impl b3Matrix3x3 {
    #[inline]
    pub unsafe fn determinant(&self) -> b3Scalar {
        b3Matrix3x3_determinant(self)
    }
    #[inline]
    pub unsafe fn adjoint(&self) -> b3Matrix3x3 {
        b3Matrix3x3_adjoint(self)
    }
    #[inline]
    pub unsafe fn absolute(&self) -> b3Matrix3x3 {
        b3Matrix3x3_absolute(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> b3Matrix3x3 {
        b3Matrix3x3_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> b3Matrix3x3 {
        b3Matrix3x3_inverse(self)
    }
    #[inline]
    pub unsafe fn transposeTimes(&self, m: *const b3Matrix3x3) -> b3Matrix3x3 {
        b3Matrix3x3_transposeTimes(self, m)
    }
    #[inline]
    pub unsafe fn timesTranspose(&self, m: *const b3Matrix3x3) -> b3Matrix3x3 {
        b3Matrix3x3_timesTranspose(self, m)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut b3Matrix3x3FloatData) {
        b3Matrix3x3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut b3Matrix3x3FloatData) {
        b3Matrix3x3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const b3Matrix3x3FloatData) {
        b3Matrix3x3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const b3Matrix3x3FloatData) {
        b3Matrix3x3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const b3Matrix3x3DoubleData) {
        b3Matrix3x3_deSerializeDouble(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Matrix3x3FloatData {
    pub m_el: [b3Vector3FloatData; 3usize],
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Matrix3x3DoubleData {
    pub m_el: [b3Vector3DoubleData; 3usize],
}
/// @brief The b3Transform class supports rigid transforms with only translation and rotation and no scaling/shear.
/// It can be used in combination with b3Vector3, b3Quaternion and b3Matrix3x3 linear algebra classes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Transform {
    /// Storage for the rotation
    pub m_basis: b3Matrix3x3,
    /// Storage for the translation
    pub m_origin: b3Vector3,
}
extern "C" {
    /// @brief Return the inverse of this transform times the other transform
    /// @param t The other transform
    /// return this.inverse() * the other
    #[link_name = "\u{1}_ZNK11b3Transform12inverseTimesERKS_"]
    pub fn b3Transform_inverseTimes(this: *const b3Transform, t: *const b3Transform)
        -> b3Transform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Transform9serializeER20b3TransformFloatData"]
    pub fn b3Transform_serialize(this: *const b3Transform, dataOut: *mut b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11b3Transform14serializeFloatER20b3TransformFloatData"]
    pub fn b3Transform_serializeFloat(this: *const b3Transform, dataOut: *mut b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Transform11deSerializeERK20b3TransformFloatData"]
    pub fn b3Transform_deSerialize(this: *mut b3Transform, dataIn: *const b3TransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Transform17deSerializeDoubleERK21b3TransformDoubleData"]
    pub fn b3Transform_deSerializeDouble(
        this: *mut b3Transform,
        dataIn: *const b3TransformDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11b3Transform16deSerializeFloatERK20b3TransformFloatData"]
    pub fn b3Transform_deSerializeFloat(
        this: *mut b3Transform,
        dataIn: *const b3TransformFloatData,
    );
}
impl b3Transform {
    #[inline]
    pub unsafe fn inverseTimes(&self, t: *const b3Transform) -> b3Transform {
        b3Transform_inverseTimes(self, t)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut b3TransformFloatData) {
        b3Transform_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut b3TransformFloatData) {
        b3Transform_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const b3TransformFloatData) {
        b3Transform_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const b3TransformDoubleData) {
        b3Transform_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const b3TransformFloatData) {
        b3Transform_deSerializeFloat(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformFloatData {
    pub m_basis: b3Matrix3x3FloatData,
    pub m_origin: b3Vector3FloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformDoubleData {
    pub m_basis: b3Matrix3x3DoubleData,
    pub m_origin: b3Vector3DoubleData,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtAabbMm {
    pub mi: b3Vector3,
    pub mx: b3Vector3,
}
pub type b3DbvtVolume = b3DbvtAabbMm;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtNode {
    pub volume: b3DbvtVolume,
    pub parent: *mut b3DbvtNode,
    pub __bindgen_anon_1: b3DbvtNode__bindgen_ty_1,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3DbvtNode__bindgen_ty_1 {
    pub childs: [*mut b3DbvtNode; 2usize],
    pub data: *mut ::std::os::raw::c_void,
    pub dataAsInt: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 2usize],
}
/// The b3DynamicBvh class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
/// This b3DynamicBvh is used for soft body collision detection and for the b3DynamicBvhBroadphase. It has a fast insert, remove and update of nodes.
/// Unlike the b3QuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh {
    pub m_root: *mut b3DbvtNode,
    pub m_free: *mut b3DbvtNode,
    pub m_lkhd: ::std::os::raw::c_int,
    pub m_leaves: ::std::os::raw::c_int,
    pub m_opath: ::std::os::raw::c_uint,
    pub m_stkStack: b3AlignedObjectArray<b3DynamicBvh_sStkNN>,
    pub m_rayTestStack: b3AlignedObjectArray<*const b3DbvtNode>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNN {
    pub a: *const b3DbvtNode,
    pub b: *const b3DbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNP {
    pub node: *const b3DbvtNode,
    pub mask: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkNPS {
    pub node: *const b3DbvtNode,
    pub mask: ::std::os::raw::c_int,
    pub value: b3Scalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicBvh_sStkCLN {
    pub node: *const b3DbvtNode,
    pub parent: *mut b3DbvtNode,
}
#[repr(C)]
pub struct b3DynamicBvh_ICollide__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh_ICollide {
    pub vtable_: *const b3DynamicBvh_ICollide__bindgen_vtable,
}
#[repr(C)]
pub struct b3DynamicBvh_IWriter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh_IWriter {
    pub vtable_: *const b3DynamicBvh_IWriter__bindgen_vtable,
}
#[repr(C)]
pub struct b3DynamicBvh_IClone__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3DynamicBvh_IClone {
    pub vtable_: *const b3DynamicBvh_IClone__bindgen_vtable,
}
pub const b3DynamicBvh_B3_SIMPLE_STACKSIZE: b3DynamicBvh__bindgen_ty_1 = 64;
pub const b3DynamicBvh_B3_DOUBLE_STACKSIZE: b3DynamicBvh__bindgen_ty_1 = 128;
pub type b3DynamicBvh__bindgen_ty_1 = u32;
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh5clearEv"]
    pub fn b3DynamicBvh_clear(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh16optimizeBottomUpEv"]
    pub fn b3DynamicBvh_optimizeBottomUp(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh15optimizeTopDownEi"]
    pub fn b3DynamicBvh_optimizeTopDown(
        this: *mut b3DynamicBvh,
        bu_treshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh19optimizeIncrementalEi"]
    pub fn b3DynamicBvh_optimizeIncremental(this: *mut b3DynamicBvh, passes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6insertERK12b3DbvtAabbMmPv"]
    pub fn b3DynamicBvh_insert(
        this: *mut b3DynamicBvh,
        box_: *const b3DbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut b3DbvtNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6updateEP10b3DbvtNodei"]
    pub fn b3DynamicBvh_update(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        lookahead: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6updateEP10b3DbvtNodeR12b3DbvtAabbMm"]
    pub fn b3DynamicBvh_update1(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6updateEP10b3DbvtNodeR12b3DbvtAabbMmRK9b3Vector3f"]
    pub fn b3DynamicBvh_update2(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6updateEP10b3DbvtNodeR12b3DbvtAabbMmRK9b3Vector3"]
    pub fn b3DynamicBvh_update3(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6updateEP10b3DbvtNodeR12b3DbvtAabbMmf"]
    pub fn b3DynamicBvh_update4(
        this: *mut b3DynamicBvh,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh6removeEP10b3DbvtNode"]
    pub fn b3DynamicBvh_remove(this: *mut b3DynamicBvh, leaf: *mut b3DbvtNode);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12b3DynamicBvh5writeEPNS_7IWriterE"]
    pub fn b3DynamicBvh_write(this: *const b3DynamicBvh, iwriter: *mut b3DynamicBvh_IWriter);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12b3DynamicBvh5cloneERS_PNS_6ICloneE"]
    pub fn b3DynamicBvh_clone(
        this: *const b3DynamicBvh,
        dest: *mut b3DynamicBvh,
        iclone: *mut b3DynamicBvh_IClone,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh8maxdepthEPK10b3DbvtNode"]
    pub fn b3DynamicBvh_maxdepth(node: *const b3DbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh11countLeavesEPK10b3DbvtNode"]
    pub fn b3DynamicBvh_countLeaves(node: *const b3DbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh13extractLeavesEPK10b3DbvtNodeR20b3AlignedObjectArrayIS2_E"]
    pub fn b3DynamicBvh_extractLeaves(
        node: *const b3DbvtNode,
        leaves: *mut b3AlignedObjectArray<*const b3DbvtNode>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh9enumNodesEPK10b3DbvtNodeRNS_8ICollideE"]
    pub fn b3DynamicBvh_enumNodes(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh10enumLeavesEPK10b3DbvtNodeRNS_8ICollideE"]
    pub fn b3DynamicBvh_enumLeaves(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh9collideTTEPK10b3DbvtNodeS2_RNS_8ICollideE"]
    pub fn b3DynamicBvh_collideTT(
        this: *mut b3DynamicBvh,
        root0: *const b3DbvtNode,
        root1: *const b3DbvtNode,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh24collideTTpersistentStackEPK10b3DbvtNodeS2_RNS_8ICollideE"]
    pub fn b3DynamicBvh_collideTTpersistentStack(
        this: *mut b3DynamicBvh,
        root0: *const b3DbvtNode,
        root1: *const b3DbvtNode,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12b3DynamicBvh9collideTVEPK10b3DbvtNodeRK12b3DbvtAabbMmRNS_8ICollideE"]
    pub fn b3DynamicBvh_collideTV(
        this: *const b3DynamicBvh,
        root: *const b3DbvtNode,
        volume: *const b3DbvtVolume,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    /// rayTest is a re-entrant ray test, and can be called in parallel as long as the b3AlignedAlloc is thread-safe (uses locking etc)
    /// ///rayTest is slower than rayTestInternal, because it builds a local stack, using memory allocations, and it recomputes signs/rayDirectionInverses each time
    #[link_name = "\u{1}_ZN12b3DynamicBvh7rayTestEPK10b3DbvtNodeRK9b3Vector3S5_RNS_8ICollideE"]
    pub fn b3DynamicBvh_rayTest(
        root: *const b3DbvtNode,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    /// rayTestInternal is faster than rayTest, because it uses a persistent stack (to reduce dynamic memory allocations to a minimum) and it uses precomputed signs/rayInverseDirections
    /// ///rayTestInternal is used by b3DynamicBvhBroadphase to accelerate world ray casts
    #[link_name = "\u{1}_ZNK12b3DynamicBvh15rayTestInternalEPK10b3DbvtNodeRK9b3Vector3S5_S5_PjfS5_S5_RNS_8ICollideE"]
    pub fn b3DynamicBvh_rayTestInternal(
        this: *const b3DynamicBvh,
        root: *const b3DbvtNode,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        rayDirectionInverse: *const b3Vector3,
        signs: *mut ::std::os::raw::c_uint,
        lambda_max: b3Scalar,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh11collideKDOPEPK10b3DbvtNodePK9b3Vector3PKfiRNS_8ICollideE"]
    pub fn b3DynamicBvh_collideKDOP(
        root: *const b3DbvtNode,
        normals: *const b3Vector3,
        offsets: *const b3Scalar,
        count: ::std::os::raw::c_int,
        policy: *mut b3DynamicBvh_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh10collideOCLEPK10b3DbvtNodePK9b3Vector3PKfRS4_iRNS_8ICollideEb"]
    pub fn b3DynamicBvh_collideOCL(
        root: *const b3DbvtNode,
        normals: *const b3Vector3,
        offsets: *const b3Scalar,
        sortaxis: *const b3Vector3,
        count: ::std::os::raw::c_int,
        policy: *mut b3DynamicBvh_ICollide,
        fullsort: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvh9collideTUEPK10b3DbvtNodeRNS_8ICollideE"]
    pub fn b3DynamicBvh_collideTU(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvhC1Ev"]
    pub fn b3DynamicBvh_b3DynamicBvh(this: *mut b3DynamicBvh);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3DynamicBvhD1Ev"]
    pub fn b3DynamicBvh_b3DynamicBvh_destructor(this: *mut b3DynamicBvh);
}
impl b3DynamicBvh {
    #[inline]
    pub unsafe fn clear(&mut self) {
        b3DynamicBvh_clear(self)
    }
    #[inline]
    pub unsafe fn optimizeBottomUp(&mut self) {
        b3DynamicBvh_optimizeBottomUp(self)
    }
    #[inline]
    pub unsafe fn optimizeTopDown(&mut self, bu_treshold: ::std::os::raw::c_int) {
        b3DynamicBvh_optimizeTopDown(self, bu_treshold)
    }
    #[inline]
    pub unsafe fn optimizeIncremental(&mut self, passes: ::std::os::raw::c_int) {
        b3DynamicBvh_optimizeIncremental(self, passes)
    }
    #[inline]
    pub unsafe fn insert(
        &mut self,
        box_: *const b3DbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut b3DbvtNode {
        b3DynamicBvh_insert(self, box_, data)
    }
    #[inline]
    pub unsafe fn update(&mut self, leaf: *mut b3DbvtNode, lookahead: ::std::os::raw::c_int) {
        b3DynamicBvh_update(self, leaf, lookahead)
    }
    #[inline]
    pub unsafe fn update1(&mut self, leaf: *mut b3DbvtNode, volume: *mut b3DbvtVolume) {
        b3DynamicBvh_update1(self, leaf, volume)
    }
    #[inline]
    pub unsafe fn update2(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3DynamicBvh_update2(self, leaf, volume, velocity, margin)
    }
    #[inline]
    pub unsafe fn update3(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        velocity: *const b3Vector3,
    ) -> bool {
        b3DynamicBvh_update3(self, leaf, volume, velocity)
    }
    #[inline]
    pub unsafe fn update4(
        &mut self,
        leaf: *mut b3DbvtNode,
        volume: *mut b3DbvtVolume,
        margin: b3Scalar,
    ) -> bool {
        b3DynamicBvh_update4(self, leaf, volume, margin)
    }
    #[inline]
    pub unsafe fn remove(&mut self, leaf: *mut b3DbvtNode) {
        b3DynamicBvh_remove(self, leaf)
    }
    #[inline]
    pub unsafe fn write(&self, iwriter: *mut b3DynamicBvh_IWriter) {
        b3DynamicBvh_write(self, iwriter)
    }
    #[inline]
    pub unsafe fn clone(&self, dest: *mut b3DynamicBvh, iclone: *mut b3DynamicBvh_IClone) {
        b3DynamicBvh_clone(self, dest, iclone)
    }
    #[inline]
    pub unsafe fn maxdepth(node: *const b3DbvtNode) -> ::std::os::raw::c_int {
        b3DynamicBvh_maxdepth(node)
    }
    #[inline]
    pub unsafe fn countLeaves(node: *const b3DbvtNode) -> ::std::os::raw::c_int {
        b3DynamicBvh_countLeaves(node)
    }
    #[inline]
    pub unsafe fn extractLeaves(
        node: *const b3DbvtNode,
        leaves: *mut b3AlignedObjectArray<*const b3DbvtNode>,
    ) {
        b3DynamicBvh_extractLeaves(node, leaves)
    }
    #[inline]
    pub unsafe fn enumNodes(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide) {
        b3DynamicBvh_enumNodes(root, policy)
    }
    #[inline]
    pub unsafe fn enumLeaves(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide) {
        b3DynamicBvh_enumLeaves(root, policy)
    }
    #[inline]
    pub unsafe fn collideTT(
        &mut self,
        root0: *const b3DbvtNode,
        root1: *const b3DbvtNode,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_collideTT(self, root0, root1, policy)
    }
    #[inline]
    pub unsafe fn collideTTpersistentStack(
        &mut self,
        root0: *const b3DbvtNode,
        root1: *const b3DbvtNode,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_collideTTpersistentStack(self, root0, root1, policy)
    }
    #[inline]
    pub unsafe fn collideTV(
        &self,
        root: *const b3DbvtNode,
        volume: *const b3DbvtVolume,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_collideTV(self, root, volume, policy)
    }
    #[inline]
    pub unsafe fn rayTest(
        root: *const b3DbvtNode,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_rayTest(root, rayFrom, rayTo, policy)
    }
    #[inline]
    pub unsafe fn rayTestInternal(
        &self,
        root: *const b3DbvtNode,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        rayDirectionInverse: *const b3Vector3,
        signs: *mut ::std::os::raw::c_uint,
        lambda_max: b3Scalar,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_rayTestInternal(
            self,
            root,
            rayFrom,
            rayTo,
            rayDirectionInverse,
            signs,
            lambda_max,
            aabbMin,
            aabbMax,
            policy,
        )
    }
    #[inline]
    pub unsafe fn collideKDOP(
        root: *const b3DbvtNode,
        normals: *const b3Vector3,
        offsets: *const b3Scalar,
        count: ::std::os::raw::c_int,
        policy: *mut b3DynamicBvh_ICollide,
    ) {
        b3DynamicBvh_collideKDOP(root, normals, offsets, count, policy)
    }
    #[inline]
    pub unsafe fn collideOCL(
        root: *const b3DbvtNode,
        normals: *const b3Vector3,
        offsets: *const b3Scalar,
        sortaxis: *const b3Vector3,
        count: ::std::os::raw::c_int,
        policy: *mut b3DynamicBvh_ICollide,
        fullsort: bool,
    ) {
        b3DynamicBvh_collideOCL(root, normals, offsets, sortaxis, count, policy, fullsort)
    }
    #[inline]
    pub unsafe fn collideTU(root: *const b3DbvtNode, policy: *mut b3DynamicBvh_ICollide) {
        b3DynamicBvh_collideTU(root, policy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3DynamicBvh_b3DynamicBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        b3DynamicBvh_b3DynamicBvh_destructor(self)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3UnsignedInt2 {
    pub __bindgen_anon_1: b3UnsignedInt2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3UnsignedInt2__bindgen_ty_1 {
    pub __bindgen_anon_1: b3UnsignedInt2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3UnsignedInt2__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt2__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt2__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Int2 {
    pub __bindgen_anon_1: b3Int2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Int2__bindgen_ty_1 {
    pub __bindgen_anon_1: b3Int2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3Int2__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int2__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int2__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Dispatcher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3UnsignedInt4 {
    pub __bindgen_anon_1: b3UnsignedInt4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3UnsignedInt4__bindgen_ty_1 {
    pub __bindgen_anon_1: b3UnsignedInt4__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3UnsignedInt4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt4__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UnsignedInt4__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Int4 {
    pub __bindgen_anon_1: b3Int4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Int4__bindgen_ty_1 {
    pub __bindgen_anon_1: b3Int4__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: b3Int4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int4__bindgen_ty_1__bindgen_ty_1 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Int4__bindgen_ty_1__bindgen_ty_2 {
    pub s: [::std::os::raw::c_int; 4usize],
}
pub type b3BroadphasePair = b3Int4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BroadphasePairSortPredicate {
    pub _address: u8,
}
pub type b3BroadphasePairArray = b3AlignedObjectArray<b3BroadphasePair>;
#[repr(C)]
pub struct b3OverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlapCallback {
    pub vtable_: *const b3OverlapCallback__bindgen_vtable,
}
#[repr(C)]
pub struct b3OverlapFilterCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlapFilterCallback {
    pub vtable_: *const b3OverlapFilterCallback__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}b3g_removePairs"]
    pub static mut b3g_removePairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}b3g_addedPairs"]
    pub static mut b3g_addedPairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}b3g_findPairs"]
    pub static mut b3g_findPairs: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct b3OverlappingPairCache__bindgen_vtable(::std::os::raw::c_void);
/// The b3OverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the b3BroadphaseInterface broadphases.
/// The b3HashedOverlappingPairCache and b3SortedOverlappingPairCache classes are two implementations.
#[repr(C)]
#[derive(Debug)]
pub struct b3OverlappingPairCache {
    pub vtable_: *const b3OverlappingPairCache__bindgen_vtable,
}
/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
#[repr(C)]
pub struct b3HashedOverlappingPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
    pub m_overlapFilterCallback: *mut b3OverlapFilterCallback,
    pub m_hashTable: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: b3AlignedObjectArray<::std::os::raw::c_int>,
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCacheC1Ev"]
    pub fn b3HashedOverlappingPairCache_b3HashedOverlappingPairCache(
        this: *mut b3HashedOverlappingPairCache,
    );
}
impl b3HashedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3HashedOverlappingPairCache_b3HashedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCacheD1Ev"]
    pub fn b3HashedOverlappingPairCache_b3HashedOverlappingPairCache_destructor(
        this: *mut b3HashedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache37removeOverlappingPairsContainingProxyEiP12b3Dispatcher"]
    pub fn b3HashedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache21removeOverlappingPairEiiP12b3Dispatcher"]
    pub fn b3HashedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache19cleanProxyFromPairsEiP12b3Dispatcher"]
    pub fn b3HashedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache26processAllOverlappingPairsEP17b3OverlapCallbackP12b3Dispatcher"]
    pub fn b3HashedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut b3OverlapCallback,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache20cleanOverlappingPairER6b3Int4P12b3Dispatcher"]
    pub fn b3HashedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut b3BroadphasePair,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3HashedOverlappingPairCache8findPairEii"]
    pub fn b3HashedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
/// b3SortedOverlappingPairCache maintains the objects with overlapping AABB
/// Typically managed by the Broadphase, Axis3Sweep or b3SimpleBroadphase
#[repr(C)]
pub struct b3SortedOverlappingPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
    pub m_blockedForChanges: bool,
    /// by default, do the removal during the pair traversal
    pub m_hasDeferredRemoval: bool,
    pub m_overlapFilterCallback: *mut b3OverlapFilterCallback,
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCacheC1Ev"]
    pub fn b3SortedOverlappingPairCache_b3SortedOverlappingPairCache(
        this: *mut b3SortedOverlappingPairCache,
    );
}
impl b3SortedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3SortedOverlappingPairCache_b3SortedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCacheD1Ev"]
    pub fn b3SortedOverlappingPairCache_b3SortedOverlappingPairCache_destructor(
        this: *mut b3SortedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache26processAllOverlappingPairsEP17b3OverlapCallbackP12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut b3OverlapCallback,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache21removeOverlappingPairEiiP12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache20cleanOverlappingPairER6b3Int4P12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut b3BroadphasePair,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache18addOverlappingPairEii"]
    pub fn b3SortedOverlappingPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache8findPairEii"]
    pub fn b3SortedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: ::std::os::raw::c_int,
        proxy1: ::std::os::raw::c_int,
    ) -> *mut b3BroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache19cleanProxyFromPairsEiP12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache37removeOverlappingPairsContainingProxyEiP12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: ::std::os::raw::c_int,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28b3SortedOverlappingPairCache20sortOverlappingPairsEP12b3Dispatcher"]
    pub fn b3SortedOverlappingPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
/// b3NullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
#[repr(C)]
pub struct b3NullPairCache {
    pub _base: b3OverlappingPairCache,
    pub m_overlappingPairArray: b3BroadphasePairArray,
}
#[repr(C)]
pub struct b3BroadphaseAabbCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3BroadphaseAabbCallback {
    pub vtable_: *const b3BroadphaseAabbCallback__bindgen_vtable,
}
#[repr(C)]
pub struct b3BroadphaseRayCallback {
    pub _base: b3BroadphaseAabbCallback,
    pub __bindgen_padding_0: u64,
    /// added some cached data to accelerate ray-AABB tests
    pub m_rayDirectionInverse: b3Vector3,
    pub m_signs: [::std::os::raw::c_uint; 3usize],
    pub m_lambda_max: b3Scalar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3BroadphaseProxy {
    pub m_clientObject: *mut ::std::os::raw::c_void,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_aabbMin: b3Vector3,
    pub m_aabbMax: b3Vector3,
}
pub const b3BroadphaseProxy_CollisionFilterGroups_DefaultFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 1;
pub const b3BroadphaseProxy_CollisionFilterGroups_StaticFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 2;
pub const b3BroadphaseProxy_CollisionFilterGroups_KinematicFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 4;
pub const b3BroadphaseProxy_CollisionFilterGroups_DebrisFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 8;
pub const b3BroadphaseProxy_CollisionFilterGroups_SensorTrigger:
    b3BroadphaseProxy_CollisionFilterGroups = 16;
pub const b3BroadphaseProxy_CollisionFilterGroups_CharacterFilter:
    b3BroadphaseProxy_CollisionFilterGroups = 32;
pub const b3BroadphaseProxy_CollisionFilterGroups_AllFilter:
    b3BroadphaseProxy_CollisionFilterGroups = -1;
/// optional filtering to cull potential collisions
pub type b3BroadphaseProxy_CollisionFilterGroups = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3DbvtProxy {
    pub _base: b3BroadphaseProxy,
    pub leaf: *mut b3DbvtNode,
    pub links: [*mut b3DbvtProxy; 2usize],
    pub stage: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
pub type b3DbvtProxyArray = b3AlignedObjectArray<*mut b3DbvtProxy>;
#[repr(C)]
pub struct b3DynamicBvhBroadphase__bindgen_vtable(::std::os::raw::c_void);
/// The b3DynamicBvhBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see b3DynamicBvh).
/// One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
/// This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases b3AxisSweep3 and b332BitAxisSweep3.
#[repr(C)]
pub struct b3DynamicBvhBroadphase {
    pub vtable_: *const b3DynamicBvhBroadphase__bindgen_vtable,
    pub m_sets: [b3DynamicBvh; 2usize],
    pub m_stageRoots: [*mut b3DbvtProxy; 3usize],
    pub m_proxies: b3AlignedObjectArray<b3DbvtProxy>,
    pub m_paircache: *mut b3OverlappingPairCache,
    pub m_prediction: b3Scalar,
    pub m_stageCurrent: ::std::os::raw::c_int,
    pub m_fupdates: ::std::os::raw::c_int,
    pub m_dupdates: ::std::os::raw::c_int,
    pub m_cupdates: ::std::os::raw::c_int,
    pub m_newpairs: ::std::os::raw::c_int,
    pub m_fixedleft: ::std::os::raw::c_int,
    pub m_updates_call: ::std::os::raw::c_uint,
    pub m_updates_done: ::std::os::raw::c_uint,
    pub m_updates_ratio: b3Scalar,
    pub m_pid: ::std::os::raw::c_int,
    pub m_cid: ::std::os::raw::c_int,
    pub m_releasepaircache: bool,
    pub m_deferedcollide: bool,
    pub m_needcleanup: bool,
}
pub const b3DynamicBvhBroadphase_DYNAMIC_SET: b3DynamicBvhBroadphase__bindgen_ty_1 = 0;
pub const b3DynamicBvhBroadphase_FIXED_SET: b3DynamicBvhBroadphase__bindgen_ty_1 = 1;
pub const b3DynamicBvhBroadphase_STAGECOUNT: b3DynamicBvhBroadphase__bindgen_ty_1 = 2;
pub type b3DynamicBvhBroadphase__bindgen_ty_1 = u32;
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase7collideEP12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_collide(
        this: *mut b3DynamicBvhBroadphase,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase8optimizeEv"]
    pub fn b3DynamicBvhBroadphase_optimize(this: *mut b3DynamicBvhBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase11createProxyERK9b3Vector3S2_iPvii"]
    pub fn b3DynamicBvhBroadphase_createProxy(
        this: *mut b3DynamicBvhBroadphase,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        objectIndex: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> *mut b3BroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase22performDeferredRemovalEP12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_performDeferredRemoval(
        this: *mut b3DynamicBvhBroadphase,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    /// this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    /// ///it is not part of the b3BroadphaseInterface but specific to b3DynamicBvhBroadphase.
    /// ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    /// ///http://code.google.com/p/bullet/issues/detail?id=223
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase18setAabbForceUpdateEP17b3BroadphaseProxyRK9b3Vector3S4_P12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_setAabbForceUpdate(
        this: *mut b3DynamicBvhBroadphase,
        absproxy: *mut b3BroadphaseProxy,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        arg1: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphaseC1EiP22b3OverlappingPairCache"]
    pub fn b3DynamicBvhBroadphase_b3DynamicBvhBroadphase(
        this: *mut b3DynamicBvhBroadphase,
        proxyCapacity: ::std::os::raw::c_int,
        paircache: *mut b3OverlappingPairCache,
    );
}
impl b3DynamicBvhBroadphase {
    #[inline]
    pub unsafe fn collide(&mut self, dispatcher: *mut b3Dispatcher) {
        b3DynamicBvhBroadphase_collide(self, dispatcher)
    }
    #[inline]
    pub unsafe fn optimize(&mut self) {
        b3DynamicBvhBroadphase_optimize(self)
    }
    #[inline]
    pub unsafe fn createProxy(
        &mut self,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        objectIndex: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> *mut b3BroadphaseProxy {
        b3DynamicBvhBroadphase_createProxy(
            self,
            aabbMin,
            aabbMax,
            objectIndex,
            userPtr,
            collisionFilterGroup,
            collisionFilterMask,
        )
    }
    #[inline]
    pub unsafe fn performDeferredRemoval(&mut self, dispatcher: *mut b3Dispatcher) {
        b3DynamicBvhBroadphase_performDeferredRemoval(self, dispatcher)
    }
    #[inline]
    pub unsafe fn setAabbForceUpdate(
        &mut self,
        absproxy: *mut b3BroadphaseProxy,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        arg1: *mut b3Dispatcher,
    ) {
        b3DynamicBvhBroadphase_setAabbForceUpdate(self, absproxy, aabbMin, aabbMax, arg1)
    }
    #[inline]
    pub unsafe fn new(
        proxyCapacity: ::std::os::raw::c_int,
        paircache: *mut b3OverlappingPairCache,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3DynamicBvhBroadphase_b3DynamicBvhBroadphase(&mut __bindgen_tmp, proxyCapacity, paircache);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphaseD1Ev"]
    pub fn b3DynamicBvhBroadphase_b3DynamicBvhBroadphase_destructor(
        this: *mut b3DynamicBvhBroadphase,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase12destroyProxyEP17b3BroadphaseProxyP12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut b3BroadphaseProxy,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase7setAabbEiRK9b3Vector3S2_P12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        objectId: ::std::os::raw::c_int,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase7rayTestERK9b3Vector3S2_R23b3BroadphaseRayCallbackS2_S2_"]
    pub fn b3DynamicBvhBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const b3Vector3,
        rayTo: *const b3Vector3,
        rayCallback: *mut b3BroadphaseRayCallback,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase8aabbTestERK9b3Vector3S2_R24b3BroadphaseAabbCallback"]
    pub fn b3DynamicBvhBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        callback: *mut b3BroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3DynamicBvhBroadphase7getAabbEiR9b3Vector3S1_"]
    pub fn b3DynamicBvhBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        objectId: ::std::os::raw::c_int,
        aabbMin: *mut b3Vector3,
        aabbMax: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase25calculateOverlappingPairsEP12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase23getOverlappingPairCacheEv"]
    pub fn b3DynamicBvhBroadphase_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3DynamicBvhBroadphase23getOverlappingPairCacheEv"]
    pub fn b3DynamicBvhBroadphase_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const b3OverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3DynamicBvhBroadphase17getBroadphaseAabbER9b3Vector3S1_"]
    pub fn b3DynamicBvhBroadphase_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut b3Vector3,
        aabbMax: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase10printStatsEv"]
    pub fn b3DynamicBvhBroadphase_printStats(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// reset broadphase internal structures, to ensure determinism/reproducability
    #[link_name = "\u{1}_ZN22b3DynamicBvhBroadphase9resetPoolEP12b3Dispatcher"]
    pub fn b3DynamicBvhBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut b3Dispatcher,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct b3MyFace {
    pub m_indices: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_plane: [b3Scalar; 4usize],
}
#[repr(C)]
pub struct b3ConvexUtility__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3ConvexUtility {
    pub vtable_: *const b3ConvexUtility__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_localCenter: b3Vector3,
    pub m_extents: b3Vector3,
    pub mC: b3Vector3,
    pub mE: b3Vector3,
    pub m_radius: b3Scalar,
    pub m_vertices: b3AlignedObjectArray<b3Vector3>,
    pub m_faces: b3AlignedObjectArray<b3MyFace>,
    pub m_uniqueEdges: b3AlignedObjectArray<b3Vector3>,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3ConvexUtility28initializePolyhedralFeaturesEPK9b3Vector3ib"]
    pub fn b3ConvexUtility_initializePolyhedralFeatures(
        this: *mut b3ConvexUtility,
        orgVertices: *const b3Vector3,
        numVertices: ::std::os::raw::c_int,
        mergeCoplanarTriangles: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3ConvexUtility10initializeEv"]
    pub fn b3ConvexUtility_initialize(this: *mut b3ConvexUtility);
}
extern "C" {
    #[link_name = "\u{1}_ZNK15b3ConvexUtility15testContainmentEv"]
    pub fn b3ConvexUtility_testContainment(this: *const b3ConvexUtility) -> bool;
}
impl b3ConvexUtility {
    #[inline]
    pub unsafe fn initializePolyhedralFeatures(
        &mut self,
        orgVertices: *const b3Vector3,
        numVertices: ::std::os::raw::c_int,
        mergeCoplanarTriangles: bool,
    ) -> bool {
        b3ConvexUtility_initializePolyhedralFeatures(
            self,
            orgVertices,
            numVertices,
            mergeCoplanarTriangles,
        )
    }
    #[inline]
    pub unsafe fn initialize(&mut self) {
        b3ConvexUtility_initialize(self)
    }
    #[inline]
    pub unsafe fn testContainment(&self) -> bool {
        b3ConvexUtility_testContainment(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3ConvexUtilityD1Ev"]
    pub fn b3ConvexUtility_b3ConvexUtility_destructor(this: *mut b3ConvexUtility);
}
pub const b3ShapeTypes_SHAPE_HEIGHT_FIELD: b3ShapeTypes = 1;
pub const b3ShapeTypes_SHAPE_CONVEX_HULL: b3ShapeTypes = 3;
pub const b3ShapeTypes_SHAPE_PLANE: b3ShapeTypes = 4;
pub const b3ShapeTypes_SHAPE_CONCAVE_TRIMESH: b3ShapeTypes = 5;
pub const b3ShapeTypes_SHAPE_COMPOUND_OF_CONVEX_HULLS: b3ShapeTypes = 6;
pub const b3ShapeTypes_SHAPE_SPHERE: b3ShapeTypes = 7;
pub const b3ShapeTypes_MAX_NUM_SHAPE_TYPES: b3ShapeTypes = 8;
pub type b3ShapeTypes = u32;
pub type b3Collidable_t = b3Collidable;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Collidable {
    pub __bindgen_anon_1: b3Collidable__bindgen_ty_1,
    pub __bindgen_anon_2: b3Collidable__bindgen_ty_2,
    pub m_shapeType: ::std::os::raw::c_int,
    pub __bindgen_anon_3: b3Collidable__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_1 {
    pub m_numChildShapes: ::std::os::raw::c_int,
    pub m_bvhIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_2 {
    pub m_radius: f32,
    pub m_compoundBvhIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Collidable__bindgen_ty_3 {
    pub m_shapeIndex: ::std::os::raw::c_int,
    pub m_height: f32,
    _bindgen_union_align: u32,
}
pub type b3GpuChildShape_t = b3GpuChildShape;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuChildShape {
    pub m_childPosition: b3Vector3,
    pub m_childOrientation: b3Quaternion,
    pub __bindgen_anon_1: b3GpuChildShape__bindgen_ty_1,
    pub __bindgen_anon_2: b3GpuChildShape__bindgen_ty_2,
    pub __bindgen_anon_3: b3GpuChildShape__bindgen_ty_3,
    pub m_shapeType: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_1 {
    pub m_shapeIndex: ::std::os::raw::c_int,
    pub m_capsuleAxis: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_2 {
    pub m_radius: f32,
    pub m_numChildShapes: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuChildShape__bindgen_ty_3 {
    pub m_height: f32,
    pub m_collidableShapeIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CompoundOverlappingPair {
    pub m_bodyIndexA: ::std::os::raw::c_int,
    pub m_bodyIndexB: ::std::os::raw::c_int,
    pub m_childShapeIndexA: ::std::os::raw::c_int,
    pub m_childShapeIndexB: ::std::os::raw::c_int,
}
pub type b3Aabb_t = b3Aabb;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Aabb {
    pub __bindgen_anon_1: b3Aabb__bindgen_ty_1,
    pub __bindgen_anon_2: b3Aabb__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Aabb__bindgen_ty_1 {
    pub m_min: [f32; 4usize],
    pub m_minVec: b3Vector3,
    pub m_minIndices: [::std::os::raw::c_int; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Aabb__bindgen_ty_2 {
    pub m_max: [f32; 4usize],
    pub m_maxVec: b3Vector3,
    pub m_signedMaxIndices: [::std::os::raw::c_int; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
pub type b3RigidBodyData_t = b3RigidBodyData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RigidBodyData {
    pub m_pos: b3Vector3,
    pub m_quat: b3Quaternion,
    pub m_linVel: b3Vector3,
    pub m_angVel: b3Vector3,
    pub m_collidableIdx: ::std::os::raw::c_int,
    pub m_invMass: f32,
    pub m_restituitionCoeff: f32,
    pub m_frictionCoeff: f32,
}
pub type b3InertiaData_t = b3InertiaData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3InertiaData {
    pub m_invInertiaWorld: b3Matrix3x3,
    pub m_initInvInertia: b3Matrix3x3,
}
pub type b3Contact4Data_t = b3Contact4Data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Contact4Data {
    pub m_worldPosB: [b3Vector3; 4usize],
    pub m_worldNormalOnB: b3Vector3,
    pub m_restituitionCoeffCmp: ::std::os::raw::c_ushort,
    pub m_frictionCoeffCmp: ::std::os::raw::c_ushort,
    pub m_batchIdx: ::std::os::raw::c_int,
    pub m_bodyAPtrAndSignBit: ::std::os::raw::c_int,
    pub m_bodyBPtrAndSignBit: ::std::os::raw::c_int,
    pub m_childIndexA: ::std::os::raw::c_int,
    pub m_childIndexB: ::std::os::raw::c_int,
    pub m_unused1: ::std::os::raw::c_int,
    pub m_unused2: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3CpuNarrowPhase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3CpuNarrowPhase {
    pub vtable_: *const b3CpuNarrowPhase__bindgen_vtable,
    pub m_data: *mut b3CpuNarrowPhaseInternalData,
    pub m_acceleratedCompanionShapeIndex: ::std::os::raw::c_int,
    pub m_planeBodyIndex: ::std::os::raw::c_int,
    pub m_static0Index: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase31registerConvexHullShapeInternalEP15b3ConvexUtilityR12b3Collidable"]
    pub fn b3CpuNarrowPhase_registerConvexHullShapeInternal(
        this: *mut b3CpuNarrowPhase,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase24registerConcaveMeshShapeEP20b3AlignedObjectArrayI9b3Vector3EPS0_IiER12b3CollidablePKf"]
    pub fn b3CpuNarrowPhase_registerConcaveMeshShape(
        this: *mut b3CpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase19registerSphereShapeEf"]
    pub fn b3CpuNarrowPhase_registerSphereShape(
        this: *mut b3CpuNarrowPhase,
        radius: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase18registerPlaneShapeERK9b3Vector3f"]
    pub fn b3CpuNarrowPhase_registerPlaneShape(
        this: *mut b3CpuNarrowPhase,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase21registerCompoundShapeEP20b3AlignedObjectArrayI15b3GpuChildShapeE"]
    pub fn b3CpuNarrowPhase_registerCompoundShape(
        this: *mut b3CpuNarrowPhase,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase12registerFaceERK9b3Vector3f"]
    pub fn b3CpuNarrowPhase_registerFace(
        this: *mut b3CpuNarrowPhase,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase19registerConcaveMeshEP20b3AlignedObjectArrayI9b3Vector3EPS0_IiEPKf"]
    pub fn b3CpuNarrowPhase_registerConcaveMesh(
        this: *mut b3CpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase23registerConvexHullShapeEP15b3ConvexUtility"]
    pub fn b3CpuNarrowPhase_registerConvexHullShape(
        this: *mut b3CpuNarrowPhase,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase23registerConvexHullShapeEPKfiiS1_"]
    pub fn b3CpuNarrowPhase_registerConvexHullShape1(
        this: *mut b3CpuNarrowPhase,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase18setObjectTransformEPKfS1_i"]
    pub fn b3CpuNarrowPhase_setObjectTransform(
        this: *mut b3CpuNarrowPhase,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase19writeAllBodiesToGpuEv"]
    pub fn b3CpuNarrowPhase_writeAllBodiesToGpu(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase5resetEv"]
    pub fn b3CpuNarrowPhase_reset(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase22readbackAllBodiesToCpuEv"]
    pub fn b3CpuNarrowPhase_readbackAllBodiesToCpu(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase25getObjectTransformFromCpuEPfS0_i"]
    pub fn b3CpuNarrowPhase_getObjectTransformFromCpu(
        this: *const b3CpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase21setObjectTransformCpuEPfS0_i"]
    pub fn b3CpuNarrowPhase_setObjectTransformCpu(
        this: *mut b3CpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase20setObjectVelocityCpuEPfS0_i"]
    pub fn b3CpuNarrowPhase_setObjectVelocityCpu(
        this: *mut b3CpuNarrowPhase,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase12getBodiesCpuEv"]
    pub fn b3CpuNarrowPhase_getBodiesCpu(this: *const b3CpuNarrowPhase) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase15getNumBodiesGpuEv"]
    pub fn b3CpuNarrowPhase_getNumBodiesGpu(this: *const b3CpuNarrowPhase)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase21getNumBodyInertiasGpuEv"]
    pub fn b3CpuNarrowPhase_getNumBodyInertiasGpu(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase17getCollidablesCpuEv"]
    pub fn b3CpuNarrowPhase_getCollidablesCpu(this: *const b3CpuNarrowPhase)
        -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase20getNumCollidablesGpuEv"]
    pub fn b3CpuNarrowPhase_getNumCollidablesGpu(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase11getContactsEv"]
    pub fn b3CpuNarrowPhase_getContacts(
        this: *const b3CpuNarrowPhase,
    ) -> *const b3AlignedObjectArray<b3Contact4Data>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase17getNumRigidBodiesEv"]
    pub fn b3CpuNarrowPhase_getNumRigidBodies(
        this: *const b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase18allocateCollidableEv"]
    pub fn b3CpuNarrowPhase_allocateCollidable(
        this: *mut b3CpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase16getCollidableCpuEi"]
    pub fn b3CpuNarrowPhase_getCollidableCpu(
        this: *mut b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase16getCollidableCpuEi"]
    pub fn b3CpuNarrowPhase_getCollidableCpu1(
        this: *const b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3CpuNarrowPhase17getLocalSpaceAabbEi"]
    pub fn b3CpuNarrowPhase_getLocalSpaceAabb(
        this: *const b3CpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Aabb;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhaseC1ERK8b3Config"]
    pub fn b3CpuNarrowPhase_b3CpuNarrowPhase(this: *mut b3CpuNarrowPhase, config: *const b3Config);
}
impl b3CpuNarrowPhase {
    #[inline]
    pub unsafe fn registerConvexHullShapeInternal(
        &mut self,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShapeInternal(self, convexPtr, col)
    }
    #[inline]
    pub unsafe fn registerConcaveMeshShape(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConcaveMeshShape(self, vertices, indices, col, scaling)
    }
    #[inline]
    pub unsafe fn registerSphereShape(&mut self, radius: f32) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerSphereShape(self, radius)
    }
    #[inline]
    pub unsafe fn registerPlaneShape(
        &mut self,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerPlaneShape(self, planeNormal, planeConstant)
    }
    #[inline]
    pub unsafe fn registerCompoundShape(
        &mut self,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerCompoundShape(self, childShapes)
    }
    #[inline]
    pub unsafe fn registerFace(
        &mut self,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerFace(self, faceNormal, faceConstant)
    }
    #[inline]
    pub unsafe fn registerConcaveMesh(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConcaveMesh(self, vertices, indices, scaling)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape(
        &mut self,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShape(self, utilPtr)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape1(
        &mut self,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_registerConvexHullShape1(
            self,
            vertices,
            strideInBytes,
            numVertices,
            scaling,
        )
    }
    #[inline]
    pub unsafe fn setObjectTransform(
        &mut self,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectTransform(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn writeAllBodiesToGpu(&mut self) {
        b3CpuNarrowPhase_writeAllBodiesToGpu(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3CpuNarrowPhase_reset(self)
    }
    #[inline]
    pub unsafe fn readbackAllBodiesToCpu(&mut self) {
        b3CpuNarrowPhase_readbackAllBodiesToCpu(self)
    }
    #[inline]
    pub unsafe fn getObjectTransformFromCpu(
        &self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool {
        b3CpuNarrowPhase_getObjectTransformFromCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectTransformCpu(
        &mut self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectTransformCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectVelocityCpu(
        &mut self,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3CpuNarrowPhase_setObjectVelocityCpu(self, linVel, angVel, bodyIndex)
    }
    #[inline]
    pub unsafe fn getBodiesCpu(&self) -> *const b3RigidBodyData {
        b3CpuNarrowPhase_getBodiesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodiesGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodyInertiasGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesCpu(&self) -> *const b3Collidable {
        b3CpuNarrowPhase_getCollidablesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumCollidablesGpu(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getContacts(&self) -> *const b3AlignedObjectArray<b3Contact4Data> {
        b3CpuNarrowPhase_getContacts(self)
    }
    #[inline]
    pub unsafe fn getNumRigidBodies(&self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_getNumRigidBodies(self)
    }
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3CpuNarrowPhase_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn getCollidableCpu(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable {
        b3CpuNarrowPhase_getCollidableCpu(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getCollidableCpu1(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable {
        b3CpuNarrowPhase_getCollidableCpu1(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabb(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Aabb {
        b3CpuNarrowPhase_getLocalSpaceAabb(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn new(config: *const b3Config) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3CpuNarrowPhase_b3CpuNarrowPhase(&mut __bindgen_tmp, config);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhaseD1Ev"]
    pub fn b3CpuNarrowPhase_b3CpuNarrowPhase_destructor(this: *mut b3CpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3CpuNarrowPhase15computeContactsER20b3AlignedObjectArrayI6b3Int4ERS0_I6b3AabbERS0_I15b3RigidBodyDataE"]
    pub fn b3CpuNarrowPhase_computeContacts(
        this: *mut ::std::os::raw::c_void,
        pairs: *mut b3AlignedObjectArray<b3Int4>,
        aabbsWorldSpace: *mut b3AlignedObjectArray<b3Aabb>,
        bodies: *mut b3AlignedObjectArray<b3RigidBodyData>,
    );
}
pub type b3GpuFace_t = b3GpuFace;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuFace {
    pub m_plane: b3Vector3,
    pub m_indexOffset: ::std::os::raw::c_int,
    pub m_numIndices: ::std::os::raw::c_int,
    pub m_unusedPadding1: ::std::os::raw::c_int,
    pub m_unusedPadding2: ::std::os::raw::c_int,
}
pub type b3ConvexPolyhedronData_t = b3ConvexPolyhedronData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ConvexPolyhedronData {
    pub m_localCenter: b3Vector3,
    pub m_extents: b3Vector3,
    pub mC: b3Vector3,
    pub mE: b3Vector3,
    pub m_radius: f32,
    pub m_faceOffset: ::std::os::raw::c_int,
    pub m_numFaces: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertexOffset: ::std::os::raw::c_int,
    pub m_uniqueEdgesOffset: ::std::os::raw::c_int,
    pub m_numUniqueEdges: ::std::os::raw::c_int,
    pub m_unused: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _b3MprSupport_t {
    /// !< Support point in minkowski sum
    pub v: b3Vector3,
    /// !< Support point in obj1
    pub v1: b3Vector3,
    /// !< Support point in obj2
    pub v2: b3Vector3,
}
pub type b3MprSupport_t = _b3MprSupport_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _b3MprSimplex_t {
    pub ps: [b3MprSupport_t; 4usize],
    /// !< index of last added point
    pub last: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
pub type b3MprSimplex_t = _b3MprSimplex_t;
extern "C" {
    #[link_name = "\u{1}_Z18b3ComputeWorldAabbiPK15b3RigidBodyDataPK12b3CollidablePK6b3AabbPS5_"]
    pub fn b3ComputeWorldAabb(
        bodyId: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData_t,
        collidables: *const b3Collidable_t,
        localShapeAABB: *const b3Aabb_t,
        worldAabbs: *mut b3Aabb_t,
    );
}
#[repr(C)]
pub struct b3FileUtils__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3FileUtils {
    pub vtable_: *const b3FileUtils__bindgen_vtable,
}
/// The b3PoolAllocator class allows to efficiently allocate a large pool of objects, instead of dynamically allocating them separately.
#[repr(C)]
#[derive(Debug)]
pub struct b3PoolAllocator {
    pub m_elemSize: ::std::os::raw::c_int,
    pub m_maxElements: ::std::os::raw::c_int,
    pub m_freeCount: ::std::os::raw::c_int,
    pub m_firstFree: *mut ::std::os::raw::c_void,
    pub m_pool: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PoolBodyHandle<U> {
    pub _base: U,
    pub m_nextFreeHandle: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<U>>,
}
#[repr(C)]
pub struct b3ResizablePool__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3ResizablePool<T> {
    pub vtable_: *const b3ResizablePool__bindgen_vtable,
    pub m_bodyHandles: b3AlignedObjectArray<T>,
    pub m_numUsedHandles: ::std::os::raw::c_int,
    pub m_firstFreeHandle: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
/// Utils related to temporal transforms
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformUtil {
    pub _address: u8,
}
/// The b3ConvexSeparatingDistanceUtil can help speed up convex collision detection
/// by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ConvexSeparatingDistanceUtil {
    pub m_ornA: b3Quaternion,
    pub m_ornB: b3Quaternion,
    pub m_posA: b3Vector3,
    pub m_posB: b3Vector3,
    pub m_separatingNormal: b3Vector3,
    pub m_boundingRadiusA: b3Scalar,
    pub m_boundingRadiusB: b3Scalar,
    pub m_separatingDistance: b3Scalar,
    pub __bindgen_padding_0: u32,
}
/// The b3SolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SolverBody {
    pub m_worldTransform: b3Transform,
    pub m_deltaLinearVelocity: b3Vector3,
    pub m_deltaAngularVelocity: b3Vector3,
    pub m_angularFactor: b3Vector3,
    pub m_linearFactor: b3Vector3,
    pub m_invMass: b3Vector3,
    pub m_pushVelocity: b3Vector3,
    pub m_turnVelocity: b3Vector3,
    pub m_linearVelocity: b3Vector3,
    pub m_angularVelocity: b3Vector3,
    pub __bindgen_anon_1: b3SolverBody__bindgen_ty_1,
    pub padding: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SolverBody__bindgen_ty_1 {
    pub m_originalBody: *mut ::std::os::raw::c_void,
    pub m_originalBodyIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SolverConstraint {
    pub m_relpos1CrossNormal: b3Vector3,
    pub m_contactNormal: b3Vector3,
    pub m_relpos2CrossNormal: b3Vector3,
    pub m_angularComponentA: b3Vector3,
    pub m_angularComponentB: b3Vector3,
    pub m_appliedPushImpulse: b3Scalar,
    pub m_appliedImpulse: b3Scalar,
    pub m_padding1: ::std::os::raw::c_int,
    pub m_padding2: ::std::os::raw::c_int,
    pub m_friction: b3Scalar,
    pub m_jacDiagABInv: b3Scalar,
    pub m_rhs: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_lowerLimit: b3Scalar,
    pub m_upperLimit: b3Scalar,
    pub m_rhsPenetration: b3Scalar,
    pub __bindgen_anon_1: b3SolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_unusedPadding4: b3Scalar,
    _bindgen_union_align: u64,
}
pub const b3SolverConstraint_b3SolverConstraintType_B3_SOLVER_CONTACT_1D:
    b3SolverConstraint_b3SolverConstraintType = 0;
pub const b3SolverConstraint_b3SolverConstraintType_B3_SOLVER_FRICTION_1D:
    b3SolverConstraint_b3SolverConstraintType = 1;
pub type b3SolverConstraint_b3SolverConstraintType = u32;
pub type b3ConstraintArray = b3AlignedObjectArray<b3SolverConstraint>;
pub const b3TypedConstraintType_B3_POINT2POINT_CONSTRAINT_TYPE: b3TypedConstraintType = 3;
pub const b3TypedConstraintType_B3_HINGE_CONSTRAINT_TYPE: b3TypedConstraintType = 4;
pub const b3TypedConstraintType_B3_CONETWIST_CONSTRAINT_TYPE: b3TypedConstraintType = 5;
pub const b3TypedConstraintType_B3_D6_CONSTRAINT_TYPE: b3TypedConstraintType = 6;
pub const b3TypedConstraintType_B3_SLIDER_CONSTRAINT_TYPE: b3TypedConstraintType = 7;
pub const b3TypedConstraintType_B3_CONTACT_CONSTRAINT_TYPE: b3TypedConstraintType = 8;
pub const b3TypedConstraintType_B3_D6_SPRING_CONSTRAINT_TYPE: b3TypedConstraintType = 9;
pub const b3TypedConstraintType_B3_GEAR_CONSTRAINT_TYPE: b3TypedConstraintType = 10;
pub const b3TypedConstraintType_B3_FIXED_CONSTRAINT_TYPE: b3TypedConstraintType = 11;
pub const b3TypedConstraintType_B3_MAX_CONSTRAINT_TYPE: b3TypedConstraintType = 12;
pub type b3TypedConstraintType = u32;
pub const b3ConstraintParams_B3_CONSTRAINT_ERP: b3ConstraintParams = 1;
pub const b3ConstraintParams_B3_CONSTRAINT_STOP_ERP: b3ConstraintParams = 2;
pub const b3ConstraintParams_B3_CONSTRAINT_CFM: b3ConstraintParams = 3;
pub const b3ConstraintParams_B3_CONSTRAINT_STOP_CFM: b3ConstraintParams = 4;
pub type b3ConstraintParams = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3JointFeedback {
    pub m_appliedForceBodyA: b3Vector3,
    pub m_appliedTorqueBodyA: b3Vector3,
    pub m_appliedForceBodyB: b3Vector3,
    pub m_appliedTorqueBodyB: b3Vector3,
}
#[repr(C)]
pub struct b3TypedConstraint__bindgen_vtable(::std::os::raw::c_void);
/// TypedConstraint is the baseclass for Bullet constraints and vehicles
#[repr(C)]
pub struct b3TypedConstraint {
    pub vtable_: *const b3TypedConstraint__bindgen_vtable,
    pub _base: b3TypedObject,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub __bindgen_anon_1: b3TypedConstraint__bindgen_ty_1,
    pub m_breakingImpulseThreshold: b3Scalar,
    pub m_isEnabled: bool,
    pub m_needsFeedback: bool,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_rbA: ::std::os::raw::c_int,
    pub m_rbB: ::std::os::raw::c_int,
    pub m_appliedImpulse: b3Scalar,
    pub m_dbgDrawSize: b3Scalar,
    pub m_jointFeedback: *mut b3JointFeedback,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3TypedConstraint__bindgen_ty_1 {
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_userConstraintPtr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraint_b3ConstraintInfo1 {
    pub m_numConstraintRows: ::std::os::raw::c_int,
    pub nub: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraint_b3ConstraintInfo2 {
    pub fps: b3Scalar,
    pub erp: b3Scalar,
    pub m_J1linearAxis: *mut b3Scalar,
    pub m_J1angularAxis: *mut b3Scalar,
    pub m_J2linearAxis: *mut b3Scalar,
    pub m_J2angularAxis: *mut b3Scalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut b3Scalar,
    pub cfm: *mut b3Scalar,
    pub m_lowerLimit: *mut b3Scalar,
    pub m_upperLimit: *mut b3Scalar,
    pub findex: *mut ::std::os::raw::c_int,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: b3Scalar,
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}_ZN17b3TypedConstraint14getMotorFactorEfffff"]
    pub fn b3TypedConstraint_getMotorFactor(
        this: *mut b3TypedConstraint,
        pos: b3Scalar,
        lowLim: b3Scalar,
        uppLim: b3Scalar,
        vel: b3Scalar,
        timeFact: b3Scalar,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3TypedConstraintC2E21b3TypedConstraintTypeii"]
    pub fn b3TypedConstraint_b3TypedConstraint(
        this: *mut b3TypedConstraint,
        type_: b3TypedConstraintType,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
    );
}
impl b3TypedConstraint {
    #[inline]
    pub unsafe fn getMotorFactor(
        &mut self,
        pos: b3Scalar,
        lowLim: b3Scalar,
        uppLim: b3Scalar,
        vel: b3Scalar,
        timeFact: b3Scalar,
    ) -> b3Scalar {
        b3TypedConstraint_getMotorFactor(self, pos, lowLim, uppLim, vel, timeFact)
    }
    #[inline]
    pub unsafe fn new(
        type_: b3TypedConstraintType,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3TypedConstraint_b3TypedConstraint(&mut __bindgen_tmp, type_, bodyA, bodyB);
        __bindgen_tmp
    }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TypedConstraintData {
    pub m_bodyA: ::std::os::raw::c_int,
    pub m_bodyB: ::std::os::raw::c_int,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AngularLimit {
    pub m_center: b3Scalar,
    pub m_halfRange: b3Scalar,
    pub m_softness: b3Scalar,
    pub m_biasFactor: b3Scalar,
    pub m_relaxationFactor: b3Scalar,
    pub m_correction: b3Scalar,
    pub m_sign: b3Scalar,
    pub m_solveLimit: bool,
}
extern "C" {
    /// Sets all limit's parameters.
    /// /// When low > high limit becomes inactive.
    /// /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
    #[link_name = "\u{1}_ZN14b3AngularLimit3setEfffff"]
    pub fn b3AngularLimit_set(
        this: *mut b3AngularLimit,
        low: b3Scalar,
        high: b3Scalar,
        _softness: b3Scalar,
        _biasFactor: b3Scalar,
        _relaxationFactor: b3Scalar,
    );
}
extern "C" {
    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// /// correction is calculated.
    #[link_name = "\u{1}_ZN14b3AngularLimit4testEf"]
    pub fn b3AngularLimit_test(this: *mut b3AngularLimit, angle: b3Scalar);
}
extern "C" {
    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// /// returned is modified so it equals to the limit closest to given angle.
    #[link_name = "\u{1}_ZNK14b3AngularLimit3fitERf"]
    pub fn b3AngularLimit_fit(this: *const b3AngularLimit, angle: *mut b3Scalar);
}
extern "C" {
    /// Returns correction value multiplied by sign value
    #[link_name = "\u{1}_ZNK14b3AngularLimit8getErrorEv"]
    pub fn b3AngularLimit_getError(this: *const b3AngularLimit) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14b3AngularLimit6getLowEv"]
    pub fn b3AngularLimit_getLow(this: *const b3AngularLimit) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14b3AngularLimit7getHighEv"]
    pub fn b3AngularLimit_getHigh(this: *const b3AngularLimit) -> b3Scalar;
}
impl b3AngularLimit {
    #[inline]
    pub unsafe fn set(
        &mut self,
        low: b3Scalar,
        high: b3Scalar,
        _softness: b3Scalar,
        _biasFactor: b3Scalar,
        _relaxationFactor: b3Scalar,
    ) {
        b3AngularLimit_set(self, low, high, _softness, _biasFactor, _relaxationFactor)
    }
    #[inline]
    pub unsafe fn test(&mut self, angle: b3Scalar) {
        b3AngularLimit_test(self, angle)
    }
    #[inline]
    pub unsafe fn fit(&self, angle: *mut b3Scalar) {
        b3AngularLimit_fit(self, angle)
    }
    #[inline]
    pub unsafe fn getError(&self) -> b3Scalar {
        b3AngularLimit_getError(self)
    }
    #[inline]
    pub unsafe fn getLow(&self) -> b3Scalar {
        b3AngularLimit_getLow(self)
    }
    #[inline]
    pub unsafe fn getHigh(&self) -> b3Scalar {
        b3AngularLimit_getHigh(self)
    }
}
#[repr(C)]
pub struct b3FixedConstraint {
    pub _base: b3TypedConstraint,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_relTargetAB: b3Quaternion,
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3FixedConstraintC1EiiRK11b3TransformS2_"]
    pub fn b3FixedConstraint_b3FixedConstraint(
        this: *mut b3FixedConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
    );
}
impl b3FixedConstraint {
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3FixedConstraint_b3FixedConstraint(&mut __bindgen_tmp, rbA, rbB, frameInA, frameInB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3FixedConstraintD1Ev"]
    pub fn b3FixedConstraint_b3FixedConstraint_destructor(this: *mut b3FixedConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3FixedConstraint8getInfo1EPN17b3TypedConstraint17b3ConstraintInfo1EPK15b3RigidBodyData"]
    pub fn b3FixedConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3FixedConstraint8getInfo2EPN17b3TypedConstraint17b3ConstraintInfo2EPK15b3RigidBodyData"]
    pub fn b3FixedConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3JacobianEntry {
    pub m_linearJointAxis: b3Vector3,
    pub m_aJ: b3Vector3,
    pub m_bJ: b3Vector3,
    pub m_0MinvJt: b3Vector3,
    pub m_1MinvJt: b3Vector3,
    pub m_Adiag: b3Scalar,
    pub __bindgen_padding_0: [u32; 3usize],
}
/// ! Rotation Limit structure for generic joints
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RotationalLimitMotor {
    /// !< joint limit
    pub m_loLimit: b3Scalar,
    /// !< joint limit
    pub m_hiLimit: b3Scalar,
    /// !< target motor velocity
    pub m_targetVelocity: b3Scalar,
    /// !< max force on motor
    pub m_maxMotorForce: b3Scalar,
    /// !< max force on limit
    pub m_maxLimitForce: b3Scalar,
    /// !< Damping.
    pub m_damping: b3Scalar,
    pub m_limitSoftness: b3Scalar,
    /// !< Constraint force mixing factor
    pub m_normalCFM: b3Scalar,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: b3Scalar,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: b3Scalar,
    /// !< restitution factor
    pub m_bounce: b3Scalar,
    pub m_enableMotor: bool,
    /// ! temp_variables
    /// //!@{
    pub m_currentLimitError: b3Scalar,
    /// !  How much is violated this limit
    pub m_currentPosition: b3Scalar,
    /// !< 0=free, 1=at lo limit, 2=at hi limit
    pub m_currentLimit: ::std::os::raw::c_int,
    pub m_accumulatedImpulse: b3Scalar,
}
extern "C" {
    /// ! calculates  error
    /// /*!
    /// calculates m_currentLimit and m_currentLimitError.
    /// */
    #[link_name = "\u{1}_ZN22b3RotationalLimitMotor14testLimitValueEf"]
    pub fn b3RotationalLimitMotor_testLimitValue(
        this: *mut b3RotationalLimitMotor,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ! apply the correction impulses for two bodies
    #[link_name = "\u{1}_ZN22b3RotationalLimitMotor18solveAngularLimitsEfR9b3Vector3fP15b3RigidBodyDataS3_"]
    pub fn b3RotationalLimitMotor_solveAngularLimits(
        this: *mut b3RotationalLimitMotor,
        timeStep: b3Scalar,
        axis: *mut b3Vector3,
        jacDiagABInv: b3Scalar,
        body0: *mut b3RigidBodyData,
        body1: *mut b3RigidBodyData,
    ) -> b3Scalar;
}
impl b3RotationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: b3Scalar) -> ::std::os::raw::c_int {
        b3RotationalLimitMotor_testLimitValue(self, test_value)
    }
    #[inline]
    pub unsafe fn solveAngularLimits(
        &mut self,
        timeStep: b3Scalar,
        axis: *mut b3Vector3,
        jacDiagABInv: b3Scalar,
        body0: *mut b3RigidBodyData,
        body1: *mut b3RigidBodyData,
    ) -> b3Scalar {
        b3RotationalLimitMotor_solveAngularLimits(self, timeStep, axis, jacDiagABInv, body0, body1)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3TranslationalLimitMotor {
    /// !< the constraint lower limits
    pub m_lowerLimit: b3Vector3,
    /// !< the constraint upper limits
    pub m_upperLimit: b3Vector3,
    pub m_accumulatedImpulse: b3Vector3,
    /// !< Constraint force mixing factor
    pub m_normalCFM: b3Vector3,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: b3Vector3,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: b3Vector3,
    /// !< target motor velocity
    pub m_targetVelocity: b3Vector3,
    /// !< max force on motor
    pub m_maxMotorForce: b3Vector3,
    pub m_currentLimitError: b3Vector3,
    /// !  How much is violated this limit
    pub m_currentLinearDiff: b3Vector3,
    /// !< Softness for linear limit
    pub m_limitSoftness: b3Scalar,
    /// !< Damping for linear limit
    pub m_damping: b3Scalar,
    pub m_restitution: b3Scalar,
    /// ! Bounce parameter for linear limit
    /// //!@}
    pub m_enableMotor: [bool; 3usize],
    /// !< 0=free, 1=at lower limit, 2=at upper limit
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN25b3TranslationalLimitMotor14testLimitValueEif"]
    pub fn b3TranslationalLimitMotor_testLimitValue(
        this: *mut b3TranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN25b3TranslationalLimitMotor15solveLinearAxisEffR15b3RigidBodyDataRK9b3Vector3S1_S4_iS4_S4_"]
    pub fn b3TranslationalLimitMotor_solveLinearAxis(
        this: *mut b3TranslationalLimitMotor,
        timeStep: b3Scalar,
        jacDiagABInv: b3Scalar,
        body1: *mut b3RigidBodyData,
        pointInA: *const b3Vector3,
        body2: *mut b3RigidBodyData,
        pointInB: *const b3Vector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const b3Vector3,
        anchorPos: *const b3Vector3,
    ) -> b3Scalar;
}
impl b3TranslationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: b3Scalar,
    ) -> ::std::os::raw::c_int {
        b3TranslationalLimitMotor_testLimitValue(self, limitIndex, test_value)
    }
    #[inline]
    pub unsafe fn solveLinearAxis(
        &mut self,
        timeStep: b3Scalar,
        jacDiagABInv: b3Scalar,
        body1: *mut b3RigidBodyData,
        pointInA: *const b3Vector3,
        body2: *mut b3RigidBodyData,
        pointInB: *const b3Vector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const b3Vector3,
        anchorPos: *const b3Vector3,
    ) -> b3Scalar {
        b3TranslationalLimitMotor_solveLinearAxis(
            self,
            timeStep,
            jacDiagABInv,
            body1,
            pointInA,
            body2,
            pointInB,
            limit_index,
            axis_normal_on_a,
            anchorPos,
        )
    }
}
pub const b36DofFlags_B3_6DOF_FLAGS_CFM_NORM: b36DofFlags = 1;
pub const b36DofFlags_B3_6DOF_FLAGS_CFM_STOP: b36DofFlags = 2;
pub const b36DofFlags_B3_6DOF_FLAGS_ERP_STOP: b36DofFlags = 4;
pub type b36DofFlags = u32;
/// b3Generic6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// *!
/// b3Generic6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
/// currently this limit supports rotational motors<br>
/// <ul>
/// <li> For Linear limits, use b3Generic6DofConstraint.setLinearUpperLimit, b3Generic6DofConstraint.setLinearLowerLimit. You can set the parameters with the b3TranslationalLimitMotor structure accsesible through the b3Generic6DofConstraint.getTranslationalLimitMotor method.
/// At this moment translational motors are not supported. May be in the future. </li>
///
/// <li> For Angular limits, use the b3RotationalLimitMotor structure for configuring the limit.
/// This is accessible through b3Generic6DofConstraint.getLimitMotor method,
/// This brings support for limit parameters and motors. </li>
///
/// <li> Angulars limits have these possible ranges:
/// <table border=1 >
/// <tr>
/// <td><b>AXIS</b></td>
/// <td><b>MIN ANGLE</b></td>
/// <td><b>MAX ANGLE</b></td>
/// </tr><tr>
/// <td>X</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr><tr>
/// <td>Y</td>
/// <td>-PI/2</td>
/// <td>PI/2</td>
/// </tr><tr>
/// <td>Z</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr>
/// </table>
/// </li>
/// </ul>
///
/// */
#[repr(C)]
pub struct b3Generic6DofConstraint {
    pub _base: b3TypedConstraint,
    /// !< the constraint space w.r.t body A
    pub m_frameInA: b3Transform,
    /// !< the constraint space w.r.t body B
    pub m_frameInB: b3Transform,
    /// ! Linear_Limit_parameters
    /// //!@{
    pub m_linearLimits: b3TranslationalLimitMotor,
    /// ! hinge_parameters
    /// //!@{
    pub m_angularLimits: [b3RotationalLimitMotor; 3usize],
    /// ! temporal variables
    /// //!@{
    pub m_calculatedTransformA: b3Transform,
    pub m_calculatedTransformB: b3Transform,
    pub m_calculatedAxisAngleDiff: b3Vector3,
    pub m_calculatedAxis: [b3Vector3; 3usize],
    pub m_calculatedLinearDiff: b3Vector3,
    pub m_timeStep: b3Scalar,
    pub m_factA: b3Scalar,
    pub m_factB: b3Scalar,
    pub m_hasStaticBody: bool,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_AnchorPos: b3Vector3,
    pub m_useLinearReferenceFrameA: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_flags: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint16setAngularLimitsEPN17b3TypedConstraint17b3ConstraintInfo2EiRK11b3TransformS5_RK9b3Vector3S8_S8_S8_"]
    pub fn b3Generic6DofConstraint_setAngularLimits(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint15setLinearLimitsEPN17b3TypedConstraint17b3ConstraintInfo2EiRK11b3TransformS5_RK9b3Vector3S8_S8_S8_"]
    pub fn b3Generic6DofConstraint_setLinearLimits(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint19calculateLinearInfoEv"]
    pub fn b3Generic6DofConstraint_calculateLinearInfo(this: *mut b3Generic6DofConstraint);
}
extern "C" {
    /// ! calcs the euler angles between the two bodies.
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint18calculateAngleInfoEv"]
    pub fn b3Generic6DofConstraint_calculateAngleInfo(this: *mut b3Generic6DofConstraint);
}
extern "C" {
    /// ! Calcs global transform of the offsets
    /// /*!
    /// Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    /// \sa b3Generic6DofConstraint.getCalculatedTransformA , b3Generic6DofConstraint.getCalculatedTransformB, b3Generic6DofConstraint.calculateAngleInfo
    /// */
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint19calculateTransformsERK11b3TransformS2_PK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_calculateTransforms(
        this: *mut b3Generic6DofConstraint,
        transA: *const b3Transform,
        transB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint19calculateTransformsEPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_calculateTransforms1(
        this: *mut b3Generic6DofConstraint,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint18getInfo1NonVirtualEPN17b3TypedConstraint17b3ConstraintInfo1EPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_getInfo1NonVirtual(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint18getInfo2NonVirtualEPN17b3TypedConstraint17b3ConstraintInfo2ERK11b3TransformS5_RK9b3Vector3S8_S8_S8_PK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_getInfo2NonVirtual(
        this: *mut b3Generic6DofConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint9updateRHSEf"]
    pub fn b3Generic6DofConstraint_updateRHS(
        this: *mut b3Generic6DofConstraint,
        timeStep: b3Scalar,
    );
}
extern "C" {
    /// ! Get the rotation axis in global coordinates
    #[link_name = "\u{1}_ZNK23b3Generic6DofConstraint7getAxisEi"]
    pub fn b3Generic6DofConstraint_getAxis(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Vector3;
}
extern "C" {
    /// ! Get the relative Euler angle
    /// /*!
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}_ZNK23b3Generic6DofConstraint8getAngleEi"]
    pub fn b3Generic6DofConstraint_getAngle(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
extern "C" {
    /// ! Get the relative position of the constraint pivot
    /// /*!
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}_ZNK23b3Generic6DofConstraint24getRelativePivotPositionEi"]
    pub fn b3Generic6DofConstraint_getRelativePivotPosition(
        this: *const b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint9setFramesERK11b3TransformS2_PK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_setFrames(
        this: *mut b3Generic6DofConstraint,
        frameA: *const b3Transform,
        frameB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// ! Test angular limit.
    /// /*!
    /// Calculates angular correction and returns true if limit needs to be corrected.
    /// \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint21testAngularLimitMotorEi"]
    pub fn b3Generic6DofConstraint_testAngularLimitMotor(
        this: *mut b3Generic6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint21get_limit_motor_info2EP22b3RotationalLimitMotorRK11b3TransformS4_RK9b3Vector3S7_S7_S7_PN17b3TypedConstraint17b3ConstraintInfo2EiRS5_ii"]
    pub fn b3Generic6DofConstraint_get_limit_motor_info2(
        this: *mut b3Generic6DofConstraint,
        limot: *mut b3RotationalLimitMotor,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut b3Vector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint7setAxisERK9b3Vector3S2_PK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_setAxis(
        this: *mut b3Generic6DofConstraint,
        axis1: *const b3Vector3,
        axis2: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraintC1EiiRK11b3TransformS2_bPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_b3Generic6DofConstraint(
        this: *mut b3Generic6DofConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
        useLinearReferenceFrameA: bool,
        bodies: *const b3RigidBodyData,
    );
}
impl b3Generic6DofConstraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_setAngularLimits(
            self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_setLinearLimits(
            self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        b3Generic6DofConstraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        b3Generic6DofConstraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const b3Transform,
        transB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_calculateTransforms(self, transA, transB, bodies)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self, bodies: *const b3RigidBodyData) {
        b3Generic6DofConstraint_calculateTransforms1(self, bodies)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_getInfo1NonVirtual(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_getInfo2NonVirtual(
            self, info, transA, transB, linVelA, linVelB, angVelA, angVelB, bodies,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: b3Scalar) {
        b3Generic6DofConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> b3Vector3 {
        b3Generic6DofConstraint_getAxis(self, axis_index)
    }
    #[inline]
    pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> b3Scalar {
        b3Generic6DofConstraint_getAngle(self, axis_index)
    }
    #[inline]
    pub unsafe fn getRelativePivotPosition(&self, axis_index: ::std::os::raw::c_int) -> b3Scalar {
        b3Generic6DofConstraint_getRelativePivotPosition(self, axis_index)
    }
    #[inline]
    pub unsafe fn setFrames(
        &mut self,
        frameA: *const b3Transform,
        frameB: *const b3Transform,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_setFrames(self, frameA, frameB, bodies)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) -> bool {
        b3Generic6DofConstraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut b3RotationalLimitMotor,
        transA: *const b3Transform,
        transB: *const b3Transform,
        linVelA: *const b3Vector3,
        linVelB: *const b3Vector3,
        angVelA: *const b3Vector3,
        angVelB: *const b3Vector3,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut b3Vector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3Generic6DofConstraint_get_limit_motor_info2(
            self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
            rotational, rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn setAxis(
        &mut self,
        axis1: *const b3Vector3,
        axis2: *const b3Vector3,
        bodies: *const b3RigidBodyData,
    ) {
        b3Generic6DofConstraint_setAxis(self, axis1, axis2, bodies)
    }
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        frameInA: *const b3Transform,
        frameInB: *const b3Transform,
        useLinearReferenceFrameA: bool,
        bodies: *const b3RigidBodyData,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Generic6DofConstraint_b3Generic6DofConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
            bodies,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint8getInfo1EPN17b3TypedConstraint17b3ConstraintInfo1EPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint8getInfo2EPN17b3TypedConstraint17b3ConstraintInfo2EPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint13calcAnchorPosEPK15b3RigidBodyData"]
    pub fn b3Generic6DofConstraint_calcAnchorPos(
        this: *mut ::std::os::raw::c_void,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}_ZN23b3Generic6DofConstraint8setParamEifi"]
    pub fn b3Generic6DofConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: b3Scalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}_ZNK23b3Generic6DofConstraint8getParamEii"]
    pub fn b3Generic6DofConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactPoint {
    _unused: [u8; 0],
}
pub const b3SolverMode_B3_SOLVER_RANDMIZE_ORDER: b3SolverMode = 1;
pub const b3SolverMode_B3_SOLVER_FRICTION_SEPARATE: b3SolverMode = 2;
pub const b3SolverMode_B3_SOLVER_USE_WARMSTARTING: b3SolverMode = 4;
pub const b3SolverMode_B3_SOLVER_USE_2_FRICTION_DIRECTIONS: b3SolverMode = 16;
pub const b3SolverMode_B3_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING: b3SolverMode = 32;
pub const b3SolverMode_B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION: b3SolverMode = 64;
pub const b3SolverMode_B3_SOLVER_CACHE_FRIENDLY: b3SolverMode = 128;
pub const b3SolverMode_B3_SOLVER_SIMD: b3SolverMode = 256;
pub const b3SolverMode_B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: b3SolverMode = 512;
pub const b3SolverMode_B3_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: b3SolverMode = 1024;
pub type b3SolverMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoData {
    pub m_tau: b3Scalar,
    pub m_damping: b3Scalar,
    pub m_friction: b3Scalar,
    pub m_timeStep: b3Scalar,
    pub m_restitution: b3Scalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_maxErrorReduction: b3Scalar,
    pub m_sor: b3Scalar,
    pub m_erp: b3Scalar,
    pub m_erp2: b3Scalar,
    pub m_globalCfm: b3Scalar,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_splitImpulsePenetrationThreshold: b3Scalar,
    pub m_splitImpulseTurnErp: b3Scalar,
    pub m_linearSlop: b3Scalar,
    pub m_warmstartingFactor: b3Scalar,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_maxGyroscopicForce: b3Scalar,
    pub m_singleAxisRollingFrictionThreshold: b3Scalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfo {
    pub _base: b3ContactSolverInfoData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoDoubleData {
    pub m_tau: f64,
    pub m_damping: f64,
    pub m_friction: f64,
    pub m_timeStep: f64,
    pub m_restitution: f64,
    pub m_maxErrorReduction: f64,
    pub m_sor: f64,
    pub m_erp: f64,
    pub m_erp2: f64,
    pub m_globalCfm: f64,
    pub m_splitImpulsePenetrationThreshold: f64,
    pub m_splitImpulseTurnErp: f64,
    pub m_linearSlop: f64,
    pub m_warmstartingFactor: f64,
    pub m_maxGyroscopicForce: f64,
    pub m_singleAxisRollingFrictionThreshold: f64,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactSolverInfoFloatData {
    pub m_tau: f32,
    pub m_damping: f32,
    pub m_friction: f32,
    pub m_timeStep: f32,
    pub m_restitution: f32,
    pub m_maxErrorReduction: f32,
    pub m_sor: f32,
    pub m_erp: f32,
    pub m_erp2: f32,
    pub m_globalCfm: f32,
    pub m_splitImpulsePenetrationThreshold: f32,
    pub m_splitImpulseTurnErp: f32,
    pub m_linearSlop: f32,
    pub m_warmstartingFactor: f32,
    pub m_maxGyroscopicForce: f32,
    pub m_singleAxisRollingFrictionThreshold: f32,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
pub struct b3PgsJacobiSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3PgsJacobiSolver {
    pub vtable_: *const b3PgsJacobiSolver__bindgen_vtable,
    pub m_tmpSolverBodyPool: b3AlignedObjectArray<b3SolverBody>,
    pub m_tmpSolverContactConstraintPool: b3ConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: b3ConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: b3ConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: b3ConstraintArray,
    pub m_orderTmpConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderNonContactConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderFrictionConstraintPool: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_tmpConstraintSizesPool: b3AlignedObjectArray<b3TypedConstraint_b3ConstraintInfo1>,
    pub m_bodyCount: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_bodyCountCheck: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_deltaLinearVelocities: b3AlignedObjectArray<b3Vector3>,
    pub m_deltaAngularVelocities: b3AlignedObjectArray<b3Vector3>,
    pub m_usePgs: bool,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_numSplitImpulseRecoveries: ::std::os::raw::c_int,
    /// m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    pub m_btSeed2: ::std::os::raw::c_ulong,
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver17averageVelocitiesEv"]
    pub fn b3PgsJacobiSolver_averageVelocities(this: *mut b3PgsJacobiSolver);
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver23setupFrictionConstraintEP15b3RigidBodyDataP13b3InertiaDataR18b3SolverConstraintRK9b3Vector3iiR14b3ContactPointS8_S8_S1_S1_fff"]
    pub fn b3PgsJacobiSolver_setupFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver30setupRollingFrictionConstraintEP15b3RigidBodyDataP13b3InertiaDataR18b3SolverConstraintRK9b3Vector3iiR14b3ContactPointS8_S8_S1_S1_fff"]
    pub fn b3PgsJacobiSolver_setupRollingFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver21addFrictionConstraintEP15b3RigidBodyDataP13b3InertiaDataRK9b3Vector3iiiR14b3ContactPointS6_S6_S1_S1_fff"]
    pub fn b3PgsJacobiSolver_addFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver28addRollingFrictionConstraintEP15b3RigidBodyDataP13b3InertiaDataRK9b3Vector3iiiR14b3ContactPointS6_S6_S1_S1_fff"]
    pub fn b3PgsJacobiSolver_addRollingFrictionConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver22setupContactConstraintEP15b3RigidBodyDataP13b3InertiaDataR18b3SolverConstraintiiR14b3ContactPointRK19b3ContactSolverInfoR9b3Vector3RfSD_SC_SC_"]
    pub fn b3PgsJacobiSolver_setupContactConstraint(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
        vel: *mut b3Vector3,
        rel_vel: *mut b3Scalar,
        relaxation: *mut b3Scalar,
        rel_pos1: *mut b3Vector3,
        rel_pos2: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver28setFrictionConstraintImpulseEP15b3RigidBodyDataP13b3InertiaDataR18b3SolverConstraintiiR14b3ContactPointRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_setFrictionConstraintImpulse(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver16restitutionCurveEff"]
    pub fn b3PgsJacobiSolver_restitutionCurve(
        this: *mut b3PgsJacobiSolver,
        rel_vel: b3Scalar,
        restitution: b3Scalar,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver14convertContactEP15b3RigidBodyDataP13b3InertiaDataP10b3Contact4RK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_convertContact(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        manifold: *mut b3Contact4,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver27resolveSplitPenetrationSIMDER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSplitPenetrationSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver43resolveSplitPenetrationImpulseCacheFriendlyER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSplitPenetrationImpulseCacheFriendly(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver19getOrInitSolverBodyEiP15b3RigidBodyDataP13b3InertiaData"]
    pub fn b3PgsJacobiSolver_getOrInitSolverBody(
        this: *mut b3PgsJacobiSolver,
        bodyIndex: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver14initSolverBodyEiP12b3SolverBodyP15b3RigidBodyData"]
    pub fn b3PgsJacobiSolver_initSolverBody(
        this: *mut b3PgsJacobiSolver,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3SolverBody,
        collisionObject: *mut b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver33resolveSingleConstraintRowGenericER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowGeneric(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver37resolveSingleConstraintRowGenericSIMDER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowGenericSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver36resolveSingleConstraintRowLowerLimitER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimit(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver40resolveSingleConstraintRowLowerLimitSIMDER12b3SolverBodyS1_RK18b3SolverConstraint"]
    pub fn b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimitSIMD(
        this: *mut b3PgsJacobiSolver,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver20solveSingleIterationEiPP17b3TypedConstraintiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveSingleIteration(
        this: *mut b3PgsJacobiSolver,
        iteration: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver13solveContactsEiP15b3RigidBodyDataP13b3InertiaDataiP10b3Contact4iPP17b3TypedConstraint"]
    pub fn b3PgsJacobiSolver_solveContacts(
        this: *mut b3PgsJacobiSolver,
        numBodies: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numContacts: ::std::os::raw::c_int,
        contacts: *mut b3Contact4,
        numConstraints: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver10solveGroupEP15b3RigidBodyDataP13b3InertiaDataiP10b3Contact4iPP17b3TypedConstraintiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveGroup(
        this: *mut b3PgsJacobiSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver7b3Rand2Ev"]
    pub fn b3PgsJacobiSolver_b3Rand2(this: *mut b3PgsJacobiSolver) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver10b3RandInt2Ei"]
    pub fn b3PgsJacobiSolver_b3RandInt2(
        this: *mut b3PgsJacobiSolver,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolverC1Eb"]
    pub fn b3PgsJacobiSolver_b3PgsJacobiSolver(this: *mut b3PgsJacobiSolver, usePgs: bool);
}
impl b3PgsJacobiSolver {
    #[inline]
    pub unsafe fn averageVelocities(&mut self) {
        b3PgsJacobiSolver_averageVelocities(self)
    }
    #[inline]
    pub unsafe fn setupFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) {
        b3PgsJacobiSolver_setupFrictionConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupRollingFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) {
        b3PgsJacobiSolver_setupRollingFrictionConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint {
        b3PgsJacobiSolver_addFrictionConstraint(
            self,
            bodies,
            inertias,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addRollingFrictionConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        normalAxis: *const b3Vector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        rel_pos1: *const b3Vector3,
        rel_pos2: *const b3Vector3,
        colObj0: *mut b3RigidBodyData,
        colObj1: *mut b3RigidBodyData,
        relaxation: b3Scalar,
        desiredVelocity: b3Scalar,
        cfmSlip: b3Scalar,
    ) -> *mut b3SolverConstraint {
        b3PgsJacobiSolver_addRollingFrictionConstraint(
            self,
            bodies,
            inertias,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupContactConstraint(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
        vel: *mut b3Vector3,
        rel_vel: *mut b3Scalar,
        relaxation: *mut b3Scalar,
        rel_pos1: *mut b3Vector3,
        rel_pos2: *mut b3Vector3,
    ) {
        b3PgsJacobiSolver_setupContactConstraint(
            self,
            bodies,
            inertias,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
            vel,
            rel_vel,
            relaxation,
            rel_pos1,
            rel_pos2,
        )
    }
    #[inline]
    pub unsafe fn setFrictionConstraintImpulse(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        solverConstraint: *mut b3SolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut b3ContactPoint,
        infoGlobal: *const b3ContactSolverInfo,
    ) {
        b3PgsJacobiSolver_setFrictionConstraintImpulse(
            self,
            bodies,
            inertias,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn restitutionCurve(
        &mut self,
        rel_vel: b3Scalar,
        restitution: b3Scalar,
    ) -> b3Scalar {
        b3PgsJacobiSolver_restitutionCurve(self, rel_vel, restitution)
    }
    #[inline]
    pub unsafe fn convertContact(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        manifold: *mut b3Contact4,
        infoGlobal: *const b3ContactSolverInfo,
    ) {
        b3PgsJacobiSolver_convertContact(self, bodies, inertias, manifold, infoGlobal)
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSplitPenetrationSIMD(self, bodyA, bodyB, contactConstraint)
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationImpulseCacheFriendly(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSplitPenetrationImpulseCacheFriendly(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn getOrInitSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
    ) -> ::std::os::raw::c_int {
        b3PgsJacobiSolver_getOrInitSolverBody(self, bodyIndex, bodies, inertias)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3SolverBody,
        collisionObject: *mut b3RigidBodyData,
    ) {
        b3PgsJacobiSolver_initSolverBody(self, bodyIndex, solverBody, collisionObject)
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGeneric(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowGeneric(self, bodyA, bodyB, contactConstraint)
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGenericSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowGenericSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimit(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimit(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimitSIMD(
        &mut self,
        bodyA: *mut b3SolverBody,
        bodyB: *mut b3SolverBody,
        contactConstraint: *const b3SolverConstraint,
    ) {
        b3PgsJacobiSolver_resolveSingleConstraintRowLowerLimitSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn solveSingleIteration(
        &mut self,
        iteration: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3PgsJacobiSolver_solveSingleIteration(
            self,
            iteration,
            constraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numContacts: ::std::os::raw::c_int,
        contacts: *mut b3Contact4,
        numConstraints: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
    ) {
        b3PgsJacobiSolver_solveContacts(
            self,
            numBodies,
            bodies,
            inertias,
            numContacts,
            contacts,
            numConstraints,
            constraints,
        )
    }
    #[inline]
    pub unsafe fn solveGroup(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3PgsJacobiSolver_solveGroup(
            self,
            bodies,
            inertias,
            numBodies,
            manifoldPtr,
            numManifolds,
            constraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn b3Rand2(&mut self) -> ::std::os::raw::c_ulong {
        b3PgsJacobiSolver_b3Rand2(self)
    }
    #[inline]
    pub unsafe fn b3RandInt2(&mut self, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        b3PgsJacobiSolver_b3RandInt2(self, n)
    }
    #[inline]
    pub unsafe fn new(usePgs: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3PgsJacobiSolver_b3PgsJacobiSolver(&mut __bindgen_tmp, usePgs);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver28solveGroupCacheFriendlySetupEP15b3RigidBodyDataP13b3InertiaDataiP10b3Contact4iPP17b3TypedConstraintiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver33solveGroupCacheFriendlyIterationsEPP17b3TypedConstraintiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver45solveGroupCacheFriendlySplitImpulseIterationsEPP17b3TypedConstraintiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlySplitImpulseIterations(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut b3TypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver29solveGroupCacheFriendlyFinishEP15b3RigidBodyDataP13b3InertiaDataiRK19b3ContactSolverInfo"]
    pub fn b3PgsJacobiSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolverD1Ev"]
    pub fn b3PgsJacobiSolver_b3PgsJacobiSolver_destructor(this: *mut b3PgsJacobiSolver);
}
extern "C" {
    /// clear internal cached data and reset random seed
    #[link_name = "\u{1}_ZN17b3PgsJacobiSolver5resetEv"]
    pub fn b3PgsJacobiSolver_reset(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RigidBody {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ConstraintSetting {
    pub m_tau: b3Scalar,
    pub m_damping: b3Scalar,
    pub m_impulseClamp: b3Scalar,
}
pub const b3Point2PointFlags_B3_P2P_FLAGS_ERP: b3Point2PointFlags = 1;
pub const b3Point2PointFlags_B3_P2P_FLAGS_CFM: b3Point2PointFlags = 2;
pub type b3Point2PointFlags = u32;
/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
#[repr(C)]
pub struct b3Point2PointConstraint {
    pub _base: b3TypedConstraint,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_erp: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_setting: b3ConstraintSetting,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint18getInfo1NonVirtualEPN17b3TypedConstraint17b3ConstraintInfo1EPK15b3RigidBodyData"]
    pub fn b3Point2PointConstraint_getInfo1NonVirtual(
        this: *mut b3Point2PointConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint18getInfo2NonVirtualEPN17b3TypedConstraint17b3ConstraintInfo2ERK11b3TransformS5_"]
    pub fn b3Point2PointConstraint_getInfo2NonVirtual(
        this: *mut b3Point2PointConstraint,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        body0_trans: *const b3Transform,
        body1_trans: *const b3Transform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint9updateRHSEf"]
    pub fn b3Point2PointConstraint_updateRHS(
        this: *mut b3Point2PointConstraint,
        timeStep: b3Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraintC1EiiRK9b3Vector3S2_"]
    pub fn b3Point2PointConstraint_b3Point2PointConstraint(
        this: *mut b3Point2PointConstraint,
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        pivotInA: *const b3Vector3,
        pivotInB: *const b3Vector3,
    );
}
impl b3Point2PointConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    ) {
        b3Point2PointConstraint_getInfo1NonVirtual(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        body0_trans: *const b3Transform,
        body1_trans: *const b3Transform,
    ) {
        b3Point2PointConstraint_getInfo2NonVirtual(self, info, body0_trans, body1_trans)
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: b3Scalar) {
        b3Point2PointConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn new(
        rbA: ::std::os::raw::c_int,
        rbB: ::std::os::raw::c_int,
        pivotInA: *const b3Vector3,
        pivotInB: *const b3Vector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Point2PointConstraint_b3Point2PointConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint8getInfo1EPN17b3TypedConstraint17b3ConstraintInfo1EPK15b3RigidBodyData"]
    pub fn b3Point2PointConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo1,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint8getInfo2EPN17b3TypedConstraint17b3ConstraintInfo2EPK15b3RigidBodyData"]
    pub fn b3Point2PointConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut b3TypedConstraint_b3ConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}_ZN23b3Point2PointConstraint8setParamEifi"]
    pub fn b3Point2PointConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: b3Scalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}_ZNK23b3Point2PointConstraint8getParamEii"]
    pub fn b3Point2PointConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> b3Scalar;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Point2PointConstraintFloatData {
    pub m_typeConstraintData: b3TypedConstraintData,
    pub m_pivotInA: b3Vector3FloatData,
    pub m_pivotInB: b3Vector3FloatData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Point2PointConstraintDoubleData {
    pub m_typeConstraintData: b3TypedConstraintData,
    pub m_pivotInA: b3Vector3DoubleData,
    pub m_pivotInB: b3Vector3DoubleData,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RayInfo {
    pub m_from: b3Vector3,
    pub m_to: b3Vector3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3RayHit {
    pub m_hitFraction: b3Scalar,
    pub m_hitBody: ::std::os::raw::c_int,
    pub m_hitResult1: ::std::os::raw::c_int,
    pub m_hitResult2: ::std::os::raw::c_int,
    pub m_hitPoint: b3Vector3,
    pub m_hitNormal: b3Vector3,
}
#[repr(C)]
pub struct b3CpuRigidBodyPipeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3CpuRigidBodyPipeline {
    pub vtable_: *const b3CpuRigidBodyPipeline__bindgen_vtable,
    pub m_data: *mut b3CpuRigidBodyPipelineInternalData,
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline18allocateCollidableEv"]
    pub fn b3CpuRigidBodyPipeline_allocateCollidable(
        this: *mut b3CpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline24registerConvexPolyhedronEP15b3ConvexUtility"]
    pub fn b3CpuRigidBodyPipeline_registerConvexPolyhedron(
        this: *mut b3CpuRigidBodyPipeline,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline23registerPhysicsInstanceEfPKfS1_ii"]
    pub fn b3CpuRigidBodyPipeline_registerPhysicsInstance(
        this: *mut b3CpuRigidBodyPipeline,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline22writeAllInstancesToGpuEv"]
    pub fn b3CpuRigidBodyPipeline_writeAllInstancesToGpu(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline21copyConstraintsToHostEv"]
    pub fn b3CpuRigidBodyPipeline_copyConstraintsToHost(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline10setGravityEPKf"]
    pub fn b3CpuRigidBodyPipeline_setGravity(this: *mut b3CpuRigidBodyPipeline, grav: *const f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline5resetEv"]
    pub fn b3CpuRigidBodyPipeline_reset(this: *mut b3CpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline27createPoint2PointConstraintEiiPKfS1_f"]
    pub fn b3CpuRigidBodyPipeline_createPoint2PointConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline21createFixedConstraintEiiPKfS1_S1_f"]
    pub fn b3CpuRigidBodyPipeline_createFixedConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline21removeConstraintByUidEi"]
    pub fn b3CpuRigidBodyPipeline_removeConstraintByUid(
        this: *mut b3CpuRigidBodyPipeline,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline13addConstraintEP17b3TypedConstraint"]
    pub fn b3CpuRigidBodyPipeline_addConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline16removeConstraintEP17b3TypedConstraint"]
    pub fn b3CpuRigidBodyPipeline_removeConstraint(
        this: *mut b3CpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline8castRaysERK20b3AlignedObjectArrayI9b3RayInfoERS0_I8b3RayHitE"]
    pub fn b3CpuRigidBodyPipeline_castRays(
        this: *mut b3CpuRigidBodyPipeline,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3CpuRigidBodyPipeline13getBodyBufferEv"]
    pub fn b3CpuRigidBodyPipeline_getBodyBuffer(
        this: *const b3CpuRigidBodyPipeline,
    ) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3CpuRigidBodyPipeline12getNumBodiesEv"]
    pub fn b3CpuRigidBodyPipeline_getNumBodies(
        this: *const b3CpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipelineC1EP16b3CpuNarrowPhaseP22b3DynamicBvhBroadphaseRK8b3Config"]
    pub fn b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline(
        this: *mut b3CpuRigidBodyPipeline,
        narrowphase: *mut b3CpuNarrowPhase,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    );
}
impl b3CpuRigidBodyPipeline {
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn registerConvexPolyhedron(
        &mut self,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_registerConvexPolyhedron(self, convex)
    }
    #[inline]
    pub unsafe fn registerPhysicsInstance(
        &mut self,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_registerPhysicsInstance(
            self,
            mass,
            position,
            orientation,
            collisionShapeIndex,
            userData,
        )
    }
    #[inline]
    pub unsafe fn writeAllInstancesToGpu(&mut self) {
        b3CpuRigidBodyPipeline_writeAllInstancesToGpu(self)
    }
    #[inline]
    pub unsafe fn copyConstraintsToHost(&mut self) {
        b3CpuRigidBodyPipeline_copyConstraintsToHost(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, grav: *const f32) {
        b3CpuRigidBodyPipeline_setGravity(self, grav)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3CpuRigidBodyPipeline_reset(self)
    }
    #[inline]
    pub unsafe fn createPoint2PointConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_createPoint2PointConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn createFixedConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_createFixedConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            relTargetAB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn removeConstraintByUid(&mut self, uid: ::std::os::raw::c_int) {
        b3CpuRigidBodyPipeline_removeConstraintByUid(self, uid)
    }
    #[inline]
    pub unsafe fn addConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3CpuRigidBodyPipeline_addConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn removeConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3CpuRigidBodyPipeline_removeConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    ) {
        b3CpuRigidBodyPipeline_castRays(self, rays, hitResults)
    }
    #[inline]
    pub unsafe fn getBodyBuffer(&self) -> *const b3RigidBodyData {
        b3CpuRigidBodyPipeline_getBodyBuffer(self)
    }
    #[inline]
    pub unsafe fn getNumBodies(&self) -> ::std::os::raw::c_int {
        b3CpuRigidBodyPipeline_getNumBodies(self)
    }
    #[inline]
    pub unsafe fn new(
        narrowphase: *mut b3CpuNarrowPhase,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline(
            &mut __bindgen_tmp,
            narrowphase,
            broadphaseDbvt,
            config,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipelineD1Ev"]
    pub fn b3CpuRigidBodyPipeline_b3CpuRigidBodyPipeline_destructor(
        this: *mut b3CpuRigidBodyPipeline,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline14stepSimulationEf"]
    pub fn b3CpuRigidBodyPipeline_stepSimulation(this: *mut ::std::os::raw::c_void, deltaTime: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline9integrateEf"]
    pub fn b3CpuRigidBodyPipeline_integrate(this: *mut ::std::os::raw::c_void, timeStep: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline20updateAabbWorldSpaceEv"]
    pub fn b3CpuRigidBodyPipeline_updateAabbWorldSpace(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline23computeOverlappingPairsEv"]
    pub fn b3CpuRigidBodyPipeline_computeOverlappingPairs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline20computeContactPointsEv"]
    pub fn b3CpuRigidBodyPipeline_computeContactPoints(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3CpuRigidBodyPipeline23solveContactConstraintsEv"]
    pub fn b3CpuRigidBodyPipeline_solveContactConstraints(this: *mut ::std::os::raw::c_void);
}
pub type b3ContactConstraint4_t = b3ContactConstraint4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3ContactConstraint4 {
    pub m_linear: b3Vector3,
    pub m_worldPos: [b3Vector3; 4usize],
    pub m_center: b3Vector3,
    pub m_jacCoeffInv: [f32; 4usize],
    pub m_b: [f32; 4usize],
    pub m_appliedRambdaDt: [f32; 4usize],
    pub m_fJacCoeffInv: [f32; 2usize],
    pub m_fAppliedRambdaDt: [f32; 2usize],
    pub m_bodyA: ::std::os::raw::c_uint,
    pub m_bodyB: ::std::os::raw::c_uint,
    pub m_batchIdx: ::std::os::raw::c_int,
    pub m_paddings: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}_Z13b3PlaneSpace1RK9b3Vector3PS_S2_"]
    pub fn b3PlaneSpace1(n: *const b3Vector3, p: *mut b3Vector3, q: *mut b3Vector3);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Inertia {
    pub m_invInertiaWorld: b3Matrix3x3,
    pub m_initInvInertia: b3Matrix3x3,
}
/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
#[repr(C)]
pub struct b3ConvexHullComputer {
    pub vertices: b3AlignedObjectArray<b3Vector3>,
    pub edges: b3AlignedObjectArray<b3ConvexHullComputer_Edge>,
    pub faces: b3AlignedObjectArray<::std::os::raw::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ConvexHullComputer_Edge {
    pub next: ::std::os::raw::c_int,
    pub reverse: ::std::os::raw::c_int,
    pub targetVertex: ::std::os::raw::c_int,
}
/// The b3GeometryUtil helper class provides a few methods to convert between plane equations and vertices.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GeometryUtil {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3GeometryUtil29getPlaneEquationsFromVerticesER20b3AlignedObjectArrayI9b3Vector3ES3_"]
    pub fn b3GeometryUtil_getPlaneEquationsFromVertices(
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        planeEquationsOut: *mut b3AlignedObjectArray<b3Vector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3GeometryUtil29getVerticesFromPlaneEquationsERK20b3AlignedObjectArrayI9b3Vector3ERS2_"]
    pub fn b3GeometryUtil_getVerticesFromPlaneEquations(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        verticesOut: *mut b3AlignedObjectArray<b3Vector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3GeometryUtil8isInsideERK20b3AlignedObjectArrayI9b3Vector3ERKS1_f"]
    pub fn b3GeometryUtil_isInside(
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        planeNormal: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3GeometryUtil19isPointInsidePlanesERK20b3AlignedObjectArrayI9b3Vector3ERKS1_f"]
    pub fn b3GeometryUtil_isPointInsidePlanes(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        point: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3GeometryUtil22areVerticesBehindPlaneERK9b3Vector3RK20b3AlignedObjectArrayIS0_Ef"]
    pub fn b3GeometryUtil_areVerticesBehindPlane(
        planeNormal: *const b3Vector3,
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        margin: b3Scalar,
    ) -> bool;
}
impl b3GeometryUtil {
    #[inline]
    pub unsafe fn getPlaneEquationsFromVertices(
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        planeEquationsOut: *mut b3AlignedObjectArray<b3Vector3>,
    ) {
        b3GeometryUtil_getPlaneEquationsFromVertices(vertices, planeEquationsOut)
    }
    #[inline]
    pub unsafe fn getVerticesFromPlaneEquations(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        verticesOut: *mut b3AlignedObjectArray<b3Vector3>,
    ) {
        b3GeometryUtil_getVerticesFromPlaneEquations(planeEquations, verticesOut)
    }
    #[inline]
    pub unsafe fn isInside(
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        planeNormal: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_isInside(vertices, planeNormal, margin)
    }
    #[inline]
    pub unsafe fn isPointInsidePlanes(
        planeEquations: *const b3AlignedObjectArray<b3Vector3>,
        point: *const b3Vector3,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_isPointInsidePlanes(planeEquations, point, margin)
    }
    #[inline]
    pub unsafe fn areVerticesBehindPlane(
        planeNormal: *const b3Vector3,
        vertices: *const b3AlignedObjectArray<b3Vector3>,
        margin: b3Scalar,
    ) -> bool {
        b3GeometryUtil_areVerticesBehindPlane(planeNormal, vertices, margin)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GrahamVector3 {
    pub _base: b3Vector3,
    pub m_angle: b3Scalar,
    pub m_orgIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3AngleCompareFunc {
    pub m_anchor: b3Vector3,
}
pub type cl_char = i8;
pub type cl_uchar = u8;
pub type cl_short = i16;
pub type cl_ushort = u16;
pub type cl_int = i32;
pub type cl_uint = u32;
pub type cl_long = i64;
pub type cl_ulong = u64;
pub type cl_half = u16;
pub type cl_float = f32;
pub type cl_double = f64;
pub type cl_GLuint = ::std::os::raw::c_uint;
pub type cl_GLint = ::std::os::raw::c_int;
pub type cl_GLenum = ::std::os::raw::c_uint;
pub type __cl_float4 = [f32; 4usize];
pub type __cl_uchar16 = [cl_uchar; 16usize];
pub type __cl_char16 = [cl_char; 16usize];
pub type __cl_ushort8 = [cl_ushort; 8usize];
pub type __cl_short8 = [cl_short; 8usize];
pub type __cl_uint4 = [cl_uint; 4usize];
pub type __cl_int4 = [cl_int; 4usize];
pub type __cl_ulong2 = [cl_ulong; 2usize];
pub type __cl_long2 = [cl_long; 2usize];
pub type __cl_double2 = [cl_double; 2usize];
pub type __cl_uchar8 = [cl_uchar; 8usize];
pub type __cl_char8 = [cl_char; 8usize];
pub type __cl_ushort4 = [cl_ushort; 4usize];
pub type __cl_short4 = [cl_short; 4usize];
pub type __cl_uint2 = [cl_uint; 2usize];
pub type __cl_int2 = [cl_int; 2usize];
pub type __cl_ulong1 = [cl_ulong; 1usize];
pub type __cl_long1 = [cl_long; 1usize];
pub type __cl_float2 = [cl_float; 2usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_char2 {
    pub s: [cl_char; 2usize],
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_char4 {
    pub s: [cl_char; 4usize],
    _bindgen_union_align: u32,
}
pub type cl_char3 = cl_char4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_char8 {
    pub s: [cl_char; 8usize],
    pub v8: __cl_char8,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_char16 {
    pub s: [cl_char; 16usize],
    pub v8: [__cl_char8; 2usize],
    pub v16: __cl_char16,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uchar2 {
    pub s: [cl_uchar; 2usize],
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uchar4 {
    pub s: [cl_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type cl_uchar3 = cl_uchar4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uchar8 {
    pub s: [cl_uchar; 8usize],
    pub v8: __cl_uchar8,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uchar16 {
    pub s: [cl_uchar; 16usize],
    pub v8: [__cl_uchar8; 2usize],
    pub v16: __cl_uchar16,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_short2 {
    pub s: [cl_short; 2usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_short4 {
    pub s: [cl_short; 4usize],
    pub v4: __cl_short4,
    _bindgen_union_align: u64,
}
pub type cl_short3 = cl_short4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_short8 {
    pub s: [cl_short; 8usize],
    pub v4: [__cl_short4; 2usize],
    pub v8: __cl_short8,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_short16 {
    pub s: [cl_short; 16usize],
    pub v4: [__cl_short4; 4usize],
    pub v8: [__cl_short8; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ushort2 {
    pub s: [cl_ushort; 2usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ushort4 {
    pub s: [cl_ushort; 4usize],
    pub v4: __cl_ushort4,
    _bindgen_union_align: u64,
}
pub type cl_ushort3 = cl_ushort4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ushort8 {
    pub s: [cl_ushort; 8usize],
    pub v4: [__cl_ushort4; 2usize],
    pub v8: __cl_ushort8,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ushort16 {
    pub s: [cl_ushort; 16usize],
    pub v4: [__cl_ushort4; 4usize],
    pub v8: [__cl_ushort8; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_int2 {
    pub s: [cl_int; 2usize],
    pub v2: __cl_int2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_int4 {
    pub s: [cl_int; 4usize],
    pub v2: [__cl_int2; 2usize],
    pub v4: __cl_int4,
    _bindgen_union_align: [u8; 16usize],
}
pub type cl_int3 = cl_int4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_int8 {
    pub s: [cl_int; 8usize],
    pub v2: [__cl_int2; 4usize],
    pub v4: [__cl_int4; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_int16 {
    pub s: [cl_int; 16usize],
    pub v2: [__cl_int2; 8usize],
    pub v4: [__cl_int4; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uint2 {
    pub s: [cl_uint; 2usize],
    pub v2: __cl_uint2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uint4 {
    pub s: [cl_uint; 4usize],
    pub v2: [__cl_uint2; 2usize],
    pub v4: __cl_uint4,
    _bindgen_union_align: [u8; 16usize],
}
pub type cl_uint3 = cl_uint4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uint8 {
    pub s: [cl_uint; 8usize],
    pub v2: [__cl_uint2; 4usize],
    pub v4: [__cl_uint4; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_uint16 {
    pub s: [cl_uint; 16usize],
    pub v2: [__cl_uint2; 8usize],
    pub v4: [__cl_uint4; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_long2 {
    pub s: [cl_long; 2usize],
    pub v2: __cl_long2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_long4 {
    pub s: [cl_long; 4usize],
    pub v2: [__cl_long2; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
pub type cl_long3 = cl_long4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_long8 {
    pub s: [cl_long; 8usize],
    pub v2: [__cl_long2; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_long16 {
    pub s: [cl_long; 16usize],
    pub v2: [__cl_long2; 8usize],
    _bindgen_union_align: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ulong2 {
    pub s: [cl_ulong; 2usize],
    pub v2: __cl_ulong2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ulong4 {
    pub s: [cl_ulong; 4usize],
    pub v2: [__cl_ulong2; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
pub type cl_ulong3 = cl_ulong4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ulong8 {
    pub s: [cl_ulong; 8usize],
    pub v2: [__cl_ulong2; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_ulong16 {
    pub s: [cl_ulong; 16usize],
    pub v2: [__cl_ulong2; 8usize],
    _bindgen_union_align: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_float2 {
    pub s: [cl_float; 2usize],
    pub v2: __cl_float2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_float4 {
    pub s: [cl_float; 4usize],
    pub v2: [__cl_float2; 2usize],
    pub v4: __cl_float4,
    _bindgen_union_align: [u8; 16usize],
}
pub type cl_float3 = cl_float4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_float8 {
    pub s: [cl_float; 8usize],
    pub v2: [__cl_float2; 4usize],
    pub v4: [__cl_float4; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_float16 {
    pub s: [cl_float; 16usize],
    pub v2: [__cl_float2; 8usize],
    pub v4: [__cl_float4; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_double2 {
    pub s: [cl_double; 2usize],
    pub v2: __cl_double2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_double4 {
    pub s: [cl_double; 4usize],
    pub v2: [__cl_double2; 2usize],
    _bindgen_union_align: [u8; 32usize],
}
pub type cl_double3 = cl_double4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_double8 {
    pub s: [cl_double; 8usize],
    pub v2: [__cl_double2; 4usize],
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_double16 {
    pub s: [cl_double; 16usize],
    pub v2: [__cl_double2; 8usize],
    _bindgen_union_align: [u8; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_platform_id {
    _unused: [u8; 0],
}

pub type cl_platform_id = *mut _cl_platform_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_device_id {
    _unused: [u8; 0],
}
pub type cl_device_id = *mut _cl_device_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_context {
    _unused: [u8; 0],
}
pub type cl_context = *mut _cl_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_command_queue {
    _unused: [u8; 0],
}
pub type cl_command_queue = *mut _cl_command_queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_mem {
    _unused: [u8; 0],
}
pub type cl_mem = *mut _cl_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_program {
    _unused: [u8; 0],
}
pub type cl_program = *mut _cl_program;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_kernel {
    _unused: [u8; 0],
}
pub type cl_kernel = *mut _cl_kernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_event {
    _unused: [u8; 0],
}
pub type cl_event = *mut _cl_event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_sampler {
    _unused: [u8; 0],
}
pub type cl_sampler = *mut _cl_sampler;
pub type cl_bool = cl_uint;
pub type cl_bitfield = cl_ulong;
pub type cl_device_type = cl_bitfield;
pub type cl_platform_info = cl_uint;
pub type cl_device_info = cl_uint;
pub type cl_device_fp_config = cl_bitfield;
pub type cl_device_mem_cache_type = cl_uint;
pub type cl_device_local_mem_type = cl_uint;
pub type cl_device_exec_capabilities = cl_bitfield;
pub type cl_command_queue_properties = cl_bitfield;
pub type cl_context_properties = isize;
pub type cl_context_info = cl_uint;
pub type cl_command_queue_info = cl_uint;
pub type cl_channel_order = cl_uint;
pub type cl_channel_type = cl_uint;
pub type cl_mem_flags = cl_bitfield;
pub type cl_mem_object_type = cl_uint;
pub type cl_mem_info = cl_uint;
pub type cl_image_info = cl_uint;
pub type cl_buffer_create_type = cl_uint;
pub type cl_addressing_mode = cl_uint;
pub type cl_filter_mode = cl_uint;
pub type cl_sampler_info = cl_uint;
pub type cl_map_flags = cl_bitfield;
pub type cl_program_info = cl_uint;
pub type cl_program_build_info = cl_uint;
pub type cl_build_status = cl_int;
pub type cl_kernel_info = cl_uint;
pub type cl_kernel_work_group_info = cl_uint;
pub type cl_event_info = cl_uint;
pub type cl_command_type = cl_uint;
pub type cl_profiling_info = cl_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_image_format {
    pub image_channel_order: cl_channel_order,
    pub image_channel_data_type: cl_channel_type,
}
pub type cl_image_format = _cl_image_format;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_buffer_region {
    pub origin: usize,
    pub size: usize,
}
pub type cl_buffer_region = _cl_buffer_region;

pub type PFNCLGETPLATFORMIDS = ::std::option::Option<
    unsafe extern "C" fn(arg1: cl_uint, arg2: *mut cl_platform_id, arg3: *mut cl_uint) -> cl_int,
>;
pub type PFNCLGETPLATFORMINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_platform_id,
        arg2: cl_platform_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLGETDEVICEIDS = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_platform_id,
        arg2: cl_device_type,
        arg3: cl_uint,
        arg4: *mut cl_device_id,
        arg5: *mut cl_uint,
    ) -> cl_int,
>;
pub type PFNCLGETDEVICEINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_device_id,
        arg2: cl_device_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATECONTEXT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const cl_context_properties,
        arg2: cl_uint,
        arg3: *const cl_device_id,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const ::std::os::raw::c_void,
                arg3: usize,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
        arg5: *mut ::std::os::raw::c_void,
        arg6: *mut cl_int,
    ) -> cl_context,
>;
pub type PFNCLCREATECONTEXTFROMTYPE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const cl_context_properties,
        arg2: cl_device_type,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const ::std::os::raw::c_void,
                arg3: usize,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut cl_int,
    ) -> cl_context,
>;
pub type PFNCLRETAINCONTEXT =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_context) -> cl_int>;
pub type PFNCLRELEASECONTEXT =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_context) -> cl_int>;
pub type PFNCLGETCONTEXTINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_context_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATECOMMANDQUEUE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_device_id,
        arg3: cl_command_queue_properties,
        arg4: *mut cl_int,
    ) -> cl_command_queue,
>;
pub type PFNCLRETAINCOMMANDQUEUE =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_command_queue) -> cl_int>;
pub type PFNCLRELEASECOMMANDQUEUE =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_command_queue) -> cl_int>;
pub type PFNCLGETCOMMANDQUEUEINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_command_queue_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATEBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_mem_flags,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut cl_int,
    ) -> cl_mem,
>;
pub type PFNCLCREATESUBBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_mem,
        arg2: cl_mem_flags,
        arg3: cl_buffer_create_type,
        arg4: *const ::std::os::raw::c_void,
        arg5: *mut cl_int,
    ) -> cl_mem,
>;
pub type PFNCLCREATEIMAGE2D = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_mem_flags,
        arg3: *const cl_image_format,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: *mut ::std::os::raw::c_void,
        arg8: *mut cl_int,
    ) -> cl_mem,
>;
pub type PFNCLCREATEIMAGE3D = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_mem_flags,
        arg3: *const cl_image_format,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: usize,
        arg8: usize,
        arg9: *mut ::std::os::raw::c_void,
        arg10: *mut cl_int,
    ) -> cl_mem,
>;
pub type PFNCLRETAINMEMOBJECT = ::std::option::Option<unsafe extern "C" fn(arg1: cl_mem) -> cl_int>;
pub type PFNCLRELEASEMEMOBJECT =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_mem) -> cl_int>;
pub type PFNCLGETSUPPORTEDIMAGEFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_mem_flags,
        arg3: cl_mem_object_type,
        arg4: cl_uint,
        arg5: *mut cl_image_format,
        arg6: *mut cl_uint,
    ) -> cl_int,
>;
pub type PFNCLGETMEMOBJECTINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_mem,
        arg2: cl_mem_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLGETIMAGEINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_mem,
        arg2: cl_image_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLSETMEMOBJECTDESTRUCTORCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_mem,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: cl_mem, arg2: *mut ::std::os::raw::c_void),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> cl_int,
>;
pub type PFNCLCREATESAMPLER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_bool,
        arg3: cl_addressing_mode,
        arg4: cl_filter_mode,
        arg5: *mut cl_int,
    ) -> cl_sampler,
>;
pub type PFNCLRETAINSAMPLER =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_sampler) -> cl_int>;
pub type PFNCLRELEASESAMPLER =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_sampler) -> cl_int>;
pub type PFNCLGETSAMPLERINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_sampler,
        arg2: cl_sampler_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATEPROGRAMWITHSOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_uint,
        arg3: *mut *const ::std::os::raw::c_char,
        arg4: *const usize,
        arg5: *mut cl_int,
    ) -> cl_program,
>;
pub type PFNCLCREATEPROGRAMWITHBINARY = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_context,
        arg2: cl_uint,
        arg3: *const cl_device_id,
        arg4: *const usize,
        arg5: *mut *const ::std::os::raw::c_uchar,
        arg6: *mut cl_int,
        arg7: *mut cl_int,
    ) -> cl_program,
>;
pub type PFNCLRETAINPROGRAM =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_program) -> cl_int>;
pub type PFNCLRELEASEPROGRAM =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_program) -> cl_int>;
pub type PFNCLBUILDPROGRAM = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_program,
        arg2: cl_uint,
        arg3: *const cl_device_id,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: cl_program, arg2: *mut ::std::os::raw::c_void),
        >,
        arg6: *mut ::std::os::raw::c_void,
    ) -> cl_int,
>;
pub type PFNCLUNLOADCOMPILER = ::std::option::Option<unsafe extern "C" fn() -> cl_int>;
pub type PFNCLGETPROGRAMINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_program,
        arg2: cl_program_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLGETPROGRAMBUILDINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_program,
        arg2: cl_device_id,
        arg3: cl_program_build_info,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_void,
        arg6: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATEKERNEL = ::std::option::Option<
    unsafe extern "C" fn(arg1: cl_program, arg2: *const ::std::os::raw::c_char, arg3: *mut cl_int)
        -> cl_kernel,
>;
pub type PFNCLCREATEKERNELSINPROGRAM = ::std::option::Option<
    unsafe extern "C" fn(arg1: cl_program, arg2: cl_uint, arg3: *mut cl_kernel, arg4: *mut cl_uint)
        -> cl_int,
>;
pub type PFNCLRETAINKERNEL = ::std::option::Option<unsafe extern "C" fn(arg1: cl_kernel) -> cl_int>;
pub type PFNCLRELEASEKERNEL =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_kernel) -> cl_int>;
pub type PFNCLSETKERNELARG = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_kernel,
        arg2: cl_uint,
        arg3: usize,
        arg4: *const ::std::os::raw::c_void,
    ) -> cl_int,
>;
pub type PFNCLGETKERNELINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_kernel,
        arg2: cl_kernel_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLGETKERNELWORKGROUPINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_kernel,
        arg2: cl_device_id,
        arg3: cl_kernel_work_group_info,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_void,
        arg6: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLWAITFOREVENTS =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_uint, arg2: *const cl_event) -> cl_int>;
pub type PFNCLGETEVENTINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_event,
        arg2: cl_event_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLCREATEUSEREVENT =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_context, arg2: *mut cl_int) -> cl_event>;
pub type PFNCLRETAINEVENT = ::std::option::Option<unsafe extern "C" fn(arg1: cl_event) -> cl_int>;
pub type PFNCLRELEASEEVENT = ::std::option::Option<unsafe extern "C" fn(arg1: cl_event) -> cl_int>;
pub type PFNCLSETUSEREVENTSTATUS =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_event, arg2: cl_int) -> cl_int>;
pub type PFNCLSETEVENTCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_event,
        arg2: cl_int,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: cl_event, arg2: cl_int, arg3: *mut ::std::os::raw::c_void),
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> cl_int,
>;
pub type PFNCLGETEVENTPROFILINGINFO = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_event,
        arg2: cl_profiling_info,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut usize,
    ) -> cl_int,
>;
pub type PFNCLFLUSH = ::std::option::Option<unsafe extern "C" fn(arg1: cl_command_queue) -> cl_int>;
pub type PFNCLFINISH =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_command_queue) -> cl_int>;
pub type PFNCLENQUEUEREADBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: usize,
        arg5: usize,
        arg6: *mut ::std::os::raw::c_void,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEREADBUFFERRECT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: *const usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: usize,
        arg8: usize,
        arg9: usize,
        arg10: usize,
        arg11: *mut ::std::os::raw::c_void,
        arg12: cl_uint,
        arg13: *const cl_event,
        arg14: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEWRITEBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: usize,
        arg5: usize,
        arg6: *const ::std::os::raw::c_void,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEWRITEBUFFERRECT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: *const usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: usize,
        arg8: usize,
        arg9: usize,
        arg10: usize,
        arg11: *const ::std::os::raw::c_void,
        arg12: cl_uint,
        arg13: *const cl_event,
        arg14: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUECOPYBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_mem,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUECOPYBUFFERRECT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_mem,
        arg4: *const usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: usize,
        arg8: usize,
        arg9: usize,
        arg10: usize,
        arg11: cl_uint,
        arg12: *const cl_event,
        arg13: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEREADIMAGE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: *const usize,
        arg5: *const usize,
        arg6: usize,
        arg7: usize,
        arg8: *mut ::std::os::raw::c_void,
        arg9: cl_uint,
        arg10: *const cl_event,
        arg11: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEWRITEIMAGE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: *const usize,
        arg5: *const usize,
        arg6: usize,
        arg7: usize,
        arg8: *const ::std::os::raw::c_void,
        arg9: cl_uint,
        arg10: *const cl_event,
        arg11: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUECOPYIMAGE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_mem,
        arg4: *const usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUECOPYIMAGETOBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_mem,
        arg4: *const usize,
        arg5: *const usize,
        arg6: usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUECOPYBUFFERTOIMAGE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_mem,
        arg4: usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEMAPBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: cl_map_flags,
        arg5: usize,
        arg6: usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
        arg10: *mut cl_int,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFNCLENQUEUEMAPIMAGE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: cl_bool,
        arg4: cl_map_flags,
        arg5: *const usize,
        arg6: *const usize,
        arg7: *mut usize,
        arg8: *mut usize,
        arg9: cl_uint,
        arg10: *const cl_event,
        arg11: *mut cl_event,
        arg12: *mut cl_int,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFNCLENQUEUEUNMAPMEMOBJECT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_mem,
        arg3: *mut ::std::os::raw::c_void,
        arg4: cl_uint,
        arg5: *const cl_event,
        arg6: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUENDRANGEKERNEL = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_kernel,
        arg3: cl_uint,
        arg4: *const usize,
        arg5: *const usize,
        arg6: *const usize,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUETASK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        arg2: cl_kernel,
        arg3: cl_uint,
        arg4: *const cl_event,
        arg5: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUENATIVEKERNEL = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: cl_command_queue,
        user_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: cl_uint,
        arg5: *const cl_mem,
        arg6: *mut *const ::std::os::raw::c_void,
        arg7: cl_uint,
        arg8: *const cl_event,
        arg9: *mut cl_event,
    ) -> cl_int,
>;
pub type PFNCLENQUEUEMARKER = ::std::option::Option<
    unsafe extern "C" fn(arg1: cl_command_queue, arg2: *mut cl_event) -> cl_int,
>;
pub type PFNCLENQUEUEWAITFOREVENTS = ::std::option::Option<
    unsafe extern "C" fn(arg1: cl_command_queue, arg2: cl_uint, arg3: *const cl_event) -> cl_int,
>;
pub type PFNCLENQUEUEBARRIER =
    ::std::option::Option<unsafe extern "C" fn(arg1: cl_command_queue) -> cl_int>;
pub type PFNCLGETEXTENSIONFUNCTIONADDRESS = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}__clewGetPlatformIDs"]
    pub static mut __clewGetPlatformIDs: PFNCLGETPLATFORMIDS;
}
extern "C" {
    #[link_name = "\u{1}__clewGetPlatformInfo"]
    pub static mut __clewGetPlatformInfo: PFNCLGETPLATFORMINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewGetDeviceIDs"]
    pub static mut __clewGetDeviceIDs: PFNCLGETDEVICEIDS;
}
extern "C" {
    #[link_name = "\u{1}__clewGetDeviceInfo"]
    pub static mut __clewGetDeviceInfo: PFNCLGETDEVICEINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateContext"]
    pub static mut __clewCreateContext: PFNCLCREATECONTEXT;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateContextFromType"]
    pub static mut __clewCreateContextFromType: PFNCLCREATECONTEXTFROMTYPE;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainContext"]
    pub static mut __clewRetainContext: PFNCLRETAINCONTEXT;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseContext"]
    pub static mut __clewReleaseContext: PFNCLRELEASECONTEXT;
}
extern "C" {
    #[link_name = "\u{1}__clewGetContextInfo"]
    pub static mut __clewGetContextInfo: PFNCLGETCONTEXTINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateCommandQueue"]
    pub static mut __clewCreateCommandQueue: PFNCLCREATECOMMANDQUEUE;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainCommandQueue"]
    pub static mut __clewRetainCommandQueue: PFNCLRETAINCOMMANDQUEUE;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseCommandQueue"]
    pub static mut __clewReleaseCommandQueue: PFNCLRELEASECOMMANDQUEUE;
}
extern "C" {
    #[link_name = "\u{1}__clewGetCommandQueueInfo"]
    pub static mut __clewGetCommandQueueInfo: PFNCLGETCOMMANDQUEUEINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateBuffer"]
    pub static mut __clewCreateBuffer: PFNCLCREATEBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateSubBuffer"]
    pub static mut __clewCreateSubBuffer: PFNCLCREATESUBBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateImage2D"]
    pub static mut __clewCreateImage2D: PFNCLCREATEIMAGE2D;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateImage3D"]
    pub static mut __clewCreateImage3D: PFNCLCREATEIMAGE3D;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainMemObject"]
    pub static mut __clewRetainMemObject: PFNCLRETAINMEMOBJECT;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseMemObject"]
    pub static mut __clewReleaseMemObject: PFNCLRELEASEMEMOBJECT;
}
extern "C" {
    #[link_name = "\u{1}__clewGetSupportedImageFormats"]
    pub static mut __clewGetSupportedImageFormats: PFNCLGETSUPPORTEDIMAGEFORMATS;
}
extern "C" {
    #[link_name = "\u{1}__clewGetMemObjectInfo"]
    pub static mut __clewGetMemObjectInfo: PFNCLGETMEMOBJECTINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewGetImageInfo"]
    pub static mut __clewGetImageInfo: PFNCLGETIMAGEINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewSetMemObjectDestructorCallback"]
    pub static mut __clewSetMemObjectDestructorCallback: PFNCLSETMEMOBJECTDESTRUCTORCALLBACK;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateSampler"]
    pub static mut __clewCreateSampler: PFNCLCREATESAMPLER;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainSampler"]
    pub static mut __clewRetainSampler: PFNCLRETAINSAMPLER;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseSampler"]
    pub static mut __clewReleaseSampler: PFNCLRELEASESAMPLER;
}
extern "C" {
    #[link_name = "\u{1}__clewGetSamplerInfo"]
    pub static mut __clewGetSamplerInfo: PFNCLGETSAMPLERINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateProgramWithSource"]
    pub static mut __clewCreateProgramWithSource: PFNCLCREATEPROGRAMWITHSOURCE;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateProgramWithBinary"]
    pub static mut __clewCreateProgramWithBinary: PFNCLCREATEPROGRAMWITHBINARY;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainProgram"]
    pub static mut __clewRetainProgram: PFNCLRETAINPROGRAM;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseProgram"]
    pub static mut __clewReleaseProgram: PFNCLRELEASEPROGRAM;
}
extern "C" {
    #[link_name = "\u{1}__clewBuildProgram"]
    pub static mut __clewBuildProgram: PFNCLBUILDPROGRAM;
}
extern "C" {
    #[link_name = "\u{1}__clewUnloadCompiler"]
    pub static mut __clewUnloadCompiler: PFNCLUNLOADCOMPILER;
}
extern "C" {
    #[link_name = "\u{1}__clewGetProgramInfo"]
    pub static mut __clewGetProgramInfo: PFNCLGETPROGRAMINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewGetProgramBuildInfo"]
    pub static mut __clewGetProgramBuildInfo: PFNCLGETPROGRAMBUILDINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateKernel"]
    pub static mut __clewCreateKernel: PFNCLCREATEKERNEL;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateKernelsInProgram"]
    pub static mut __clewCreateKernelsInProgram: PFNCLCREATEKERNELSINPROGRAM;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainKernel"]
    pub static mut __clewRetainKernel: PFNCLRETAINKERNEL;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseKernel"]
    pub static mut __clewReleaseKernel: PFNCLRELEASEKERNEL;
}
extern "C" {
    #[link_name = "\u{1}__clewSetKernelArg"]
    pub static mut __clewSetKernelArg: PFNCLSETKERNELARG;
}
extern "C" {
    #[link_name = "\u{1}__clewGetKernelInfo"]
    pub static mut __clewGetKernelInfo: PFNCLGETKERNELINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewGetKernelWorkGroupInfo"]
    pub static mut __clewGetKernelWorkGroupInfo: PFNCLGETKERNELWORKGROUPINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewWaitForEvents"]
    pub static mut __clewWaitForEvents: PFNCLWAITFOREVENTS;
}
extern "C" {
    #[link_name = "\u{1}__clewGetEventInfo"]
    pub static mut __clewGetEventInfo: PFNCLGETEVENTINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewCreateUserEvent"]
    pub static mut __clewCreateUserEvent: PFNCLCREATEUSEREVENT;
}
extern "C" {
    #[link_name = "\u{1}__clewRetainEvent"]
    pub static mut __clewRetainEvent: PFNCLRETAINEVENT;
}
extern "C" {
    #[link_name = "\u{1}__clewReleaseEvent"]
    pub static mut __clewReleaseEvent: PFNCLRELEASEEVENT;
}
extern "C" {
    #[link_name = "\u{1}__clewSetUserEventStatus"]
    pub static mut __clewSetUserEventStatus: PFNCLSETUSEREVENTSTATUS;
}
extern "C" {
    #[link_name = "\u{1}__clewSetEventCallback"]
    pub static mut __clewSetEventCallback: PFNCLSETEVENTCALLBACK;
}
extern "C" {
    #[link_name = "\u{1}__clewGetEventProfilingInfo"]
    pub static mut __clewGetEventProfilingInfo: PFNCLGETEVENTPROFILINGINFO;
}
extern "C" {
    #[link_name = "\u{1}__clewFlush"]
    pub static mut __clewFlush: PFNCLFLUSH;
}
extern "C" {
    #[link_name = "\u{1}__clewFinish"]
    pub static mut __clewFinish: PFNCLFINISH;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueReadBuffer"]
    pub static mut __clewEnqueueReadBuffer: PFNCLENQUEUEREADBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueReadBufferRect"]
    pub static mut __clewEnqueueReadBufferRect: PFNCLENQUEUEREADBUFFERRECT;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueWriteBuffer"]
    pub static mut __clewEnqueueWriteBuffer: PFNCLENQUEUEWRITEBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueWriteBufferRect"]
    pub static mut __clewEnqueueWriteBufferRect: PFNCLENQUEUEWRITEBUFFERRECT;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueCopyBuffer"]
    pub static mut __clewEnqueueCopyBuffer: PFNCLENQUEUECOPYBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueCopyBufferRect"]
    pub static mut __clewEnqueueCopyBufferRect: PFNCLENQUEUECOPYBUFFERRECT;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueReadImage"]
    pub static mut __clewEnqueueReadImage: PFNCLENQUEUEREADIMAGE;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueWriteImage"]
    pub static mut __clewEnqueueWriteImage: PFNCLENQUEUEWRITEIMAGE;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueCopyImage"]
    pub static mut __clewEnqueueCopyImage: PFNCLENQUEUECOPYIMAGE;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueCopyImageToBuffer"]
    pub static mut __clewEnqueueCopyImageToBuffer: PFNCLENQUEUECOPYIMAGETOBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueCopyBufferToImage"]
    pub static mut __clewEnqueueCopyBufferToImage: PFNCLENQUEUECOPYBUFFERTOIMAGE;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueMapBuffer"]
    pub static mut __clewEnqueueMapBuffer: PFNCLENQUEUEMAPBUFFER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueMapImage"]
    pub static mut __clewEnqueueMapImage: PFNCLENQUEUEMAPIMAGE;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueUnmapMemObject"]
    pub static mut __clewEnqueueUnmapMemObject: PFNCLENQUEUEUNMAPMEMOBJECT;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueNDRangeKernel"]
    pub static mut __clewEnqueueNDRangeKernel: PFNCLENQUEUENDRANGEKERNEL;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueTask"]
    pub static mut __clewEnqueueTask: PFNCLENQUEUETASK;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueNativeKernel"]
    pub static mut __clewEnqueueNativeKernel: PFNCLENQUEUENATIVEKERNEL;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueMarker"]
    pub static mut __clewEnqueueMarker: PFNCLENQUEUEMARKER;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueWaitForEvents"]
    pub static mut __clewEnqueueWaitForEvents: PFNCLENQUEUEWAITFOREVENTS;
}
extern "C" {
    #[link_name = "\u{1}__clewEnqueueBarrier"]
    pub static mut __clewEnqueueBarrier: PFNCLENQUEUEBARRIER;
}
extern "C" {
    #[link_name = "\u{1}__clewGetExtensionFunctionAddress"]
    pub static mut __clewGetExtensionFunctionAddress: PFNCLGETEXTENSIONFUNCTIONADDRESS;
}
extern "C" {
    /// ! \brief Load OpenCL dynamic library and set function entry points
    pub fn clewInit(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ! \brief Exit clew and unload OpenCL dynamic library
    pub fn clewExit();
}
extern "C" {
    /// ! \brief Convert an OpenCL error code to its string equivalent
    pub fn clewErrorString(error: cl_int) -> *const ::std::os::raw::c_char;
}
/// just make sure that the b3Aabb is 16-byte aligned
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SapAabb {
    pub _base: b3Aabb,
}
#[repr(C)]
pub struct b3OpenCLArray__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3OpenCLArray {
    pub vtable_: *const b3OpenCLArray__bindgen_vtable,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_clBuffer: cl_mem,
    pub m_clContext: cl_context,
    pub m_commandQueue: cl_command_queue,
    pub m_ownsMemory: bool,
    pub m_allowGrowingCapacity: bool,
}
#[repr(C)]
pub struct b3GpuBroadphaseInterface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuBroadphaseInterface {
    pub vtable_: *const b3GpuBroadphaseInterface__bindgen_vtable,
}
pub type b3GpuBroadphaseInterface_CreateFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: cl_context, device: cl_device_id, q: cl_command_queue)
        -> *mut b3GpuBroadphaseInterface,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SortData {
    pub __bindgen_anon_1: b3SortData__bindgen_ty_1,
    pub __bindgen_anon_2: b3SortData__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SortData__bindgen_ty_1 {
    pub m_key: ::std::os::raw::c_uint,
    pub x: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3SortData__bindgen_ty_2 {
    pub m_value: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BufferInfoCL {
    pub m_clBuffer: cl_mem,
    pub m_isReadOnly: bool,
}
#[repr(C)]
pub struct b3RadixSort32CL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3RadixSort32CL {
    pub vtable_: *const b3RadixSort32CL__bindgen_vtable,
    pub m_workBuffer1: *mut b3OpenCLArray,
    pub m_workBuffer2: *mut b3OpenCLArray,
    pub m_workBuffer3: *mut b3OpenCLArray,
    pub m_workBuffer4: *mut b3OpenCLArray,
    pub m_workBuffer3a: *mut b3OpenCLArray,
    pub m_workBuffer4a: *mut b3OpenCLArray,
    pub m_commandQueue: cl_command_queue,
    pub m_streamCountSortDataKernel: cl_kernel,
    pub m_streamCountKernel: cl_kernel,
    pub m_prefixScanKernel: cl_kernel,
    pub m_sortAndScatterSortDataKernel: cl_kernel,
    pub m_sortAndScatterKernel: cl_kernel,
    pub m_deviceCPU: bool,
    pub m_scan: *mut b3PrefixScanCL,
    pub m_fill: *mut b3FillCL,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RadixSort32CL_b3ConstData {
    pub m_n: ::std::os::raw::c_int,
    pub m_nWGs: ::std::os::raw::c_int,
    pub m_startBit: ::std::os::raw::c_int,
    pub m_nBlocksPerWG: ::std::os::raw::c_int,
}
pub const b3RadixSort32CL_DATA_ALIGNMENT: b3RadixSort32CL__bindgen_ty_1 = 256;
pub const b3RadixSort32CL_WG_SIZE: b3RadixSort32CL__bindgen_ty_1 = 64;
pub const b3RadixSort32CL_BLOCK_SIZE: b3RadixSort32CL__bindgen_ty_1 = 256;
pub const b3RadixSort32CL_ELEMENTS_PER_WORK_ITEM: b3RadixSort32CL__bindgen_ty_1 = 4;
pub const b3RadixSort32CL_BITS_PER_PASS: b3RadixSort32CL__bindgen_ty_1 = 4;
pub const b3RadixSort32CL_NUM_BUCKET: b3RadixSort32CL__bindgen_ty_1 = 16;
pub const b3RadixSort32CL_NUM_WGS: b3RadixSort32CL__bindgen_ty_1 = 120;
pub type b3RadixSort32CL__bindgen_ty_1 = u32;
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CL7executeER13b3OpenCLArrayIjES2_S2_S2_ii"]
    pub fn b3RadixSort32CL_execute(
        this: *mut b3RadixSort32CL,
        keysIn: *mut b3OpenCLArray,
        keysOut: *mut b3OpenCLArray,
        valuesIn: *mut b3OpenCLArray,
        valuesOut: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// keys only
    #[link_name = "\u{1}_ZN15b3RadixSort32CL7executeER13b3OpenCLArrayIjEi"]
    pub fn b3RadixSort32CL_execute1(
        this: *mut b3RadixSort32CL,
        keysInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CL7executeER13b3OpenCLArrayI10b3SortDataEi"]
    pub fn b3RadixSort32CL_execute2(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CL11executeHostER13b3OpenCLArrayI10b3SortDataEi"]
    pub fn b3RadixSort32CL_executeHost(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CL11executeHostER20b3AlignedObjectArrayI10b3SortDataEi"]
    pub fn b3RadixSort32CL_executeHost1(
        this: *mut b3RadixSort32CL,
        keyValuesInOut: *mut b3AlignedObjectArray<b3SortData>,
        sortBits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CLC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3RadixSort32CL_b3RadixSort32CL(
        this: *mut b3RadixSort32CL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        initialCapacity: ::std::os::raw::c_int,
    );
}
impl b3RadixSort32CL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        keysIn: *mut b3OpenCLArray,
        keysOut: *mut b3OpenCLArray,
        valuesIn: *mut b3OpenCLArray,
        valuesOut: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute(self, keysIn, keysOut, valuesIn, valuesOut, n, sortBits)
    }
    #[inline]
    pub unsafe fn execute1(
        &mut self,
        keysInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute1(self, keysInOut, sortBits)
    }
    #[inline]
    pub unsafe fn execute2(
        &mut self,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_execute2(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        keyValuesInOut: *mut b3OpenCLArray,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_executeHost(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn executeHost1(
        &mut self,
        keyValuesInOut: *mut b3AlignedObjectArray<b3SortData>,
        sortBits: ::std::os::raw::c_int,
    ) {
        b3RadixSort32CL_executeHost1(self, keyValuesInOut, sortBits)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        initialCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3RadixSort32CL_b3RadixSort32CL(&mut __bindgen_tmp, ctx, device, queue, initialCapacity);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3RadixSort32CLD1Ev"]
    pub fn b3RadixSort32CL_b3RadixSort32CL_destructor(this: *mut b3RadixSort32CL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ParamsGridBroadphaseCL {
    pub m_invCellSize: [f32; 4usize],
    pub m_gridSize: [::std::os::raw::c_int; 4usize],
}
#[repr(C)]
pub struct b3GpuGridBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_allAabbsGPU1: b3OpenCLArray,
    pub m_allAabbsCPU1: b3AlignedObjectArray<b3SapAabb>,
    pub m_smallAabbsMappingGPU: b3OpenCLArray,
    pub m_smallAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingGPU: b3OpenCLArray,
    pub m_largeAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_hostPairs: b3AlignedObjectArray<b3Int4>,
    pub m_gpuPairs: b3OpenCLArray,
    pub m_hashGpu: b3OpenCLArray,
    pub m_cellStartGpu: b3OpenCLArray,
    pub m_paramsCPU: b3ParamsGridBroadphaseCL,
    pub m_paramsGPU: b3OpenCLArray,
    pub m_sorter: *mut b3RadixSort32CL,
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphaseC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue"]
    pub fn b3GpuGridBroadphase_b3GpuGridBroadphase(
        this: *mut b3GpuGridBroadphase,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
    );
}
impl b3GpuGridBroadphase {
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, q: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuGridBroadphase_b3GpuGridBroadphase(&mut __bindgen_tmp, ctx, device, q);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphaseD1Ev"]
    pub fn b3GpuGridBroadphase_b3GpuGridBroadphase_destructor(this: *mut b3GpuGridBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase11createProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuGridBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase16createLargeProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuGridBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase25calculateOverlappingPairsEi"]
    pub fn b3GpuGridBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase29calculateOverlappingPairsHostEi"]
    pub fn b3GpuGridBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase15writeAabbsToGpuEv"]
    pub fn b3GpuGridBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase15getAabbBufferWSEv"]
    pub fn b3GpuGridBroadphase_getAabbBufferWS(this: *mut ::std::os::raw::c_void) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase13getNumOverlapEv"]
    pub fn b3GpuGridBroadphase_getNumOverlap(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase24getOverlappingPairBufferEv"]
    pub fn b3GpuGridBroadphase_getOverlappingPairBuffer(
        this: *mut ::std::os::raw::c_void,
    ) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase14getAllAabbsGPUEv"]
    pub fn b3GpuGridBroadphase_getAllAabbsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase14getAllAabbsCPUEv"]
    pub fn b3GpuGridBroadphase_getAllAabbsCPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3AlignedObjectArray<b3SapAabb>;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase22getOverlappingPairsGPUEv"]
    pub fn b3GpuGridBroadphase_getOverlappingPairsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase22getSmallAabbIndicesGPUEv"]
    pub fn b3GpuGridBroadphase_getSmallAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN19b3GpuGridBroadphase22getLargeAabbIndicesGPUEv"]
    pub fn b3GpuGridBroadphase_getLargeAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
#[repr(C)]
pub struct b3FillCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3FillCL {
    pub vtable_: *const b3FillCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_fillKernelInt2: cl_kernel,
    pub m_fillIntKernel: cl_kernel,
    pub m_fillUnsignedIntKernel: cl_kernel,
    pub m_fillFloatKernel: cl_kernel,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3FillCL_b3ConstData {
    pub __bindgen_anon_1: b3FillCL_b3ConstData__bindgen_ty_1,
    pub m_offset: ::std::os::raw::c_int,
    pub m_n: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3FillCL_b3ConstData__bindgen_ty_1 {
    pub m_data: b3Int4,
    pub m_UnsignedData: b3UnsignedInt4,
    _bindgen_union_align: [u8; 16usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL7executeER13b3OpenCLArrayIjEjii"]
    pub fn b3FillCL_execute(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL7executeER13b3OpenCLArrayIiEiii"]
    pub fn b3FillCL_execute1(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL7executeER13b3OpenCLArrayIfEfii"]
    pub fn b3FillCL_execute2(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: f32,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL7executeER13b3OpenCLArrayI6b3Int2ERKS1_ii"]
    pub fn b3FillCL_execute3(
        this: *mut b3FillCL,
        src: *mut b3OpenCLArray,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL11executeHostER20b3AlignedObjectArrayI6b3Int2ERKS1_ii"]
    pub fn b3FillCL_executeHost(
        this: *mut b3FillCL,
        src: *mut b3AlignedObjectArray<b3Int2>,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCL11executeHostER20b3AlignedObjectArrayIiEiii"]
    pub fn b3FillCL_executeHost1(
        this: *mut b3FillCL,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCLC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue"]
    pub fn b3FillCL_b3FillCL(
        this: *mut b3FillCL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3FillCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute1(
        &mut self,
        src: *mut b3OpenCLArray,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute1(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute2(
        &mut self,
        src: *mut b3OpenCLArray,
        value: f32,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute2(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn execute3(
        &mut self,
        src: *mut b3OpenCLArray,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_execute3(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<b3Int2>,
        value: *const b3Int2,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_executeHost(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn executeHost1(
        &mut self,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        value: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        b3FillCL_executeHost1(self, src, value, n, offset)
    }
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3FillCL_b3FillCL(&mut __bindgen_tmp, ctx, device, queue);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3FillCLD1Ev"]
    pub fn b3FillCL_b3FillCL_destructor(this: *mut b3FillCL);
}
#[repr(C)]
pub struct b3PrefixScanCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3PrefixScanCL {
    pub vtable_: *const b3PrefixScanCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_localScanKernel: cl_kernel,
    pub m_blockSumKernel: cl_kernel,
    pub m_propagationKernel: cl_kernel,
    pub m_workBuffer: *mut b3OpenCLArray,
}
pub const b3PrefixScanCL_BLOCK_SIZE: b3PrefixScanCL__bindgen_ty_1 = 128;
pub type b3PrefixScanCL__bindgen_ty_1 = u32;
extern "C" {
    #[link_name = "\u{1}_ZN14b3PrefixScanCL7executeER13b3OpenCLArrayIjES2_iPj"]
    pub fn b3PrefixScanCL_execute(
        this: *mut b3PrefixScanCL,
        src: *mut b3OpenCLArray,
        dst: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3PrefixScanCL11executeHostER20b3AlignedObjectArrayIjES2_iPj"]
    pub fn b3PrefixScanCL_executeHost(
        this: *mut b3PrefixScanCL,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3PrefixScanCLC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3PrefixScanCL_b3PrefixScanCL(
        this: *mut b3PrefixScanCL,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    );
}
impl b3PrefixScanCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        dst: *mut b3OpenCLArray,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    ) {
        b3PrefixScanCL_execute(self, src, dst, n, sum)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        n: ::std::os::raw::c_int,
        sum: *mut ::std::os::raw::c_uint,
    ) {
        b3PrefixScanCL_executeHost(self, src, dst, n, sum)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3PrefixScanCL_b3PrefixScanCL(&mut __bindgen_tmp, ctx, device, queue, size);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3PrefixScanCLD1Ev"]
    pub fn b3PrefixScanCL_b3PrefixScanCL_destructor(this: *mut b3PrefixScanCL);
}
#[repr(C)]
pub struct b3GpuParallelLinearBvh__bindgen_vtable(::std::os::raw::c_void);
/// @brief GPU Parallel Linearized Bounding Volume Heirarchy(LBVH) that is reconstructed every frame
/// @remarks
/// See presentation in docs/b3GpuParallelLinearBvh.pdf for algorithm details.
/// @par
/// Related papers: \n
/// "Fast BVH Construction on GPUs" [Lauterbach et al. 2009] \n
/// "Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d trees" [Karras 2012] \n
/// @par
/// The basic algorithm for building the BVH as presented in [Lauterbach et al. 2009] consists of 4 stages:
/// - [fully parallel] Assign morton codes for each AABB using its center (after quantizing the AABB centers into a virtual grid)
/// - [fully parallel] Sort morton codes
/// - [somewhat parallel] Build binary radix tree (assign parent/child pointers for internal nodes of the BVH)
/// - [somewhat parallel] Set internal node AABBs
/// @par
/// [Karras 2012] improves on the algorithm by introducing fully parallel methods for the last 2 stages.
/// The BVH implementation here shares many concepts with [Karras 2012], but a different method is used for constructing the tree.
/// Instead of searching for the child nodes of each internal node, we search for the parent node of each node.
/// Additionally, a non-atomic traversal that starts from the leaf nodes and moves towards the root node is used to set the AABBs.
#[repr(C)]
pub struct b3GpuParallelLinearBvh {
    pub vtable_: *const b3GpuParallelLinearBvh__bindgen_vtable,
    pub m_queue: cl_command_queue,
    pub m_parallelLinearBvhProgram: cl_program,
    pub m_separateAabbsKernel: cl_kernel,
    pub m_findAllNodesMergedAabbKernel: cl_kernel,
    pub m_assignMortonCodesAndAabbIndiciesKernel: cl_kernel,
    pub m_computeAdjacentPairCommonPrefixKernel: cl_kernel,
    pub m_buildBinaryRadixTreeLeafNodesKernel: cl_kernel,
    pub m_buildBinaryRadixTreeInternalNodesKernel: cl_kernel,
    pub m_findDistanceFromRootKernel: cl_kernel,
    pub m_buildBinaryRadixTreeAabbsRecursiveKernel: cl_kernel,
    pub m_findLeafIndexRangesKernel: cl_kernel,
    pub m_plbvhCalculateOverlappingPairsKernel: cl_kernel,
    pub m_plbvhRayTraverseKernel: cl_kernel,
    pub m_plbvhLargeAabbAabbTestKernel: cl_kernel,
    pub m_plbvhLargeAabbRayTestKernel: cl_kernel,
    pub m_radixSorter: b3RadixSort32CL,
    pub m_rootNodeIndex: b3OpenCLArray,
    pub m_maxDistanceFromRoot: b3OpenCLArray,
    pub m_temp: b3OpenCLArray,
    pub m_internalNodeAabbs: b3OpenCLArray,
    pub m_internalNodeLeafIndexRanges: b3OpenCLArray,
    pub m_internalNodeChildNodes: b3OpenCLArray,
    pub m_internalNodeParentNodes: b3OpenCLArray,
    pub m_commonPrefixes: b3OpenCLArray,
    pub m_commonPrefixLengths: b3OpenCLArray,
    pub m_distanceFromRoot: b3OpenCLArray,
    pub m_leafNodeParentNodes: b3OpenCLArray,
    pub m_mortonCodesAndAabbIndicies: b3OpenCLArray,
    pub m_mergedAabb: b3OpenCLArray,
    pub m_leafNodeAabbs: b3OpenCLArray,
    pub m_largeAabbs: b3OpenCLArray,
}
extern "C" {
    /// Must be called before any other function
    #[link_name = "\u{1}_ZN22b3GpuParallelLinearBvh5buildERK13b3OpenCLArrayI9b3SapAabbERKS0_IiES7_"]
    pub fn b3GpuParallelLinearBvh_build(
        this: *mut b3GpuParallelLinearBvh,
        worldSpaceAabbs: *const b3OpenCLArray,
        smallAabbIndices: *const b3OpenCLArray,
        largeAabbIndices: *const b3OpenCLArray,
    );
}
extern "C" {
    /// calculateOverlappingPairs() uses the worldSpaceAabbs parameter of b3GpuParallelLinearBvh::build() as the query AABBs.
    /// ///@param out_overlappingPairs The size() of this array is used to determine the max number of pairs.
    /// ///If the number of overlapping pairs is < out_overlappingPairs.size(), out_overlappingPairs is resized.
    #[link_name = "\u{1}_ZN22b3GpuParallelLinearBvh25calculateOverlappingPairsER13b3OpenCLArrayI6b3Int4E"]
    pub fn b3GpuParallelLinearBvh_calculateOverlappingPairs(
        this: *mut b3GpuParallelLinearBvh,
        out_overlappingPairs: *mut b3OpenCLArray,
    );
}
extern "C" {
    /// @param out_numRigidRayPairs Array of length 1; contains the number of detected ray-rigid AABB intersections;
    /// ///this value may be greater than out_rayRigidPairs.size() if out_rayRigidPairs is not large enough.
    /// ///@param out_rayRigidPairs Contains an array of rays intersecting rigid AABBs; x == ray index, y == rigid body index.
    /// ///If the size of this array is insufficient to hold all ray-rigid AABB intersections, additional intersections are discarded.
    #[link_name = "\u{1}_ZN22b3GpuParallelLinearBvh23testRaysAgainstBvhAabbsERK13b3OpenCLArrayI9b3RayInfoERS0_IiERS0_I6b3Int2E"]
    pub fn b3GpuParallelLinearBvh_testRaysAgainstBvhAabbs(
        this: *mut b3GpuParallelLinearBvh,
        rays: *const b3OpenCLArray,
        out_numRayRigidPairs: *mut b3OpenCLArray,
        out_rayRigidPairs: *mut b3OpenCLArray,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuParallelLinearBvhC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue"]
    pub fn b3GpuParallelLinearBvh_b3GpuParallelLinearBvh(
        this: *mut b3GpuParallelLinearBvh,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3GpuParallelLinearBvh {
    #[inline]
    pub unsafe fn build(
        &mut self,
        worldSpaceAabbs: *const b3OpenCLArray,
        smallAabbIndices: *const b3OpenCLArray,
        largeAabbIndices: *const b3OpenCLArray,
    ) {
        b3GpuParallelLinearBvh_build(self, worldSpaceAabbs, smallAabbIndices, largeAabbIndices)
    }
    #[inline]
    pub unsafe fn calculateOverlappingPairs(&mut self, out_overlappingPairs: *mut b3OpenCLArray) {
        b3GpuParallelLinearBvh_calculateOverlappingPairs(self, out_overlappingPairs)
    }
    #[inline]
    pub unsafe fn testRaysAgainstBvhAabbs(
        &mut self,
        rays: *const b3OpenCLArray,
        out_numRayRigidPairs: *mut b3OpenCLArray,
        out_rayRigidPairs: *mut b3OpenCLArray,
    ) {
        b3GpuParallelLinearBvh_testRaysAgainstBvhAabbs(
            self,
            rays,
            out_numRayRigidPairs,
            out_rayRigidPairs,
        )
    }
    #[inline]
    pub unsafe fn new(context: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuParallelLinearBvh_b3GpuParallelLinearBvh(&mut __bindgen_tmp, context, device, queue);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuParallelLinearBvhD1Ev"]
    pub fn b3GpuParallelLinearBvh_b3GpuParallelLinearBvh_destructor(
        this: *mut b3GpuParallelLinearBvh,
    );
}
#[repr(C)]
pub struct b3GpuParallelLinearBvhBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_plbvh: b3GpuParallelLinearBvh,
    pub m_overlappingPairsGpu: b3OpenCLArray,
    pub m_aabbsGpu: b3OpenCLArray,
    pub m_smallAabbsMappingGpu: b3OpenCLArray,
    pub m_largeAabbsMappingGpu: b3OpenCLArray,
    pub m_aabbsCpu: b3AlignedObjectArray<b3SapAabb>,
    pub m_smallAabbsMappingCpu: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingCpu: b3AlignedObjectArray<::std::os::raw::c_int>,
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphaseC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue"]
    pub fn b3GpuParallelLinearBvhBroadphase_b3GpuParallelLinearBvhBroadphase(
        this: *mut b3GpuParallelLinearBvhBroadphase,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
    );
}
impl b3GpuParallelLinearBvhBroadphase {
    #[inline]
    pub unsafe fn new(context: cl_context, device: cl_device_id, queue: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuParallelLinearBvhBroadphase_b3GpuParallelLinearBvhBroadphase(
            &mut __bindgen_tmp,
            context,
            device,
            queue,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphase11createProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuParallelLinearBvhBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphase16createLargeProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuParallelLinearBvhBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphase25calculateOverlappingPairsEi"]
    pub fn b3GpuParallelLinearBvhBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphase29calculateOverlappingPairsHostEi"]
    pub fn b3GpuParallelLinearBvhBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32b3GpuParallelLinearBvhBroadphase15writeAabbsToGpuEv"]
    pub fn b3GpuParallelLinearBvhBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct b3GpuSapBroadphase {
    pub _base: b3GpuBroadphaseInterface,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_flipFloatKernel: cl_kernel,
    pub m_scatterKernel: cl_kernel,
    pub m_copyAabbsKernel: cl_kernel,
    pub m_sapKernel: cl_kernel,
    pub m_sap2Kernel: cl_kernel,
    pub m_prepareSumVarianceKernel: cl_kernel,
    pub m_sorter: *mut b3RadixSort32CL,
    /// test for 3d SAP
    pub m_sortedAxisCPU: [[b3AlignedObjectArray<b3SortData>; 2usize]; 3usize],
    pub m_objectMinMaxIndexCPU: [[b3AlignedObjectArray<b3UnsignedInt2>; 2usize]; 3usize],
    pub m_objectMinMaxIndexGPUaxis0: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis1: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis2: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis0prev: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis1prev: b3OpenCLArray,
    pub m_objectMinMaxIndexGPUaxis2prev: b3OpenCLArray,
    pub m_sortedAxisGPU0: b3OpenCLArray,
    pub m_sortedAxisGPU1: b3OpenCLArray,
    pub m_sortedAxisGPU2: b3OpenCLArray,
    pub m_sortedAxisGPU0prev: b3OpenCLArray,
    pub m_sortedAxisGPU1prev: b3OpenCLArray,
    pub m_sortedAxisGPU2prev: b3OpenCLArray,
    pub m_addedHostPairsGPU: b3OpenCLArray,
    pub m_removedHostPairsGPU: b3OpenCLArray,
    pub m_addedCountGPU: b3OpenCLArray,
    pub m_removedCountGPU: b3OpenCLArray,
    pub m_currentBuffer: ::std::os::raw::c_int,
    pub m_pairCount: b3OpenCLArray,
    pub m_allAabbsGPU: b3OpenCLArray,
    pub m_allAabbsCPU: b3AlignedObjectArray<b3SapAabb>,
    pub m_sum: b3OpenCLArray,
    pub m_sum2: b3OpenCLArray,
    pub m_dst: b3OpenCLArray,
    pub m_smallAabbsMappingGPU: b3OpenCLArray,
    pub m_smallAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_largeAabbsMappingGPU: b3OpenCLArray,
    pub m_largeAabbsMappingCPU: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_overlappingPairs: b3OpenCLArray,
    pub m_gpuSmallSortData: b3OpenCLArray,
    pub m_gpuSmallSortedAabbs: b3OpenCLArray,
    pub m_prefixScanFloat4: *mut b3PrefixScanFloat4CL,
}
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BRUTE_FORCE_CPU:
    b3GpuSapBroadphase_b3GpuSapKernelType = 1;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BRUTE_FORCE_GPU:
    b3GpuSapBroadphase_b3GpuSapKernelType = 2;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_ORIGINAL:
    b3GpuSapBroadphase_b3GpuSapKernelType = 3;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_BARRIER:
    b3GpuSapBroadphase_b3GpuSapKernelType = 4;
pub const b3GpuSapBroadphase_b3GpuSapKernelType_B3_GPU_SAP_KERNEL_LOCAL_SHARED_MEMORY:
    b3GpuSapBroadphase_b3GpuSapKernelType = 5;
pub type b3GpuSapBroadphase_b3GpuSapKernelType = u32;
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase5resetEv"]
    pub fn b3GpuSapBroadphase_reset(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase9init3dSapEv"]
    pub fn b3GpuSapBroadphase_init3dSap(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphaseC1EP11_cl_contextP13_cl_device_idP17_cl_command_queueNS_18b3GpuSapKernelTypeE"]
    pub fn b3GpuSapBroadphase_b3GpuSapBroadphase(
        this: *mut b3GpuSapBroadphase,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        kernelType: b3GpuSapBroadphase_b3GpuSapKernelType,
    );
}
impl b3GpuSapBroadphase {
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuSapBroadphase_reset(self)
    }
    #[inline]
    pub unsafe fn init3dSap(&mut self) {
        b3GpuSapBroadphase_init3dSap(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        kernelType: b3GpuSapBroadphase_b3GpuSapKernelType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuSapBroadphase_b3GpuSapBroadphase(&mut __bindgen_tmp, ctx, device, q, kernelType);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphaseD1Ev"]
    pub fn b3GpuSapBroadphase_b3GpuSapBroadphase_destructor(this: *mut b3GpuSapBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase25calculateOverlappingPairsEi"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase29calculateOverlappingPairsHostEi"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairsHost(
        this: *mut ::std::os::raw::c_void,
        maxPairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase44calculateOverlappingPairsHostIncremental3SapEv"]
    pub fn b3GpuSapBroadphase_calculateOverlappingPairsHostIncremental3Sap(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase11createProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuSapBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase16createLargeProxyERK9b3Vector3S2_iii"]
    pub fn b3GpuSapBroadphase_createLargeProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const b3Vector3,
        aabbMax: *const b3Vector3,
        userPtr: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase15writeAabbsToGpuEv"]
    pub fn b3GpuSapBroadphase_writeAabbsToGpu(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase15getAabbBufferWSEv"]
    pub fn b3GpuSapBroadphase_getAabbBufferWS(this: *mut ::std::os::raw::c_void) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase13getNumOverlapEv"]
    pub fn b3GpuSapBroadphase_getNumOverlap(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase24getOverlappingPairBufferEv"]
    pub fn b3GpuSapBroadphase_getOverlappingPairBuffer(this: *mut ::std::os::raw::c_void)
        -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase22getOverlappingPairsGPUEv"]
    pub fn b3GpuSapBroadphase_getOverlappingPairsGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase22getSmallAabbIndicesGPUEv"]
    pub fn b3GpuSapBroadphase_getSmallAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN18b3GpuSapBroadphase22getLargeAabbIndicesGPUEv"]
    pub fn b3GpuSapBroadphase_getLargeAabbIndicesGPU(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut b3OpenCLArray;
}
/// b3ContactCache is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
/// Those contact points are created by the collision narrow phase.
/// The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
/// updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
/// reduces the cache to 4 points, when more then 4 points are added, using following rules:
/// the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
/// note that some pairs of objects might have more then one contact manifold.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactCache {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3ContactCache16addManifoldPointERK9b3Vector3"]
    pub fn b3ContactCache_addManifoldPoint(
        this: *mut b3ContactCache,
        newPoint: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3ContactCache20validContactDistanceERK9b3Vector3"]
    pub fn b3ContactCache_validContactDistance(pt: *const b3Vector3) -> bool;
}
extern "C" {
    /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
    #[link_name = "\u{1}_ZN14b3ContactCache20refreshContactPointsERK11b3TransformS2_R14b3Contact4Data"]
    pub fn b3ContactCache_refreshContactPoints(
        trA: *const b3Transform,
        trB: *const b3Transform,
        newContactCache: *mut b3Contact4Data,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14b3ContactCache18removeContactPointER14b3Contact4Datai"]
    pub fn b3ContactCache_removeContactPoint(
        newContactCache: *mut b3Contact4Data,
        i: ::std::os::raw::c_int,
    );
}
impl b3ContactCache {
    #[inline]
    pub unsafe fn addManifoldPoint(&mut self, newPoint: *const b3Vector3) -> ::std::os::raw::c_int {
        b3ContactCache_addManifoldPoint(self, newPoint)
    }
    #[inline]
    pub unsafe fn validContactDistance(pt: *const b3Vector3) -> bool {
        b3ContactCache_validContactDistance(pt)
    }
    #[inline]
    pub unsafe fn refreshContactPoints(
        trA: *const b3Transform,
        trB: *const b3Transform,
        newContactCache: *mut b3Contact4Data,
    ) {
        b3ContactCache_refreshContactPoints(trA, trB, newContactCache)
    }
    #[inline]
    pub unsafe fn removeContactPoint(
        newContactCache: *mut b3Contact4Data,
        i: ::std::os::raw::c_int,
    ) {
        b3ContactCache_removeContactPoint(newContactCache, i)
    }
}
/// btGjkEpaSolver contributed under zlib by Nathanael Presson
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GjkEpaSolver2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GjkEpaSolver2_sResults {
    pub status: b3GjkEpaSolver2_sResults_eStatus,
    pub __bindgen_padding_0: u64,
    pub witnesses: [b3Vector3; 2usize],
    pub normal: b3Vector3,
    pub distance: b3Scalar,
    pub __bindgen_padding_1: [u32; 3usize],
}
pub const b3GjkEpaSolver2_sResults_eStatus_Separated: b3GjkEpaSolver2_sResults_eStatus = 0;
pub const b3GjkEpaSolver2_sResults_eStatus_Penetrating: b3GjkEpaSolver2_sResults_eStatus = 1;
pub const b3GjkEpaSolver2_sResults_eStatus_GJK_Failed: b3GjkEpaSolver2_sResults_eStatus = 2;
pub const b3GjkEpaSolver2_sResults_eStatus_EPA_Failed: b3GjkEpaSolver2_sResults_eStatus = 3;
pub type b3GjkEpaSolver2_sResults_eStatus = u32;
extern "C" {
    #[link_name = "\u{1}_ZN15b3GjkEpaSolver220StackSizeRequirementEv"]
    pub fn b3GjkEpaSolver2_StackSizeRequirement() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3GjkEpaSolver28DistanceERK11b3TransformS2_PK22b3ConvexPolyhedronDataS5_RK20b3AlignedObjectArrayI9b3Vector3ESA_RKS7_RNS_8sResultsE"]
    pub fn b3GjkEpaSolver2_Distance(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3GjkEpaSolver211PenetrationERK11b3TransformS2_PK22b3ConvexPolyhedronDataS5_RK20b3AlignedObjectArrayI9b3Vector3ESA_RKS7_RNS_8sResultsEb"]
    pub fn b3GjkEpaSolver2_Penetration(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool;
}
impl b3GjkEpaSolver2 {
    #[inline]
    pub unsafe fn StackSizeRequirement() -> ::std::os::raw::c_int {
        b3GjkEpaSolver2_StackSizeRequirement()
    }
    #[inline]
    pub unsafe fn Distance(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
    ) -> bool {
        b3GjkEpaSolver2_Distance(
            transA, transB, hullA, hullB, verticesA, verticesB, guess, results,
        )
    }
    #[inline]
    pub unsafe fn Penetration(
        transA: *const b3Transform,
        transB: *const b3Transform,
        hullA: *const b3ConvexPolyhedronData,
        hullB: *const b3ConvexPolyhedronData,
        verticesA: *const b3AlignedObjectArray<b3Vector3>,
        verticesB: *const b3AlignedObjectArray<b3Vector3>,
        guess: *const b3Vector3,
        results: *mut b3GjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool {
        b3GjkEpaSolver2_Penetration(
            transA, transB, hullA, hullB, verticesA, verticesB, guess, results, usemargins,
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GjkPairDetector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UsageBitfield {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
    pub __bindgen_align: [u16; 0usize],
}
impl b3UsageBitfield {
    #[inline]
    pub fn usedVertexA(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexA(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexB(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexB(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexC(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexC(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexD(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexD(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused4(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused4(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usedVertexA: ::std::os::raw::c_ushort,
        usedVertexB: ::std::os::raw::c_ushort,
        usedVertexC: ::std::os::raw::c_ushort,
        usedVertexD: ::std::os::raw::c_ushort,
        unused1: ::std::os::raw::c_ushort,
        unused2: ::std::os::raw::c_ushort,
        unused3: ::std::os::raw::c_ushort,
        unused4: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let usedVertexA: u16 = unsafe { ::std::mem::transmute(usedVertexA) };
            usedVertexA as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usedVertexB: u16 = unsafe { ::std::mem::transmute(usedVertexB) };
            usedVertexB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usedVertexC: u16 = unsafe { ::std::mem::transmute(usedVertexC) };
            usedVertexC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let usedVertexD: u16 = unsafe { ::std::mem::transmute(usedVertexD) };
            usedVertexD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unused1: u16 = unsafe { ::std::mem::transmute(unused1) };
            unused1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unused2: u16 = unsafe { ::std::mem::transmute(unused2) };
            unused2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let unused3: u16 = unsafe { ::std::mem::transmute(unused3) };
            unused3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let unused4: u16 = unsafe { ::std::mem::transmute(unused4) };
            unused4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3SubSimplexClosestResult {
    pub m_closestPointOnSimplex: b3Vector3,
    pub m_usedVertices: b3UsageBitfield,
    pub m_barycentricCoords: [b3Scalar; 4usize],
    pub m_degenerate: bool,
    pub __bindgen_padding_0: [u8; 11usize],
}
/// b3VoronoiSimplexSolver is an implementation of the closest point distance algorithm from a 1-4 points simplex to the origin.
/// Can be used with GJK, as an alternative to Johnson distance algorithm.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3VoronoiSimplexSolver {
    pub m_numVertices: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_simplexVectorW: [b3Vector3; 5usize],
    pub m_simplexPointsP: [b3Vector3; 5usize],
    pub m_simplexPointsQ: [b3Vector3; 5usize],
    pub m_cachedP1: b3Vector3,
    pub m_cachedP2: b3Vector3,
    pub m_cachedV: b3Vector3,
    pub m_lastW: b3Vector3,
    pub m_equalVertexThreshold: b3Scalar,
    pub m_cachedValidClosest: bool,
    pub __bindgen_padding_1: u64,
    pub m_cachedBC: b3SubSimplexClosestResult,
    pub m_needsUpdate: bool,
    pub __bindgen_padding_2: [u8; 15usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver12removeVertexEi"]
    pub fn b3VoronoiSimplexSolver_removeVertex(
        this: *mut b3VoronoiSimplexSolver,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver14reduceVerticesERK15b3UsageBitfield"]
    pub fn b3VoronoiSimplexSolver_reduceVertices(
        this: *mut b3VoronoiSimplexSolver,
        usedVerts: *const b3UsageBitfield,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver28updateClosestVectorAndPointsEv"]
    pub fn b3VoronoiSimplexSolver_updateClosestVectorAndPoints(
        this: *mut b3VoronoiSimplexSolver,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver25closestPtPointTetrahedronERK9b3Vector3S2_S2_S2_S2_R25b3SubSimplexClosestResult"]
    pub fn b3VoronoiSimplexSolver_closestPtPointTetrahedron(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
        finalResult: *mut b3SubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver19pointOutsideOfPlaneERK9b3Vector3S2_S2_S2_S2_"]
    pub fn b3VoronoiSimplexSolver_pointOutsideOfPlane(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver22closestPtPointTriangleERK9b3Vector3S2_S2_S2_R25b3SubSimplexClosestResult"]
    pub fn b3VoronoiSimplexSolver_closestPtPointTriangle(
        this: *mut b3VoronoiSimplexSolver,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        result: *mut b3SubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver5resetEv"]
    pub fn b3VoronoiSimplexSolver_reset(this: *mut b3VoronoiSimplexSolver);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver9addVertexERK9b3Vector3S2_S2_"]
    pub fn b3VoronoiSimplexSolver_addVertex(
        this: *mut b3VoronoiSimplexSolver,
        w: *const b3Vector3,
        p: *const b3Vector3,
        q: *const b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver7closestER9b3Vector3"]
    pub fn b3VoronoiSimplexSolver_closest(
        this: *mut b3VoronoiSimplexSolver,
        v: *mut b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver9maxVertexEv"]
    pub fn b3VoronoiSimplexSolver_maxVertex(this: *mut b3VoronoiSimplexSolver) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3VoronoiSimplexSolver10getSimplexEP9b3Vector3S1_S1_"]
    pub fn b3VoronoiSimplexSolver_getSimplex(
        this: *const b3VoronoiSimplexSolver,
        pBuf: *mut b3Vector3,
        qBuf: *mut b3Vector3,
        yBuf: *mut b3Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver9inSimplexERK9b3Vector3"]
    pub fn b3VoronoiSimplexSolver_inSimplex(
        this: *mut b3VoronoiSimplexSolver,
        w: *const b3Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver14backup_closestER9b3Vector3"]
    pub fn b3VoronoiSimplexSolver_backup_closest(
        this: *mut b3VoronoiSimplexSolver,
        v: *mut b3Vector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3VoronoiSimplexSolver12emptySimplexEv"]
    pub fn b3VoronoiSimplexSolver_emptySimplex(this: *const b3VoronoiSimplexSolver) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3VoronoiSimplexSolver14compute_pointsER9b3Vector3S1_"]
    pub fn b3VoronoiSimplexSolver_compute_points(
        this: *mut b3VoronoiSimplexSolver,
        p1: *mut b3Vector3,
        p2: *mut b3Vector3,
    );
}
impl b3VoronoiSimplexSolver {
    #[inline]
    pub unsafe fn removeVertex(&mut self, index: ::std::os::raw::c_int) {
        b3VoronoiSimplexSolver_removeVertex(self, index)
    }
    #[inline]
    pub unsafe fn reduceVertices(&mut self, usedVerts: *const b3UsageBitfield) {
        b3VoronoiSimplexSolver_reduceVertices(self, usedVerts)
    }
    #[inline]
    pub unsafe fn updateClosestVectorAndPoints(&mut self) -> bool {
        b3VoronoiSimplexSolver_updateClosestVectorAndPoints(self)
    }
    #[inline]
    pub unsafe fn closestPtPointTetrahedron(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
        finalResult: *mut b3SubSimplexClosestResult,
    ) -> bool {
        b3VoronoiSimplexSolver_closestPtPointTetrahedron(self, p, a, b, c, d, finalResult)
    }
    #[inline]
    pub unsafe fn pointOutsideOfPlane(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        d: *const b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3VoronoiSimplexSolver_pointOutsideOfPlane(self, p, a, b, c, d)
    }
    #[inline]
    pub unsafe fn closestPtPointTriangle(
        &mut self,
        p: *const b3Vector3,
        a: *const b3Vector3,
        b: *const b3Vector3,
        c: *const b3Vector3,
        result: *mut b3SubSimplexClosestResult,
    ) -> bool {
        b3VoronoiSimplexSolver_closestPtPointTriangle(self, p, a, b, c, result)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3VoronoiSimplexSolver_reset(self)
    }
    #[inline]
    pub unsafe fn addVertex(
        &mut self,
        w: *const b3Vector3,
        p: *const b3Vector3,
        q: *const b3Vector3,
    ) {
        b3VoronoiSimplexSolver_addVertex(self, w, p, q)
    }
    #[inline]
    pub unsafe fn closest(&mut self, v: *mut b3Vector3) -> bool {
        b3VoronoiSimplexSolver_closest(self, v)
    }
    #[inline]
    pub unsafe fn maxVertex(&mut self) -> b3Scalar {
        b3VoronoiSimplexSolver_maxVertex(self)
    }
    #[inline]
    pub unsafe fn getSimplex(
        &self,
        pBuf: *mut b3Vector3,
        qBuf: *mut b3Vector3,
        yBuf: *mut b3Vector3,
    ) -> ::std::os::raw::c_int {
        b3VoronoiSimplexSolver_getSimplex(self, pBuf, qBuf, yBuf)
    }
    #[inline]
    pub unsafe fn inSimplex(&mut self, w: *const b3Vector3) -> bool {
        b3VoronoiSimplexSolver_inSimplex(self, w)
    }
    #[inline]
    pub unsafe fn backup_closest(&mut self, v: *mut b3Vector3) {
        b3VoronoiSimplexSolver_backup_closest(self, v)
    }
    #[inline]
    pub unsafe fn emptySimplex(&self) -> bool {
        b3VoronoiSimplexSolver_emptySimplex(self)
    }
    #[inline]
    pub unsafe fn compute_points(&mut self, p1: *mut b3Vector3, p2: *mut b3Vector3) {
        b3VoronoiSimplexSolver_compute_points(self, p1, p2)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3KernelArgData {
    pub m_isBuffer: ::std::os::raw::c_int,
    pub m_argIndex: ::std::os::raw::c_int,
    pub m_argSizeInBytes: ::std::os::raw::c_int,
    pub m_unusedPadding: ::std::os::raw::c_int,
    pub __bindgen_anon_1: b3KernelArgData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3KernelArgData__bindgen_ty_1 {
    pub m_clBuffer: cl_mem,
    pub m_argData: [::std::os::raw::c_uchar; 16usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
pub struct b3LauncherCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3LauncherCL {
    pub vtable_: *const b3LauncherCL__bindgen_vtable,
    pub m_commandQueue: cl_command_queue,
    pub m_kernel: cl_kernel,
    pub m_idx: ::std::os::raw::c_int,
    pub m_kernelArguments: b3AlignedObjectArray<b3KernelArgData>,
    pub m_serializationSizeInBytes: ::std::os::raw::c_int,
    pub m_enableSerialization: bool,
    pub m_name: *const ::std::os::raw::c_char,
    pub m_arrays: b3AlignedObjectArray<*mut b3OpenCLArray>,
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCL9setBufferEP7_cl_mem"]
    pub fn b3LauncherCL_setBuffer(this: *mut b3LauncherCL, clBuffer: cl_mem);
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi"]
    pub fn b3LauncherCL_setBuffers(
        this: *mut b3LauncherCL,
        buffInfo: *mut b3BufferInfoCL,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCL15deserializeArgsEPhiP11_cl_context"]
    pub fn b3LauncherCL_deserializeArgs(
        this: *mut b3LauncherCL,
        buf: *mut ::std::os::raw::c_uchar,
        bufSize: ::std::os::raw::c_int,
        ctx: cl_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCL18serializeArgumentsEPhi"]
    pub fn b3LauncherCL_serializeArguments(
        this: *mut b3LauncherCL,
        destBuffer: *mut ::std::os::raw::c_uchar,
        destBufferCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCL15serializeToFileEPKci"]
    pub fn b3LauncherCL_serializeToFile(
        this: *mut b3LauncherCL,
        fileName: *const ::std::os::raw::c_char,
        numWorkItems: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc"]
    pub fn b3LauncherCL_b3LauncherCL(
        this: *mut b3LauncherCL,
        queue: cl_command_queue,
        kernel: cl_kernel,
        name: *const ::std::os::raw::c_char,
    );
}
impl b3LauncherCL {
    #[inline]
    pub unsafe fn setBuffer(&mut self, clBuffer: cl_mem) {
        b3LauncherCL_setBuffer(self, clBuffer)
    }
    #[inline]
    pub unsafe fn setBuffers(&mut self, buffInfo: *mut b3BufferInfoCL, n: ::std::os::raw::c_int) {
        b3LauncherCL_setBuffers(self, buffInfo, n)
    }
    #[inline]
    pub unsafe fn deserializeArgs(
        &mut self,
        buf: *mut ::std::os::raw::c_uchar,
        bufSize: ::std::os::raw::c_int,
        ctx: cl_context,
    ) -> ::std::os::raw::c_int {
        b3LauncherCL_deserializeArgs(self, buf, bufSize, ctx)
    }
    #[inline]
    pub unsafe fn serializeArguments(
        &mut self,
        destBuffer: *mut ::std::os::raw::c_uchar,
        destBufferCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3LauncherCL_serializeArguments(self, destBuffer, destBufferCapacity)
    }
    #[inline]
    pub unsafe fn serializeToFile(
        &mut self,
        fileName: *const ::std::os::raw::c_char,
        numWorkItems: ::std::os::raw::c_int,
    ) {
        b3LauncherCL_serializeToFile(self, fileName, numWorkItems)
    }
    #[inline]
    pub unsafe fn new(
        queue: cl_command_queue,
        kernel: cl_kernel,
        name: *const ::std::os::raw::c_char,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3LauncherCL_b3LauncherCL(&mut __bindgen_tmp, queue, kernel, name);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3LauncherCLD1Ev"]
    pub fn b3LauncherCL_b3LauncherCL_destructor(this: *mut b3LauncherCL);
}
#[repr(C)]
pub struct b3GpuRaycast__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuRaycast {
    pub vtable_: *const b3GpuRaycast__bindgen_vtable,
    pub m_data: *mut b3GpuRaycastInternalData,
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3GpuRaycast12castRaysHostERK20b3AlignedObjectArrayI9b3RayInfoERS0_I8b3RayHitEiPK15b3RigidBodyDataiPK12b3CollidablePK28b3GpuNarrowPhaseInternalData"]
    pub fn b3GpuRaycast_castRaysHost(
        this: *mut b3GpuRaycast,
        raysIn: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *mut b3GpuNarrowPhaseInternalData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3GpuRaycast8castRaysERK20b3AlignedObjectArrayI9b3RayInfoERS0_I8b3RayHitEiPK15b3RigidBodyDataiPK12b3CollidablePK28b3GpuNarrowPhaseInternalDataP24b3GpuBroadphaseInterface"]
    pub fn b3GpuRaycast_castRays(
        this: *mut b3GpuRaycast,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *const b3GpuNarrowPhaseInternalData,
        broadphase: *mut b3GpuBroadphaseInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3GpuRaycastC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue"]
    pub fn b3GpuRaycast_b3GpuRaycast(
        this: *mut b3GpuRaycast,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
    );
}
impl b3GpuRaycast {
    #[inline]
    pub unsafe fn castRaysHost(
        &mut self,
        raysIn: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *mut b3GpuNarrowPhaseInternalData,
    ) {
        b3GpuRaycast_castRaysHost(
            self,
            raysIn,
            hitResults,
            numBodies,
            bodies,
            numCollidables,
            collidables,
            narrowphaseData,
        )
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
        numBodies: ::std::os::raw::c_int,
        bodies: *const b3RigidBodyData,
        numCollidables: ::std::os::raw::c_int,
        collidables: *const b3Collidable,
        narrowphaseData: *const b3GpuNarrowPhaseInternalData,
        broadphase: *mut b3GpuBroadphaseInterface,
    ) {
        b3GpuRaycast_castRays(
            self,
            rays,
            hitResults,
            numBodies,
            bodies,
            numCollidables,
            collidables,
            narrowphaseData,
            broadphase,
        )
    }
    #[inline]
    pub unsafe fn new(ctx: cl_context, device: cl_device_id, q: cl_command_queue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuRaycast_b3GpuRaycast(&mut __bindgen_tmp, ctx, device, q);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12b3GpuRaycastD1Ev"]
    pub fn b3GpuRaycast_b3GpuRaycast_destructor(this: *mut b3GpuRaycast);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3JacobiSolverInfo {
    pub m_fixedBodyIndex: ::std::os::raw::c_int,
    pub m_deltaTime: f32,
    pub m_positionDrift: f32,
    pub m_positionConstraintCoeff: f32,
    pub m_numIterations: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3GpuJacobiContactSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuJacobiContactSolver {
    pub vtable_: *const b3GpuJacobiContactSolver__bindgen_vtable,
    pub m_data: *mut b3GpuJacobiSolverInternalData,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuJacobiContactSolver13solveContactsEiP7_cl_memS1_iS1_RK8b3Configi"]
    pub fn b3GpuJacobiContactSolver_solveContacts(
        this: *mut b3GpuJacobiContactSolver,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuJacobiContactSolver14solveGroupHostEP15b3RigidBodyDataP13b3InertiaDataiP10b3Contact4iRK18b3JacobiSolverInfo"]
    pub fn b3GpuJacobiContactSolver_solveGroupHost(
        this: *mut b3GpuJacobiContactSolver,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        solverInfo: *const b3JacobiSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuJacobiContactSolverC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3GpuJacobiContactSolver_b3GpuJacobiContactSolver(
        this: *mut b3GpuJacobiContactSolver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3GpuJacobiContactSolver {
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    ) {
        b3GpuJacobiContactSolver_solveContacts(
            self,
            numBodies,
            bodyBuf,
            inertiaBuf,
            numContacts,
            contactBuf,
            config,
            static0Index,
        )
    }
    #[inline]
    pub unsafe fn solveGroupHost(
        &mut self,
        bodies: *mut b3RigidBodyData,
        inertias: *mut b3InertiaData,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut b3Contact4,
        numManifolds: ::std::os::raw::c_int,
        solverInfo: *const b3JacobiSolverInfo,
    ) {
        b3GpuJacobiContactSolver_solveGroupHost(
            self,
            bodies,
            inertias,
            numBodies,
            manifoldPtr,
            numManifolds,
            solverInfo,
        )
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuJacobiContactSolver_b3GpuJacobiContactSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            queue,
            pairCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuJacobiContactSolverD1Ev"]
    pub fn b3GpuJacobiContactSolver_b3GpuJacobiContactSolver_destructor(
        this: *mut b3GpuJacobiContactSolver,
    );
}
#[repr(C)]
pub struct b3GpuNarrowPhase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuNarrowPhase {
    pub vtable_: *const b3GpuNarrowPhase__bindgen_vtable,
    pub m_data: *mut b3GpuNarrowPhaseInternalData,
    pub m_acceleratedCompanionShapeIndex: ::std::os::raw::c_int,
    pub m_planeBodyIndex: ::std::os::raw::c_int,
    pub m_static0Index: ::std::os::raw::c_int,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase31registerConvexHullShapeInternalEP15b3ConvexUtilityR12b3Collidable"]
    pub fn b3GpuNarrowPhase_registerConvexHullShapeInternal(
        this: *mut b3GpuNarrowPhase,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase24registerConcaveMeshShapeEP20b3AlignedObjectArrayI9b3Vector3EPS0_IiER12b3CollidablePKf"]
    pub fn b3GpuNarrowPhase_registerConcaveMeshShape(
        this: *mut b3GpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase19registerSphereShapeEf"]
    pub fn b3GpuNarrowPhase_registerSphereShape(
        this: *mut b3GpuNarrowPhase,
        radius: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase18registerPlaneShapeERK9b3Vector3f"]
    pub fn b3GpuNarrowPhase_registerPlaneShape(
        this: *mut b3GpuNarrowPhase,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase21registerCompoundShapeEP20b3AlignedObjectArrayI15b3GpuChildShapeE"]
    pub fn b3GpuNarrowPhase_registerCompoundShape(
        this: *mut b3GpuNarrowPhase,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase12registerFaceERK9b3Vector3f"]
    pub fn b3GpuNarrowPhase_registerFace(
        this: *mut b3GpuNarrowPhase,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase19registerConcaveMeshEP20b3AlignedObjectArrayI9b3Vector3EPS0_IiEPKf"]
    pub fn b3GpuNarrowPhase_registerConcaveMesh(
        this: *mut b3GpuNarrowPhase,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase23registerConvexHullShapeEP15b3ConvexUtility"]
    pub fn b3GpuNarrowPhase_registerConvexHullShape(
        this: *mut b3GpuNarrowPhase,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase23registerConvexHullShapeEPKfiiS1_"]
    pub fn b3GpuNarrowPhase_registerConvexHullShape1(
        this: *mut b3GpuNarrowPhase,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase17registerRigidBodyEifPKfS1_S1_S1_b"]
    pub fn b3GpuNarrowPhase_registerRigidBody(
        this: *mut b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        aabbMin: *const f32,
        aabbMax: *const f32,
        writeToGpu: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase18setObjectTransformEPKfS1_i"]
    pub fn b3GpuNarrowPhase_setObjectTransform(
        this: *mut b3GpuNarrowPhase,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase19writeAllBodiesToGpuEv"]
    pub fn b3GpuNarrowPhase_writeAllBodiesToGpu(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase5resetEv"]
    pub fn b3GpuNarrowPhase_reset(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase22readbackAllBodiesToCpuEv"]
    pub fn b3GpuNarrowPhase_readbackAllBodiesToCpu(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase25getObjectTransformFromCpuEPfS0_i"]
    pub fn b3GpuNarrowPhase_getObjectTransformFromCpu(
        this: *const b3GpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase21setObjectTransformCpuEPfS0_i"]
    pub fn b3GpuNarrowPhase_setObjectTransformCpu(
        this: *mut b3GpuNarrowPhase,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase20setObjectVelocityCpuEPfS0_i"]
    pub fn b3GpuNarrowPhase_setObjectVelocityCpu(
        this: *mut b3GpuNarrowPhase,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase12getBodiesGpuEv"]
    pub fn b3GpuNarrowPhase_getBodiesGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase12getBodiesCpuEv"]
    pub fn b3GpuNarrowPhase_getBodiesCpu(this: *const b3GpuNarrowPhase) -> *const b3RigidBodyData;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase15getNumBodiesGpuEv"]
    pub fn b3GpuNarrowPhase_getNumBodiesGpu(this: *const b3GpuNarrowPhase)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase18getBodyInertiasGpuEv"]
    pub fn b3GpuNarrowPhase_getBodyInertiasGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase21getNumBodyInertiasGpuEv"]
    pub fn b3GpuNarrowPhase_getNumBodyInertiasGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase17getCollidablesGpuEv"]
    pub fn b3GpuNarrowPhase_getCollidablesGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase17getCollidablesCpuEv"]
    pub fn b3GpuNarrowPhase_getCollidablesCpu(this: *const b3GpuNarrowPhase)
        -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase20getNumCollidablesGpuEv"]
    pub fn b3GpuNarrowPhase_getNumCollidablesGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase21getLocalSpaceAabbsCpuEv"]
    pub fn b3GpuNarrowPhase_getLocalSpaceAabbsCpu(
        this: *const b3GpuNarrowPhase,
    ) -> *const b3SapAabb;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase14getContactsCPUEv"]
    pub fn b3GpuNarrowPhase_getContactsCPU(this: *const b3GpuNarrowPhase) -> *const b3Contact4;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase14getContactsGpuEv"]
    pub fn b3GpuNarrowPhase_getContactsGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase17getNumContactsGpuEv"]
    pub fn b3GpuNarrowPhase_getNumContactsGpu(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase26getAabbLocalSpaceBufferGpuEv"]
    pub fn b3GpuNarrowPhase_getAabbLocalSpaceBufferGpu(this: *mut b3GpuNarrowPhase) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase17getNumRigidBodiesEv"]
    pub fn b3GpuNarrowPhase_getNumRigidBodies(
        this: *const b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase18allocateCollidableEv"]
    pub fn b3GpuNarrowPhase_allocateCollidable(
        this: *mut b3GpuNarrowPhase,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase16getCollidableCpuEi"]
    pub fn b3GpuNarrowPhase_getCollidableCpu(
        this: *mut b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase16getCollidableCpuEi"]
    pub fn b3GpuNarrowPhase_getCollidableCpu1(
        this: *const b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16b3GpuNarrowPhase17getLocalSpaceAabbEi"]
    pub fn b3GpuNarrowPhase_getLocalSpaceAabb(
        this: *const b3GpuNarrowPhase,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3SapAabb;
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhaseC1EP11_cl_contextP13_cl_device_idP17_cl_command_queueRK8b3Config"]
    pub fn b3GpuNarrowPhase_b3GpuNarrowPhase(
        this: *mut b3GpuNarrowPhase,
        vtx: cl_context,
        dev: cl_device_id,
        q: cl_command_queue,
        config: *const b3Config,
    );
}
impl b3GpuNarrowPhase {
    #[inline]
    pub unsafe fn registerConvexHullShapeInternal(
        &mut self,
        convexPtr: *mut b3ConvexUtility,
        col: *mut b3Collidable,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShapeInternal(self, convexPtr, col)
    }
    #[inline]
    pub unsafe fn registerConcaveMeshShape(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        col: *mut b3Collidable,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConcaveMeshShape(self, vertices, indices, col, scaling)
    }
    #[inline]
    pub unsafe fn registerSphereShape(&mut self, radius: f32) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerSphereShape(self, radius)
    }
    #[inline]
    pub unsafe fn registerPlaneShape(
        &mut self,
        planeNormal: *const b3Vector3,
        planeConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerPlaneShape(self, planeNormal, planeConstant)
    }
    #[inline]
    pub unsafe fn registerCompoundShape(
        &mut self,
        childShapes: *mut b3AlignedObjectArray<b3GpuChildShape>,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerCompoundShape(self, childShapes)
    }
    #[inline]
    pub unsafe fn registerFace(
        &mut self,
        faceNormal: *const b3Vector3,
        faceConstant: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerFace(self, faceNormal, faceConstant)
    }
    #[inline]
    pub unsafe fn registerConcaveMesh(
        &mut self,
        vertices: *mut b3AlignedObjectArray<b3Vector3>,
        indices: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConcaveMesh(self, vertices, indices, scaling)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape(
        &mut self,
        utilPtr: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShape(self, utilPtr)
    }
    #[inline]
    pub unsafe fn registerConvexHullShape1(
        &mut self,
        vertices: *const f32,
        strideInBytes: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        scaling: *const f32,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerConvexHullShape1(
            self,
            vertices,
            strideInBytes,
            numVertices,
            scaling,
        )
    }
    #[inline]
    pub unsafe fn registerRigidBody(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        aabbMin: *const f32,
        aabbMax: *const f32,
        writeToGpu: bool,
    ) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_registerRigidBody(
            self,
            collidableIndex,
            mass,
            position,
            orientation,
            aabbMin,
            aabbMax,
            writeToGpu,
        )
    }
    #[inline]
    pub unsafe fn setObjectTransform(
        &mut self,
        position: *const f32,
        orientation: *const f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectTransform(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn writeAllBodiesToGpu(&mut self) {
        b3GpuNarrowPhase_writeAllBodiesToGpu(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuNarrowPhase_reset(self)
    }
    #[inline]
    pub unsafe fn readbackAllBodiesToCpu(&mut self) {
        b3GpuNarrowPhase_readbackAllBodiesToCpu(self)
    }
    #[inline]
    pub unsafe fn getObjectTransformFromCpu(
        &self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) -> bool {
        b3GpuNarrowPhase_getObjectTransformFromCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectTransformCpu(
        &mut self,
        position: *mut f32,
        orientation: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectTransformCpu(self, position, orientation, bodyIndex)
    }
    #[inline]
    pub unsafe fn setObjectVelocityCpu(
        &mut self,
        linVel: *mut f32,
        angVel: *mut f32,
        bodyIndex: ::std::os::raw::c_int,
    ) {
        b3GpuNarrowPhase_setObjectVelocityCpu(self, linVel, angVel, bodyIndex)
    }
    #[inline]
    pub unsafe fn getBodiesGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getBodiesCpu(&self) -> *const b3RigidBodyData {
        b3GpuNarrowPhase_getBodiesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodiesGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumBodiesGpu(self)
    }
    #[inline]
    pub unsafe fn getBodyInertiasGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getNumBodyInertiasGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumBodyInertiasGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getCollidablesCpu(&self) -> *const b3Collidable {
        b3GpuNarrowPhase_getCollidablesCpu(self)
    }
    #[inline]
    pub unsafe fn getNumCollidablesGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumCollidablesGpu(self)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabbsCpu(&self) -> *const b3SapAabb {
        b3GpuNarrowPhase_getLocalSpaceAabbsCpu(self)
    }
    #[inline]
    pub unsafe fn getContactsCPU(&self) -> *const b3Contact4 {
        b3GpuNarrowPhase_getContactsCPU(self)
    }
    #[inline]
    pub unsafe fn getContactsGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getContactsGpu(self)
    }
    #[inline]
    pub unsafe fn getNumContactsGpu(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumContactsGpu(self)
    }
    #[inline]
    pub unsafe fn getAabbLocalSpaceBufferGpu(&mut self) -> cl_mem {
        b3GpuNarrowPhase_getAabbLocalSpaceBufferGpu(self)
    }
    #[inline]
    pub unsafe fn getNumRigidBodies(&self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_getNumRigidBodies(self)
    }
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3GpuNarrowPhase_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn getCollidableCpu(
        &mut self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *mut b3Collidable {
        b3GpuNarrowPhase_getCollidableCpu(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getCollidableCpu1(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3Collidable {
        b3GpuNarrowPhase_getCollidableCpu1(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn getLocalSpaceAabb(
        &self,
        collidableIndex: ::std::os::raw::c_int,
    ) -> *const b3SapAabb {
        b3GpuNarrowPhase_getLocalSpaceAabb(self, collidableIndex)
    }
    #[inline]
    pub unsafe fn new(
        vtx: cl_context,
        dev: cl_device_id,
        q: cl_command_queue,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuNarrowPhase_b3GpuNarrowPhase(&mut __bindgen_tmp, vtx, dev, q, config);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhaseD1Ev"]
    pub fn b3GpuNarrowPhase_b3GpuNarrowPhase_destructor(this: *mut b3GpuNarrowPhase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16b3GpuNarrowPhase15computeContactsEP7_cl_memiS1_i"]
    pub fn b3GpuNarrowPhase_computeContacts(
        this: *mut ::std::os::raw::c_void,
        broadphasePairs: cl_mem,
        numBroadphasePairs: ::std::os::raw::c_int,
        aabbsWorldSpace: cl_mem,
        numObjects: ::std::os::raw::c_int,
    );
}
/// The b3SolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuSolverBody {
    pub m_deltaLinearVelocity: b3Vector3,
    pub m_deltaAngularVelocity: b3Vector3,
    pub m_angularFactor: b3Vector3,
    pub m_linearFactor: b3Vector3,
    pub m_invMass: b3Vector3,
    pub m_pushVelocity: b3Vector3,
    pub m_turnVelocity: b3Vector3,
    pub m_linearVelocity: b3Vector3,
    pub m_angularVelocity: b3Vector3,
    pub __bindgen_anon_1: b3GpuSolverBody__bindgen_ty_1,
    pub padding: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuSolverBody__bindgen_ty_1 {
    pub m_originalBody: *mut ::std::os::raw::c_void,
    pub m_originalBodyIndex: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuSolverConstraint {
    pub m_relpos1CrossNormal: b3Vector3,
    pub m_contactNormal: b3Vector3,
    pub m_relpos2CrossNormal: b3Vector3,
    pub m_angularComponentA: b3Vector3,
    pub m_angularComponentB: b3Vector3,
    pub m_appliedPushImpulse: b3Scalar,
    pub m_appliedImpulse: b3Scalar,
    pub m_padding1: ::std::os::raw::c_int,
    pub m_padding2: ::std::os::raw::c_int,
    pub m_friction: b3Scalar,
    pub m_jacDiagABInv: b3Scalar,
    pub m_rhs: b3Scalar,
    pub m_cfm: b3Scalar,
    pub m_lowerLimit: b3Scalar,
    pub m_upperLimit: b3Scalar,
    pub m_rhsPenetration: b3Scalar,
    pub __bindgen_anon_1: b3GpuSolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3GpuSolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_originalConstraintIndex: ::std::os::raw::c_int,
    pub m_unusedPadding4: b3Scalar,
    _bindgen_union_align: u64,
}
pub const b3GpuSolverConstraint_b3SolverConstraintType_B3_SOLVER_CONTACT_1D:
    b3GpuSolverConstraint_b3SolverConstraintType = 0;
pub const b3GpuSolverConstraint_b3SolverConstraintType_B3_SOLVER_FRICTION_1D:
    b3GpuSolverConstraint_b3SolverConstraintType = 1;
pub type b3GpuSolverConstraint_b3SolverConstraintType = u32;
pub type b3GpuConstraintArray = b3AlignedObjectArray<b3GpuSolverConstraint>;
pub const b3GpuGenericConstraintType_B3_GPU_POINT2POINT_CONSTRAINT_TYPE:
    b3GpuGenericConstraintType = 3;
pub const b3GpuGenericConstraintType_B3_GPU_FIXED_CONSTRAINT_TYPE: b3GpuGenericConstraintType = 4;
pub const b3GpuGenericConstraintType_B3_GPU_MAX_CONSTRAINT_TYPE: b3GpuGenericConstraintType = 5;
pub type b3GpuGenericConstraintType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuConstraintInfo2 {
    pub fps: b3Scalar,
    pub erp: b3Scalar,
    pub m_J1linearAxis: *mut b3Scalar,
    pub m_J1angularAxis: *mut b3Scalar,
    pub m_J2linearAxis: *mut b3Scalar,
    pub m_J2angularAxis: *mut b3Scalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut b3Scalar,
    pub cfm: *mut b3Scalar,
    pub m_lowerLimit: *mut b3Scalar,
    pub m_upperLimit: *mut b3Scalar,
    pub findex: *mut ::std::os::raw::c_int,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: b3Scalar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuGenericConstraint {
    pub m_constraintType: ::std::os::raw::c_int,
    pub m_rbA: ::std::os::raw::c_int,
    pub m_rbB: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_pivotInA: b3Vector3,
    pub m_pivotInB: b3Vector3,
    pub m_relTargetAB: b3Quaternion,
    pub m_flags: ::std::os::raw::c_int,
    pub m_uid: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 2usize],
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}_ZN22b3GpuGenericConstraint8getInfo1EPjPK15b3RigidBodyData"]
    pub fn b3GpuGenericConstraint_getInfo1(
        this: *mut b3GpuGenericConstraint,
        info: *mut ::std::os::raw::c_uint,
        bodies: *const b3RigidBodyData,
    );
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}_ZN22b3GpuGenericConstraint8getInfo2EP20b3GpuConstraintInfo2PK15b3RigidBodyData"]
    pub fn b3GpuGenericConstraint_getInfo2(
        this: *mut b3GpuGenericConstraint,
        info: *mut b3GpuConstraintInfo2,
        bodies: *const b3RigidBodyData,
    );
}
impl b3GpuGenericConstraint {
    #[inline]
    pub unsafe fn getInfo1(
        &mut self,
        info: *mut ::std::os::raw::c_uint,
        bodies: *const b3RigidBodyData,
    ) {
        b3GpuGenericConstraint_getInfo1(self, info, bodies)
    }
    #[inline]
    pub unsafe fn getInfo2(
        &mut self,
        info: *mut b3GpuConstraintInfo2,
        bodies: *const b3RigidBodyData,
    ) {
        b3GpuGenericConstraint_getInfo2(self, info, bodies)
    }
}
#[repr(C)]
pub struct b3GpuPgsConstraintSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct b3GpuPgsConstraintSolver {
    pub vtable_: *const b3GpuPgsConstraintSolver__bindgen_vtable,
    pub m_staticIdx: ::std::os::raw::c_int,
    pub m_gpuData: *mut b3GpuPgsJacobiSolverInternalData,
    pub m_tmpSolverBodyPool: b3AlignedObjectArray<b3GpuSolverBody>,
    pub m_tmpSolverContactConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: b3GpuConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: b3GpuConstraintArray,
    pub m_tmpConstraintSizesPool: b3AlignedObjectArray<::std::os::raw::c_uint>,
    pub m_usePgs: bool,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_numSplitImpulseRecoveries: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver17averageVelocitiesEv"]
    pub fn b3GpuPgsConstraintSolver_averageVelocities(this: *mut b3GpuPgsConstraintSolver);
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver14initSolverBodyEiP15b3GpuSolverBodyP15b3RigidBodyData"]
    pub fn b3GpuPgsConstraintSolver_initSolverBody(
        this: *mut b3GpuPgsConstraintSolver,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3GpuSolverBody,
        rb: *mut b3RigidBodyData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver29solveGroupCacheFriendlyFinishEP13b3OpenCLArrayI15b3RigidBodyDataEPS0_I13b3InertiaDataEiPS0_I22b3GpuGenericConstraintEiRK19b3ContactSolverInfo"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut b3GpuPgsConstraintSolver,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver10solveGroupEP13b3OpenCLArrayI15b3RigidBodyDataEPS0_I13b3InertiaDataEiPS0_I22b3GpuGenericConstraintEiRK19b3ContactSolverInfo"]
    pub fn b3GpuPgsConstraintSolver_solveGroup(
        this: *mut b3GpuPgsConstraintSolver,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver11solveJointsEiP13b3OpenCLArrayI15b3RigidBodyDataEPS0_I13b3InertiaDataEiPS0_I22b3GpuGenericConstraintE"]
    pub fn b3GpuPgsConstraintSolver_solveJoints(
        this: *mut b3GpuPgsConstraintSolver,
        numBodies: ::std::os::raw::c_int,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver22sortConstraintByBatch3EP17b3BatchConstraintiiii"]
    pub fn b3GpuPgsConstraintSolver_sortConstraintByBatch3(
        this: *mut b3GpuPgsConstraintSolver,
        cs: *mut b3BatchConstraint,
        numConstraints: ::std::os::raw::c_int,
        simdWidth: ::std::os::raw::c_int,
        staticIdx: ::std::os::raw::c_int,
        numBodies: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver16recomputeBatchesEv"]
    pub fn b3GpuPgsConstraintSolver_recomputeBatches(this: *mut b3GpuPgsConstraintSolver);
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolverC1EP11_cl_contextP13_cl_device_idP17_cl_command_queueb"]
    pub fn b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver(
        this: *mut b3GpuPgsConstraintSolver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        usePgs: bool,
    );
}
impl b3GpuPgsConstraintSolver {
    #[inline]
    pub unsafe fn averageVelocities(&mut self) {
        b3GpuPgsConstraintSolver_averageVelocities(self)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        bodyIndex: ::std::os::raw::c_int,
        solverBody: *mut b3GpuSolverBody,
        rb: *mut b3RigidBodyData,
    ) {
        b3GpuPgsConstraintSolver_initSolverBody(self, bodyIndex, solverBody, rb)
    }
    #[inline]
    pub unsafe fn solveGroupCacheFriendlyFinish(
        &mut self,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3GpuPgsConstraintSolver_solveGroupCacheFriendlyFinish(
            self,
            gpuBodies,
            gpuInertias,
            numBodies,
            gpuConstraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveGroup(
        &mut self,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar {
        b3GpuPgsConstraintSolver_solveGroup(
            self,
            gpuBodies,
            gpuInertias,
            numBodies,
            gpuConstraints,
            numConstraints,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn solveJoints(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
    ) {
        b3GpuPgsConstraintSolver_solveJoints(
            self,
            numBodies,
            gpuBodies,
            gpuInertias,
            numConstraints,
            gpuConstraints,
        )
    }
    #[inline]
    pub unsafe fn sortConstraintByBatch3(
        &mut self,
        cs: *mut b3BatchConstraint,
        numConstraints: ::std::os::raw::c_int,
        simdWidth: ::std::os::raw::c_int,
        staticIdx: ::std::os::raw::c_int,
        numBodies: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        b3GpuPgsConstraintSolver_sortConstraintByBatch3(
            self,
            cs,
            numConstraints,
            simdWidth,
            staticIdx,
            numBodies,
        )
    }
    #[inline]
    pub unsafe fn recomputeBatches(&mut self) {
        b3GpuPgsConstraintSolver_recomputeBatches(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        usePgs: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            queue,
            usePgs,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolverD1Ev"]
    pub fn b3GpuPgsConstraintSolver_b3GpuPgsConstraintSolver_destructor(
        this: *mut b3GpuPgsConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver33solveGroupCacheFriendlyIterationsEP13b3OpenCLArrayI22b3GpuGenericConstraintEiRK19b3ContactSolverInfo"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        gpuConstraints1: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN24b3GpuPgsConstraintSolver28solveGroupCacheFriendlySetupEP13b3OpenCLArrayI15b3RigidBodyDataEPS0_I13b3InertiaDataEiPS0_I22b3GpuGenericConstraintEiRK19b3ContactSolverInfo"]
    pub fn b3GpuPgsConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        gpuBodies: *mut b3OpenCLArray,
        gpuInertias: *mut b3OpenCLArray,
        numBodies: ::std::os::raw::c_int,
        gpuConstraints: *mut b3OpenCLArray,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const b3ContactSolverInfo,
    ) -> b3Scalar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Contact4 {
    pub _base: b3Contact4Data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3GpuConstraint4 {
    pub _base: b3ContactConstraint4,
}
#[repr(C)]
pub struct b3GpuPgsContactSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuPgsContactSolver {
    pub vtable_: *const b3GpuPgsContactSolver__bindgen_vtable,
    pub m_debugOutput: ::std::os::raw::c_int,
    pub m_data: *mut b3GpuBatchingPgsSolverInternalData,
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolver13batchContactsEP13b3OpenCLArrayI10b3Contact4EiPS0_IjES5_i"]
    pub fn b3GpuPgsContactSolver_batchContacts(
        this: *mut b3GpuPgsContactSolver,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolver32solveContactConstraintBatchSizesEPK13b3OpenCLArrayI15b3RigidBodyDataEPKS0_I13b3InertiaDataEPS0_I16b3GpuConstraint4EPviiiPK20b3AlignedObjectArrayIiE"]
    pub fn b3GpuPgsContactSolver_solveContactConstraintBatchSizes(
        this: *mut b3GpuPgsContactSolver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolver22solveContactConstraintEPK13b3OpenCLArrayI15b3RigidBodyDataEPKS0_I13b3InertiaDataEPS0_I16b3GpuConstraint4EPviiiPK20b3AlignedObjectArrayIiE"]
    pub fn b3GpuPgsContactSolver_solveContactConstraint(
        this: *mut b3GpuPgsContactSolver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolver13solveContactsEiP7_cl_memS1_iS1_RK8b3Configi"]
    pub fn b3GpuPgsContactSolver_solveContacts(
        this: *mut b3GpuPgsContactSolver,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolverC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3GpuPgsContactSolver_b3GpuPgsContactSolver(
        this: *mut b3GpuPgsContactSolver,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3GpuPgsContactSolver {
    #[inline]
    pub unsafe fn batchContacts(
        &mut self,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    ) {
        b3GpuPgsContactSolver_batchContacts(self, contacts, nContacts, n, offsets, staticIdx)
    }
    #[inline]
    pub unsafe fn solveContactConstraintBatchSizes(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3GpuPgsContactSolver_solveContactConstraintBatchSizes(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            numIterations,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn solveContactConstraint(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
        batchSizes: *const b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3GpuPgsContactSolver_solveContactConstraint(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            numIterations,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn solveContacts(
        &mut self,
        numBodies: ::std::os::raw::c_int,
        bodyBuf: cl_mem,
        inertiaBuf: cl_mem,
        numContacts: ::std::os::raw::c_int,
        contactBuf: cl_mem,
        config: *const b3Config,
        static0Index: ::std::os::raw::c_int,
    ) {
        b3GpuPgsContactSolver_solveContacts(
            self,
            numBodies,
            bodyBuf,
            inertiaBuf,
            numContacts,
            contactBuf,
            config,
            static0Index,
        )
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuPgsContactSolver_b3GpuPgsContactSolver(
            &mut __bindgen_tmp,
            ctx,
            device,
            q,
            pairCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN21b3GpuPgsContactSolverD1Ev"]
    pub fn b3GpuPgsContactSolver_b3GpuPgsContactSolver_destructor(this: *mut b3GpuPgsContactSolver);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Config {
    pub m_maxConvexBodies: ::std::os::raw::c_int,
    pub m_maxConvexShapes: ::std::os::raw::c_int,
    pub m_maxBroadphasePairs: ::std::os::raw::c_int,
    pub m_maxContactCapacity: ::std::os::raw::c_int,
    pub m_compoundPairCapacity: ::std::os::raw::c_int,
    pub m_maxVerticesPerFace: ::std::os::raw::c_int,
    pub m_maxFacesPerShape: ::std::os::raw::c_int,
    pub m_maxConvexVertices: ::std::os::raw::c_int,
    pub m_maxConvexIndices: ::std::os::raw::c_int,
    pub m_maxConvexUniqueEdges: ::std::os::raw::c_int,
    pub m_maxCompoundChildShapes: ::std::os::raw::c_int,
    pub m_maxTriConvexPairCapacity: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3GpuRigidBodyPipeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3GpuRigidBodyPipeline {
    pub vtable_: *const b3GpuRigidBodyPipeline__bindgen_vtable,
    pub m_data: *mut b3GpuRigidBodyPipelineInternalData,
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline18allocateCollidableEv"]
    pub fn b3GpuRigidBodyPipeline_allocateCollidable(
        this: *mut b3GpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline14stepSimulationEf"]
    pub fn b3GpuRigidBodyPipeline_stepSimulation(this: *mut b3GpuRigidBodyPipeline, deltaTime: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline9integrateEf"]
    pub fn b3GpuRigidBodyPipeline_integrate(this: *mut b3GpuRigidBodyPipeline, timeStep: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline17setupGpuAabbsFullEv"]
    pub fn b3GpuRigidBodyPipeline_setupGpuAabbsFull(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline24registerConvexPolyhedronEP15b3ConvexUtility"]
    pub fn b3GpuRigidBodyPipeline_registerConvexPolyhedron(
        this: *mut b3GpuRigidBodyPipeline,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline23registerPhysicsInstanceEfPKfS1_iib"]
    pub fn b3GpuRigidBodyPipeline_registerPhysicsInstance(
        this: *mut b3GpuRigidBodyPipeline,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
        writeInstanceToGpu: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline22writeAllInstancesToGpuEv"]
    pub fn b3GpuRigidBodyPipeline_writeAllInstancesToGpu(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline21copyConstraintsToHostEv"]
    pub fn b3GpuRigidBodyPipeline_copyConstraintsToHost(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline10setGravityEPKf"]
    pub fn b3GpuRigidBodyPipeline_setGravity(this: *mut b3GpuRigidBodyPipeline, grav: *const f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline5resetEv"]
    pub fn b3GpuRigidBodyPipeline_reset(this: *mut b3GpuRigidBodyPipeline);
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline27createPoint2PointConstraintEiiPKfS1_f"]
    pub fn b3GpuRigidBodyPipeline_createPoint2PointConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline21createFixedConstraintEiiPKfS1_S1_f"]
    pub fn b3GpuRigidBodyPipeline_createFixedConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline21removeConstraintByUidEi"]
    pub fn b3GpuRigidBodyPipeline_removeConstraintByUid(
        this: *mut b3GpuRigidBodyPipeline,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline13addConstraintEP17b3TypedConstraint"]
    pub fn b3GpuRigidBodyPipeline_addConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline16removeConstraintEP17b3TypedConstraint"]
    pub fn b3GpuRigidBodyPipeline_removeConstraint(
        this: *mut b3GpuRigidBodyPipeline,
        constraint: *mut b3TypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline8castRaysERK20b3AlignedObjectArrayI9b3RayInfoERS0_I8b3RayHitE"]
    pub fn b3GpuRigidBodyPipeline_castRays(
        this: *mut b3GpuRigidBodyPipeline,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipeline13getBodyBufferEv"]
    pub fn b3GpuRigidBodyPipeline_getBodyBuffer(this: *mut b3GpuRigidBodyPipeline) -> cl_mem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22b3GpuRigidBodyPipeline12getNumBodiesEv"]
    pub fn b3GpuRigidBodyPipeline_getNumBodies(
        this: *const b3GpuRigidBodyPipeline,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipelineC1EP11_cl_contextP13_cl_device_idP17_cl_command_queueP16b3GpuNarrowPhaseP24b3GpuBroadphaseInterfaceP22b3DynamicBvhBroadphaseRK8b3Config"]
    pub fn b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline(
        this: *mut b3GpuRigidBodyPipeline,
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        narrowphase: *mut b3GpuNarrowPhase,
        broadphaseSap: *mut b3GpuBroadphaseInterface,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    );
}
impl b3GpuRigidBodyPipeline {
    #[inline]
    pub unsafe fn allocateCollidable(&mut self) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_allocateCollidable(self)
    }
    #[inline]
    pub unsafe fn stepSimulation(&mut self, deltaTime: f32) {
        b3GpuRigidBodyPipeline_stepSimulation(self, deltaTime)
    }
    #[inline]
    pub unsafe fn integrate(&mut self, timeStep: f32) {
        b3GpuRigidBodyPipeline_integrate(self, timeStep)
    }
    #[inline]
    pub unsafe fn setupGpuAabbsFull(&mut self) {
        b3GpuRigidBodyPipeline_setupGpuAabbsFull(self)
    }
    #[inline]
    pub unsafe fn registerConvexPolyhedron(
        &mut self,
        convex: *mut b3ConvexUtility,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_registerConvexPolyhedron(self, convex)
    }
    #[inline]
    pub unsafe fn registerPhysicsInstance(
        &mut self,
        mass: f32,
        position: *const f32,
        orientation: *const f32,
        collisionShapeIndex: ::std::os::raw::c_int,
        userData: ::std::os::raw::c_int,
        writeInstanceToGpu: bool,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_registerPhysicsInstance(
            self,
            mass,
            position,
            orientation,
            collisionShapeIndex,
            userData,
            writeInstanceToGpu,
        )
    }
    #[inline]
    pub unsafe fn writeAllInstancesToGpu(&mut self) {
        b3GpuRigidBodyPipeline_writeAllInstancesToGpu(self)
    }
    #[inline]
    pub unsafe fn copyConstraintsToHost(&mut self) {
        b3GpuRigidBodyPipeline_copyConstraintsToHost(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, grav: *const f32) {
        b3GpuRigidBodyPipeline_setGravity(self, grav)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        b3GpuRigidBodyPipeline_reset(self)
    }
    #[inline]
    pub unsafe fn createPoint2PointConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_createPoint2PointConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn createFixedConstraint(
        &mut self,
        bodyA: ::std::os::raw::c_int,
        bodyB: ::std::os::raw::c_int,
        pivotInA: *const f32,
        pivotInB: *const f32,
        relTargetAB: *const f32,
        breakingThreshold: f32,
    ) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_createFixedConstraint(
            self,
            bodyA,
            bodyB,
            pivotInA,
            pivotInB,
            relTargetAB,
            breakingThreshold,
        )
    }
    #[inline]
    pub unsafe fn removeConstraintByUid(&mut self, uid: ::std::os::raw::c_int) {
        b3GpuRigidBodyPipeline_removeConstraintByUid(self, uid)
    }
    #[inline]
    pub unsafe fn addConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3GpuRigidBodyPipeline_addConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn removeConstraint(&mut self, constraint: *mut b3TypedConstraint) {
        b3GpuRigidBodyPipeline_removeConstraint(self, constraint)
    }
    #[inline]
    pub unsafe fn castRays(
        &mut self,
        rays: *const b3AlignedObjectArray<b3RayInfo>,
        hitResults: *mut b3AlignedObjectArray<b3RayHit>,
    ) {
        b3GpuRigidBodyPipeline_castRays(self, rays, hitResults)
    }
    #[inline]
    pub unsafe fn getBodyBuffer(&mut self) -> cl_mem {
        b3GpuRigidBodyPipeline_getBodyBuffer(self)
    }
    #[inline]
    pub unsafe fn getNumBodies(&self) -> ::std::os::raw::c_int {
        b3GpuRigidBodyPipeline_getNumBodies(self)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        q: cl_command_queue,
        narrowphase: *mut b3GpuNarrowPhase,
        broadphaseSap: *mut b3GpuBroadphaseInterface,
        broadphaseDbvt: *mut b3DynamicBvhBroadphase,
        config: *const b3Config,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline(
            &mut __bindgen_tmp,
            ctx,
            device,
            q,
            narrowphase,
            broadphaseSap,
            broadphaseDbvt,
            config,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22b3GpuRigidBodyPipelineD1Ev"]
    pub fn b3GpuRigidBodyPipeline_b3GpuRigidBodyPipeline_destructor(
        this: *mut b3GpuRigidBodyPipeline,
    );
}
#[repr(C)]
pub struct b3GpuRigidBodyPipelineInternalData {
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_integrateTransformsKernel: cl_kernel,
    pub m_updateAabbsKernel: cl_kernel,
    pub m_clearOverlappingPairsKernel: cl_kernel,
    pub m_solver: *mut b3PgsJacobiSolver,
    pub m_gpuSolver: *mut b3GpuPgsConstraintSolver,
    pub m_solver2: *mut b3GpuPgsContactSolver,
    pub m_solver3: *mut b3GpuJacobiContactSolver,
    pub m_raycaster: *mut b3GpuRaycast,
    pub m_broadphaseSap: *mut b3GpuBroadphaseInterface,
    pub m_broadphaseDbvt: *mut b3DynamicBvhBroadphase,
    pub m_allAabbsGPU: *mut b3OpenCLArray,
    pub m_allAabbsCPU: b3AlignedObjectArray<b3SapAabb>,
    pub m_overlappingPairsGPU: *mut b3OpenCLArray,
    pub m_gpuConstraints: *mut b3OpenCLArray,
    pub m_cpuConstraints: b3AlignedObjectArray<b3GpuGenericConstraint>,
    pub m_joints: b3AlignedObjectArray<*mut b3TypedConstraint>,
    pub m_constraintUid: ::std::os::raw::c_int,
    pub m_narrowphase: *mut b3GpuNarrowPhase,
    pub m_gravity: b3Vector3,
    pub m_config: b3Config,
}
#[repr(C)]
pub struct b3BoundSearchCL__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3BoundSearchCL {
    pub vtable_: *const b3BoundSearchCL__bindgen_vtable,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_lowerSortDataKernel: cl_kernel,
    pub m_upperSortDataKernel: cl_kernel,
    pub m_subtractKernel: cl_kernel,
    pub m_constbtOpenCLArray: *mut b3OpenCLArray,
    pub m_lower: *mut b3OpenCLArray,
    pub m_upper: *mut b3OpenCLArray,
    pub m_filler: *mut b3FillCL,
}
pub const b3BoundSearchCL_Option_BOUND_LOWER: b3BoundSearchCL_Option = 0;
pub const b3BoundSearchCL_Option_BOUND_UPPER: b3BoundSearchCL_Option = 1;
pub const b3BoundSearchCL_Option_COUNT: b3BoundSearchCL_Option = 2;
pub type b3BoundSearchCL_Option = u32;
extern "C" {
    #[link_name = "\u{1}_ZN15b3BoundSearchCL7executeER13b3OpenCLArrayI10b3SortDataEiRS0_IjEiNS_6OptionE"]
    pub fn b3BoundSearchCL_execute(
        this: *mut b3BoundSearchCL,
        src: *mut b3OpenCLArray,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3OpenCLArray,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3BoundSearchCL11executeHostER20b3AlignedObjectArrayI10b3SortDataEiRS0_IjEiNS_6OptionE"]
    pub fn b3BoundSearchCL_executeHost(
        this: *mut b3BoundSearchCL,
        src: *mut b3AlignedObjectArray<b3SortData>,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3BoundSearchCLC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3BoundSearchCL_b3BoundSearchCL(
        this: *mut b3BoundSearchCL,
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    );
}
impl b3BoundSearchCL {
    #[inline]
    pub unsafe fn execute(
        &mut self,
        src: *mut b3OpenCLArray,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3OpenCLArray,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    ) {
        b3BoundSearchCL_execute(self, src, nSrc, dst, nDst, option)
    }
    #[inline]
    pub unsafe fn executeHost(
        &mut self,
        src: *mut b3AlignedObjectArray<b3SortData>,
        nSrc: ::std::os::raw::c_int,
        dst: *mut b3AlignedObjectArray<::std::os::raw::c_uint>,
        nDst: ::std::os::raw::c_int,
        option: b3BoundSearchCL_Option,
    ) {
        b3BoundSearchCL_executeHost(self, src, nSrc, dst, nDst, option)
    }
    #[inline]
    pub unsafe fn new(
        context: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        size: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3BoundSearchCL_b3BoundSearchCL(&mut __bindgen_tmp, context, device, queue, size);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15b3BoundSearchCLD1Ev"]
    pub fn b3BoundSearchCL_b3BoundSearchCL_destructor(this: *mut b3BoundSearchCL);
}
extern "C" {
    /// CL Context optionally takes a GL context. This is a generic type because we don't really want this code
    /// to have to understand GL types. It is a HGLRC in _WIN32 or a GLXContext otherwise.
    pub fn b3OpenCLUtils_createContextFromType(
        deviceType: cl_device_type,
        pErrNum: *mut cl_int,
        pGLCtx: *mut ::std::os::raw::c_void,
        pGLDC: *mut ::std::os::raw::c_void,
        preferredDeviceIndex: ::std::os::raw::c_int,
        preferredPlatformIndex: ::std::os::raw::c_int,
        platformId: *mut cl_platform_id,
    ) -> cl_context;
}
extern "C" {
    pub fn b3OpenCLUtils_getNumDevices(cxMainContext: cl_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3OpenCLUtils_getDevice(
        cxMainContext: cl_context,
        nr: ::std::os::raw::c_int,
    ) -> cl_device_id;
}
extern "C" {
    pub fn b3OpenCLUtils_printDeviceInfo(device: cl_device_id);
}
extern "C" {
    pub fn b3OpenCLUtils_compileCLKernelFromString(
        clContext: cl_context,
        device: cl_device_id,
        kernelSource: *const ::std::os::raw::c_char,
        kernelName: *const ::std::os::raw::c_char,
        pErrNum: *mut cl_int,
        prog: cl_program,
        additionalMacros: *const ::std::os::raw::c_char,
    ) -> cl_kernel;
}
extern "C" {
    pub fn b3OpenCLUtils_compileCLProgramFromString(
        clContext: cl_context,
        device: cl_device_id,
        kernelSource: *const ::std::os::raw::c_char,
        pErrNum: *mut cl_int,
        additionalMacros: *const ::std::os::raw::c_char,
        srcFileNameForCaching: *const ::std::os::raw::c_char,
        disableBinaryCaching: bool,
    ) -> cl_program;
}
extern "C" {
    pub fn b3OpenCLUtils_getNumPlatforms(pErrNum: *mut cl_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get the nr'th platform, where nr is in the range [0..getNumPlatforms)
    pub fn b3OpenCLUtils_getPlatform(
        nr: ::std::os::raw::c_int,
        pErrNum: *mut cl_int,
    ) -> cl_platform_id;
}
extern "C" {
    pub fn b3OpenCLUtils_printPlatformInfo(platform: cl_platform_id);
}
extern "C" {
    pub fn b3OpenCLUtils_getSdkVendorName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// set the path (directory/folder) where the compiled OpenCL kernel are stored
    pub fn b3OpenCLUtils_setCachePath(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn b3OpenCLUtils_createContextFromPlatform(
        platform: cl_platform_id,
        deviceType: cl_device_type,
        pErrNum: *mut cl_int,
        pGLCtx: *mut ::std::os::raw::c_void,
        pGLDC: *mut ::std::os::raw::c_void,
        preferredDeviceIndex: ::std::os::raw::c_int,
        preferredPlatformIndex: ::std::os::raw::c_int,
    ) -> cl_context;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3OpenCLDeviceInfo {
    pub m_deviceName: [::std::os::raw::c_char; 1024usize],
    pub m_deviceVendor: [::std::os::raw::c_char; 1024usize],
    pub m_driverVersion: [::std::os::raw::c_char; 1024usize],
    pub m_deviceExtensions: [::std::os::raw::c_char; 1024usize],
    pub m_deviceType: cl_device_type,
    pub m_computeUnits: cl_uint,
    pub m_workitemDims: usize,
    pub m_workItemSize: [usize; 3usize],
    pub m_image2dMaxWidth: usize,
    pub m_image2dMaxHeight: usize,
    pub m_image3dMaxWidth: usize,
    pub m_image3dMaxHeight: usize,
    pub m_image3dMaxDepth: usize,
    pub m_workgroupSize: usize,
    pub m_clockFrequency: cl_uint,
    pub m_constantBufferSize: cl_ulong,
    pub m_localMemSize: cl_ulong,
    pub m_globalMemSize: cl_ulong,
    pub m_errorCorrectionSupport: cl_bool,
    pub m_localMemType: cl_device_local_mem_type,
    pub m_maxReadImageArgs: cl_uint,
    pub m_maxWriteImageArgs: cl_uint,
    pub m_addressBits: cl_uint,
    pub m_maxMemAllocSize: cl_ulong,
    pub m_queueProperties: cl_command_queue_properties,
    pub m_imageSupport: cl_bool,
    pub m_vecWidthChar: cl_uint,
    pub m_vecWidthShort: cl_uint,
    pub m_vecWidthInt: cl_uint,
    pub m_vecWidthLong: cl_uint,
    pub m_vecWidthFloat: cl_uint,
    pub m_vecWidthDouble: cl_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3OpenCLPlatformInfo {
    pub m_platformVendor: [::std::os::raw::c_char; 1024usize],
    pub m_platformName: [::std::os::raw::c_char; 1024usize],
    pub m_platformVersion: [::std::os::raw::c_char; 1024usize],
}
/// C++ API for OpenCL utilities: convenience functions
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3OpenCLUtils {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN13b3OpenCLUtils13getDeviceInfoEP13_cl_device_idP18b3OpenCLDeviceInfo"]
    pub fn b3OpenCLUtils_getDeviceInfo(device: cl_device_id, info: *mut b3OpenCLDeviceInfo);
}
extern "C" {
    #[link_name = "\u{1}_ZN13b3OpenCLUtils15getPlatformInfoEP15_cl_platform_idP20b3OpenCLPlatformInfo"]
    pub fn b3OpenCLUtils_getPlatformInfo(
        platform: cl_platform_id,
        platformInfo: *mut b3OpenCLPlatformInfo,
    );
}
impl b3OpenCLUtils {
    #[inline]
    pub unsafe fn getDeviceInfo(device: cl_device_id, info: *mut b3OpenCLDeviceInfo) {
        b3OpenCLUtils_getDeviceInfo(device, info)
    }
    #[inline]
    pub unsafe fn getPlatformInfo(
        platform: cl_platform_id,
        platformInfo: *mut b3OpenCLPlatformInfo,
    ) {
        b3OpenCLUtils_getPlatformInfo(platform, platformInfo)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SolverBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SolverBase_ConstraintCfg {
    pub m_positionDrift: f32,
    pub m_positionConstraintCoeff: f32,
    pub m_dt: f32,
    pub m_enableParallelSolve: bool,
    pub m_batchCellSize: f32,
    pub m_staticIdx: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct b3Solver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3Solver {
    pub vtable_: *const b3Solver__bindgen_vtable,
    pub m_context: cl_context,
    pub m_device: cl_device_id,
    pub m_queue: cl_command_queue,
    pub m_numConstraints: *mut b3OpenCLArray,
    pub m_offsets: *mut b3OpenCLArray,
    pub m_batchSizes: b3OpenCLArray,
    pub m_nIterations: ::std::os::raw::c_int,
    pub m_batchingKernel: cl_kernel,
    pub m_batchingKernelNew: cl_kernel,
    pub m_solveContactKernel: cl_kernel,
    pub m_solveFrictionKernel: cl_kernel,
    pub m_contactToConstraintKernel: cl_kernel,
    pub m_setSortDataKernel: cl_kernel,
    pub m_reorderContactKernel: cl_kernel,
    pub m_copyConstraintKernel: cl_kernel,
    pub m_sort32: *mut b3RadixSort32CL,
    pub m_search: *mut b3BoundSearchCL,
    pub m_scan: *mut b3PrefixScanCL,
    pub m_sortDataBuffer: *mut b3OpenCLArray,
    pub m_contactBuffer2: *mut b3OpenCLArray,
}
pub const b3Solver_DYNAMIC_CONTACT_ALLOCATION_THRESHOLD: b3Solver__bindgen_ty_1 = 2000000;
pub type b3Solver__bindgen_ty_1 = u32;
extern "C" {
    #[link_name = "\u{1}_ZN8b3Solver22solveContactConstraintEPK13b3OpenCLArrayI15b3RigidBodyDataEPKS0_I13b3InertiaDataEPS0_I16b3GpuConstraint4EPvii"]
    pub fn b3Solver_solveContactConstraint(
        this: *mut b3Solver,
        bodyBuf: *const b3OpenCLArray,
        inertiaBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3Solver26solveContactConstraintHostEP13b3OpenCLArrayI15b3RigidBodyDataEPS0_I13b3InertiaDataEPS0_I16b3GpuConstraint4EPviiP20b3AlignedObjectArrayIiE"]
    pub fn b3Solver_solveContactConstraintHost(
        this: *mut b3Solver,
        bodyBuf: *mut b3OpenCLArray,
        shapeBuf: *mut b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        batchSizes: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3Solver20convertToConstraintsEPK13b3OpenCLArrayI15b3RigidBodyDataEPKS0_I13b3InertiaDataEPS0_I10b3Contact4EPS0_I16b3GpuConstraint4EPviRKN12b3SolverBase13ConstraintCfgE"]
    pub fn b3Solver_convertToConstraints(
        this: *mut b3Solver,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        contactsIn: *mut b3OpenCLArray,
        contactCOut: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        nContacts: ::std::os::raw::c_int,
        cfg: *const b3SolverBase_ConstraintCfg,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3Solver13batchContactsEP13b3OpenCLArrayI10b3Contact4EiPS0_IjES5_i"]
    pub fn b3Solver_batchContacts(
        this: *mut b3Solver,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3SolverC1EP11_cl_contextP13_cl_device_idP17_cl_command_queuei"]
    pub fn b3Solver_b3Solver(
        this: *mut b3Solver,
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    );
}
impl b3Solver {
    #[inline]
    pub unsafe fn solveContactConstraint(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        inertiaBuf: *const b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
    ) {
        b3Solver_solveContactConstraint(
            self,
            bodyBuf,
            inertiaBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
        )
    }
    #[inline]
    pub unsafe fn solveContactConstraintHost(
        &mut self,
        bodyBuf: *mut b3OpenCLArray,
        shapeBuf: *mut b3OpenCLArray,
        constraint: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        maxNumBatches: ::std::os::raw::c_int,
        batchSizes: *mut b3AlignedObjectArray<::std::os::raw::c_int>,
    ) {
        b3Solver_solveContactConstraintHost(
            self,
            bodyBuf,
            shapeBuf,
            constraint,
            additionalData,
            n,
            maxNumBatches,
            batchSizes,
        )
    }
    #[inline]
    pub unsafe fn convertToConstraints(
        &mut self,
        bodyBuf: *const b3OpenCLArray,
        shapeBuf: *const b3OpenCLArray,
        contactsIn: *mut b3OpenCLArray,
        contactCOut: *mut b3OpenCLArray,
        additionalData: *mut ::std::os::raw::c_void,
        nContacts: ::std::os::raw::c_int,
        cfg: *const b3SolverBase_ConstraintCfg,
    ) {
        b3Solver_convertToConstraints(
            self,
            bodyBuf,
            shapeBuf,
            contactsIn,
            contactCOut,
            additionalData,
            nContacts,
            cfg,
        )
    }
    #[inline]
    pub unsafe fn batchContacts(
        &mut self,
        contacts: *mut b3OpenCLArray,
        nContacts: ::std::os::raw::c_int,
        n: *mut b3OpenCLArray,
        offsets: *mut b3OpenCLArray,
        staticIdx: ::std::os::raw::c_int,
    ) {
        b3Solver_batchContacts(self, contacts, nContacts, n, offsets, staticIdx)
    }
    #[inline]
    pub unsafe fn new(
        ctx: cl_context,
        device: cl_device_id,
        queue: cl_command_queue,
        pairCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        b3Solver_b3Solver(&mut __bindgen_tmp, ctx, device, queue, pairCapacity);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8b3SolverD1Ev"]
    pub fn b3Solver_b3Solver_destructor(this: *mut b3Solver);
}
pub type mbstate_t = __mbstate_t;
/// very basic hashable string implementation, compatible with b3HashMap
#[repr(C)]
pub struct b3HashString {
    pub m_string: std_string,
    pub m_hash: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashInt {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3HashPtr {
    pub __bindgen_anon_1: b3HashPtr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3HashPtr__bindgen_ty_1 {
    pub m_pointer: *const ::std::os::raw::c_void,
    pub m_hashValues: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashKeyPtr {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3HashKey {
    pub m_uid: ::std::os::raw::c_int,
}
/// The b3HashMap template class implements a generic and lightweight hashmap.
/// A basic sample of how to use b3HashMap is located in Demos\BasicDemo\main.cpp
#[repr(C)]
#[derive(Debug)]
pub struct b3HashMap<Key, Value> {
    pub m_hashTable: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_valueArray: b3AlignedObjectArray<Value>,
    pub m_keyArray: b3AlignedObjectArray<Key>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Key>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bStructHandle {
    pub unused: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bChunkInd {
    pub code: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
    pub oldPtr: *mut ::std::os::raw::c_void,
    pub dna_nr: ::std::os::raw::c_int,
    pub nr: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bParse_bNameInfo {
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_isPointer: bool,
    pub m_dim0: ::std::os::raw::c_int,
    pub m_dim1: ::std::os::raw::c_int,
}
/// The b3Block class is an internal structure for the b3StackAlloc memory allocator.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Block {
    pub previous: *mut b3Block,
    pub address: *mut ::std::os::raw::c_uchar,
}
/// The StackAlloc class provides some fast stack-based memory allocator (LIFO last-in first-out)
#[repr(C)]
#[derive(Debug)]
pub struct b3StackAlloc {
    pub data: *mut ::std::os::raw::c_uchar,
    pub totalsize: ::std::os::raw::c_uint,
    pub usedsize: ::std::os::raw::c_uint,
    pub current: *mut b3Block,
    pub ischild: bool,
}
extern "C" {
    #[link_name = "\u{1}b3s_bulletDNAstr"]
    pub static mut b3s_bulletDNAstr: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}b3s_bulletDNAlen"]
    pub static mut b3s_bulletDNAlen: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}b3s_bulletDNAstr64"]
    pub static mut b3s_bulletDNAstr64: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}b3s_bulletDNAlen64"]
    pub static mut b3s_bulletDNAlen64: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3Chunk {
    pub m_chunkCode: ::std::os::raw::c_int,
    pub m_length: ::std::os::raw::c_int,
    pub m_oldPtr: *mut ::std::os::raw::c_void,
    pub m_dna_nr: ::std::os::raw::c_int,
    pub m_number: ::std::os::raw::c_int,
}
pub const b3SerializationFlags_B3_SERIALIZE_NO_BVH: b3SerializationFlags = 1;
pub const b3SerializationFlags_B3_SERIALIZE_NO_TRIANGLEINFOMAP: b3SerializationFlags = 2;
pub const b3SerializationFlags_B3_SERIALIZE_NO_DUPLICATE_ASSERT: b3SerializationFlags = 4;
pub type b3SerializationFlags = u32;
#[repr(C)]
pub struct b3Serializer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct b3Serializer {
    pub vtable_: *const b3Serializer__bindgen_vtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3PointerUid {
    pub __bindgen_anon_1: b3PointerUid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3PointerUid__bindgen_ty_1 {
    pub m_ptr: *mut ::std::os::raw::c_void,
    pub m_uniqueIds: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
/// The b3DefaultSerializer is the main Bullet serialization class.
/// The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
#[repr(C)]
pub struct b3DefaultSerializer {
    pub _base: b3Serializer,
    pub mTypes: b3AlignedObjectArray<*mut ::std::os::raw::c_char>,
    pub mStructs: b3AlignedObjectArray<*mut ::std::os::raw::c_short>,
    pub mTlens: b3AlignedObjectArray<::std::os::raw::c_short>,
    pub mStructReverse: b3HashMap<b3HashInt, ::std::os::raw::c_int>,
    pub mTypeLookup: b3HashMap<b3HashString, ::std::os::raw::c_int>,
    pub m_chunkP: b3HashMap<b3HashPtr, *mut ::std::os::raw::c_void>,
    pub m_nameMap: b3HashMap<b3HashPtr, *const ::std::os::raw::c_char>,
    pub m_uniquePointers: b3HashMap<b3HashPtr, b3PointerUid>,
    pub m_uniqueIdGenerator: ::std::os::raw::c_int,
    pub m_totalSize: ::std::os::raw::c_int,
    pub m_buffer: *mut ::std::os::raw::c_uchar,
    pub m_currentSize: ::std::os::raw::c_int,
    pub m_dna: *mut ::std::os::raw::c_void,
    pub m_dnaLength: ::std::os::raw::c_int,
    pub m_serializationFlags: ::std::os::raw::c_int,
    pub m_chunkPtrs: b3AlignedObjectArray<*mut b3Chunk>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CpuNarrowPhaseInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CpuRigidBodyPipelineInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PrefixScanFloat4CL {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuRaycastInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuNarrowPhaseInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuJacobiSolverInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuPgsJacobiSolverInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BatchConstraint {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3GpuBatchingPgsSolverInternalData {
    pub _address: u8,
}
