/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const btVector3DataName: &'static [u8; 20usize] = b"btVector3DoubleData\0";
pub const btQuaternionDataName: &'static [u8; 23usize] = b"btQuaternionDoubleData\0";
pub const btPersistentManifoldDataName: &'static [u8; 31usize] =
    b"btPersistentManifoldDoubleData\0";
pub const btCollisionObjectDataName: &'static [u8; 28usize] = b"btCollisionObjectDoubleData\0";
pub const btQuantizedBvhDataName: &'static [u8; 25usize] = b"btQuantizedBvhDoubleData\0";
pub const btRigidBodyDataName: &'static [u8; 22usize] = b"btRigidBodyDoubleData\0";
pub const btTypedConstraintDataName: &'static [u8; 28usize] = b"btTypedConstraintDoubleData\0";
pub const btMultiBodyDataName: &'static [u8; 22usize] = b"btMultiBodyDoubleData\0";
pub const btMultiBodyLinkDataName: &'static [u8; 26usize] = b"btMultiBodyLinkDoubleData\0";
pub const btMultiBodyLinkColliderDataName: &'static [u8; 34usize] =
    b"btMultiBodyLinkColliderDoubleData\0";
pub const btSoftBodyDataName: &'static [u8; 20usize] = b"btSoftBodyFloatData\0";
pub const btPoint2PointConstraintDataName: &'static [u8; 35usize] =
    b"btPoint2PointConstraintDoubleData2\0";
pub const btHingeConstraintDataName: &'static [u8; 29usize] = b"btHingeConstraintDoubleData2\0";
pub const btConeTwistConstraintDataName: &'static [u8; 32usize] =
    b"btConeTwistConstraintDoubleData\0";
pub const btGeneric6DofConstraintDataName: &'static [u8; 35usize] =
    b"btGeneric6DofConstraintDoubleData2\0";
pub const btSliderConstraintDataName: &'static [u8; 29usize] = b"btSliderConstraintDoubleData\0";
pub const btGeneric6DofSpringConstraintDataName: &'static [u8; 41usize] =
    b"btGeneric6DofSpringConstraintDoubleData2\0";
pub const btGeneric6DofSpring2ConstraintDataName: &'static [u8; 42usize] =
    b"btGeneric6DofSpring2ConstraintDoubleData2\0";
pub const btGearConstraintDataName: &'static [u8; 27usize] = b"btGearConstraintDoubleData\0";
pub type wint_t = ::std::os::raw::c_ushort;
pub type btScalar = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btInfMaskConverter {
    pub __bindgen_anon_1: btInfMaskConverter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btInfMaskConverter__bindgen_ty_1 {
    pub mask: f32,
    pub intmask: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
extern "C" {
    #[link_name = "\u{1}btInfinityMask"]
    pub static mut btInfinityMask: btInfMaskConverter;
}
/// rudimentary class to provide type info
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedObject {
    pub m_objectType: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?btAlignedAllocInternal@@YAPEAX_KH@Z"]
    pub fn btAlignedAllocInternal(
        size: usize,
        alignment: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?btAlignedFreeInternal@@YAXPEAX@Z"]
    pub fn btAlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
}
pub type btAlignedAllocFunc = ::std::option::Option<
    unsafe extern "C" fn(size: usize, alignment: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void,
>;
pub type btAlignedFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
pub type btAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type btFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
    #[link_name = "\u{1}?btAlignedAllocSetCustom@@YAXP6APEAX_K@ZP6AXPEAX@Z@Z"]
    pub fn btAlignedAllocSetCustom(allocFunc: btAllocFunc, freeFunc: btFreeFunc);
}
extern "C" {
    /// If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
    #[link_name = "\u{1}?btAlignedAllocSetCustomAligned@@YAXP6APEAX_KH@ZP6AXPEAX@Z@Z"]
    pub fn btAlignedAllocSetCustomAligned(
        allocFunc: btAlignedAllocFunc,
        freeFunc: btAlignedFreeFunc,
    );
}
pub type btAlignedAllocator_self_type = u8;
pub type btAlignedAllocator_const_pointer<T> = *const T;
pub type btAlignedAllocator_const_reference<T> = *const T;
pub type btAlignedAllocator_pointer<T> = *mut T;
pub type btAlignedAllocator_reference<T> = *mut T;
pub type btAlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedAllocator_rebind {
    pub _address: u8,
}
pub type btAlignedAllocator_rebind_other = u8;
/// @brief btVector3 can be used to represent 3D points and vectors.
/// It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
/// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3 {
    pub m_floats: [btScalar; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector4 {
    pub _base: btVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3FloatData {
    pub m_floats: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3DoubleData {
    pub m_floats: [f64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuadWord {
    pub m_floats: [btScalar; 4usize],
}
/// @brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternion {
    pub _base: btQuadWord,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternionFloatData {
    pub m_floats: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternionDoubleData {
    pub m_floats: [f64; 4usize],
}
/// @brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
/// Make sure to only include a pure orthogonal matrix without scaling.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3 {
    /// Data storage for the matrix, each vector is a row of the matrix
    pub m_el: [btVector3; 3usize],
}
extern "C" {
    /// @brief Return the determinant of the matrix
    #[link_name = "\u{1}?determinant@btMatrix3x3@@QEBANXZ"]
    pub fn btMatrix3x3_determinant(this: *const btMatrix3x3) -> btScalar;
}
extern "C" {
    /// @brief Return the adjoint of the matrix
    #[link_name = "\u{1}?adjoint@btMatrix3x3@@QEBA?AV1@XZ"]
    pub fn btMatrix3x3_adjoint(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the matrix with all values non negative
    #[link_name = "\u{1}?absolute@btMatrix3x3@@QEBA?AV1@XZ"]
    pub fn btMatrix3x3_absolute(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the transpose of the matrix
    #[link_name = "\u{1}?transpose@btMatrix3x3@@QEBA?AV1@XZ"]
    pub fn btMatrix3x3_transpose(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the inverse of the matrix
    #[link_name = "\u{1}?inverse@btMatrix3x3@@QEBA?AV1@XZ"]
    pub fn btMatrix3x3_inverse(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?transposeTimes@btMatrix3x3@@QEBA?AV1@AEBV1@@Z"]
    pub fn btMatrix3x3_transposeTimes(
        this: *const btMatrix3x3,
        m: *const btMatrix3x3,
    ) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?timesTranspose@btMatrix3x3@@QEBA?AV1@AEBV1@@Z"]
    pub fn btMatrix3x3_timesTranspose(
        this: *const btMatrix3x3,
        m: *const btMatrix3x3,
    ) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?serialize@btMatrix3x3@@QEBAXAEAUbtMatrix3x3DoubleData@@@Z"]
    pub fn btMatrix3x3_serialize(this: *const btMatrix3x3, dataOut: *mut btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}?serializeFloat@btMatrix3x3@@QEBAXAEAUbtMatrix3x3FloatData@@@Z"]
    pub fn btMatrix3x3_serializeFloat(this: *const btMatrix3x3, dataOut: *mut btMatrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@btMatrix3x3@@QEAAXAEBUbtMatrix3x3DoubleData@@@Z"]
    pub fn btMatrix3x3_deSerialize(this: *mut btMatrix3x3, dataIn: *const btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}?deSerializeFloat@btMatrix3x3@@QEAAXAEBUbtMatrix3x3FloatData@@@Z"]
    pub fn btMatrix3x3_deSerializeFloat(
        this: *mut btMatrix3x3,
        dataIn: *const btMatrix3x3FloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerializeDouble@btMatrix3x3@@QEAAXAEBUbtMatrix3x3DoubleData@@@Z"]
    pub fn btMatrix3x3_deSerializeDouble(
        this: *mut btMatrix3x3,
        dataIn: *const btMatrix3x3DoubleData,
    );
}
impl btMatrix3x3 {
    #[inline]
    pub unsafe fn determinant(&self) -> btScalar {
        btMatrix3x3_determinant(self)
    }
    #[inline]
    pub unsafe fn adjoint(&self) -> btMatrix3x3 {
        btMatrix3x3_adjoint(self)
    }
    #[inline]
    pub unsafe fn absolute(&self) -> btMatrix3x3 {
        btMatrix3x3_absolute(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> btMatrix3x3 {
        btMatrix3x3_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> btMatrix3x3 {
        btMatrix3x3_inverse(self)
    }
    #[inline]
    pub unsafe fn transposeTimes(&self, m: *const btMatrix3x3) -> btMatrix3x3 {
        btMatrix3x3_transposeTimes(self, m)
    }
    #[inline]
    pub unsafe fn timesTranspose(&self, m: *const btMatrix3x3) -> btMatrix3x3 {
        btMatrix3x3_timesTranspose(self, m)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btMatrix3x3DoubleData) {
        btMatrix3x3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btMatrix3x3FloatData) {
        btMatrix3x3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btMatrix3x3FloatData) {
        btMatrix3x3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerializeDouble(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3FloatData {
    pub m_el: [btVector3FloatData; 3usize],
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3DoubleData {
    pub m_el: [btVector3DoubleData; 3usize],
}
/// @brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
/// It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransform {
    /// Storage for the rotation
    pub m_basis: btMatrix3x3,
    /// Storage for the translation
    pub m_origin: btVector3,
}
extern "C" {
    /// @brief Return the inverse of this transform times the other transform
    /// @param t The other transform
    /// return this.inverse() * the other
    #[link_name = "\u{1}?inverseTimes@btTransform@@QEBA?AV1@AEBV1@@Z"]
    pub fn btTransform_inverseTimes(this: *const btTransform, t: *const btTransform)
        -> btTransform;
}
extern "C" {
    #[link_name = "\u{1}?serialize@btTransform@@QEBAXAEAUbtTransformDoubleData@@@Z"]
    pub fn btTransform_serialize(this: *const btTransform, dataOut: *mut btTransformDoubleData);
}
extern "C" {
    #[link_name = "\u{1}?serializeFloat@btTransform@@QEBAXAEAUbtTransformFloatData@@@Z"]
    pub fn btTransform_serializeFloat(this: *const btTransform, dataOut: *mut btTransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@btTransform@@QEAAXAEBUbtTransformDoubleData@@@Z"]
    pub fn btTransform_deSerialize(this: *mut btTransform, dataIn: *const btTransformDoubleData);
}
extern "C" {
    #[link_name = "\u{1}?deSerializeDouble@btTransform@@QEAAXAEBUbtTransformDoubleData@@@Z"]
    pub fn btTransform_deSerializeDouble(
        this: *mut btTransform,
        dataIn: *const btTransformDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerializeFloat@btTransform@@QEAAXAEBUbtTransformFloatData@@@Z"]
    pub fn btTransform_deSerializeFloat(
        this: *mut btTransform,
        dataIn: *const btTransformFloatData,
    );
}
impl btTransform {
    #[inline]
    pub unsafe fn inverseTimes(&self, t: *const btTransform) -> btTransform {
        btTransform_inverseTimes(self, t)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btTransformDoubleData) {
        btTransform_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btTransformFloatData) {
        btTransform_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btTransformDoubleData) {
        btTransform_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btTransformDoubleData) {
        btTransform_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btTransformFloatData) {
        btTransform_deSerializeFloat(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformFloatData {
    pub m_basis: btMatrix3x3FloatData,
    pub m_origin: btVector3FloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformDoubleData {
    pub m_basis: btMatrix3x3DoubleData,
    pub m_origin: btVector3DoubleData,
}
#[repr(C)]
pub struct btDiscreteCollisionDetectorInterface__bindgen_vtable(::std::os::raw::c_void);
/// This interface is made to be used by an iterative approach to do TimeOfImpact calculations
/// This interface allows to query for closest points and penetration depth between two (convex) objects
/// the closest point is on the second object (B), and the normal points from the surface on B towards A.
/// distance is between closest points on B and closest point on A. So you can calculate closest point on A
/// by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteCollisionDetectorInterface {
    pub vtable_: *const btDiscreteCollisionDetectorInterface__bindgen_vtable,
}
#[repr(C)]
pub struct btDiscreteCollisionDetectorInterface_Result__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteCollisionDetectorInterface_Result {
    pub vtable_: *const btDiscreteCollisionDetectorInterface_Result__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDiscreteCollisionDetectorInterface_ClosestPointInput {
    pub m_transformA: btTransform,
    pub m_transformB: btTransform,
    pub m_maximumDistanceSquared: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btStorageResult {
    pub _base: btDiscreteCollisionDetectorInterface_Result,
    pub __bindgen_padding_0: u64,
    pub m_normalOnSurfaceB: btVector3,
    pub m_closestPointInB: btVector3,
    pub m_distance: btScalar,
    pub __bindgen_padding_1: u64,
}
/// The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct btAlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedObjectArray_less {
    pub _address: u8,
}
pub type btManifoldArray = btAlignedObjectArray<*mut btPersistentManifold>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionAlgorithmConstructionInfo {
    pub m_dispatcher1: *mut btDispatcher,
    pub m_manifold: *mut btPersistentManifold,
}
#[repr(C)]
pub struct btCollisionAlgorithm__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
/// It is persistent over frames
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionAlgorithm {
    pub vtable_: *const btCollisionAlgorithm__bindgen_vtable,
    pub m_dispatcher: *mut btDispatcher,
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z"]
    pub fn btCollisionAlgorithm_btCollisionAlgorithm(
        this: *mut btCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
impl btCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithm_btCollisionAlgorithm(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
}
/// This class is not enabled yet (work-in-progress) to more aggressively activate objects.
#[repr(C)]
#[derive(Debug)]
pub struct btActivatingCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
}
extern "C" {
    #[link_name = "\u{1}??0btActivatingCollisionAlgorithm@@IEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(
        this: *mut btActivatingCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btActivatingCollisionAlgorithm@@IEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1@Z"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
        this: *mut btActivatingCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btActivatingCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtActivatingCollisionAlgorithm@@QEAAXXZ"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm_destructor(
        this: *mut btActivatingCollisionAlgorithm,
    );
}
/// The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
/// It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBroadphaseProxy {
    pub m_clientObject: *mut ::std::os::raw::c_void,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
}
pub const btBroadphaseProxy_CollisionFilterGroups_DefaultFilter:
    btBroadphaseProxy_CollisionFilterGroups = 1;
pub const btBroadphaseProxy_CollisionFilterGroups_StaticFilter:
    btBroadphaseProxy_CollisionFilterGroups = 2;
pub const btBroadphaseProxy_CollisionFilterGroups_KinematicFilter:
    btBroadphaseProxy_CollisionFilterGroups = 4;
pub const btBroadphaseProxy_CollisionFilterGroups_DebrisFilter:
    btBroadphaseProxy_CollisionFilterGroups = 8;
pub const btBroadphaseProxy_CollisionFilterGroups_SensorTrigger:
    btBroadphaseProxy_CollisionFilterGroups = 16;
pub const btBroadphaseProxy_CollisionFilterGroups_CharacterFilter:
    btBroadphaseProxy_CollisionFilterGroups = 32;
pub const btBroadphaseProxy_CollisionFilterGroups_AllFilter:
    btBroadphaseProxy_CollisionFilterGroups = -1;
/// optional filtering to cull potential collisions
pub type btBroadphaseProxy_CollisionFilterGroups = i32;
/// The btBroadphasePair class contains a pair of aabb-overlapping objects.
/// A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btBroadphasePair {
    pub m_pProxy0: *mut btBroadphaseProxy,
    pub m_pProxy1: *mut btBroadphaseProxy,
    pub m_algorithm: *mut btCollisionAlgorithm,
    pub __bindgen_anon_1: btBroadphasePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btBroadphasePair__bindgen_ty_1 {
    pub m_internalInfo1: *mut ::std::os::raw::c_void,
    pub m_internalTmpValue: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBroadphasePairSortPredicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDispatcherInfo {
    pub m_timeStep: btScalar,
    pub m_stepCount: ::std::os::raw::c_int,
    pub m_dispatchFunc: ::std::os::raw::c_int,
    pub m_timeOfImpact: btScalar,
    pub m_useContinuous: bool,
    pub m_debugDraw: *mut btIDebugDraw,
    pub m_enableSatConvex: bool,
    pub m_enableSPU: bool,
    pub m_useEpa: bool,
    pub m_allowedCcdPenetration: btScalar,
    pub m_useConvexConservativeDistanceUtil: bool,
    pub m_convexConservativeDistanceThreshold: btScalar,
    pub m_deterministicOverlappingPairs: bool,
}
pub const btDispatcherInfo_DispatchFunc_DISPATCH_DISCRETE: btDispatcherInfo_DispatchFunc = 1;
pub const btDispatcherInfo_DispatchFunc_DISPATCH_CONTINUOUS: btDispatcherInfo_DispatchFunc = 2;
pub type btDispatcherInfo_DispatchFunc = i32;
pub const ebtDispatcherQueryType_BT_CONTACT_POINT_ALGORITHMS: ebtDispatcherQueryType = 1;
pub const ebtDispatcherQueryType_BT_CLOSEST_POINT_ALGORITHMS: ebtDispatcherQueryType = 2;
pub type ebtDispatcherQueryType = i32;
#[repr(C)]
pub struct btDispatcher__bindgen_vtable(::std::os::raw::c_void);
/// The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
/// For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
#[repr(C)]
#[derive(Debug)]
pub struct btDispatcher {
    pub vtable_: *const btDispatcher__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}??_DbtDispatcher@@QEAAXXZ"]
    pub fn btDispatcher_btDispatcher_destructor(this: *mut btDispatcher);
}
#[repr(C)]
pub struct btCollisionAlgorithmCreateFunc__bindgen_vtable(::std::os::raw::c_void);
/// Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionAlgorithmCreateFunc {
    pub vtable_: *const btCollisionAlgorithmCreateFunc__bindgen_vtable,
    pub m_swapped: bool,
}
/// box-box collision detection
#[repr(C)]
#[derive(Debug)]
pub struct btBox2dBox2dCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
#[repr(C)]
#[derive(Debug)]
pub struct btBox2dBox2dCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btBox2dBox2dCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z"]
    pub fn btBox2dBox2dCollisionAlgorithm_btBox2dBox2dCollisionAlgorithm(
        this: *mut btBox2dBox2dCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btBox2dBox2dCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBox2dBox2dCollisionAlgorithm_btBox2dBox2dCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btBox2dBox2dCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btBox2dBox2dCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btBox2dBox2dCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btBox2dBox2dCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtBox2dBox2dCollisionAlgorithm@@QEAAXXZ"]
    pub fn btBox2dBox2dCollisionAlgorithm_btBox2dBox2dCollisionAlgorithm_destructor(
        this: *mut btBox2dBox2dCollisionAlgorithm,
    );
}
/// box-box collision detection
#[repr(C)]
#[derive(Debug)]
pub struct btBoxBoxCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
#[repr(C)]
#[derive(Debug)]
pub struct btBoxBoxCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btBoxBoxCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z"]
    pub fn btBoxBoxCollisionAlgorithm_btBoxBoxCollisionAlgorithm(
        this: *mut btBoxBoxCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btBoxBoxCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBoxBoxCollisionAlgorithm_btBoxBoxCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btBoxBoxCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btBoxBoxCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btBoxBoxCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btBoxBoxCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtBoxBoxCollisionAlgorithm@@QEAAXXZ"]
    pub fn btBoxBoxCollisionAlgorithm_btBoxBoxCollisionAlgorithm_destructor(
        this: *mut btBoxBoxCollisionAlgorithm,
    );
}
/// btBoxBoxDetector wraps the ODE box-box collision detector
/// re-distributed under the Zlib license with permission from Russell L. Smith
#[repr(C)]
#[derive(Debug)]
pub struct btBoxBoxDetector {
    pub _base: btDiscreteCollisionDetectorInterface,
    pub m_box1: *const btBoxShape,
    pub m_box2: *const btBoxShape,
}
extern "C" {
    #[link_name = "\u{1}??0btBoxBoxDetector@@QEAA@PEBVbtBoxShape@@0@Z"]
    pub fn btBoxBoxDetector_btBoxBoxDetector(
        this: *mut btBoxBoxDetector,
        box1: *const btBoxShape,
        box2: *const btBoxShape,
    );
}
impl btBoxBoxDetector {
    #[inline]
    pub unsafe fn new(box1: *const btBoxShape, box2: *const btBoxShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBoxBoxDetector_btBoxBoxDetector(&mut __bindgen_tmp, box1, box2);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getClosestPoints@btBoxBoxDetector@@UEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@_N@Z"]
    pub fn btBoxBoxDetector_getClosestPoints(
        this: *mut ::std::os::raw::c_void,
        input: *const btDiscreteCollisionDetectorInterface_ClosestPointInput,
        output: *mut btDiscreteCollisionDetectorInterface_Result,
        debugDraw: *mut btIDebugDraw,
        swapResults: bool,
    );
}
/// Utils related to temporal transforms
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformUtil {
    pub _address: u8,
}
/// The btConvexSeparatingDistanceUtil can help speed up convex collision detection
/// by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexSeparatingDistanceUtil {
    pub m_ornA: btQuaternion,
    pub m_ornB: btQuaternion,
    pub m_posA: btVector3,
    pub m_posB: btVector3,
    pub m_separatingNormal: btVector3,
    pub m_boundingRadiusA: btScalar,
    pub m_boundingRadiusB: btScalar,
    pub m_separatingDistance: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConstraintRow {
    pub m_normal: [btScalar; 3usize],
    pub m_rhs: btScalar,
    pub m_jacDiagInv: btScalar,
    pub m_lowerLimit: btScalar,
    pub m_upperLimit: btScalar,
    pub m_accumImpulse: btScalar,
}
pub const btContactPointFlags_BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED: btContactPointFlags = 1;
pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_CFM: btContactPointFlags = 2;
pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_ERP: btContactPointFlags = 4;
pub const btContactPointFlags_BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING: btContactPointFlags = 8;
pub const btContactPointFlags_BT_CONTACT_FLAG_FRICTION_ANCHOR: btContactPointFlags = 16;
pub type btContactPointFlags = i32;
/// ManifoldContactPoint collects and maintains persistent contactpoints.
/// used to improve stability and performance of rigidbody dynamics response.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btManifoldPoint {
    pub m_localPointA: btVector3,
    pub m_localPointB: btVector3,
    pub m_positionWorldOnB: btVector3,
    /// m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
    pub m_positionWorldOnA: btVector3,
    pub m_normalWorldOnB: btVector3,
    pub m_distance1: btScalar,
    pub m_combinedFriction: btScalar,
    pub m_combinedRollingFriction: btScalar,
    pub m_combinedSpinningFriction: btScalar,
    pub m_combinedRestitution: btScalar,
    pub m_partId0: ::std::os::raw::c_int,
    pub m_partId1: ::std::os::raw::c_int,
    pub m_index0: ::std::os::raw::c_int,
    pub m_index1: ::std::os::raw::c_int,
    pub m_userPersistentData: *mut ::std::os::raw::c_void,
    pub m_contactPointFlags: ::std::os::raw::c_int,
    pub m_appliedImpulse: btScalar,
    pub m_appliedImpulseLateral1: btScalar,
    pub m_appliedImpulseLateral2: btScalar,
    pub m_contactMotion1: btScalar,
    pub m_contactMotion2: btScalar,
    pub __bindgen_anon_1: btManifoldPoint__bindgen_ty_1,
    pub __bindgen_anon_2: btManifoldPoint__bindgen_ty_2,
    pub m_frictionCFM: btScalar,
    pub m_lifeTime: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_lateralFrictionDir1: btVector3,
    pub m_lateralFrictionDir2: btVector3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btManifoldPoint__bindgen_ty_1 {
    pub m_contactCFM: btScalar,
    pub m_combinedContactStiffness1: btScalar,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btManifoldPoint__bindgen_ty_2 {
    pub m_contactERP: btScalar,
    pub m_combinedContactDamping1: btScalar,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionResult {
    _unused: [u8; 0],
}
pub const btContactManifoldTypes_MIN_CONTACT_MANIFOLD_TYPE: btContactManifoldTypes = 1024;
pub const btContactManifoldTypes_BT_PERSISTENT_MANIFOLD_TYPE: btContactManifoldTypes = 1025;
pub type btContactManifoldTypes = i32;
/// btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
/// Those contact points are created by the collision narrow phase.
/// The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
/// updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
/// reduces the cache to 4 points, when more then 4 points are added, using following rules:
/// the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
/// note that some pairs of objects might have more then one contact manifold.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btPersistentManifold {
    pub _base: btTypedObject,
    pub __bindgen_padding_0: u64,
    pub m_pointCache: [btManifoldPoint; 4usize],
    /// this two body pointers can point to the physics rigidbody class.
    pub m_body0: *const btCollisionObject,
    pub m_body1: *const btCollisionObject,
    pub m_cachedPoints: ::std::os::raw::c_int,
    pub m_contactBreakingThreshold: btScalar,
    pub m_contactProcessingThreshold: btScalar,
    pub m_companionIdA: ::std::os::raw::c_int,
    pub m_companionIdB: ::std::os::raw::c_int,
    pub m_index1a: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}?clearUserCache@btPersistentManifold@@QEAAXAEAVbtManifoldPoint@@@Z"]
    pub fn btPersistentManifold_clearUserCache(
        this: *mut btPersistentManifold,
        pt: *mut btManifoldPoint,
    );
}
extern "C" {
    /// @todo: get this margin from the current physics / collision environment
    #[link_name = "\u{1}?getContactBreakingThreshold@btPersistentManifold@@QEBANXZ"]
    pub fn btPersistentManifold_getContactBreakingThreshold(
        this: *const btPersistentManifold,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getCacheEntry@btPersistentManifold@@QEBAHAEBVbtManifoldPoint@@@Z"]
    pub fn btPersistentManifold_getCacheEntry(
        this: *const btPersistentManifold,
        newPoint: *const btManifoldPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?addManifoldPoint@btPersistentManifold@@QEAAHAEBVbtManifoldPoint@@_N@Z"]
    pub fn btPersistentManifold_addManifoldPoint(
        this: *mut btPersistentManifold,
        newPoint: *const btManifoldPoint,
        isPredictive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
    #[link_name = "\u{1}?refreshContactPoints@btPersistentManifold@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btPersistentManifold_refreshContactPoints(
        this: *mut btPersistentManifold,
        trA: *const btTransform,
        trB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btPersistentManifold@@QEBAHXZ"]
    pub fn btPersistentManifold_calculateSerializeBufferSize(
        this: *const btPersistentManifold,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?serialize@btPersistentManifold@@QEBAPEBDPEBV1@PEAXPEAVbtSerializer@@@Z"]
    pub fn btPersistentManifold_serialize(
        this: *const btPersistentManifold,
        manifold: *const btPersistentManifold,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@btPersistentManifold@@QEAAXPEBUbtPersistentManifoldDoubleData@@@Z"]
    pub fn btPersistentManifold_deSerialize(
        this: *mut btPersistentManifold,
        manifoldDataPtr: *const btPersistentManifoldDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerialize@btPersistentManifold@@QEAAXPEBUbtPersistentManifoldFloatData@@@Z"]
    pub fn btPersistentManifold_deSerialize1(
        this: *mut btPersistentManifold,
        manifoldDataPtr: *const btPersistentManifoldFloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btPersistentManifold@@QEAA@XZ"]
    pub fn btPersistentManifold_btPersistentManifold(this: *mut btPersistentManifold);
}
impl btPersistentManifold {
    #[inline]
    pub unsafe fn clearUserCache(&mut self, pt: *mut btManifoldPoint) {
        btPersistentManifold_clearUserCache(self, pt)
    }
    #[inline]
    pub unsafe fn getContactBreakingThreshold(&self) -> btScalar {
        btPersistentManifold_getContactBreakingThreshold(self)
    }
    #[inline]
    pub unsafe fn getCacheEntry(&self, newPoint: *const btManifoldPoint) -> ::std::os::raw::c_int {
        btPersistentManifold_getCacheEntry(self, newPoint)
    }
    #[inline]
    pub unsafe fn addManifoldPoint(
        &mut self,
        newPoint: *const btManifoldPoint,
        isPredictive: bool,
    ) -> ::std::os::raw::c_int {
        btPersistentManifold_addManifoldPoint(self, newPoint, isPredictive)
    }
    #[inline]
    pub unsafe fn refreshContactPoints(
        &mut self,
        trA: *const btTransform,
        trB: *const btTransform,
    ) {
        btPersistentManifold_refreshContactPoints(self, trA, trB)
    }
    #[inline]
    pub unsafe fn calculateSerializeBufferSize(&self) -> ::std::os::raw::c_int {
        btPersistentManifold_calculateSerializeBufferSize(self)
    }
    #[inline]
    pub unsafe fn serialize(
        &self,
        manifold: *const btPersistentManifold,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char {
        btPersistentManifold_serialize(self, manifold, dataBuffer, serializer)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, manifoldDataPtr: *const btPersistentManifoldDoubleData) {
        btPersistentManifold_deSerialize(self, manifoldDataPtr)
    }
    #[inline]
    pub unsafe fn deSerialize1(&mut self, manifoldDataPtr: *const btPersistentManifoldFloatData) {
        btPersistentManifold_deSerialize1(self, manifoldDataPtr)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPersistentManifold_btPersistentManifold(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPersistentManifoldDoubleData {
    pub m_pointCacheLocalPointA: [btVector3DoubleData; 4usize],
    pub m_pointCacheLocalPointB: [btVector3DoubleData; 4usize],
    pub m_pointCachePositionWorldOnA: [btVector3DoubleData; 4usize],
    pub m_pointCachePositionWorldOnB: [btVector3DoubleData; 4usize],
    pub m_pointCacheNormalWorldOnB: [btVector3DoubleData; 4usize],
    pub m_pointCacheLateralFrictionDir1: [btVector3DoubleData; 4usize],
    pub m_pointCacheLateralFrictionDir2: [btVector3DoubleData; 4usize],
    pub m_pointCacheDistance: [f64; 4usize],
    pub m_pointCacheAppliedImpulse: [f64; 4usize],
    pub m_pointCacheCombinedFriction: [f64; 4usize],
    pub m_pointCacheCombinedRollingFriction: [f64; 4usize],
    pub m_pointCacheCombinedSpinningFriction: [f64; 4usize],
    pub m_pointCacheCombinedRestitution: [f64; 4usize],
    pub m_pointCachePartId0: [::std::os::raw::c_int; 4usize],
    pub m_pointCachePartId1: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheIndex0: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheIndex1: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheContactPointFlags: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheAppliedImpulseLateral1: [f64; 4usize],
    pub m_pointCacheAppliedImpulseLateral2: [f64; 4usize],
    pub m_pointCacheContactMotion1: [f64; 4usize],
    pub m_pointCacheContactMotion2: [f64; 4usize],
    pub m_pointCacheContactCFM: [f64; 4usize],
    pub m_pointCacheCombinedContactStiffness1: [f64; 4usize],
    pub m_pointCacheContactERP: [f64; 4usize],
    pub m_pointCacheCombinedContactDamping1: [f64; 4usize],
    pub m_pointCacheFrictionCFM: [f64; 4usize],
    pub m_pointCacheLifeTime: [::std::os::raw::c_int; 4usize],
    pub m_numCachedPoints: ::std::os::raw::c_int,
    pub m_companionIdA: ::std::os::raw::c_int,
    pub m_companionIdB: ::std::os::raw::c_int,
    pub m_index1a: ::std::os::raw::c_int,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_contactBreakingThreshold: f64,
    pub m_contactProcessingThreshold: f64,
    pub m_padding: ::std::os::raw::c_int,
    pub m_body0: *mut btCollisionObjectDoubleData,
    pub m_body1: *mut btCollisionObjectDoubleData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPersistentManifoldFloatData {
    pub m_pointCacheLocalPointA: [btVector3FloatData; 4usize],
    pub m_pointCacheLocalPointB: [btVector3FloatData; 4usize],
    pub m_pointCachePositionWorldOnA: [btVector3FloatData; 4usize],
    pub m_pointCachePositionWorldOnB: [btVector3FloatData; 4usize],
    pub m_pointCacheNormalWorldOnB: [btVector3FloatData; 4usize],
    pub m_pointCacheLateralFrictionDir1: [btVector3FloatData; 4usize],
    pub m_pointCacheLateralFrictionDir2: [btVector3FloatData; 4usize],
    pub m_pointCacheDistance: [f32; 4usize],
    pub m_pointCacheAppliedImpulse: [f32; 4usize],
    pub m_pointCacheCombinedFriction: [f32; 4usize],
    pub m_pointCacheCombinedRollingFriction: [f32; 4usize],
    pub m_pointCacheCombinedSpinningFriction: [f32; 4usize],
    pub m_pointCacheCombinedRestitution: [f32; 4usize],
    pub m_pointCachePartId0: [::std::os::raw::c_int; 4usize],
    pub m_pointCachePartId1: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheIndex0: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheIndex1: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheContactPointFlags: [::std::os::raw::c_int; 4usize],
    pub m_pointCacheAppliedImpulseLateral1: [f32; 4usize],
    pub m_pointCacheAppliedImpulseLateral2: [f32; 4usize],
    pub m_pointCacheContactMotion1: [f32; 4usize],
    pub m_pointCacheContactMotion2: [f32; 4usize],
    pub m_pointCacheContactCFM: [f32; 4usize],
    pub m_pointCacheCombinedContactStiffness1: [f32; 4usize],
    pub m_pointCacheContactERP: [f32; 4usize],
    pub m_pointCacheCombinedContactDamping1: [f32; 4usize],
    pub m_pointCacheFrictionCFM: [f32; 4usize],
    pub m_pointCacheLifeTime: [::std::os::raw::c_int; 4usize],
    pub m_numCachedPoints: ::std::os::raw::c_int,
    pub m_companionIdA: ::std::os::raw::c_int,
    pub m_companionIdB: ::std::os::raw::c_int,
    pub m_index1a: ::std::os::raw::c_int,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_contactBreakingThreshold: f32,
    pub m_contactProcessingThreshold: f32,
    pub m_padding: ::std::os::raw::c_int,
    pub m_body0: *mut btCollisionObjectFloatData,
    pub m_body1: *mut btCollisionObjectFloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectWrapper {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
#[repr(C)]
pub struct btMotionState__bindgen_vtable(::std::os::raw::c_void);
/// The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
/// For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
#[repr(C)]
#[derive(Debug)]
pub struct btMotionState {
    pub vtable_: *const btMotionState__bindgen_vtable,
}
pub type btCollisionObjectArray = btAlignedObjectArray<*mut btCollisionObject>;
#[repr(C)]
pub struct btCollisionObject__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionObject {
    pub vtable_: *const btCollisionObject__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_worldTransform: btTransform,
    /// m_interpolationWorldTransform is used for CCD and interpolation
    /// ///it can be either previous or future (predicted) transform
    pub m_interpolationWorldTransform: btTransform,
    pub m_interpolationLinearVelocity: btVector3,
    pub m_interpolationAngularVelocity: btVector3,
    pub m_anisotropicFriction: btVector3,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_contactProcessingThreshold: btScalar,
    pub m_broadphaseHandle: *mut btBroadphaseProxy,
    pub m_collisionShape: *mut btCollisionShape,
    /// m_extensionPointer is used by some internal low-level Bullet extensions.
    pub m_extensionPointer: *mut ::std::os::raw::c_void,
    /// m_rootCollisionShape is temporarily used to store the original collision shape
    /// ///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
    /// ///If it is NULL, the m_collisionShape is not temporarily replaced.
    pub m_rootCollisionShape: *mut btCollisionShape,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_worldArrayIndex: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_deactivationTime: btScalar,
    pub m_friction: btScalar,
    pub m_restitution: btScalar,
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    pub m_contactDamping: btScalar,
    pub m_contactStiffness: btScalar,
    /// m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
    /// ///do not assign your own m_internalType unless you write a new dynamics object class.
    pub m_internalType: ::std::os::raw::c_int,
    /// users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
    pub m_userObjectPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex2: ::std::os::raw::c_int,
    pub m_userIndex: ::std::os::raw::c_int,
    /// time of impact calculation
    pub m_hitFraction: btScalar,
    /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    pub m_ccdSweptSphereRadius: btScalar,
    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
    pub m_ccdMotionThreshold: btScalar,
    /// If some object should have elaborate collision filtering by sub-classes
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_objectsWithoutCollisionCheck: btAlignedObjectArray<*const btCollisionObject>,
    /// internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
    pub m_updateRevision: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u64; 0usize],
    pub m_customDebugColorRGB: btVector3,
}
pub const btCollisionObject_CollisionFlags_CF_STATIC_OBJECT: btCollisionObject_CollisionFlags = 1;
pub const btCollisionObject_CollisionFlags_CF_KINEMATIC_OBJECT: btCollisionObject_CollisionFlags =
    2;
pub const btCollisionObject_CollisionFlags_CF_NO_CONTACT_RESPONSE:
    btCollisionObject_CollisionFlags = 4;
pub const btCollisionObject_CollisionFlags_CF_CUSTOM_MATERIAL_CALLBACK:
    btCollisionObject_CollisionFlags = 8;
pub const btCollisionObject_CollisionFlags_CF_CHARACTER_OBJECT: btCollisionObject_CollisionFlags =
    16;
pub const btCollisionObject_CollisionFlags_CF_DISABLE_VISUALIZE_OBJECT:
    btCollisionObject_CollisionFlags = 32;
pub const btCollisionObject_CollisionFlags_CF_DISABLE_SPU_COLLISION_PROCESSING:
    btCollisionObject_CollisionFlags = 64;
pub const btCollisionObject_CollisionFlags_CF_HAS_CONTACT_STIFFNESS_DAMPING:
    btCollisionObject_CollisionFlags = 128;
pub const btCollisionObject_CollisionFlags_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR:
    btCollisionObject_CollisionFlags = 256;
pub const btCollisionObject_CollisionFlags_CF_HAS_FRICTION_ANCHOR:
    btCollisionObject_CollisionFlags = 512;
pub const btCollisionObject_CollisionFlags_CF_HAS_COLLISION_SOUND_TRIGGER:
    btCollisionObject_CollisionFlags = 1024;
pub type btCollisionObject_CollisionFlags = i32;
pub const btCollisionObject_CollisionObjectTypes_CO_COLLISION_OBJECT:
    btCollisionObject_CollisionObjectTypes = 1;
pub const btCollisionObject_CollisionObjectTypes_CO_RIGID_BODY:
    btCollisionObject_CollisionObjectTypes = 2;
/// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
/// ///It is useful for collision sensors, explosion objects, character controller etc.
pub const btCollisionObject_CollisionObjectTypes_CO_GHOST_OBJECT:
    btCollisionObject_CollisionObjectTypes = 4;
/// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
/// ///It is useful for collision sensors, explosion objects, character controller etc.
pub const btCollisionObject_CollisionObjectTypes_CO_SOFT_BODY:
    btCollisionObject_CollisionObjectTypes = 8;
/// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
/// ///It is useful for collision sensors, explosion objects, character controller etc.
pub const btCollisionObject_CollisionObjectTypes_CO_HF_FLUID:
    btCollisionObject_CollisionObjectTypes = 16;
/// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
/// ///It is useful for collision sensors, explosion objects, character controller etc.
pub const btCollisionObject_CollisionObjectTypes_CO_USER_TYPE:
    btCollisionObject_CollisionObjectTypes = 32;
/// CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
/// ///It is useful for collision sensors, explosion objects, character controller etc.
pub const btCollisionObject_CollisionObjectTypes_CO_FEATHERSTONE_LINK:
    btCollisionObject_CollisionObjectTypes = 64;
pub type btCollisionObject_CollisionObjectTypes = i32;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION_DISABLED:
    btCollisionObject_AnisotropicFrictionFlags = 0;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION:
    btCollisionObject_AnisotropicFrictionFlags = 1;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_ROLLING_FRICTION:
    btCollisionObject_AnisotropicFrictionFlags = 2;
pub type btCollisionObject_AnisotropicFrictionFlags = i32;
extern "C" {
    #[link_name = "\u{1}?setActivationState@btCollisionObject@@QEBAXH@Z"]
    pub fn btCollisionObject_setActivationState(
        this: *const btCollisionObject,
        newState: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?forceActivationState@btCollisionObject@@QEBAXH@Z"]
    pub fn btCollisionObject_forceActivationState(
        this: *const btCollisionObject,
        newState: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?activate@btCollisionObject@@QEBAX_N@Z"]
    pub fn btCollisionObject_activate(this: *const btCollisionObject, forceActivation: bool);
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionObject@@QEAA@XZ"]
    pub fn btCollisionObject_btCollisionObject(this: *mut btCollisionObject);
}
impl btCollisionObject {
    #[inline]
    pub unsafe fn setActivationState(&self, newState: ::std::os::raw::c_int) {
        btCollisionObject_setActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn forceActivationState(&self, newState: ::std::os::raw::c_int) {
        btCollisionObject_forceActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn activate(&self, forceActivation: bool) {
        btCollisionObject_activate(self, forceActivation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionObject_btCollisionObject(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCollisionObject@@QEAAXXZ"]
    pub fn btCollisionObject_btCollisionObject_destructor(this: *mut btCollisionObject);
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btCollisionObject@@UEBAHXZ"]
    pub fn btCollisionObject_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btCollisionObject@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionObject_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?serializeSingleObject@btCollisionObject@@UEBAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionObject_serializeSingleObject(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectDoubleData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformDoubleData,
    pub m_interpolationWorldTransform: btTransformDoubleData,
    pub m_interpolationLinearVelocity: btVector3DoubleData,
    pub m_interpolationAngularVelocity: btVector3DoubleData,
    pub m_anisotropicFriction: btVector3DoubleData,
    pub m_contactProcessingThreshold: f64,
    pub m_deactivationTime: f64,
    pub m_friction: f64,
    pub m_rollingFriction: f64,
    pub m_contactDamping: f64,
    pub m_contactStiffness: f64,
    pub m_restitution: f64,
    pub m_hitFraction: f64,
    pub m_ccdSweptSphereRadius: f64,
    pub m_ccdMotionThreshold: f64,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectFloatData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformFloatData,
    pub m_interpolationWorldTransform: btTransformFloatData,
    pub m_interpolationLinearVelocity: btVector3FloatData,
    pub m_interpolationAngularVelocity: btVector3FloatData,
    pub m_anisotropicFriction: btVector3FloatData,
    pub m_contactProcessingThreshold: f32,
    pub m_deactivationTime: f32,
    pub m_friction: f32,
    pub m_rollingFriction: f32,
    pub m_contactDamping: f32,
    pub m_contactStiffness: f32,
    pub m_restitution: f32,
    pub m_hitFraction: f32,
    pub m_ccdSweptSphereRadius: f32,
    pub m_ccdMotionThreshold: f32,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
}
/// btManifoldResult is a helper class to manage  contact results.
#[repr(C)]
#[derive(Debug)]
pub struct btManifoldResult {
    pub _base: btDiscreteCollisionDetectorInterface_Result,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_body0Wrap: *const btCollisionObjectWrapper,
    pub m_body1Wrap: *const btCollisionObjectWrapper,
    pub m_partId0: ::std::os::raw::c_int,
    pub m_partId1: ::std::os::raw::c_int,
    pub m_index0: ::std::os::raw::c_int,
    pub m_index1: ::std::os::raw::c_int,
    pub m_closestPointDistanceThreshold: btScalar,
}
extern "C" {
    /// in the future we can let the user override the methods to combine restitution and friction
    #[link_name = "\u{1}?calculateCombinedRestitution@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedRestitution(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateCombinedFriction@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateCombinedRollingFriction@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedRollingFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateCombinedSpinningFriction@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedSpinningFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateCombinedContactDamping@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedContactDamping(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateCombinedContactStiffness@btManifoldResult@@SANPEBVbtCollisionObject@@0@Z"]
    pub fn btManifoldResult_calculateCombinedContactStiffness(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??0btManifoldResult@@QEAA@PEBUbtCollisionObjectWrapper@@0@Z"]
    pub fn btManifoldResult_btManifoldResult(
        this: *mut btManifoldResult,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btManifoldResult {
    #[inline]
    pub unsafe fn calculateCombinedRestitution(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedRestitution(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedRollingFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedRollingFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedSpinningFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedSpinningFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedContactDamping(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedContactDamping(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedContactStiffness(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedContactStiffness(body0, body1)
    }
    #[inline]
    pub unsafe fn new(
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btManifoldResult_btManifoldResult(&mut __bindgen_tmp, body0Wrap, body1Wrap);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?addContactPoint@btManifoldResult@@UEAAXAEBVbtVector3@@0N@Z"]
    pub fn btManifoldResult_addContactPoint(
        this: *mut ::std::os::raw::c_void,
        normalOnBInWorld: *const btVector3,
        pointInWorld: *const btVector3,
        depth: btScalar,
    );
}
/// user can override this nearcallback for collision filtering and more finegrained control over collision detection
pub type btNearCallback = ::std::option::Option<
    unsafe extern "C" fn(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    ),
>;
/// btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
/// Time of Impact, Closest Points and Penetration Depth.
#[repr(C)]
pub struct btCollisionDispatcher {
    pub _base: btDispatcher,
    pub m_dispatcherFlags: ::std::os::raw::c_int,
    pub m_manifoldsPtr: btAlignedObjectArray<*mut btPersistentManifold>,
    pub m_defaultManifoldResult: btManifoldResult,
    pub m_nearCallback: btNearCallback,
    pub m_collisionAlgorithmPoolAllocator: *mut btPoolAllocator,
    pub m_persistentManifoldPoolAllocator: *mut btPoolAllocator,
    pub m_doubleDispatchContactPoints: [[*mut btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
    pub m_doubleDispatchClosestPoints: [[*mut btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
    pub m_collisionConfiguration: *mut btCollisionConfiguration,
}
pub const btCollisionDispatcher_DispatcherFlags_CD_STATIC_STATIC_REPORTED:
    btCollisionDispatcher_DispatcherFlags = 1;
pub const btCollisionDispatcher_DispatcherFlags_CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD:
    btCollisionDispatcher_DispatcherFlags = 2;
pub const btCollisionDispatcher_DispatcherFlags_CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION:
    btCollisionDispatcher_DispatcherFlags = 4;
pub type btCollisionDispatcher_DispatcherFlags = i32;
extern "C" {
    /// registerCollisionCreateFunc allows registration of custom/alternative collision create functions
    #[link_name = "\u{1}?registerCollisionCreateFunc@btCollisionDispatcher@@QEAAXHHPEAUbtCollisionAlgorithmCreateFunc@@@Z"]
    pub fn btCollisionDispatcher_registerCollisionCreateFunc(
        this: *mut btCollisionDispatcher,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}?registerClosestPointsCreateFunc@btCollisionDispatcher@@QEAAXHHPEAUbtCollisionAlgorithmCreateFunc@@@Z"]
    pub fn btCollisionDispatcher_registerClosestPointsCreateFunc(
        this: *mut btCollisionDispatcher,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}?defaultNearCallback@btCollisionDispatcher@@SAXAEAUbtBroadphasePair@@AEAV1@AEBUbtDispatcherInfo@@@Z"]
    pub fn btCollisionDispatcher_defaultNearCallback(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionDispatcher@@QEAA@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btCollisionDispatcher_btCollisionDispatcher(
        this: *mut btCollisionDispatcher,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btCollisionDispatcher {
    #[inline]
    pub unsafe fn registerCollisionCreateFunc(
        &mut self,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    ) {
        btCollisionDispatcher_registerCollisionCreateFunc(self, proxyType0, proxyType1, createFunc)
    }
    #[inline]
    pub unsafe fn registerClosestPointsCreateFunc(
        &mut self,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    ) {
        btCollisionDispatcher_registerClosestPointsCreateFunc(
            self, proxyType0, proxyType1, createFunc,
        )
    }
    #[inline]
    pub unsafe fn defaultNearCallback(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    ) {
        btCollisionDispatcher_defaultNearCallback(collisionPair, dispatcher, dispatchInfo)
    }
    #[inline]
    pub unsafe fn new(collisionConfiguration: *mut btCollisionConfiguration) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionDispatcher_btCollisionDispatcher(&mut __bindgen_tmp, collisionConfiguration);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCollisionDispatcher@@QEAAXXZ"]
    pub fn btCollisionDispatcher_btCollisionDispatcher_destructor(this: *mut btCollisionDispatcher);
}
extern "C" {
    #[link_name = "\u{1}?getNewManifold@btCollisionDispatcher@@UEAAPEAVbtPersistentManifold@@PEBVbtCollisionObject@@0@Z"]
    pub fn btCollisionDispatcher_getNewManifold(
        this: *mut ::std::os::raw::c_void,
        b0: *const btCollisionObject,
        b1: *const btCollisionObject,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}?releaseManifold@btCollisionDispatcher@@UEAAXPEAVbtPersistentManifold@@@Z"]
    pub fn btCollisionDispatcher_releaseManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}?clearManifold@btCollisionDispatcher@@UEAAXPEAVbtPersistentManifold@@@Z"]
    pub fn btCollisionDispatcher_clearManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}?findAlgorithm@btCollisionDispatcher@@UEAAPEAVbtCollisionAlgorithm@@PEBUbtCollisionObjectWrapper@@0PEAVbtPersistentManifold@@W4ebtDispatcherQueryType@@@Z"]
    pub fn btCollisionDispatcher_findAlgorithm(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        sharedManifold: *mut btPersistentManifold,
        queryType: ebtDispatcherQueryType,
    ) -> *mut btCollisionAlgorithm;
}
extern "C" {
    #[link_name = "\u{1}?needsCollision@btCollisionDispatcher@@UEAA_NPEBVbtCollisionObject@@0@Z"]
    pub fn btCollisionDispatcher_needsCollision(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?needsResponse@btCollisionDispatcher@@UEAA_NPEBVbtCollisionObject@@0@Z"]
    pub fn btCollisionDispatcher_needsResponse(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?dispatchAllCollisionPairs@btCollisionDispatcher@@UEAAXPEAVbtOverlappingPairCache@@AEBUbtDispatcherInfo@@PEAVbtDispatcher@@@Z"]
    pub fn btCollisionDispatcher_dispatchAllCollisionPairs(
        this: *mut ::std::os::raw::c_void,
        pairCache: *mut btOverlappingPairCache,
        dispatchInfo: *const btDispatcherInfo,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?allocateCollisionAlgorithm@btCollisionDispatcher@@UEAAPEAXH@Z"]
    pub fn btCollisionDispatcher_allocateCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?freeCollisionAlgorithm@btCollisionDispatcher@@UEAAXPEAX@Z"]
    pub fn btCollisionDispatcher_freeCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?btIsMainThread@@YA_NXZ"]
    pub fn btIsMainThread() -> bool;
}
extern "C" {
    #[link_name = "\u{1}?btThreadsAreRunning@@YA_NXZ"]
    pub fn btThreadsAreRunning() -> bool;
}
extern "C" {
    #[link_name = "\u{1}?btGetCurrentThreadIndex@@YAIXZ"]
    pub fn btGetCurrentThreadIndex() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?btResetThreadIndexCounter@@YAXXZ"]
    pub fn btResetThreadIndexCounter();
}
///
/// btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
/// a thread to sleep because it is designed to be used with a task scheduler
/// which has one thread per core and the threads don't sleep until they
/// run out of tasks. Not good for general purpose use.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSpinMutex {
    pub mLock: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?lock@btSpinMutex@@QEAAXXZ"]
    pub fn btSpinMutex_lock(this: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}?unlock@btSpinMutex@@QEAAXXZ"]
    pub fn btSpinMutex_unlock(this: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}?tryLock@btSpinMutex@@QEAA_NXZ"]
    pub fn btSpinMutex_tryLock(this: *mut btSpinMutex) -> bool;
}
impl btSpinMutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        btSpinMutex_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        btSpinMutex_unlock(self)
    }
    #[inline]
    pub unsafe fn tryLock(&mut self) -> bool {
        btSpinMutex_tryLock(self)
    }
}
#[repr(C)]
pub struct btIParallelForBody__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btIParallelForBody {
    pub vtable_: *const btIParallelForBody__bindgen_vtable,
}
#[repr(C)]
pub struct btIParallelSumBody__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btIParallelSumBody {
    pub vtable_: *const btIParallelSumBody__bindgen_vtable,
}
#[repr(C)]
pub struct btITaskScheduler__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btITaskScheduler {
    pub vtable_: *const btITaskScheduler__bindgen_vtable,
    pub m_name: *const ::std::os::raw::c_char,
    pub m_savedThreadCounter: ::std::os::raw::c_uint,
    pub m_isActive: bool,
}
extern "C" {
    #[link_name = "\u{1}??0btITaskScheduler@@QEAA@PEBD@Z"]
    pub fn btITaskScheduler_btITaskScheduler(
        this: *mut btITaskScheduler,
        name: *const ::std::os::raw::c_char,
    );
}
impl btITaskScheduler {
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btITaskScheduler_btITaskScheduler(&mut __bindgen_tmp, name);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?activate@btITaskScheduler@@UEAAXXZ"]
    pub fn btITaskScheduler_activate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?deactivate@btITaskScheduler@@UEAAXXZ"]
    pub fn btITaskScheduler_deactivate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?btSetTaskScheduler@@YAXPEAVbtITaskScheduler@@@Z"]
    pub fn btSetTaskScheduler(ts: *mut btITaskScheduler);
}
extern "C" {
    #[link_name = "\u{1}?btGetTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btGetTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btGetSequentialTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btGetSequentialTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btCreateDefaultTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btCreateDefaultTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btGetOpenMPTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btGetOpenMPTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btGetTBBTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btGetTBBTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btGetPPLTaskScheduler@@YAPEAVbtITaskScheduler@@XZ"]
    pub fn btGetPPLTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}?btParallelFor@@YAXHHHAEBVbtIParallelForBody@@@Z"]
    pub fn btParallelFor(
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        grainSize: ::std::os::raw::c_int,
        body: *const btIParallelForBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?btParallelSum@@YANHHHAEBVbtIParallelSumBody@@@Z"]
    pub fn btParallelSum(
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        grainSize: ::std::os::raw::c_int,
        body: *const btIParallelSumBody,
    ) -> btScalar;
}
#[repr(C)]
pub struct btCollisionDispatcherMt {
    pub _base: btCollisionDispatcher,
    pub m_batchUpdating: bool,
    pub m_grainSize: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionDispatcherMt@@QEAA@PEAVbtCollisionConfiguration@@H@Z"]
    pub fn btCollisionDispatcherMt_btCollisionDispatcherMt(
        this: *mut btCollisionDispatcherMt,
        config: *mut btCollisionConfiguration,
        grainSize: ::std::os::raw::c_int,
    );
}
impl btCollisionDispatcherMt {
    #[inline]
    pub unsafe fn new(
        config: *mut btCollisionConfiguration,
        grainSize: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionDispatcherMt_btCollisionDispatcherMt(&mut __bindgen_tmp, config, grainSize);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getNewManifold@btCollisionDispatcherMt@@UEAAPEAVbtPersistentManifold@@PEBVbtCollisionObject@@0@Z"]
    pub fn btCollisionDispatcherMt_getNewManifold(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}?releaseManifold@btCollisionDispatcherMt@@UEAAXPEAVbtPersistentManifold@@@Z"]
    pub fn btCollisionDispatcherMt_releaseManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}?dispatchAllCollisionPairs@btCollisionDispatcherMt@@UEAAXPEAVbtOverlappingPairCache@@AEBUbtDispatcherInfo@@PEAVbtDispatcher@@@Z"]
    pub fn btCollisionDispatcherMt_dispatchAllCollisionPairs(
        this: *mut ::std::os::raw::c_void,
        pairCache: *mut btOverlappingPairCache,
        info: *const btDispatcherInfo,
        dispatcher: *mut btDispatcher,
    );
}
/// very basic hashable string implementation, compatible with btHashMap
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashString {
    pub m_string: *const ::std::os::raw::c_char,
    pub m_hash: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashInt {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btHashPtr {
    pub __bindgen_anon_1: btHashPtr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btHashPtr__bindgen_ty_1 {
    pub m_pointer: *const ::std::os::raw::c_void,
    pub m_hashValues: [::std::os::raw::c_uint; 2usize],
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashKeyPtr {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashKey {
    pub m_uid: ::std::os::raw::c_int,
}
/// The btHashMap template class implements a generic and lightweight hashmap.
/// A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
#[repr(C)]
#[derive(Debug)]
pub struct btHashMap<Key, Value> {
    pub m_hashTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_valueArray: btAlignedObjectArray<Value>,
    pub m_keyArray: btAlignedObjectArray<Key>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Key>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Value>>,
}
#[repr(C)]
pub struct btCollisionWorldImporter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct btCollisionWorldImporter {
    pub vtable_: *const btCollisionWorldImporter__bindgen_vtable,
    pub m_collisionWorld: *mut btCollisionWorld,
    pub m_verboseMode: ::std::os::raw::c_int,
    pub m_allocatedCollisionShapes: btAlignedObjectArray<*mut btCollisionShape>,
    pub m_allocatedRigidBodies: btAlignedObjectArray<*mut btCollisionObject>,
    pub m_allocatedBvhs: btAlignedObjectArray<*mut btOptimizedBvh>,
    pub m_allocatedTriangleInfoMaps: btAlignedObjectArray<*mut btTriangleInfoMap>,
    pub m_allocatedTriangleIndexArrays: btAlignedObjectArray<*mut btTriangleIndexVertexArray>,
    pub m_allocatedbtStridingMeshInterfaceDatas:
        btAlignedObjectArray<*mut btStridingMeshInterfaceData>,
    pub m_allocatedCollisionObjects: btAlignedObjectArray<*mut btCollisionObject>,
    pub m_allocatedNames: btAlignedObjectArray<*mut ::std::os::raw::c_char>,
    pub m_indexArrays: btAlignedObjectArray<*mut ::std::os::raw::c_int>,
    pub m_shortIndexArrays: btAlignedObjectArray<*mut ::std::os::raw::c_short>,
    pub m_charIndexArrays: btAlignedObjectArray<*mut ::std::os::raw::c_uchar>,
    pub m_floatVertexArrays: btAlignedObjectArray<*mut btVector3FloatData>,
    pub m_doubleVertexArrays: btAlignedObjectArray<*mut btVector3DoubleData>,
    pub m_bvhMap: btHashMap<btHashPtr, *mut btOptimizedBvh>,
    pub m_timMap: btHashMap<btHashPtr, *mut btTriangleInfoMap>,
    pub m_nameShapeMap: btHashMap<btHashString, *mut btCollisionShape>,
    pub m_nameColObjMap: btHashMap<btHashString, *mut btCollisionObject>,
    pub m_objectNameMap: btHashMap<btHashPtr, *const ::std::os::raw::c_char>,
    pub m_shapeMap: btHashMap<btHashPtr, *mut btCollisionShape>,
    pub m_bodyMap: btHashMap<btHashPtr, *mut btCollisionObject>,
}
extern "C" {
    #[link_name = "\u{1}?duplicateName@btCollisionWorldImporter@@IEAAPEADPEBD@Z"]
    pub fn btCollisionWorldImporter_duplicateName(
        this: *mut btCollisionWorldImporter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?convertCollisionShape@btCollisionWorldImporter@@IEAAPEAVbtCollisionShape@@PEAUbtCollisionShapeData@@@Z"]
    pub fn btCollisionWorldImporter_convertCollisionShape(
        this: *mut btCollisionWorldImporter,
        shapeData: *mut btCollisionShapeData,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?convertAllObjects@btCollisionWorldImporter@@QEAA_NPEAUbtBulletSerializedArrays@@@Z"]
    pub fn btCollisionWorldImporter_convertAllObjects(
        this: *mut btCollisionWorldImporter,
        arrays: *mut btBulletSerializedArrays,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getNumCollisionShapes@btCollisionWorldImporter@@QEBAHXZ"]
    pub fn btCollisionWorldImporter_getNumCollisionShapes(
        this: *const btCollisionWorldImporter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getCollisionShapeByIndex@btCollisionWorldImporter@@QEAAPEAVbtCollisionShape@@H@Z"]
    pub fn btCollisionWorldImporter_getCollisionShapeByIndex(
        this: *mut btCollisionWorldImporter,
        index: ::std::os::raw::c_int,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?getNumRigidBodies@btCollisionWorldImporter@@QEBAHXZ"]
    pub fn btCollisionWorldImporter_getNumRigidBodies(
        this: *const btCollisionWorldImporter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getRigidBodyByIndex@btCollisionWorldImporter@@QEBAPEAVbtCollisionObject@@H@Z"]
    pub fn btCollisionWorldImporter_getRigidBodyByIndex(
        this: *const btCollisionWorldImporter,
        index: ::std::os::raw::c_int,
    ) -> *mut btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}?getNumBvhs@btCollisionWorldImporter@@QEBAHXZ"]
    pub fn btCollisionWorldImporter_getNumBvhs(
        this: *const btCollisionWorldImporter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBvhByIndex@btCollisionWorldImporter@@QEBAPEAVbtOptimizedBvh@@H@Z"]
    pub fn btCollisionWorldImporter_getBvhByIndex(
        this: *const btCollisionWorldImporter,
        index: ::std::os::raw::c_int,
    ) -> *mut btOptimizedBvh;
}
extern "C" {
    #[link_name = "\u{1}?getNumTriangleInfoMaps@btCollisionWorldImporter@@QEBAHXZ"]
    pub fn btCollisionWorldImporter_getNumTriangleInfoMaps(
        this: *const btCollisionWorldImporter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getTriangleInfoMapByIndex@btCollisionWorldImporter@@QEBAPEAUbtTriangleInfoMap@@H@Z"]
    pub fn btCollisionWorldImporter_getTriangleInfoMapByIndex(
        this: *const btCollisionWorldImporter,
        index: ::std::os::raw::c_int,
    ) -> *mut btTriangleInfoMap;
}
extern "C" {
    #[link_name = "\u{1}?getCollisionShapeByName@btCollisionWorldImporter@@QEAAPEAVbtCollisionShape@@PEBD@Z"]
    pub fn btCollisionWorldImporter_getCollisionShapeByName(
        this: *mut btCollisionWorldImporter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?getCollisionObjectByName@btCollisionWorldImporter@@QEAAPEAVbtCollisionObject@@PEBD@Z"]
    pub fn btCollisionWorldImporter_getCollisionObjectByName(
        this: *mut btCollisionWorldImporter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}?getNameForPointer@btCollisionWorldImporter@@QEBAPEBDPEBX@Z"]
    pub fn btCollisionWorldImporter_getNameForPointer(
        this: *const btCollisionWorldImporter,
        ptr: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionWorldImporter@@QEAA@PEAVbtCollisionWorld@@@Z"]
    pub fn btCollisionWorldImporter_btCollisionWorldImporter(
        this: *mut btCollisionWorldImporter,
        world: *mut btCollisionWorld,
    );
}
impl btCollisionWorldImporter {
    #[inline]
    pub unsafe fn duplicateName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        btCollisionWorldImporter_duplicateName(self, name)
    }
    #[inline]
    pub unsafe fn convertCollisionShape(
        &mut self,
        shapeData: *mut btCollisionShapeData,
    ) -> *mut btCollisionShape {
        btCollisionWorldImporter_convertCollisionShape(self, shapeData)
    }
    #[inline]
    pub unsafe fn convertAllObjects(&mut self, arrays: *mut btBulletSerializedArrays) -> bool {
        btCollisionWorldImporter_convertAllObjects(self, arrays)
    }
    #[inline]
    pub unsafe fn getNumCollisionShapes(&self) -> ::std::os::raw::c_int {
        btCollisionWorldImporter_getNumCollisionShapes(self)
    }
    #[inline]
    pub unsafe fn getCollisionShapeByIndex(
        &mut self,
        index: ::std::os::raw::c_int,
    ) -> *mut btCollisionShape {
        btCollisionWorldImporter_getCollisionShapeByIndex(self, index)
    }
    #[inline]
    pub unsafe fn getNumRigidBodies(&self) -> ::std::os::raw::c_int {
        btCollisionWorldImporter_getNumRigidBodies(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyByIndex(
        &self,
        index: ::std::os::raw::c_int,
    ) -> *mut btCollisionObject {
        btCollisionWorldImporter_getRigidBodyByIndex(self, index)
    }
    #[inline]
    pub unsafe fn getNumBvhs(&self) -> ::std::os::raw::c_int {
        btCollisionWorldImporter_getNumBvhs(self)
    }
    #[inline]
    pub unsafe fn getBvhByIndex(&self, index: ::std::os::raw::c_int) -> *mut btOptimizedBvh {
        btCollisionWorldImporter_getBvhByIndex(self, index)
    }
    #[inline]
    pub unsafe fn getNumTriangleInfoMaps(&self) -> ::std::os::raw::c_int {
        btCollisionWorldImporter_getNumTriangleInfoMaps(self)
    }
    #[inline]
    pub unsafe fn getTriangleInfoMapByIndex(
        &self,
        index: ::std::os::raw::c_int,
    ) -> *mut btTriangleInfoMap {
        btCollisionWorldImporter_getTriangleInfoMapByIndex(self, index)
    }
    #[inline]
    pub unsafe fn getCollisionShapeByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut btCollisionShape {
        btCollisionWorldImporter_getCollisionShapeByName(self, name)
    }
    #[inline]
    pub unsafe fn getCollisionObjectByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut btCollisionObject {
        btCollisionWorldImporter_getCollisionObjectByName(self, name)
    }
    #[inline]
    pub unsafe fn getNameForPointer(
        &self,
        ptr: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char {
        btCollisionWorldImporter_getNameForPointer(self, ptr)
    }
    #[inline]
    pub unsafe fn new(world: *mut btCollisionWorld) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorldImporter_btCollisionWorldImporter(&mut __bindgen_tmp, world);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCollisionWorldImporter@@QEAAXXZ"]
    pub fn btCollisionWorldImporter_btCollisionWorldImporter_destructor(
        this: *mut btCollisionWorldImporter,
    );
}
extern "C" {
    /// delete all memory collision shapes, rigid bodies, constraints etc. allocated during the load.
    /// ///make sure you don't use the dynamics world containing objects after you call this method
    #[link_name = "\u{1}?deleteAllData@btCollisionWorldImporter@@UEAAXXZ"]
    pub fn btCollisionWorldImporter_deleteAllData(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// those virtuals are called by load and can be overridden by the user
    #[link_name = "\u{1}?createCollisionObject@btCollisionWorldImporter@@UEAAPEAVbtCollisionObject@@AEBVbtTransform@@PEAVbtCollisionShape@@PEBD@Z"]
    pub fn btCollisionWorldImporter_createCollisionObject(
        this: *mut ::std::os::raw::c_void,
        startTransform: *const btTransform,
        shape: *mut btCollisionShape,
        bodyName: *const ::std::os::raw::c_char,
    ) -> *mut btCollisionObject;
}
extern "C" {
    /// shapes
    #[link_name = "\u{1}?createPlaneShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@AEBVbtVector3@@N@Z"]
    pub fn btCollisionWorldImporter_createPlaneShape(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *const btVector3,
        planeConstant: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createBoxShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@AEBVbtVector3@@@Z"]
    pub fn btCollisionWorldImporter_createBoxShape(
        this: *mut ::std::os::raw::c_void,
        halfExtents: *const btVector3,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createSphereShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@N@Z"]
    pub fn btCollisionWorldImporter_createSphereShape(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCapsuleShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCapsuleShapeX(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCapsuleShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCapsuleShapeY(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCapsuleShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCapsuleShapeZ(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCylinderShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCylinderShapeX(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCylinderShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCylinderShapeY(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createCylinderShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createCylinderShapeZ(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createConeShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createConeShapeX(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createConeShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createConeShapeY(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createConeShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@NN@Z"]
    pub fn btCollisionWorldImporter_createConeShapeZ(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createTriangleMeshContainer@btCollisionWorldImporter@@UEAAPEAVbtTriangleIndexVertexArray@@XZ"]
    pub fn btCollisionWorldImporter_createTriangleMeshContainer(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btTriangleIndexVertexArray;
}
extern "C" {
    #[link_name = "\u{1}?createBvhTriangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtBvhTriangleMeshShape@@PEAVbtStridingMeshInterface@@PEAVbtOptimizedBvh@@@Z"]
    pub fn btCollisionWorldImporter_createBvhTriangleMeshShape(
        this: *mut ::std::os::raw::c_void,
        trimesh: *mut btStridingMeshInterface,
        bvh: *mut btOptimizedBvh,
    ) -> *mut btBvhTriangleMeshShape;
}
extern "C" {
    #[link_name = "\u{1}?createConvexTriangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@PEAVbtStridingMeshInterface@@@Z"]
    pub fn btCollisionWorldImporter_createConvexTriangleMeshShape(
        this: *mut ::std::os::raw::c_void,
        trimesh: *mut btStridingMeshInterface,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}?createStridingMeshInterfaceData@btCollisionWorldImporter@@UEAAPEAUbtStridingMeshInterfaceData@@PEAU2@@Z"]
    pub fn btCollisionWorldImporter_createStridingMeshInterfaceData(
        this: *mut ::std::os::raw::c_void,
        interfaceData: *mut btStridingMeshInterfaceData,
    ) -> *mut btStridingMeshInterfaceData;
}
extern "C" {
    #[link_name = "\u{1}?createConvexHullShape@btCollisionWorldImporter@@UEAAPEAVbtConvexHullShape@@XZ"]
    pub fn btCollisionWorldImporter_createConvexHullShape(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConvexHullShape;
}
extern "C" {
    #[link_name = "\u{1}?createCompoundShape@btCollisionWorldImporter@@UEAAPEAVbtCompoundShape@@XZ"]
    pub fn btCollisionWorldImporter_createCompoundShape(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btCompoundShape;
}
extern "C" {
    #[link_name = "\u{1}?createScaledTrangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtScaledBvhTriangleMeshShape@@PEAVbtBvhTriangleMeshShape@@AEBVbtVector3@@@Z"]
    pub fn btCollisionWorldImporter_createScaledTrangleMeshShape(
        this: *mut ::std::os::raw::c_void,
        meshShape: *mut btBvhTriangleMeshShape,
        localScalingbtBvhTriangleMeshShape: *const btVector3,
    ) -> *mut btScaledBvhTriangleMeshShape;
}
extern "C" {
    #[link_name = "\u{1}?createMultiSphereShape@btCollisionWorldImporter@@UEAAPEAVbtMultiSphereShape@@PEBVbtVector3@@PEBNH@Z"]
    pub fn btCollisionWorldImporter_createMultiSphereShape(
        this: *mut ::std::os::raw::c_void,
        positions: *const btVector3,
        radi: *const btScalar,
        numSpheres: ::std::os::raw::c_int,
    ) -> *mut btMultiSphereShape;
}
extern "C" {
    #[link_name = "\u{1}?createMeshInterface@btCollisionWorldImporter@@UEAAPEAVbtTriangleIndexVertexArray@@AEAUbtStridingMeshInterfaceData@@@Z"]
    pub fn btCollisionWorldImporter_createMeshInterface(
        this: *mut ::std::os::raw::c_void,
        meshData: *mut btStridingMeshInterfaceData,
    ) -> *mut btTriangleIndexVertexArray;
}
extern "C" {
    /// acceleration and connectivity structures
    #[link_name = "\u{1}?createOptimizedBvh@btCollisionWorldImporter@@UEAAPEAVbtOptimizedBvh@@XZ"]
    pub fn btCollisionWorldImporter_createOptimizedBvh(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btOptimizedBvh;
}
extern "C" {
    #[link_name = "\u{1}?createTriangleInfoMap@btCollisionWorldImporter@@UEAAPEAUbtTriangleInfoMap@@XZ"]
    pub fn btCollisionWorldImporter_createTriangleInfoMap(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btTriangleInfoMap;
}
#[repr(C)]
pub struct btBroadphaseAabbCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseAabbCallback {
    pub vtable_: *const btBroadphaseAabbCallback__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseRayCallback {
    pub _base: btBroadphaseAabbCallback,
    pub __bindgen_padding_0: u64,
    /// added some cached data to accelerate ray-AABB tests
    pub m_rayDirectionInverse: btVector3,
    pub m_signs: [::std::os::raw::c_uint; 3usize],
    pub m_lambda_max: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
pub struct btBroadphaseInterface__bindgen_vtable(::std::os::raw::c_void);
/// The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
/// Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
/// The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class.
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseInterface {
    pub vtable_: *const btBroadphaseInterface__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvtAabbMm {
    pub mi: btVector3,
    pub mx: btVector3,
}
pub type btDbvtVolume = btDbvtAabbMm;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btDbvtNode {
    pub volume: btDbvtVolume,
    pub parent: *mut btDbvtNode,
    pub __bindgen_anon_1: btDbvtNode__bindgen_ty_1,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btDbvtNode__bindgen_ty_1 {
    pub childs: [*mut btDbvtNode; 2usize],
    pub data: *mut ::std::os::raw::c_void,
    pub dataAsInt: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 2usize],
}
pub type btNodeStack = btAlignedObjectArray<*const btDbvtNode>;
/// The btDbvt class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
/// This btDbvt is used for soft body collision detection and for the btDbvtBroadphase. It has a fast insert, remove and update of nodes.
/// Unlike the btQuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt {
    pub m_root: *mut btDbvtNode,
    pub m_free: *mut btDbvtNode,
    pub m_lkhd: ::std::os::raw::c_int,
    pub m_leaves: ::std::os::raw::c_int,
    pub m_opath: ::std::os::raw::c_uint,
    pub m_stkStack: btAlignedObjectArray<btDbvt_sStkNN>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNN {
    pub a: *const btDbvtNode,
    pub b: *const btDbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNP {
    pub node: *const btDbvtNode,
    pub mask: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNPS {
    pub node: *const btDbvtNode,
    pub mask: ::std::os::raw::c_int,
    pub value: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkCLN {
    pub node: *const btDbvtNode,
    pub parent: *mut btDbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_ICollide {
    pub _address: u8,
}
#[repr(C)]
pub struct btDbvt_IWriter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt_IWriter {
    pub vtable_: *const btDbvt_IWriter__bindgen_vtable,
}
#[repr(C)]
pub struct btDbvt_IClone__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt_IClone {
    pub vtable_: *const btDbvt_IClone__bindgen_vtable,
}
pub const btDbvt_SIMPLE_STACKSIZE: btDbvt__bindgen_ty_1 = 64;
pub const btDbvt_DOUBLE_STACKSIZE: btDbvt__bindgen_ty_1 = 128;
pub type btDbvt__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?clear@btDbvt@@QEAAXXZ"]
    pub fn btDbvt_clear(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}?optimizeBottomUp@btDbvt@@QEAAXXZ"]
    pub fn btDbvt_optimizeBottomUp(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}?optimizeTopDown@btDbvt@@QEAAXH@Z"]
    pub fn btDbvt_optimizeTopDown(this: *mut btDbvt, bu_treshold: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?optimizeIncremental@btDbvt@@QEAAXH@Z"]
    pub fn btDbvt_optimizeIncremental(this: *mut btDbvt, passes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?insert@btDbvt@@QEAAPEAUbtDbvtNode@@AEBUbtDbvtAabbMm@@PEAX@Z"]
    pub fn btDbvt_insert(
        this: *mut btDbvt,
        box_: *const btDbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut btDbvtNode;
}
extern "C" {
    #[link_name = "\u{1}?update@btDbvt@@QEAAXPEAUbtDbvtNode@@H@Z"]
    pub fn btDbvt_update(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        lookahead: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?update@btDbvt@@QEAAXPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@@Z"]
    pub fn btDbvt_update1(this: *mut btDbvt, leaf: *mut btDbvtNode, volume: *mut btDbvtVolume);
}
extern "C" {
    #[link_name = "\u{1}?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@AEBVbtVector3@@N@Z"]
    pub fn btDbvt_update2(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@AEBVbtVector3@@@Z"]
    pub fn btDbvt_update3(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@N@Z"]
    pub fn btDbvt_update4(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?remove@btDbvt@@QEAAXPEAUbtDbvtNode@@@Z"]
    pub fn btDbvt_remove(this: *mut btDbvt, leaf: *mut btDbvtNode);
}
extern "C" {
    #[link_name = "\u{1}?write@btDbvt@@QEBAXPEAUIWriter@1@@Z"]
    pub fn btDbvt_write(this: *const btDbvt, iwriter: *mut btDbvt_IWriter);
}
extern "C" {
    #[link_name = "\u{1}?clone@btDbvt@@QEBAXAEAU1@PEAUIClone@1@@Z"]
    pub fn btDbvt_clone(this: *const btDbvt, dest: *mut btDbvt, iclone: *mut btDbvt_IClone);
}
extern "C" {
    #[link_name = "\u{1}?maxdepth@btDbvt@@SAHPEBUbtDbvtNode@@@Z"]
    pub fn btDbvt_maxdepth(node: *const btDbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?countLeaves@btDbvt@@SAHPEBUbtDbvtNode@@@Z"]
    pub fn btDbvt_countLeaves(node: *const btDbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?extractLeaves@btDbvt@@SAXPEBUbtDbvtNode@@AEAV?$btAlignedObjectArray@PEBUbtDbvtNode@@@@@Z"]
    pub fn btDbvt_extractLeaves(
        node: *const btDbvtNode,
        leaves: *mut btAlignedObjectArray<*const btDbvtNode>,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btDbvt@@QEAA@XZ"]
    pub fn btDbvt_btDbvt(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}??_DbtDbvt@@QEAAXXZ"]
    pub fn btDbvt_btDbvt_destructor(this: *mut btDbvt);
}
impl btDbvt {
    #[inline]
    pub unsafe fn clear(&mut self) {
        btDbvt_clear(self)
    }
    #[inline]
    pub unsafe fn optimizeBottomUp(&mut self) {
        btDbvt_optimizeBottomUp(self)
    }
    #[inline]
    pub unsafe fn optimizeTopDown(&mut self, bu_treshold: ::std::os::raw::c_int) {
        btDbvt_optimizeTopDown(self, bu_treshold)
    }
    #[inline]
    pub unsafe fn optimizeIncremental(&mut self, passes: ::std::os::raw::c_int) {
        btDbvt_optimizeIncremental(self, passes)
    }
    #[inline]
    pub unsafe fn insert(
        &mut self,
        box_: *const btDbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut btDbvtNode {
        btDbvt_insert(self, box_, data)
    }
    #[inline]
    pub unsafe fn update(&mut self, leaf: *mut btDbvtNode, lookahead: ::std::os::raw::c_int) {
        btDbvt_update(self, leaf, lookahead)
    }
    #[inline]
    pub unsafe fn update1(&mut self, leaf: *mut btDbvtNode, volume: *mut btDbvtVolume) {
        btDbvt_update1(self, leaf, volume)
    }
    #[inline]
    pub unsafe fn update2(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
        margin: btScalar,
    ) -> bool {
        btDbvt_update2(self, leaf, volume, velocity, margin)
    }
    #[inline]
    pub unsafe fn update3(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
    ) -> bool {
        btDbvt_update3(self, leaf, volume, velocity)
    }
    #[inline]
    pub unsafe fn update4(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        margin: btScalar,
    ) -> bool {
        btDbvt_update4(self, leaf, volume, margin)
    }
    #[inline]
    pub unsafe fn remove(&mut self, leaf: *mut btDbvtNode) {
        btDbvt_remove(self, leaf)
    }
    #[inline]
    pub unsafe fn write(&self, iwriter: *mut btDbvt_IWriter) {
        btDbvt_write(self, iwriter)
    }
    #[inline]
    pub unsafe fn clone(&self, dest: *mut btDbvt, iclone: *mut btDbvt_IClone) {
        btDbvt_clone(self, dest, iclone)
    }
    #[inline]
    pub unsafe fn maxdepth(node: *const btDbvtNode) -> ::std::os::raw::c_int {
        btDbvt_maxdepth(node)
    }
    #[inline]
    pub unsafe fn countLeaves(node: *const btDbvtNode) -> ::std::os::raw::c_int {
        btDbvt_countLeaves(node)
    }
    #[inline]
    pub unsafe fn extractLeaves(
        node: *const btDbvtNode,
        leaves: *mut btAlignedObjectArray<*const btDbvtNode>,
    ) {
        btDbvt_extractLeaves(node, leaves)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_btDbvt(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btDbvt_btDbvt_destructor(self)
    }
}
pub type btShapePairCallback = ::std::option::Option<
    unsafe extern "C" fn(pShape0: *const btCollisionShape, pShape1: *const btCollisionShape)
        -> bool,
>;
/// btCompoundCollisionAlgorithm  supports collision between CompoundCollisionShapes and other collision shapes
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub stack2: btNodeStack,
    pub manifoldArray: btManifoldArray,
    pub m_childCollisionAlgorithms: btAlignedObjectArray<*mut btCollisionAlgorithm>,
    pub m_isSwapped: bool,
    pub m_sharedManifold: *mut btPersistentManifold,
    pub m_ownsManifold: bool,
    pub m_compoundShapeRevision: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundCollisionAlgorithm_SwappedCreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}?removeChildAlgorithms@btCompoundCollisionAlgorithm@@IEAAXXZ"]
    pub fn btCompoundCollisionAlgorithm_removeChildAlgorithms(
        this: *mut btCompoundCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?preallocateChildAlgorithms@btCompoundCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0@Z"]
    pub fn btCompoundCollisionAlgorithm_preallocateChildAlgorithms(
        this: *mut btCompoundCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btCompoundCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btCompoundCollisionAlgorithm_btCompoundCollisionAlgorithm(
        this: *mut btCompoundCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btCompoundCollisionAlgorithm {
    #[inline]
    pub unsafe fn removeChildAlgorithms(&mut self) {
        btCompoundCollisionAlgorithm_removeChildAlgorithms(self)
    }
    #[inline]
    pub unsafe fn preallocateChildAlgorithms(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) {
        btCompoundCollisionAlgorithm_preallocateChildAlgorithms(self, body0Wrap, body1Wrap)
    }
    #[inline]
    pub unsafe fn new(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCompoundCollisionAlgorithm_btCompoundCollisionAlgorithm(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCompoundCollisionAlgorithm@@QEAAXXZ"]
    pub fn btCompoundCollisionAlgorithm_btCompoundCollisionAlgorithm_destructor(
        this: *mut btCompoundCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btCompoundCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btCompoundCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btCompoundCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btCompoundCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btSimplePair {
    pub m_indexA: ::std::os::raw::c_int,
    pub m_indexB: ::std::os::raw::c_int,
    pub __bindgen_anon_1: btSimplePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btSimplePair__bindgen_ty_1 {
    pub m_userPointer: *mut ::std::os::raw::c_void,
    pub m_userValue: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
pub type btSimplePairArray = btAlignedObjectArray<btSimplePair>;
#[repr(C)]
pub struct btHashedSimplePairCache__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct btHashedSimplePairCache {
    pub vtable_: *const btHashedSimplePairCache__bindgen_vtable,
    pub m_overlappingPairArray: btSimplePairArray,
    pub m_hashTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: btAlignedObjectArray<::std::os::raw::c_int>,
}
extern "C" {
    #[link_name = "\u{1}?removeAllPairs@btHashedSimplePairCache@@QEAAXXZ"]
    pub fn btHashedSimplePairCache_removeAllPairs(this: *mut btHashedSimplePairCache);
}
extern "C" {
    #[link_name = "\u{1}?findPair@btHashedSimplePairCache@@QEAAPEAUbtSimplePair@@HH@Z"]
    pub fn btHashedSimplePairCache_findPair(
        this: *mut btHashedSimplePairCache,
        indexA: ::std::os::raw::c_int,
        indexB: ::std::os::raw::c_int,
    ) -> *mut btSimplePair;
}
extern "C" {
    #[link_name = "\u{1}??0btHashedSimplePairCache@@QEAA@XZ"]
    pub fn btHashedSimplePairCache_btHashedSimplePairCache(this: *mut btHashedSimplePairCache);
}
impl btHashedSimplePairCache {
    #[inline]
    pub unsafe fn removeAllPairs(&mut self) {
        btHashedSimplePairCache_removeAllPairs(self)
    }
    #[inline]
    pub unsafe fn findPair(
        &mut self,
        indexA: ::std::os::raw::c_int,
        indexB: ::std::os::raw::c_int,
    ) -> *mut btSimplePair {
        btHashedSimplePairCache_findPair(self, indexA, indexB)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashedSimplePairCache_btHashedSimplePairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtHashedSimplePairCache@@QEAAXXZ"]
    pub fn btHashedSimplePairCache_btHashedSimplePairCache_destructor(
        this: *mut btHashedSimplePairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPair@btHashedSimplePairCache@@UEAAPEAXHH@Z"]
    pub fn btHashedSimplePairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        indexA: ::std::os::raw::c_int,
        indexB: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
/// btCompoundCompoundCollisionAlgorithm  supports collision between two btCompoundCollisionShape shapes
#[repr(C)]
pub struct btCompoundCompoundCollisionAlgorithm {
    pub _base: btCompoundCollisionAlgorithm,
    pub m_childCollisionAlgorithmCache: *mut btHashedSimplePairCache,
    pub m_removePairs: btSimplePairArray,
    pub m_compoundShapeRevision0: ::std::os::raw::c_int,
    pub m_compoundShapeRevision1: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundCompoundCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btCompoundCompoundCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btCompoundCompoundCollisionAlgorithm_btCompoundCompoundCollisionAlgorithm(
        this: *mut btCompoundCompoundCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btCompoundCompoundCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCompoundCompoundCollisionAlgorithm_btCompoundCompoundCollisionAlgorithm(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCompoundCompoundCollisionAlgorithm@@QEAAXXZ"]
    pub fn btCompoundCompoundCollisionAlgorithm_btCompoundCompoundCollisionAlgorithm_destructor(
        this: *mut btCompoundCompoundCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btCompoundCompoundCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btCompoundCompoundCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btCompoundCompoundCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btCompoundCompoundCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getAllContactManifolds@btCompoundCompoundCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z"]
    pub fn btCompoundCompoundCollisionAlgorithm_getAllContactManifolds(
        this: *mut ::std::os::raw::c_void,
        manifoldArray: *mut btManifoldArray,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btUsageBitfield {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
    pub __bindgen_align: [u16; 0usize],
}
impl btUsageBitfield {
    #[inline]
    pub fn usedVertexA(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexA(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexB(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexB(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexC(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexC(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usedVertexD(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_usedVertexD(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused4(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unused4(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usedVertexA: ::std::os::raw::c_ushort,
        usedVertexB: ::std::os::raw::c_ushort,
        usedVertexC: ::std::os::raw::c_ushort,
        usedVertexD: ::std::os::raw::c_ushort,
        unused1: ::std::os::raw::c_ushort,
        unused2: ::std::os::raw::c_ushort,
        unused3: ::std::os::raw::c_ushort,
        unused4: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let usedVertexA: u16 = unsafe { ::std::mem::transmute(usedVertexA) };
            usedVertexA as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usedVertexB: u16 = unsafe { ::std::mem::transmute(usedVertexB) };
            usedVertexB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usedVertexC: u16 = unsafe { ::std::mem::transmute(usedVertexC) };
            usedVertexC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let usedVertexD: u16 = unsafe { ::std::mem::transmute(usedVertexD) };
            usedVertexD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unused1: u16 = unsafe { ::std::mem::transmute(unused1) };
            unused1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unused2: u16 = unsafe { ::std::mem::transmute(unused2) };
            unused2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let unused3: u16 = unsafe { ::std::mem::transmute(unused3) };
            unused3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let unused4: u16 = unsafe { ::std::mem::transmute(unused4) };
            unused4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSubSimplexClosestResult {
    pub m_closestPointOnSimplex: btVector3,
    pub m_usedVertices: btUsageBitfield,
    pub m_barycentricCoords: [btScalar; 4usize],
    pub m_degenerate: bool,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVoronoiSimplexSolver {
    pub m_numVertices: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_simplexVectorW: [btVector3; 5usize],
    pub m_simplexPointsP: [btVector3; 5usize],
    pub m_simplexPointsQ: [btVector3; 5usize],
    pub m_cachedP1: btVector3,
    pub m_cachedP2: btVector3,
    pub m_cachedV: btVector3,
    pub m_lastW: btVector3,
    pub m_equalVertexThreshold: btScalar,
    pub m_cachedValidClosest: bool,
    pub __bindgen_padding_1: [u64; 0usize],
    pub m_cachedBC: btSubSimplexClosestResult,
    pub m_needsUpdate: bool,
    pub __bindgen_padding_2: [u8; 15usize],
}
extern "C" {
    #[link_name = "\u{1}?removeVertex@btVoronoiSimplexSolver@@QEAAXH@Z"]
    pub fn btVoronoiSimplexSolver_removeVertex(
        this: *mut btVoronoiSimplexSolver,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?reduceVertices@btVoronoiSimplexSolver@@QEAAXAEBUbtUsageBitfield@@@Z"]
    pub fn btVoronoiSimplexSolver_reduceVertices(
        this: *mut btVoronoiSimplexSolver,
        usedVerts: *const btUsageBitfield,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateClosestVectorAndPoints@btVoronoiSimplexSolver@@QEAA_NXZ"]
    pub fn btVoronoiSimplexSolver_updateClosestVectorAndPoints(
        this: *mut btVoronoiSimplexSolver,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?closestPtPointTetrahedron@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@0000AEAUbtSubSimplexClosestResult@@@Z"]
    pub fn btVoronoiSimplexSolver_closestPtPointTetrahedron(
        this: *mut btVoronoiSimplexSolver,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        d: *const btVector3,
        finalResult: *mut btSubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?pointOutsideOfPlane@btVoronoiSimplexSolver@@QEAAHAEBVbtVector3@@0000@Z"]
    pub fn btVoronoiSimplexSolver_pointOutsideOfPlane(
        this: *mut btVoronoiSimplexSolver,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        d: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?closestPtPointTriangle@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@000AEAUbtSubSimplexClosestResult@@@Z"]
    pub fn btVoronoiSimplexSolver_closestPtPointTriangle(
        this: *mut btVoronoiSimplexSolver,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        result: *mut btSubSimplexClosestResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?reset@btVoronoiSimplexSolver@@QEAAXXZ"]
    pub fn btVoronoiSimplexSolver_reset(this: *mut btVoronoiSimplexSolver);
}
extern "C" {
    #[link_name = "\u{1}?addVertex@btVoronoiSimplexSolver@@QEAAXAEBVbtVector3@@00@Z"]
    pub fn btVoronoiSimplexSolver_addVertex(
        this: *mut btVoronoiSimplexSolver,
        w: *const btVector3,
        p: *const btVector3,
        q: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?closest@btVoronoiSimplexSolver@@QEAA_NAEAVbtVector3@@@Z"]
    pub fn btVoronoiSimplexSolver_closest(
        this: *mut btVoronoiSimplexSolver,
        v: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?maxVertex@btVoronoiSimplexSolver@@QEAANXZ"]
    pub fn btVoronoiSimplexSolver_maxVertex(this: *mut btVoronoiSimplexSolver) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getSimplex@btVoronoiSimplexSolver@@QEBAHPEAVbtVector3@@00@Z"]
    pub fn btVoronoiSimplexSolver_getSimplex(
        this: *const btVoronoiSimplexSolver,
        pBuf: *mut btVector3,
        qBuf: *mut btVector3,
        yBuf: *mut btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?inSimplex@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@@Z"]
    pub fn btVoronoiSimplexSolver_inSimplex(
        this: *mut btVoronoiSimplexSolver,
        w: *const btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?backup_closest@btVoronoiSimplexSolver@@QEAAXAEAVbtVector3@@@Z"]
    pub fn btVoronoiSimplexSolver_backup_closest(
        this: *mut btVoronoiSimplexSolver,
        v: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?emptySimplex@btVoronoiSimplexSolver@@QEBA_NXZ"]
    pub fn btVoronoiSimplexSolver_emptySimplex(this: *const btVoronoiSimplexSolver) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?compute_points@btVoronoiSimplexSolver@@QEAAXAEAVbtVector3@@0@Z"]
    pub fn btVoronoiSimplexSolver_compute_points(
        this: *mut btVoronoiSimplexSolver,
        p1: *mut btVector3,
        p2: *mut btVector3,
    );
}
impl btVoronoiSimplexSolver {
    #[inline]
    pub unsafe fn removeVertex(&mut self, index: ::std::os::raw::c_int) {
        btVoronoiSimplexSolver_removeVertex(self, index)
    }
    #[inline]
    pub unsafe fn reduceVertices(&mut self, usedVerts: *const btUsageBitfield) {
        btVoronoiSimplexSolver_reduceVertices(self, usedVerts)
    }
    #[inline]
    pub unsafe fn updateClosestVectorAndPoints(&mut self) -> bool {
        btVoronoiSimplexSolver_updateClosestVectorAndPoints(self)
    }
    #[inline]
    pub unsafe fn closestPtPointTetrahedron(
        &mut self,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        d: *const btVector3,
        finalResult: *mut btSubSimplexClosestResult,
    ) -> bool {
        btVoronoiSimplexSolver_closestPtPointTetrahedron(self, p, a, b, c, d, finalResult)
    }
    #[inline]
    pub unsafe fn pointOutsideOfPlane(
        &mut self,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        d: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btVoronoiSimplexSolver_pointOutsideOfPlane(self, p, a, b, c, d)
    }
    #[inline]
    pub unsafe fn closestPtPointTriangle(
        &mut self,
        p: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        result: *mut btSubSimplexClosestResult,
    ) -> bool {
        btVoronoiSimplexSolver_closestPtPointTriangle(self, p, a, b, c, result)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        btVoronoiSimplexSolver_reset(self)
    }
    #[inline]
    pub unsafe fn addVertex(
        &mut self,
        w: *const btVector3,
        p: *const btVector3,
        q: *const btVector3,
    ) {
        btVoronoiSimplexSolver_addVertex(self, w, p, q)
    }
    #[inline]
    pub unsafe fn closest(&mut self, v: *mut btVector3) -> bool {
        btVoronoiSimplexSolver_closest(self, v)
    }
    #[inline]
    pub unsafe fn maxVertex(&mut self) -> btScalar {
        btVoronoiSimplexSolver_maxVertex(self)
    }
    #[inline]
    pub unsafe fn getSimplex(
        &self,
        pBuf: *mut btVector3,
        qBuf: *mut btVector3,
        yBuf: *mut btVector3,
    ) -> ::std::os::raw::c_int {
        btVoronoiSimplexSolver_getSimplex(self, pBuf, qBuf, yBuf)
    }
    #[inline]
    pub unsafe fn inSimplex(&mut self, w: *const btVector3) -> bool {
        btVoronoiSimplexSolver_inSimplex(self, w)
    }
    #[inline]
    pub unsafe fn backup_closest(&mut self, v: *mut btVector3) {
        btVoronoiSimplexSolver_backup_closest(self, v)
    }
    #[inline]
    pub unsafe fn emptySimplex(&self) -> bool {
        btVoronoiSimplexSolver_emptySimplex(self)
    }
    #[inline]
    pub unsafe fn compute_points(&mut self, p1: *mut btVector3, p2: *mut btVector3) {
        btVoronoiSimplexSolver_compute_points(self, p1, p2)
    }
}
/// btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface
#[repr(C)]
#[derive(Debug)]
pub struct btGjkPairDetector {
    pub _base: btDiscreteCollisionDetectorInterface,
    pub __bindgen_padding_0: u64,
    pub m_cachedSeparatingAxis: btVector3,
    pub m_penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_minkowskiA: *const btConvexShape,
    pub m_minkowskiB: *const btConvexShape,
    pub m_shapeTypeA: ::std::os::raw::c_int,
    pub m_shapeTypeB: ::std::os::raw::c_int,
    pub m_marginA: btScalar,
    pub m_marginB: btScalar,
    pub m_ignoreMargin: bool,
    pub m_cachedSeparatingDistance: btScalar,
    pub m_lastUsedMethod: ::std::os::raw::c_int,
    pub m_curIter: ::std::os::raw::c_int,
    pub m_degenerateSimplex: ::std::os::raw::c_int,
    pub m_catchDegeneracies: ::std::os::raw::c_int,
    pub m_fixContactNormalDirection: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u32,
}
extern "C" {
    #[link_name = "\u{1}?getClosestPointsNonVirtual@btGjkPairDetector@@QEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@@Z"]
    pub fn btGjkPairDetector_getClosestPointsNonVirtual(
        this: *mut btGjkPairDetector,
        input: *const btDiscreteCollisionDetectorInterface_ClosestPointInput,
        output: *mut btDiscreteCollisionDetectorInterface_Result,
        debugDraw: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGjkPairDetector@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z"]
    pub fn btGjkPairDetector_btGjkPairDetector(
        this: *mut btGjkPairDetector,
        objectA: *const btConvexShape,
        objectB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGjkPairDetector@@QEAA@PEBVbtConvexShape@@0HHNNPEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z"]
    pub fn btGjkPairDetector_btGjkPairDetector1(
        this: *mut btGjkPairDetector,
        objectA: *const btConvexShape,
        objectB: *const btConvexShape,
        shapeTypeA: ::std::os::raw::c_int,
        shapeTypeB: ::std::os::raw::c_int,
        marginA: btScalar,
        marginB: btScalar,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    );
}
impl btGjkPairDetector {
    #[inline]
    pub unsafe fn getClosestPointsNonVirtual(
        &mut self,
        input: *const btDiscreteCollisionDetectorInterface_ClosestPointInput,
        output: *mut btDiscreteCollisionDetectorInterface_Result,
        debugDraw: *mut btIDebugDraw,
    ) {
        btGjkPairDetector_getClosestPointsNonVirtual(self, input, output, debugDraw)
    }
    #[inline]
    pub unsafe fn new(
        objectA: *const btConvexShape,
        objectB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGjkPairDetector_btGjkPairDetector(
            &mut __bindgen_tmp,
            objectA,
            objectB,
            simplexSolver,
            penetrationDepthSolver,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        objectA: *const btConvexShape,
        objectB: *const btConvexShape,
        shapeTypeA: ::std::os::raw::c_int,
        shapeTypeB: ::std::os::raw::c_int,
        marginA: btScalar,
        marginB: btScalar,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGjkPairDetector_btGjkPairDetector1(
            &mut __bindgen_tmp,
            objectA,
            objectB,
            shapeTypeA,
            shapeTypeB,
            marginA,
            marginB,
            simplexSolver,
            penetrationDepthSolver,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getClosestPoints@btGjkPairDetector@@UEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@_N@Z"]
    pub fn btGjkPairDetector_getClosestPoints(
        this: *mut ::std::os::raw::c_void,
        input: *const btDiscreteCollisionDetectorInterface_ClosestPointInput,
        output: *mut btDiscreteCollisionDetectorInterface_Result,
        debugDraw: *mut btIDebugDraw,
        swapResults: bool,
    );
}
/// The convex2dConvex2dAlgorithm collision algorithm support 2d collision detection for btConvex2dShape
/// Currently it requires the btMinkowskiPenetrationDepthSolver, it has support for 2d penetration depth computation
#[repr(C)]
#[derive(Debug)]
pub struct btConvex2dConvex2dAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_lowLevelOfDetail: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct btConvex2dConvex2dAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_numPerturbationIterations: ::std::os::raw::c_int,
    pub m_minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}??0CreateFunc@btConvex2dConvex2dAlgorithm@@QEAA@PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z"]
    pub fn btConvex2dConvex2dAlgorithm_CreateFunc_CreateFunc(
        this: *mut btConvex2dConvex2dAlgorithm_CreateFunc,
        simplexSolver: *mut btVoronoiSimplexSolver,
        pdSolver: *mut btConvexPenetrationDepthSolver,
    );
}
impl btConvex2dConvex2dAlgorithm_CreateFunc {
    #[inline]
    pub unsafe fn new(
        simplexSolver: *mut btVoronoiSimplexSolver,
        pdSolver: *mut btConvexPenetrationDepthSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvex2dConvex2dAlgorithm_CreateFunc_CreateFunc(
            &mut __bindgen_tmp,
            simplexSolver,
            pdSolver,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?setLowLevelOfDetail@btConvex2dConvex2dAlgorithm@@QEAAX_N@Z"]
    pub fn btConvex2dConvex2dAlgorithm_setLowLevelOfDetail(
        this: *mut btConvex2dConvex2dAlgorithm,
        useLowLevel: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvex2dConvex2dAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@HH@Z"]
    pub fn btConvex2dConvex2dAlgorithm_btConvex2dConvex2dAlgorithm(
        this: *mut btConvex2dConvex2dAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        simplexSolver: *mut btVoronoiSimplexSolver,
        pdSolver: *mut btConvexPenetrationDepthSolver,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
impl btConvex2dConvex2dAlgorithm {
    #[inline]
    pub unsafe fn setLowLevelOfDetail(&mut self, useLowLevel: bool) {
        btConvex2dConvex2dAlgorithm_setLowLevelOfDetail(self, useLowLevel)
    }
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        simplexSolver: *mut btVoronoiSimplexSolver,
        pdSolver: *mut btConvexPenetrationDepthSolver,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvex2dConvex2dAlgorithm_btConvex2dConvex2dAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
            simplexSolver,
            pdSolver,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvex2dConvex2dAlgorithm@@QEAAXXZ"]
    pub fn btConvex2dConvex2dAlgorithm_btConvex2dConvex2dAlgorithm_destructor(
        this: *mut btConvex2dConvex2dAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btConvex2dConvex2dAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvex2dConvex2dAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btConvex2dConvex2dAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvex2dConvex2dAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DCreateFunc@btConvex2dConvex2dAlgorithm@@QEAAXXZ"]
    pub fn btConvex2dConvex2dAlgorithm_CreateFunc_CreateFunc_destructor(
        this: *mut btConvex2dConvex2dAlgorithm_CreateFunc,
    );
}
#[repr(C)]
pub struct btTriangleCallback__bindgen_vtable(::std::os::raw::c_void);
/// The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
/// This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleCallback {
    pub vtable_: *const btTriangleCallback__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}??_DbtTriangleCallback@@QEAAXXZ"]
    pub fn btTriangleCallback_btTriangleCallback_destructor(this: *mut btTriangleCallback);
}
#[repr(C)]
pub struct btInternalTriangleIndexCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btInternalTriangleIndexCallback {
    pub vtable_: *const btInternalTriangleIndexCallback__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}??_DbtInternalTriangleIndexCallback@@QEAAXXZ"]
    pub fn btInternalTriangleIndexCallback_btInternalTriangleIndexCallback_destructor(
        this: *mut btInternalTriangleIndexCallback,
    );
}
/// For each triangle in the concave mesh that overlaps with the AABB of a convex (m_convexProxy), processTriangle is called.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexTriangleCallback {
    pub _base: btTriangleCallback,
    pub __bindgen_padding_0: u64,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
    pub m_convexBodyWrap: *const btCollisionObjectWrapper,
    pub m_triBodyWrap: *const btCollisionObjectWrapper,
    pub m_resultOut: *mut btManifoldResult,
    pub m_dispatcher: *mut btDispatcher,
    pub m_dispatchInfoPtr: *const btDispatcherInfo,
    pub m_collisionMarginTriangle: btScalar,
    pub m_triangleCount: ::std::os::raw::c_int,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
extern "C" {
    #[link_name = "\u{1}?setTimeStepAndCounters@btConvexTriangleCallback@@QEAAXNAEBUbtDispatcherInfo@@PEBUbtCollisionObjectWrapper@@1PEAVbtManifoldResult@@@Z"]
    pub fn btConvexTriangleCallback_setTimeStepAndCounters(
        this: *mut btConvexTriangleCallback,
        collisionMarginTriangle: btScalar,
        dispatchInfo: *const btDispatcherInfo,
        convexBodyWrap: *const btCollisionObjectWrapper,
        triBodyWrap: *const btCollisionObjectWrapper,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?clearCache@btConvexTriangleCallback@@QEAAXXZ"]
    pub fn btConvexTriangleCallback_clearCache(this: *mut btConvexTriangleCallback);
}
extern "C" {
    #[link_name = "\u{1}??0btConvexTriangleCallback@@QEAA@PEAVbtDispatcher@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btConvexTriangleCallback_btConvexTriangleCallback(
        this: *mut btConvexTriangleCallback,
        dispatcher: *mut btDispatcher,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btConvexTriangleCallback {
    #[inline]
    pub unsafe fn setTimeStepAndCounters(
        &mut self,
        collisionMarginTriangle: btScalar,
        dispatchInfo: *const btDispatcherInfo,
        convexBodyWrap: *const btCollisionObjectWrapper,
        triBodyWrap: *const btCollisionObjectWrapper,
        resultOut: *mut btManifoldResult,
    ) {
        btConvexTriangleCallback_setTimeStepAndCounters(
            self,
            collisionMarginTriangle,
            dispatchInfo,
            convexBodyWrap,
            triBodyWrap,
            resultOut,
        )
    }
    #[inline]
    pub unsafe fn clearCache(&mut self) {
        btConvexTriangleCallback_clearCache(self)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexTriangleCallback_btConvexTriangleCallback(
            &mut __bindgen_tmp,
            dispatcher,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexTriangleCallback@@QEAAXXZ"]
    pub fn btConvexTriangleCallback_btConvexTriangleCallback_destructor(
        this: *mut btConvexTriangleCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?processTriangle@btConvexTriangleCallback@@UEAAXPEAVbtVector3@@HH@Z"]
    pub fn btConvexTriangleCallback_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
/// btConvexConcaveCollisionAlgorithm  supports collision between convex shapes and (concave) trianges meshes.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexConcaveCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_btConvexTriangleCallback: btConvexTriangleCallback,
    pub m_isSwapped: bool,
    pub __bindgen_padding_0: [u8; 15usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct btConvexConcaveCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
#[repr(C)]
#[derive(Debug)]
pub struct btConvexConcaveCollisionAlgorithm_SwappedCreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}?clearCache@btConvexConcaveCollisionAlgorithm@@QEAAXXZ"]
    pub fn btConvexConcaveCollisionAlgorithm_clearCache(
        this: *mut btConvexConcaveCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexConcaveCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btConvexConcaveCollisionAlgorithm_btConvexConcaveCollisionAlgorithm(
        this: *mut btConvexConcaveCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btConvexConcaveCollisionAlgorithm {
    #[inline]
    pub unsafe fn clearCache(&mut self) {
        btConvexConcaveCollisionAlgorithm_clearCache(self)
    }
    #[inline]
    pub unsafe fn new(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexConcaveCollisionAlgorithm_btConvexConcaveCollisionAlgorithm(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexConcaveCollisionAlgorithm@@QEAAXXZ"]
    pub fn btConvexConcaveCollisionAlgorithm_btConvexConcaveCollisionAlgorithm_destructor(
        this: *mut btConvexConcaveCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btConvexConcaveCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexConcaveCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btConvexConcaveCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexConcaveCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getAllContactManifolds@btConvexConcaveCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z"]
    pub fn btConvexConcaveCollisionAlgorithm_getAllContactManifolds(
        this: *mut ::std::os::raw::c_void,
        manifoldArray: *mut btManifoldArray,
    );
}
/// btSphereBoxCollisionAlgorithm  provides sphere-box collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexPlaneCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_isSwapped: bool,
    pub m_numPerturbationIterations: ::std::os::raw::c_int,
    pub m_minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btConvexPlaneCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
    pub m_numPerturbationIterations: ::std::os::raw::c_int,
    pub m_minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?collideSingleContact@btConvexPlaneCollisionAlgorithm@@QEAAXAEBVbtQuaternion@@PEBUbtCollisionObjectWrapper@@1AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexPlaneCollisionAlgorithm_collideSingleContact(
        this: *mut btConvexPlaneCollisionAlgorithm,
        perturbeRot: *const btQuaternion,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexPlaneCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_NHH@Z"]
    pub fn btConvexPlaneCollisionAlgorithm_btConvexPlaneCollisionAlgorithm(
        this: *mut btConvexPlaneCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
impl btConvexPlaneCollisionAlgorithm {
    #[inline]
    pub unsafe fn collideSingleContact(
        &mut self,
        perturbeRot: *const btQuaternion,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) {
        btConvexPlaneCollisionAlgorithm_collideSingleContact(
            self,
            perturbeRot,
            body0Wrap,
            body1Wrap,
            dispatchInfo,
            resultOut,
        )
    }
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexPlaneCollisionAlgorithm_btConvexPlaneCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexPlaneCollisionAlgorithm@@QEAAXXZ"]
    pub fn btConvexPlaneCollisionAlgorithm_btConvexPlaneCollisionAlgorithm_destructor(
        this: *mut btConvexPlaneCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btConvexPlaneCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexPlaneCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btConvexPlaneCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexPlaneCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
/// EmptyAlgorithm is a stub for unsupported collision pairs.
/// The dispatcher can dispatch a persistent btEmptyAlgorithm to avoid a search every frame.
#[repr(C)]
#[derive(Debug)]
pub struct btEmptyAlgorithm {
    pub _base: btCollisionAlgorithm,
}
#[repr(C)]
#[derive(Debug)]
pub struct btEmptyAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btEmptyAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z"]
    pub fn btEmptyAlgorithm_btEmptyAlgorithm(
        this: *mut btEmptyAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
impl btEmptyAlgorithm {
    #[inline]
    pub unsafe fn new(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btEmptyAlgorithm_btEmptyAlgorithm(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btEmptyAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btEmptyAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btEmptyAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btEmptyAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
#[repr(C)]
pub struct btOverlappingPairCallback__bindgen_vtable(::std::os::raw::c_void);
/// The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
#[repr(C)]
#[derive(Debug)]
pub struct btOverlappingPairCallback {
    pub vtable_: *const btOverlappingPairCallback__bindgen_vtable,
}
pub type btBroadphasePairArray = btAlignedObjectArray<btBroadphasePair>;
#[repr(C)]
pub struct btOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btOverlapCallback {
    pub vtable_: *const btOverlapCallback__bindgen_vtable,
}
#[repr(C)]
pub struct btOverlapFilterCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btOverlapFilterCallback {
    pub vtable_: *const btOverlapFilterCallback__bindgen_vtable,
}
/// The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
/// The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
#[repr(C)]
#[derive(Debug)]
pub struct btOverlappingPairCache {
    pub _base: btOverlappingPairCallback,
}
/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
#[repr(C)]
pub struct btHashedOverlappingPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
    pub m_overlapFilterCallback: *mut btOverlapFilterCallback,
    pub m_hashTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_ghostPairCallback: *mut btOverlappingPairCallback,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btHashedOverlappingPairCache@@QEAA@XZ"]
    pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache(
        this: *mut btHashedOverlappingPairCache,
    );
}
impl btHashedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashedOverlappingPairCache_btHashedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtHashedOverlappingPairCache@@QEAAXXZ"]
    pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache_destructor(
        this: *mut btHashedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPairsContainingProxy@btHashedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPair@btHashedOverlappingPairCache@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z"]
    pub fn btHashedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?cleanProxyFromPairs@btHashedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btHashedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllOverlappingPairs@btHashedOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@@Z"]
    pub fn btHashedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?cleanOverlappingPair@btHashedOverlappingPairCache@@UEAAXAEAUbtBroadphasePair@@PEAVbtDispatcher@@@Z"]
    pub fn btHashedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?findPair@btHashedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z"]
    pub fn btHashedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
/// btSortedOverlappingPairCache maintains the objects with overlapping AABB
/// Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
#[repr(C)]
pub struct btSortedOverlappingPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
    pub m_blockedForChanges: bool,
    /// by default, do the removal during the pair traversal
    pub m_hasDeferredRemoval: bool,
    pub m_overlapFilterCallback: *mut btOverlapFilterCallback,
    pub m_ghostPairCallback: *mut btOverlappingPairCallback,
}
extern "C" {
    #[link_name = "\u{1}??0btSortedOverlappingPairCache@@QEAA@XZ"]
    pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache(
        this: *mut btSortedOverlappingPairCache,
    );
}
impl btSortedOverlappingPairCache {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSortedOverlappingPairCache_btSortedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSortedOverlappingPairCache@@QEAAXXZ"]
    pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache_destructor(
        this: *mut btSortedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllOverlappingPairs@btSortedOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPair@btSortedOverlappingPairCache@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?cleanOverlappingPair@btSortedOverlappingPairCache@@UEAAXAEAUbtBroadphasePair@@PEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?addOverlappingPair@btSortedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z"]
    pub fn btSortedOverlappingPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}?findPair@btSortedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z"]
    pub fn btSortedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}?cleanProxyFromPairs@btSortedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingPairsContainingProxy@btSortedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?sortOverlappingPairs@btSortedOverlappingPairCache@@UEAAXPEAVbtDispatcher@@@Z"]
    pub fn btSortedOverlappingPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
/// btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
#[repr(C)]
pub struct btNullPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
}
#[repr(C)]
pub struct btCollisionWorld__bindgen_vtable(::std::os::raw::c_void);
/// CollisionWorld is interface and container for the collision detection
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld {
    pub vtable_: *const btCollisionWorld__bindgen_vtable,
    pub m_collisionObjects: btAlignedObjectArray<*mut btCollisionObject>,
    pub m_dispatcher1: *mut btDispatcher,
    pub m_dispatchInfo: btDispatcherInfo,
    pub m_broadphasePairCache: *mut btBroadphaseInterface,
    pub m_debugDrawer: *mut btIDebugDraw,
    /// m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
    /// ///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
    pub m_forceUpdateAllAabbs: bool,
}
/// LocalShapeInfo gives extra information for complex shapes
/// ///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalShapeInfo {
    pub m_shapePart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalRayResult {
    pub m_collisionObject: *const btCollisionObject,
    pub m_localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
    pub m_hitNormalLocal: btVector3,
    pub m_hitFraction: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
pub struct btCollisionWorld_RayResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// RayResultCallback is used to report new raycast results
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_RayResultCallback {
    pub vtable_: *const btCollisionWorld_RayResultCallback__bindgen_vtable,
    pub m_closestHitFraction: btScalar,
    pub m_collisionObject: *const btCollisionObject,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ClosestRayResultCallback {
    pub _base: btCollisionWorld_RayResultCallback,
    pub __bindgen_padding_0: u64,
    pub m_rayFromWorld: btVector3,
    pub m_rayToWorld: btVector3,
    pub m_hitNormalWorld: btVector3,
    pub m_hitPointWorld: btVector3,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_AllHitsRayResultCallback {
    pub _base: btCollisionWorld_RayResultCallback,
    pub m_collisionObjects: btAlignedObjectArray<*const btCollisionObject>,
    pub __bindgen_padding_0: u64,
    pub m_rayFromWorld: btVector3,
    pub m_rayToWorld: btVector3,
    pub m_hitNormalWorld: btAlignedObjectArray<btVector3>,
    pub m_hitPointWorld: btAlignedObjectArray<btVector3>,
    pub m_hitFractions: btAlignedObjectArray<btScalar>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalConvexResult {
    pub m_hitCollisionObject: *const btCollisionObject,
    pub m_localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
    pub m_hitNormalLocal: btVector3,
    pub m_hitPointLocal: btVector3,
    pub m_hitFraction: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
pub struct btCollisionWorld_ConvexResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// RayResultCallback is used to report new raycast results
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ConvexResultCallback {
    pub vtable_: *const btCollisionWorld_ConvexResultCallback__bindgen_vtable,
    pub m_closestHitFraction: btScalar,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ClosestConvexResultCallback {
    pub _base: btCollisionWorld_ConvexResultCallback,
    pub __bindgen_padding_0: u64,
    pub m_convexFromWorld: btVector3,
    pub m_convexToWorld: btVector3,
    pub m_hitNormalWorld: btVector3,
    pub m_hitPointWorld: btVector3,
    pub m_hitCollisionObject: *const btCollisionObject,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
pub struct btCollisionWorld_ContactResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// ContactResultCallback is used to report contact points
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ContactResultCallback {
    pub vtable_: *const btCollisionWorld_ContactResultCallback__bindgen_vtable,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_closestDistanceThreshold: btScalar,
}
extern "C" {
    #[link_name = "\u{1}?serializeCollisionObjects@btCollisionWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionWorld_serializeCollisionObjects(
        this: *mut btCollisionWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeContactManifolds@btCollisionWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionWorld_serializeContactManifolds(
        this: *mut btCollisionWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateSingleAabb@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btCollisionWorld_updateSingleAabb(
        this: *mut btCollisionWorld,
        colObj: *mut btCollisionObject,
    );
}
extern "C" {
    /// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
    /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
    #[link_name = "\u{1}?convexSweepTest@btCollisionWorld@@QEBAXPEBVbtConvexShape@@AEBVbtTransform@@1AEAUConvexResultCallback@1@N@Z"]
    pub fn btCollisionWorld_convexSweepTest(
        this: *const btCollisionWorld,
        castShape: *const btConvexShape,
        from: *const btTransform,
        to: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    );
}
extern "C" {
    /// contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
    /// ///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
    #[link_name = "\u{1}?contactTest@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@AEAUContactResultCallback@1@@Z"]
    pub fn btCollisionWorld_contactTest(
        this: *mut btCollisionWorld,
        colObj: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    );
}
extern "C" {
    /// contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
    /// ///it reports one or more contact points (including the one with deepest penetration)
    #[link_name = "\u{1}?contactPairTest@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@0AEAUContactResultCallback@1@@Z"]
    pub fn btCollisionWorld_contactPairTest(
        this: *mut btCollisionWorld,
        colObjA: *mut btCollisionObject,
        colObjB: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    );
}
extern "C" {
    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// /// This allows more customization.
    #[link_name = "\u{1}?rayTestSingle@btCollisionWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@1@@Z"]
    pub fn btCollisionWorld_rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTestSingleInternal@btCollisionWorld@@SAXAEBVbtTransform@@0PEBUbtCollisionObjectWrapper@@AEAURayResultCallback@1@@Z"]
    pub fn btCollisionWorld_rayTestSingleInternal(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObjectWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    /// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
    #[link_name = "\u{1}?objectQuerySingle@btCollisionWorld@@SAXPEBVbtConvexShape@@AEBVbtTransform@@1PEAVbtCollisionObject@@PEBVbtCollisionShape@@1AEAUConvexResultCallback@1@N@Z"]
    pub fn btCollisionWorld_objectQuerySingle(
        castShape: *const btConvexShape,
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?objectQuerySingleInternal@btCollisionWorld@@SAXPEBVbtConvexShape@@AEBVbtTransform@@1PEBUbtCollisionObjectWrapper@@AEAUConvexResultCallback@1@N@Z"]
    pub fn btCollisionWorld_objectQuerySingleInternal(
        castShape: *const btConvexShape,
        convexFromTrans: *const btTransform,
        convexToTrans: *const btTransform,
        colObjWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btCollisionWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btCollisionWorld_btCollisionWorld(
        this: *mut btCollisionWorld,
        dispatcher: *mut btDispatcher,
        broadphasePairCache: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btCollisionWorld {
    #[inline]
    pub unsafe fn serializeCollisionObjects(&mut self, serializer: *mut btSerializer) {
        btCollisionWorld_serializeCollisionObjects(self, serializer)
    }
    #[inline]
    pub unsafe fn serializeContactManifolds(&mut self, serializer: *mut btSerializer) {
        btCollisionWorld_serializeContactManifolds(self, serializer)
    }
    #[inline]
    pub unsafe fn updateSingleAabb(&mut self, colObj: *mut btCollisionObject) {
        btCollisionWorld_updateSingleAabb(self, colObj)
    }
    #[inline]
    pub unsafe fn convexSweepTest(
        &self,
        castShape: *const btConvexShape,
        from: *const btTransform,
        to: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    ) {
        btCollisionWorld_convexSweepTest(
            self,
            castShape,
            from,
            to,
            resultCallback,
            allowedCcdPenetration,
        )
    }
    #[inline]
    pub unsafe fn contactTest(
        &mut self,
        colObj: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    ) {
        btCollisionWorld_contactTest(self, colObj, resultCallback)
    }
    #[inline]
    pub unsafe fn contactPairTest(
        &mut self,
        colObjA: *mut btCollisionObject,
        colObjB: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    ) {
        btCollisionWorld_contactPairTest(self, colObjA, colObjB, resultCallback)
    }
    #[inline]
    pub unsafe fn rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btCollisionWorld_rayTestSingle(
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn rayTestSingleInternal(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObjectWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btCollisionWorld_rayTestSingleInternal(
            rayFromTrans,
            rayToTrans,
            collisionObjectWrap,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn objectQuerySingle(
        castShape: *const btConvexShape,
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    ) {
        btCollisionWorld_objectQuerySingle(
            castShape,
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
            allowedPenetration,
        )
    }
    #[inline]
    pub unsafe fn objectQuerySingleInternal(
        castShape: *const btConvexShape,
        convexFromTrans: *const btTransform,
        convexToTrans: *const btTransform,
        colObjWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    ) {
        btCollisionWorld_objectQuerySingleInternal(
            castShape,
            convexFromTrans,
            convexToTrans,
            colObjWrap,
            resultCallback,
            allowedPenetration,
        )
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        broadphasePairCache: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_btCollisionWorld(
            &mut __bindgen_tmp,
            dispatcher,
            broadphasePairCache,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCollisionWorld@@QEAAXXZ"]
    pub fn btCollisionWorld_btCollisionWorld_destructor(this: *mut btCollisionWorld);
}
extern "C" {
    #[link_name = "\u{1}?updateAabbs@btCollisionWorld@@UEAAXXZ"]
    pub fn btCollisionWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
    /// ///it can be useful to use if you perform ray tests without collision detection/simulation
    #[link_name = "\u{1}?computeOverlappingPairs@btCollisionWorld@@UEAAXXZ"]
    pub fn btCollisionWorld_computeOverlappingPairs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btCollisionWorld@@UEAAXXZ"]
    pub fn btCollisionWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?debugDrawObject@btCollisionWorld@@UEAAXAEBVbtTransform@@PEBVbtCollisionShape@@AEBVbtVector3@@@Z"]
    pub fn btCollisionWorld_debugDrawObject(
        this: *mut ::std::os::raw::c_void,
        worldTransform: *const btTransform,
        shape: *const btCollisionShape,
        color: *const btVector3,
    );
}
extern "C" {
    /// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
    /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
    #[link_name = "\u{1}?rayTest@btCollisionWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@1@@Z"]
    pub fn btCollisionWorld_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?addCollisionObject@btCollisionWorld@@UEAAXPEAVbtCollisionObject@@HH@Z"]
    pub fn btCollisionWorld_addCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeCollisionObject@btCollisionWorld@@UEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btCollisionWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?performDiscreteCollisionDetection@btCollisionWorld@@UEAAXXZ"]
    pub fn btCollisionWorld_performDiscreteCollisionDetection(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
    #[link_name = "\u{1}?serialize@btCollisionWorld@@UEAAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// The btGhostObject can keep track of all objects that are overlapping
/// By default, this overlap is based on the AABB
/// This is useful for creating a character controller, collision sensors/triggers, explosions etc.
/// We plan on adding rayTest and other queries for the btGhostObject
#[repr(C)]
#[derive(Debug)]
pub struct btGhostObject {
    pub _base: btCollisionObject,
    pub m_overlappingObjects: btAlignedObjectArray<*mut btCollisionObject>,
}
extern "C" {
    #[link_name = "\u{1}?convexSweepTest@btGhostObject@@QEBAXPEBVbtConvexShape@@AEBVbtTransform@@1AEAUConvexResultCallback@btCollisionWorld@@N@Z"]
    pub fn btGhostObject_convexSweepTest(
        this: *const btGhostObject,
        castShape: *const btConvexShape,
        convexFromWorld: *const btTransform,
        convexToWorld: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btGhostObject@@QEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btGhostObject_rayTest(
        this: *const btGhostObject,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGhostObject@@QEAA@XZ"]
    pub fn btGhostObject_btGhostObject(this: *mut btGhostObject);
}
impl btGhostObject {
    #[inline]
    pub unsafe fn convexSweepTest(
        &self,
        castShape: *const btConvexShape,
        convexFromWorld: *const btTransform,
        convexToWorld: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    ) {
        btGhostObject_convexSweepTest(
            self,
            castShape,
            convexFromWorld,
            convexToWorld,
            resultCallback,
            allowedCcdPenetration,
        )
    }
    #[inline]
    pub unsafe fn rayTest(
        &self,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btGhostObject_rayTest(self, rayFromWorld, rayToWorld, resultCallback)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGhostObject_btGhostObject(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtGhostObject@@QEAAXXZ"]
    pub fn btGhostObject_btGhostObject_destructor(this: *mut btGhostObject);
}
extern "C" {
    /// this method is mainly for expert/internal use only.
    #[link_name = "\u{1}?addOverlappingObjectInternal@btGhostObject@@UEAAXPEAUbtBroadphaseProxy@@0@Z"]
    pub fn btGhostObject_addOverlappingObjectInternal(
        this: *mut ::std::os::raw::c_void,
        otherProxy: *mut btBroadphaseProxy,
        thisProxy: *mut btBroadphaseProxy,
    );
}
extern "C" {
    /// this method is mainly for expert/internal use only.
    #[link_name = "\u{1}?removeOverlappingObjectInternal@btGhostObject@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@0@Z"]
    pub fn btGhostObject_removeOverlappingObjectInternal(
        this: *mut ::std::os::raw::c_void,
        otherProxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
        thisProxy: *mut btBroadphaseProxy,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btPairCachingGhostObject {
    pub _base: btGhostObject,
    pub m_hashPairCache: *mut btHashedOverlappingPairCache,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btPairCachingGhostObject@@QEAA@XZ"]
    pub fn btPairCachingGhostObject_btPairCachingGhostObject(this: *mut btPairCachingGhostObject);
}
impl btPairCachingGhostObject {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPairCachingGhostObject_btPairCachingGhostObject(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtPairCachingGhostObject@@QEAAXXZ"]
    pub fn btPairCachingGhostObject_btPairCachingGhostObject_destructor(
        this: *mut btPairCachingGhostObject,
    );
}
extern "C" {
    /// this method is mainly for expert/internal use only.
    #[link_name = "\u{1}?addOverlappingObjectInternal@btPairCachingGhostObject@@UEAAXPEAUbtBroadphaseProxy@@0@Z"]
    pub fn btPairCachingGhostObject_addOverlappingObjectInternal(
        this: *mut ::std::os::raw::c_void,
        otherProxy: *mut btBroadphaseProxy,
        thisProxy: *mut btBroadphaseProxy,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeOverlappingObjectInternal@btPairCachingGhostObject@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@0@Z"]
    pub fn btPairCachingGhostObject_removeOverlappingObjectInternal(
        this: *mut ::std::os::raw::c_void,
        otherProxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
        thisProxy: *mut btBroadphaseProxy,
    );
}
/// The btGhostPairCallback interfaces and forwards adding and removal of overlapping pairs from the btBroadphaseInterface to btGhostObject.
#[repr(C)]
#[derive(Debug)]
pub struct btGhostPairCallback {
    pub _base: btOverlappingPairCallback,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btChunk {
    pub m_chunkCode: ::std::os::raw::c_int,
    pub m_length: ::std::os::raw::c_int,
    pub m_oldPtr: *mut ::std::os::raw::c_void,
    pub m_dna_nr: ::std::os::raw::c_int,
    pub m_number: ::std::os::raw::c_int,
}
pub const btSerializationFlags_BT_SERIALIZE_NO_BVH: btSerializationFlags = 1;
pub const btSerializationFlags_BT_SERIALIZE_NO_TRIANGLEINFOMAP: btSerializationFlags = 2;
pub const btSerializationFlags_BT_SERIALIZE_NO_DUPLICATE_ASSERT: btSerializationFlags = 4;
pub const btSerializationFlags_BT_SERIALIZE_CONTACT_MANIFOLDS: btSerializationFlags = 8;
pub type btSerializationFlags = i32;
#[repr(C)]
pub struct btSerializer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSerializer {
    pub vtable_: *const btSerializer__bindgen_vtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btPointerUid {
    pub __bindgen_anon_1: btPointerUid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btPointerUid__bindgen_ty_1 {
    pub m_ptr: *mut ::std::os::raw::c_void,
    pub m_uniqueIds: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btBulletSerializedArrays {
    pub m_bvhsDouble: btAlignedObjectArray<*mut btQuantizedBvhDoubleData>,
    pub m_bvhsFloat: btAlignedObjectArray<*mut btQuantizedBvhFloatData>,
    pub m_colShapeData: btAlignedObjectArray<*mut btCollisionShapeData>,
    pub m_dynamicWorldInfoDataDouble: btAlignedObjectArray<*mut btDynamicsWorldDoubleData>,
    pub m_dynamicWorldInfoDataFloat: btAlignedObjectArray<*mut btDynamicsWorldFloatData>,
    pub m_rigidBodyDataDouble: btAlignedObjectArray<*mut btRigidBodyDoubleData>,
    pub m_rigidBodyDataFloat: btAlignedObjectArray<*mut btRigidBodyFloatData>,
    pub m_collisionObjectDataDouble: btAlignedObjectArray<*mut btCollisionObjectDoubleData>,
    pub m_collisionObjectDataFloat: btAlignedObjectArray<*mut btCollisionObjectFloatData>,
    pub m_constraintDataFloat: btAlignedObjectArray<*mut btTypedConstraintFloatData>,
    pub m_constraintDataDouble: btAlignedObjectArray<*mut btTypedConstraintDoubleData>,
    pub m_constraintData: btAlignedObjectArray<*mut btTypedConstraintData>,
    pub m_softBodyFloatData: btAlignedObjectArray<*mut btSoftBodyFloatData>,
    pub m_softBodyDoubleData: btAlignedObjectArray<*mut btSoftBodyDoubleData>,
}
/// The btDefaultSerializer is the main Bullet serialization class.
/// The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
#[repr(C)]
pub struct btDefaultSerializer {
    pub _base: btSerializer,
    pub mTypes: btAlignedObjectArray<*mut ::std::os::raw::c_char>,
    pub mStructs: btAlignedObjectArray<*mut ::std::os::raw::c_short>,
    pub mTlens: btAlignedObjectArray<::std::os::raw::c_short>,
    pub mStructReverse: btHashMap<btHashInt, ::std::os::raw::c_int>,
    pub mTypeLookup: btHashMap<btHashString, ::std::os::raw::c_int>,
    pub m_chunkP: btHashMap<btHashPtr, *mut ::std::os::raw::c_void>,
    pub m_nameMap: btHashMap<btHashPtr, *const ::std::os::raw::c_char>,
    pub m_uniquePointers: btHashMap<btHashPtr, btPointerUid>,
    pub m_uniqueIdGenerator: ::std::os::raw::c_int,
    pub m_totalSize: ::std::os::raw::c_int,
    pub m_buffer: *mut ::std::os::raw::c_uchar,
    pub m_ownsBuffer: bool,
    pub m_currentSize: ::std::os::raw::c_int,
    pub m_dna: *mut ::std::os::raw::c_void,
    pub m_dnaLength: ::std::os::raw::c_int,
    pub m_serializationFlags: ::std::os::raw::c_int,
    pub m_chunkPtrs: btAlignedObjectArray<*mut btChunk>,
    pub m_skipPointers: btHashMap<btHashPtr, *mut ::std::os::raw::c_void>,
}
/// The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
/// it can be generated using
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfo {
    pub m_flags: ::std::os::raw::c_int,
    pub m_edgeV0V1Angle: btScalar,
    pub m_edgeV1V2Angle: btScalar,
    pub m_edgeV2V0Angle: btScalar,
}
pub type btInternalTriangleInfoMap = btHashMap<btHashInt, btTriangleInfo>;
#[repr(C)]
pub struct btTriangleInfoMap__bindgen_vtable(::std::os::raw::c_void);
/// The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleInfoMap {
    pub vtable_: *const btTriangleInfoMap__bindgen_vtable,
    pub _base: btInternalTriangleInfoMap,
    pub m_convexEpsilon: btScalar,
    /// used to determine if an edge or contact normal is convex, using the dot product
    pub m_planarEpsilon: btScalar,
    /// used to determine if a triangle edge is planar with zero angle
    pub m_equalVertexThreshold: btScalar,
    /// used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared'
    pub m_edgeDistanceThreshold: btScalar,
    /// used to determine edge contacts: if the closest distance between a contact point and an edge is smaller than this distance threshold it is considered to "hit the edge"
    pub m_maxEdgeAngleThreshold: btScalar,
    pub m_zeroAreaThreshold: btScalar,
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?deSerialize@btTriangleInfoMap@@QEAAXAEAUbtTriangleInfoMapData@@@Z"]
    pub fn btTriangleInfoMap_deSerialize(
        this: *mut btTriangleInfoMap,
        data: *mut btTriangleInfoMapData,
    );
}
impl btTriangleInfoMap {
    #[inline]
    pub unsafe fn deSerialize(&mut self, data: *mut btTriangleInfoMapData) {
        btTriangleInfoMap_deSerialize(self, data)
    }
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btTriangleInfoMap@@UEBAHXZ"]
    pub fn btTriangleInfoMap_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btTriangleInfoMap@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btTriangleInfoMap_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// those fields have to be float and not btScalar for the serialization to work properly
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfoData {
    pub m_flags: ::std::os::raw::c_int,
    pub m_edgeV0V1Angle: f32,
    pub m_edgeV1V2Angle: f32,
    pub m_edgeV2V0Angle: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfoMapData {
    pub m_hashTablePtr: *mut ::std::os::raw::c_int,
    pub m_nextPtr: *mut ::std::os::raw::c_int,
    pub m_valueArrayPtr: *mut btTriangleInfoData,
    pub m_keyArrayPtr: *mut ::std::os::raw::c_int,
    pub m_convexEpsilon: f32,
    pub m_planarEpsilon: f32,
    pub m_equalVertexThreshold: f32,
    pub m_edgeDistanceThreshold: f32,
    pub m_zeroAreaThreshold: f32,
    pub m_nextSize: ::std::os::raw::c_int,
    pub m_hashTableSize: ::std::os::raw::c_int,
    pub m_numValues: ::std::os::raw::c_int,
    pub m_numKeys: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
pub const btInternalEdgeAdjustFlags_BT_TRIANGLE_CONVEX_BACKFACE_MODE: btInternalEdgeAdjustFlags = 1;
pub const btInternalEdgeAdjustFlags_BT_TRIANGLE_CONCAVE_DOUBLE_SIDED: btInternalEdgeAdjustFlags = 2;
pub const btInternalEdgeAdjustFlags_BT_TRIANGLE_CONVEX_DOUBLE_SIDED: btInternalEdgeAdjustFlags = 4;
pub type btInternalEdgeAdjustFlags = i32;
extern "C" {
    /// Call btGenerateInternalEdgeInfo to create triangle info, store in the shape 'userInfo'
    #[link_name = "\u{1}?btGenerateInternalEdgeInfo@@YAXPEAVbtBvhTriangleMeshShape@@PEAUbtTriangleInfoMap@@@Z"]
    pub fn btGenerateInternalEdgeInfo(
        trimeshShape: *mut btBvhTriangleMeshShape,
        triangleInfoMap: *mut btTriangleInfoMap,
    );
}
extern "C" {
    /// Call the btFixMeshNormal to adjust the collision normal, using the triangle info map (generated using btGenerateInternalEdgeInfo)
    /// If this info map is missing, or the triangle is not store in this map, nothing will be done
    #[link_name = "\u{1}?btAdjustInternalEdgeContacts@@YAXAEAVbtManifoldPoint@@PEBUbtCollisionObjectWrapper@@1HHH@Z"]
    pub fn btAdjustInternalEdgeContacts(
        cp: *mut btManifoldPoint,
        trimeshColObj0Wrap: *const btCollisionObjectWrapper,
        otherColObj1Wrap: *const btCollisionObjectWrapper,
        partId0: ::std::os::raw::c_int,
        index0: ::std::os::raw::c_int,
        normalAdjustFlags: ::std::os::raw::c_int,
    );
}
/// btSphereBoxCollisionAlgorithm  provides sphere-box collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
#[repr(C)]
#[derive(Debug)]
pub struct btSphereBoxCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_isSwapped: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSphereBoxCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}?getSphereDistance@btSphereBoxCollisionAlgorithm@@QEAA_NPEBUbtCollisionObjectWrapper@@AEAVbtVector3@@1AEANAEBV3@NN@Z"]
    pub fn btSphereBoxCollisionAlgorithm_getSphereDistance(
        this: *mut btSphereBoxCollisionAlgorithm,
        boxObjWrap: *const btCollisionObjectWrapper,
        v3PointOnBox: *mut btVector3,
        normal: *mut btVector3,
        penetrationDepth: *mut btScalar,
        v3SphereCenter: *const btVector3,
        fRadius: btScalar,
        maxContactDistance: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?getSpherePenetration@btSphereBoxCollisionAlgorithm@@QEAANAEBVbtVector3@@0AEAV2@1@Z"]
    pub fn btSphereBoxCollisionAlgorithm_getSpherePenetration(
        this: *mut btSphereBoxCollisionAlgorithm,
        boxHalfExtent: *const btVector3,
        sphereRelPos: *const btVector3,
        closestPoint: *mut btVector3,
        normal: *mut btVector3,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??0btSphereBoxCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z"]
    pub fn btSphereBoxCollisionAlgorithm_btSphereBoxCollisionAlgorithm(
        this: *mut btSphereBoxCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btSphereBoxCollisionAlgorithm {
    #[inline]
    pub unsafe fn getSphereDistance(
        &mut self,
        boxObjWrap: *const btCollisionObjectWrapper,
        v3PointOnBox: *mut btVector3,
        normal: *mut btVector3,
        penetrationDepth: *mut btScalar,
        v3SphereCenter: *const btVector3,
        fRadius: btScalar,
        maxContactDistance: btScalar,
    ) -> bool {
        btSphereBoxCollisionAlgorithm_getSphereDistance(
            self,
            boxObjWrap,
            v3PointOnBox,
            normal,
            penetrationDepth,
            v3SphereCenter,
            fRadius,
            maxContactDistance,
        )
    }
    #[inline]
    pub unsafe fn getSpherePenetration(
        &mut self,
        boxHalfExtent: *const btVector3,
        sphereRelPos: *const btVector3,
        closestPoint: *mut btVector3,
        normal: *mut btVector3,
    ) -> btScalar {
        btSphereBoxCollisionAlgorithm_getSpherePenetration(
            self,
            boxHalfExtent,
            sphereRelPos,
            closestPoint,
            normal,
        )
    }
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereBoxCollisionAlgorithm_btSphereBoxCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSphereBoxCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSphereBoxCollisionAlgorithm_btSphereBoxCollisionAlgorithm_destructor(
        this: *mut btSphereBoxCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSphereBoxCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereBoxCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSphereBoxCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereBoxCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
/// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
/// Also provides the most basic sample for custom/user btCollisionAlgorithm
#[repr(C)]
#[derive(Debug)]
pub struct btSphereTriangleCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_swapped: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSphereTriangleCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btSphereTriangleCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z"]
    pub fn btSphereTriangleCollisionAlgorithm_btSphereTriangleCollisionAlgorithm(
        this: *mut btSphereTriangleCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        swapped: bool,
    );
}
impl btSphereTriangleCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        swapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereTriangleCollisionAlgorithm_btSphereTriangleCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
            swapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSphereTriangleCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereTriangleCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSphereTriangleCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereTriangleCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtSphereTriangleCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSphereTriangleCollisionAlgorithm_btSphereTriangleCollisionAlgorithm_destructor(
        this: *mut btSphereTriangleCollisionAlgorithm,
    );
}
#[repr(C)]
pub struct btCollisionShape__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionObjectWrapperis an internal data structure.
/// Most users can ignore this and use btCollisionObject and btCollisionShape instead
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionShape {
    pub vtable_: *const btCollisionShape__bindgen_vtable,
    pub m_shapeType: ::std::os::raw::c_int,
    pub m_userPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    /// calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
    /// ///result is conservative
    #[link_name = "\u{1}?calculateTemporalAabb@btCollisionShape@@QEBAXAEBVbtTransform@@AEBVbtVector3@@1NAEAV3@2@Z"]
    pub fn btCollisionShape_calculateTemporalAabb(
        this: *const btCollisionShape,
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        temporalAabbMin: *mut btVector3,
        temporalAabbMax: *mut btVector3,
    );
}
impl btCollisionShape {
    #[inline]
    pub unsafe fn calculateTemporalAabb(
        &self,
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        temporalAabbMin: *mut btVector3,
        temporalAabbMax: *mut btVector3,
    ) {
        btCollisionShape_calculateTemporalAabb(
            self,
            curTrans,
            linvel,
            angvel,
            timeStep,
            temporalAabbMin,
            temporalAabbMax,
        )
    }
}
extern "C" {
    #[link_name = "\u{1}?getBoundingSphere@btCollisionShape@@UEBAXAEAVbtVector3@@AEAN@Z"]
    pub fn btCollisionShape_getBoundingSphere(
        this: *mut ::std::os::raw::c_void,
        center: *mut btVector3,
        radius: *mut btScalar,
    );
}
extern "C" {
    /// getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
    #[link_name = "\u{1}?getAngularMotionDisc@btCollisionShape@@UEBANXZ"]
    pub fn btCollisionShape_getAngularMotionDisc(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getContactBreakingThreshold@btCollisionShape@@UEBANN@Z"]
    pub fn btCollisionShape_getContactBreakingThreshold(
        this: *mut ::std::os::raw::c_void,
        defaultContactThresholdFactor: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btCollisionShape@@UEBAHXZ"]
    pub fn btCollisionShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btCollisionShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?serializeSingleShape@btCollisionShape@@UEBAXPEAVbtSerializer@@@Z"]
    pub fn btCollisionShape_serializeSingleShape(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionShapeData {
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_shapeType: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexShape {
    pub _base: btCollisionShape,
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportVertexWithoutMarginNonVirtual@btConvexShape@@QEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(
        this: *const btConvexShape,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportVertexNonVirtual@btConvexShape@@QEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexShape_localGetSupportVertexNonVirtual(
        this: *const btConvexShape,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getMarginNonVirtual@btConvexShape@@QEBANXZ"]
    pub fn btConvexShape_getMarginNonVirtual(this: *const btConvexShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getAabbNonVirtual@btConvexShape@@QEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btConvexShape_getAabbNonVirtual(
        this: *const btConvexShape,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexShape@@QEAA@XZ"]
    pub fn btConvexShape_btConvexShape(this: *mut btConvexShape);
}
impl btConvexShape {
    #[inline]
    pub unsafe fn localGetSupportVertexWithoutMarginNonVirtual(
        &self,
        vec: *const btVector3,
    ) -> btVector3 {
        btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(self, vec)
    }
    #[inline]
    pub unsafe fn localGetSupportVertexNonVirtual(&self, vec: *const btVector3) -> btVector3 {
        btConvexShape_localGetSupportVertexNonVirtual(self, vec)
    }
    #[inline]
    pub unsafe fn getMarginNonVirtual(&self) -> btScalar {
        btConvexShape_getMarginNonVirtual(self)
    }
    #[inline]
    pub unsafe fn getAabbNonVirtual(
        &self,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    ) {
        btConvexShape_getAabbNonVirtual(self, t, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexShape_btConvexShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexShape@@QEAAXXZ"]
    pub fn btConvexShape_btConvexShape_destructor(this: *mut btConvexShape);
}
extern "C" {
    #[link_name = "\u{1}?project@btConvexShape@@UEBAXAEBVbtTransform@@AEBVbtVector3@@AEAN2AEAV3@3@Z"]
    pub fn btConvexShape_project(
        this: *mut ::std::os::raw::c_void,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    );
}
/// The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
/// The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
/// This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
/// Note that when creating small shapes (derived from btConvexInternalShape),
/// you need to make sure to set a smaller collision margin, using the 'setMargin' API
/// There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
#[repr(C)]
#[derive(Debug)]
pub struct btConvexInternalShape {
    pub _base: btConvexShape,
    pub m_localScaling: btVector3,
    pub m_implicitShapeDimensions: btVector3,
    pub m_collisionMargin: btScalar,
    pub m_padding: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btConvexInternalShape@@IEAA@XZ"]
    pub fn btConvexInternalShape_btConvexInternalShape(this: *mut btConvexInternalShape);
}
impl btConvexInternalShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexInternalShape_btConvexInternalShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConvexInternalShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexInternalShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getAabbSlow@btConvexInternalShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btConvexInternalShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btConvexInternalShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvexInternalShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btConvexInternalShape@@UEBAHXZ"]
    pub fn btConvexInternalShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btConvexInternalShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btConvexInternalShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexInternalShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_localScaling: btVector3FloatData,
    pub m_implicitShapeDimensions: btVector3FloatData,
    pub m_collisionMargin: f32,
    pub m_padding: ::std::os::raw::c_int,
}
/// btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
#[repr(C)]
#[derive(Debug)]
pub struct btConvexInternalAabbCachingShape {
    pub _base: btConvexInternalShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_isLocalAabbValid: bool,
    pub __bindgen_padding_0: [u8; 15usize],
}
extern "C" {
    #[link_name = "\u{1}?recalcLocalAabb@btConvexInternalAabbCachingShape@@QEAAXXZ"]
    pub fn btConvexInternalAabbCachingShape_recalcLocalAabb(
        this: *mut btConvexInternalAabbCachingShape,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexInternalAabbCachingShape@@IEAA@XZ"]
    pub fn btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(
        this: *mut btConvexInternalAabbCachingShape,
    );
}
impl btConvexInternalAabbCachingShape {
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btConvexInternalAabbCachingShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btConvexInternalAabbCachingShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvexInternalAabbCachingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btConvexInternalAabbCachingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btConvexInternalAabbCachingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
/// The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
#[repr(C)]
#[derive(Debug)]
pub struct btPolyhedralConvexShape {
    pub _base: btConvexInternalShape,
    pub m_polyhedron: *mut btConvexPolyhedron,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btPolyhedralConvexShape@@QEAA@XZ"]
    pub fn btPolyhedralConvexShape_btPolyhedralConvexShape(this: *mut btPolyhedralConvexShape);
}
impl btPolyhedralConvexShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPolyhedralConvexShape_btPolyhedralConvexShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtPolyhedralConvexShape@@QEAAXXZ"]
    pub fn btPolyhedralConvexShape_btPolyhedralConvexShape_destructor(
        this: *mut btPolyhedralConvexShape,
    );
}
extern "C" {
    /// optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
    /// ///experimental/work-in-progress
    #[link_name = "\u{1}?initializePolyhedralFeatures@btPolyhedralConvexShape@@UEAA_NH@Z"]
    pub fn btPolyhedralConvexShape_initializePolyhedralFeatures(
        this: *mut ::std::os::raw::c_void,
        shiftVerticesByMargin: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btPolyhedralConvexShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btPolyhedralConvexShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btPolyhedralConvexShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btPolyhedralConvexShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
/// The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
#[repr(C)]
#[derive(Debug)]
pub struct btPolyhedralConvexAabbCachingShape {
    pub _base: btPolyhedralConvexShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_isLocalAabbValid: bool,
    pub __bindgen_padding_0: [u8; 15usize],
}
extern "C" {
    #[link_name = "\u{1}?recalcLocalAabb@btPolyhedralConvexAabbCachingShape@@QEAAXXZ"]
    pub fn btPolyhedralConvexAabbCachingShape_recalcLocalAabb(
        this: *mut btPolyhedralConvexAabbCachingShape,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btPolyhedralConvexAabbCachingShape@@IEAA@XZ"]
    pub fn btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(
        this: *mut btPolyhedralConvexAabbCachingShape,
    );
}
impl btPolyhedralConvexAabbCachingShape {
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btPolyhedralConvexAabbCachingShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btPolyhedralConvexAabbCachingShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btPolyhedralConvexAabbCachingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btPolyhedralConvexAabbCachingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btPolyhedralConvexAabbCachingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
/// The btBox2dShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
#[repr(C)]
#[derive(Debug)]
pub struct btBox2dShape {
    pub _base: btPolyhedralConvexShape,
    pub m_centroid: btVector3,
    pub m_vertices: [btVector3; 4usize],
    pub m_normals: [btVector3; 4usize],
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btBox2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btBox2dShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btBox2dShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btBox2dShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
/// The btConvex2dShape allows to use arbitrary convex shapes as 2d convex shapes, with the Z component assumed to be 0.
/// For 2d boxes, the btBox2dShape is recommended.
#[repr(C)]
#[derive(Debug)]
pub struct btConvex2dShape {
    pub _base: btConvexShape,
    pub m_childConvexShape: *mut btConvexShape,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btConvex2dShape@@QEAA@PEAVbtConvexShape@@@Z"]
    pub fn btConvex2dShape_btConvex2dShape(
        this: *mut btConvex2dShape,
        convexChildShape: *mut btConvexShape,
    );
}
impl btConvex2dShape {
    #[inline]
    pub unsafe fn new(convexChildShape: *mut btConvexShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvex2dShape_btConvex2dShape(&mut __bindgen_tmp, convexChildShape);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvex2dShape@@QEAAXXZ"]
    pub fn btConvex2dShape_btConvex2dShape_destructor(this: *mut btConvex2dShape);
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btConvex2dShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvex2dShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConvex2dShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvex2dShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvex2dShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btConvex2dShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btConvex2dShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btConvex2dShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    #[link_name = "\u{1}?getAabb@btConvex2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btConvex2dShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabbSlow@btConvex2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btConvex2dShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btConvex2dShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvex2dShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btConvex2dShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btConvex2dShape_getLocalScaling(this: *mut ::std::os::raw::c_void) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?setMargin@btConvex2dShape@@UEAAXN@Z"]
    pub fn btConvex2dShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?getMargin@btConvex2dShape@@UEBANXZ"]
    pub fn btConvex2dShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getNumPreferredPenetrationDirections@btConvex2dShape@@UEBAHXZ"]
    pub fn btConvex2dShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPreferredPenetrationDirection@btConvex2dShape@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btConvex2dShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
/// The btConvexPointCloudShape implements an implicit convex hull of an array of vertices.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexPointCloudShape {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_unscaledPoints: *mut btVector3,
    pub m_numPoints: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConvexPointCloudShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexPointCloudShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btConvexPointCloudShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexPointCloudShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexPointCloudShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btConvexPointCloudShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumVertices@btConvexPointCloudShape@@UEBAHXZ"]
    pub fn btConvexPointCloudShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getNumEdges@btConvexPointCloudShape@@UEBAHXZ"]
    pub fn btConvexPointCloudShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getEdge@btConvexPointCloudShape@@UEBAXHAEAVbtVector3@@0@Z"]
    pub fn btConvexPointCloudShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVertex@btConvexPointCloudShape@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btConvexPointCloudShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumPlanes@btConvexPointCloudShape@@UEBAHXZ"]
    pub fn btConvexPointCloudShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPlane@btConvexPointCloudShape@@UEBAXAEAVbtVector3@@0H@Z"]
    pub fn btConvexPointCloudShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?isInside@btConvexPointCloudShape@@UEBA_NAEBVbtVector3@@N@Z"]
    pub fn btConvexPointCloudShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {
    /// in case we receive negative scaling
    #[link_name = "\u{1}?setLocalScaling@btConvexPointCloudShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvexPointCloudShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btFace {
    pub m_indices: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_plane: [btScalar; 4usize],
}
#[repr(C)]
pub struct btConvexPolyhedron__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btConvexPolyhedron {
    pub vtable_: *const btConvexPolyhedron__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_vertices: btAlignedObjectArray<btVector3>,
    pub m_faces: btAlignedObjectArray<btFace>,
    pub m_uniqueEdges: btAlignedObjectArray<btVector3>,
    pub m_localCenter: btVector3,
    pub m_extents: btVector3,
    pub m_radius: btScalar,
    pub __bindgen_padding_1: u64,
    pub mC: btVector3,
    pub mE: btVector3,
}
extern "C" {
    #[link_name = "\u{1}?initialize@btConvexPolyhedron@@QEAAXXZ"]
    pub fn btConvexPolyhedron_initialize(this: *mut btConvexPolyhedron);
}
extern "C" {
    #[link_name = "\u{1}?testContainment@btConvexPolyhedron@@QEBA_NXZ"]
    pub fn btConvexPolyhedron_testContainment(this: *const btConvexPolyhedron) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?project@btConvexPolyhedron@@QEBAXAEBVbtTransform@@AEBVbtVector3@@AEAN2AEAV3@3@Z"]
    pub fn btConvexPolyhedron_project(
        this: *const btConvexPolyhedron,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexPolyhedron@@QEAA@XZ"]
    pub fn btConvexPolyhedron_btConvexPolyhedron(this: *mut btConvexPolyhedron);
}
impl btConvexPolyhedron {
    #[inline]
    pub unsafe fn initialize(&mut self) {
        btConvexPolyhedron_initialize(self)
    }
    #[inline]
    pub unsafe fn testContainment(&self) -> bool {
        btConvexPolyhedron_testContainment(self)
    }
    #[inline]
    pub unsafe fn project(
        &self,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    ) {
        btConvexPolyhedron_project(self, trans, dir, minProj, maxProj, witnesPtMin, witnesPtMax)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexPolyhedron_btConvexPolyhedron(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexPolyhedron@@QEAAXXZ"]
    pub fn btConvexPolyhedron_btConvexPolyhedron_destructor(this: *mut btConvexPolyhedron);
}
pub const PHY_ScalarType_PHY_FLOAT: PHY_ScalarType = 0;
pub const PHY_ScalarType_PHY_DOUBLE: PHY_ScalarType = 1;
pub const PHY_ScalarType_PHY_INTEGER: PHY_ScalarType = 2;
pub const PHY_ScalarType_PHY_SHORT: PHY_ScalarType = 3;
pub const PHY_ScalarType_PHY_FIXEDPOINT88: PHY_ScalarType = 4;
pub const PHY_ScalarType_PHY_UCHAR: PHY_ScalarType = 5;
/// PHY_ScalarType enumerates possible scalar types.
/// See the btStridingMeshInterface or btHeightfieldTerrainShape for its use
pub type PHY_ScalarType = i32;
/// The btConcaveShape class provides an interface for non-moving (static) concave shapes.
/// It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
#[repr(C)]
#[derive(Debug)]
pub struct btConcaveShape {
    pub _base: btCollisionShape,
    pub m_collisionMargin: btScalar,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btConcaveShape@@QEAA@XZ"]
    pub fn btConcaveShape_btConcaveShape(this: *mut btConcaveShape);
}
impl btConcaveShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConcaveShape_btConcaveShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConcaveShape@@QEAAXXZ"]
    pub fn btConcaveShape_btConcaveShape_destructor(this: *mut btConcaveShape);
}
/// btHeightfieldTerrainShape simulates a 2D heightfield terrain
/// **
/// The caller is responsible for maintaining the heightfield array; this
/// class does not make a copy.
///
/// The heightfield can be dynamic so long as the min/max height values
/// capture the extremes (heights must always be in that range).
///
/// The local origin of the heightfield is assumed to be the exact
/// center (as determined by width and length and height, with each
/// axis multiplied by the localScaling).
///
/// \b NOTE: be careful with coordinates.  If you have a heightfield with a local
/// min height of -100m, and a max height of +500m, you may be tempted to place it
/// at the origin (0,0) and expect the heights in world coordinates to be
/// -100 to +500 meters.
/// Actually, the heights will be -300 to +300m, because bullet will re-center
/// the heightfield based on its AABB (which is determined by the min/max
/// heights).  So keep in mind that once you create a btHeightfieldTerrainShape
/// object, the heights will be adjusted relative to the center of the AABB.  This
/// is different to the behavior of many rendering engines, but is useful for
/// physics engines.
///
/// Most (but not all) rendering and heightfield libraries assume upAxis = 1
/// (that is, the y-axis is "up").  This class allows any of the 3 coordinates
/// to be "up".  Make sure your choice of axis is consistent with your rendering
/// system.
///
/// The heightfield heights are determined from the data type used for the
/// heightfieldData array.
///
/// - PHY_UCHAR: height at a point is the uchar value at the
/// grid point, multipled by heightScale.  uchar isn't recommended
/// because of its inability to deal with negative values, and
/// low resolution (8-bit).
///
/// - PHY_SHORT: height at a point is the short int value at that grid
/// point, multipled by heightScale.
///
/// - PHY_FLOAT: height at a point is the float value at that grid
/// point.  heightScale is ignored when using the float heightfield
/// data type.
///
/// Whatever the caller specifies as minHeight and maxHeight will be honored.
/// The class will not inspect the heightfield to discover the actual minimum
/// or maximum heights.  These values are used to determine the heightfield's
/// axis-aligned bounding box, multiplied by localScaling.
///
/// For usage and testing see the TerrainDemo.
/// */
#[repr(C)]
pub struct btHeightfieldTerrainShape {
    pub _base: btConcaveShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_localOrigin: btVector3,
    /// terrain data
    pub m_heightStickWidth: ::std::os::raw::c_int,
    pub m_heightStickLength: ::std::os::raw::c_int,
    pub m_minHeight: btScalar,
    pub m_maxHeight: btScalar,
    pub m_width: btScalar,
    pub m_length: btScalar,
    pub m_heightScale: btScalar,
    pub __bindgen_anon_1: btHeightfieldTerrainShape__bindgen_ty_1,
    pub m_heightDataType: PHY_ScalarType,
    pub m_flipQuadEdges: bool,
    pub m_useDiamondSubdivision: bool,
    pub m_useZigzagSubdivision: bool,
    pub m_upAxis: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_localScaling: btVector3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btHeightfieldTerrainShape__bindgen_ty_1 {
    pub m_heightfieldDataUnsignedChar: *const ::std::os::raw::c_uchar,
    pub m_heightfieldDataShort: *const ::std::os::raw::c_short,
    pub m_heightfieldDataFloat: *const btScalar,
    pub m_heightfieldDataUnknown: *const ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
extern "C" {
    #[link_name = "\u{1}?quantizeWithClamp@btHeightfieldTerrainShape@@IEBAXPEAHAEBVbtVector3@@H@Z"]
    pub fn btHeightfieldTerrainShape_quantizeWithClamp(
        this: *const btHeightfieldTerrainShape,
        out: *mut ::std::os::raw::c_int,
        point: *const btVector3,
        isMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVertex@btHeightfieldTerrainShape@@IEBAXHHAEAVbtVector3@@@Z"]
    pub fn btHeightfieldTerrainShape_getVertex(
        this: *const btHeightfieldTerrainShape,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        vertex: *mut btVector3,
    );
}
extern "C" {
    /// protected initialization
    /// /**
    /// Handles the work of constructors so that public constructors can be
    /// backwards-compatible without a lot of copy/paste.
    /// */
    #[link_name = "\u{1}?initialize@btHeightfieldTerrainShape@@IEAAXHHPEBXNNNHW4PHY_ScalarType@@_N@Z"]
    pub fn btHeightfieldTerrainShape_initialize(
        this: *mut btHeightfieldTerrainShape,
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        heightScale: btScalar,
        minHeight: btScalar,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        heightDataType: PHY_ScalarType,
        flipQuadEdges: bool,
    );
}
extern "C" {
    /// preferred constructor
    /// /**
    /// This constructor supports a range of heightfield
    /// data types, and allows for a non-zero minimum height value.
    /// heightScale is needed for any integer-based heightfield data types.
    /// */
    #[link_name = "\u{1}??0btHeightfieldTerrainShape@@QEAA@HHPEBXNNNHW4PHY_ScalarType@@_N@Z"]
    pub fn btHeightfieldTerrainShape_btHeightfieldTerrainShape(
        this: *mut btHeightfieldTerrainShape,
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        heightScale: btScalar,
        minHeight: btScalar,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        heightDataType: PHY_ScalarType,
        flipQuadEdges: bool,
    );
}
extern "C" {
    /// legacy constructor
    /// /**
    /// The legacy constructor assumes the heightfield has a minimum height
    /// of zero.  Only unsigned char or floats are supported.  For legacy
    /// compatibility reasons, heightScale is calculated as maxHeight / 65535
    /// (and is only used when useFloatData = false).
    /// */
    #[link_name = "\u{1}??0btHeightfieldTerrainShape@@QEAA@HHPEBXNH_N1@Z"]
    pub fn btHeightfieldTerrainShape_btHeightfieldTerrainShape1(
        this: *mut btHeightfieldTerrainShape,
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        useFloatData: bool,
        flipQuadEdges: bool,
    );
}
impl btHeightfieldTerrainShape {
    #[inline]
    pub unsafe fn quantizeWithClamp(
        &self,
        out: *mut ::std::os::raw::c_int,
        point: *const btVector3,
        isMax: ::std::os::raw::c_int,
    ) {
        btHeightfieldTerrainShape_quantizeWithClamp(self, out, point, isMax)
    }
    #[inline]
    pub unsafe fn getVertex(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        vertex: *mut btVector3,
    ) {
        btHeightfieldTerrainShape_getVertex(self, x, y, vertex)
    }
    #[inline]
    pub unsafe fn initialize(
        &mut self,
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        heightScale: btScalar,
        minHeight: btScalar,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        heightDataType: PHY_ScalarType,
        flipQuadEdges: bool,
    ) {
        btHeightfieldTerrainShape_initialize(
            self,
            heightStickWidth,
            heightStickLength,
            heightfieldData,
            heightScale,
            minHeight,
            maxHeight,
            upAxis,
            heightDataType,
            flipQuadEdges,
        )
    }
    #[inline]
    pub unsafe fn new(
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        heightScale: btScalar,
        minHeight: btScalar,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        heightDataType: PHY_ScalarType,
        flipQuadEdges: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHeightfieldTerrainShape_btHeightfieldTerrainShape(
            &mut __bindgen_tmp,
            heightStickWidth,
            heightStickLength,
            heightfieldData,
            heightScale,
            minHeight,
            maxHeight,
            upAxis,
            heightDataType,
            flipQuadEdges,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        heightStickWidth: ::std::os::raw::c_int,
        heightStickLength: ::std::os::raw::c_int,
        heightfieldData: *const ::std::os::raw::c_void,
        maxHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        useFloatData: bool,
        flipQuadEdges: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHeightfieldTerrainShape_btHeightfieldTerrainShape1(
            &mut __bindgen_tmp,
            heightStickWidth,
            heightStickLength,
            heightfieldData,
            maxHeight,
            upAxis,
            useFloatData,
            flipQuadEdges,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getRawHeightFieldValue@btHeightfieldTerrainShape@@MEBANHH@Z"]
    pub fn btHeightfieldTerrainShape_getRawHeightFieldValue(
        this: *mut ::std::os::raw::c_void,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtHeightfieldTerrainShape@@QEAAXXZ"]
    pub fn btHeightfieldTerrainShape_btHeightfieldTerrainShape_destructor(
        this: *mut btHeightfieldTerrainShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btHeightfieldTerrainShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btHeightfieldTerrainShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btHeightfieldTerrainShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btHeightfieldTerrainShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btHeightfieldTerrainShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btHeightfieldTerrainShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btHeightfieldTerrainShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btHeightfieldTerrainShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btHeightfieldTerrainShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btHeightfieldTerrainShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiIndex {
    pub ijk: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedBox3d {
    pub m_min: btVector3,
    pub m_max: btVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShapeMatrix {
    pub m_vec: [f64; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShapeGradients {
    pub m_vec: [btVector3; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCell32 {
    pub m_cells: [::std::os::raw::c_uint; 32usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct btMiniSDF {
    pub m_domain: btAlignedBox3d,
    pub m_resolution: [::std::os::raw::c_uint; 3usize],
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_cell_size: btVector3,
    pub m_inv_cell_size: btVector3,
    pub m_n_cells: usize,
    pub m_n_fields: usize,
    pub m_isValid: bool,
    pub m_nodes: btAlignedObjectArray<btAlignedObjectArray<f64>>,
    pub m_cells: btAlignedObjectArray<btAlignedObjectArray<btCell32>>,
    pub m_cell_map: btAlignedObjectArray<btAlignedObjectArray<::std::os::raw::c_uint>>,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}?load@btMiniSDF@@QEAA_NPEBDH@Z"]
    pub fn btMiniSDF_load(
        this: *mut btMiniSDF,
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?multiToSingleIndex@btMiniSDF@@QEBAIAEBUbtMultiIndex@@@Z"]
    pub fn btMiniSDF_multiToSingleIndex(
        this: *const btMiniSDF,
        ijk: *const btMultiIndex,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?subdomain@btMiniSDF@@QEBA?AUbtAlignedBox3d@@AEBUbtMultiIndex@@@Z"]
    pub fn btMiniSDF_subdomain(this: *const btMiniSDF, ijk: *const btMultiIndex) -> btAlignedBox3d;
}
extern "C" {
    #[link_name = "\u{1}?singleToMultiIndex@btMiniSDF@@QEBA?AUbtMultiIndex@@I@Z"]
    pub fn btMiniSDF_singleToMultiIndex(
        this: *const btMiniSDF,
        l: ::std::os::raw::c_uint,
    ) -> btMultiIndex;
}
extern "C" {
    #[link_name = "\u{1}?subdomain@btMiniSDF@@QEBA?AUbtAlignedBox3d@@I@Z"]
    pub fn btMiniSDF_subdomain1(
        this: *const btMiniSDF,
        l: ::std::os::raw::c_uint,
    ) -> btAlignedBox3d;
}
extern "C" {
    #[link_name = "\u{1}?shape_function_@btMiniSDF@@QEBA?AUbtShapeMatrix@@AEBVbtVector3@@PEAUbtShapeGradients@@@Z"]
    pub fn btMiniSDF_shape_function_(
        this: *const btMiniSDF,
        xi: *const btVector3,
        gradient: *mut btShapeGradients,
    ) -> btShapeMatrix;
}
extern "C" {
    #[link_name = "\u{1}?interpolate@btMiniSDF@@QEBA_NIAEANAEBVbtVector3@@PEAV2@@Z"]
    pub fn btMiniSDF_interpolate(
        this: *const btMiniSDF,
        field_id: ::std::os::raw::c_uint,
        dist: *mut f64,
        x: *const btVector3,
        gradient: *mut btVector3,
    ) -> bool;
}
impl btMiniSDF {
    #[inline]
    pub unsafe fn load(
        &mut self,
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> bool {
        btMiniSDF_load(self, data, size)
    }
    #[inline]
    pub unsafe fn multiToSingleIndex(&self, ijk: *const btMultiIndex) -> ::std::os::raw::c_uint {
        btMiniSDF_multiToSingleIndex(self, ijk)
    }
    #[inline]
    pub unsafe fn subdomain(&self, ijk: *const btMultiIndex) -> btAlignedBox3d {
        btMiniSDF_subdomain(self, ijk)
    }
    #[inline]
    pub unsafe fn singleToMultiIndex(&self, l: ::std::os::raw::c_uint) -> btMultiIndex {
        btMiniSDF_singleToMultiIndex(self, l)
    }
    #[inline]
    pub unsafe fn subdomain1(&self, l: ::std::os::raw::c_uint) -> btAlignedBox3d {
        btMiniSDF_subdomain1(self, l)
    }
    #[inline]
    pub unsafe fn shape_function_(
        &self,
        xi: *const btVector3,
        gradient: *mut btShapeGradients,
    ) -> btShapeMatrix {
        btMiniSDF_shape_function_(self, xi, gradient)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        field_id: ::std::os::raw::c_uint,
        dist: *mut f64,
        x: *const btVector3,
        gradient: *mut btVector3,
    ) -> bool {
        btMiniSDF_interpolate(self, field_id, dist, x, gradient)
    }
}
/// The btMinkowskiSumShape is only for advanced users. This shape represents implicit based minkowski sum of two convex implicit shapes.
#[repr(C)]
#[derive(Debug)]
pub struct btMinkowskiSumShape {
    pub _base: btConvexInternalShape,
    pub m_transA: btTransform,
    pub m_transB: btTransform,
    pub m_shapeA: *const btConvexShape,
    pub m_shapeB: *const btConvexShape,
}
extern "C" {
    #[link_name = "\u{1}??0btMinkowskiSumShape@@QEAA@PEBVbtConvexShape@@0@Z"]
    pub fn btMinkowskiSumShape_btMinkowskiSumShape(
        this: *mut btMinkowskiSumShape,
        shapeA: *const btConvexShape,
        shapeB: *const btConvexShape,
    );
}
impl btMinkowskiSumShape {
    #[inline]
    pub unsafe fn new(shapeA: *const btConvexShape, shapeB: *const btConvexShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMinkowskiSumShape_btMinkowskiSumShape(&mut __bindgen_tmp, shapeA, shapeB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btMinkowskiSumShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btMinkowskiSumShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btMinkowskiSumShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btMinkowskiSumShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btMinkowskiSumShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btMinkowskiSumShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getMargin@btMinkowskiSumShape@@UEBANXZ"]
    pub fn btMinkowskiSumShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
#[repr(C)]
pub struct btStridingMeshInterface__bindgen_vtable(::std::os::raw::c_void);
/// The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
/// Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
/// It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
#[repr(C)]
#[derive(Debug)]
pub struct btStridingMeshInterface {
    pub vtable_: *const btStridingMeshInterface__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_scaling: btVector3,
}
extern "C" {
    /// brute force method to calculate aabb
    #[link_name = "\u{1}?calculateAabbBruteForce@btStridingMeshInterface@@QEAAXAEAVbtVector3@@0@Z"]
    pub fn btStridingMeshInterface_calculateAabbBruteForce(
        this: *mut btStridingMeshInterface,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
impl btStridingMeshInterface {
    #[inline]
    pub unsafe fn calculateAabbBruteForce(
        &mut self,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    ) {
        btStridingMeshInterface_calculateAabbBruteForce(self, aabbMin, aabbMax)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtStridingMeshInterface@@QEAAXXZ"]
    pub fn btStridingMeshInterface_btStridingMeshInterface_destructor(
        this: *mut btStridingMeshInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}?InternalProcessAllTriangles@btStridingMeshInterface@@UEBAXPEAVbtInternalTriangleIndexCallback@@AEBVbtVector3@@1@Z"]
    pub fn btStridingMeshInterface_InternalProcessAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btInternalTriangleIndexCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btStridingMeshInterface@@UEBAHXZ"]
    pub fn btStridingMeshInterface_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btStridingMeshInterface@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btStridingMeshInterface_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIntIndexData {
    pub m_value: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShortIntIndexData {
    pub m_value: ::std::os::raw::c_short,
    pub m_pad: [::std::os::raw::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShortIntIndexTripletData {
    pub m_values: [::std::os::raw::c_short; 3usize],
    pub m_pad: [::std::os::raw::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCharIndexTripletData {
    pub m_values: [::std::os::raw::c_uchar; 3usize],
    pub m_pad: ::std::os::raw::c_char,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMeshPartData {
    pub m_vertices3f: *mut btVector3FloatData,
    pub m_vertices3d: *mut btVector3DoubleData,
    pub m_indices32: *mut btIntIndexData,
    pub m_3indices16: *mut btShortIntIndexTripletData,
    pub m_3indices8: *mut btCharIndexTripletData,
    pub m_indices16: *mut btShortIntIndexData,
    pub m_numTriangles: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btStridingMeshInterfaceData {
    pub m_meshPartsPtr: *mut btMeshPartData,
    pub m_scaling: btVector3FloatData,
    pub m_numMeshParts: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleMeshShape {
    pub _base: btConcaveShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_meshInterface: *mut btStridingMeshInterface,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?recalcLocalAabb@btTriangleMeshShape@@QEAAXXZ"]
    pub fn btTriangleMeshShape_recalcLocalAabb(this: *mut btTriangleMeshShape);
}
extern "C" {
    /// btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
    /// ///Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!
    #[link_name = "\u{1}??0btTriangleMeshShape@@IEAA@PEAVbtStridingMeshInterface@@@Z"]
    pub fn btTriangleMeshShape_btTriangleMeshShape(
        this: *mut btTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
    );
}
impl btTriangleMeshShape {
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btTriangleMeshShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn new(meshInterface: *mut btStridingMeshInterface) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleMeshShape_btTriangleMeshShape(&mut __bindgen_tmp, meshInterface);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtTriangleMeshShape@@QEAAXXZ"]
    pub fn btTriangleMeshShape_btTriangleMeshShape_destructor(this: *mut btTriangleMeshShape);
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btTriangleMeshShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btTriangleMeshShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btTriangleMeshShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btTriangleMeshShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btTriangleMeshShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btTriangleMeshShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
/// btQuantizedBvhNode is a compressed aabb node, 16 bytes.
/// Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhNode {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
}
/// btOptimizedBvhNode contains both internal and leaf node information.
/// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNode {
    pub m_aabbMinOrg: btVector3,
    pub m_aabbMaxOrg: btVector3,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 20usize],
}
/// btBvhSubtreeInfo provides info to gather a subtree of limited size
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBvhSubtreeInfo {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_rootNodeIndex: ::std::os::raw::c_int,
    pub m_subtreeSize: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 3usize],
}
#[repr(C)]
pub struct btNodeOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btNodeOverlapCallback {
    pub vtable_: *const btNodeOverlapCallback__bindgen_vtable,
}
/// for code readability:
pub type NodeArray = btAlignedObjectArray<btOptimizedBvhNode>;
pub type QuantizedNodeArray = btAlignedObjectArray<btQuantizedBvhNode>;
pub type BvhSubtreeInfoArray = btAlignedObjectArray<btBvhSubtreeInfo>;
#[repr(C)]
pub struct btQuantizedBvh__bindgen_vtable(::std::os::raw::c_void);
/// The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
/// It is used by the btBvhTriangleMeshShape as midphase.
/// It is recommended to use quantization for better performance and lower memory requirements.
#[repr(C)]
#[derive(Debug)]
pub struct btQuantizedBvh {
    pub vtable_: *const btQuantizedBvh__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_bvhAabbMin: btVector3,
    pub m_bvhAabbMax: btVector3,
    pub m_bvhQuantization: btVector3,
    pub m_bulletVersion: ::std::os::raw::c_int,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: bool,
    pub m_leafNodes: NodeArray,
    pub m_contiguousNodes: NodeArray,
    pub m_quantizedLeafNodes: QuantizedNodeArray,
    pub m_quantizedContiguousNodes: QuantizedNodeArray,
    pub m_traversalMode: btQuantizedBvh_btTraversalMode,
    pub m_SubtreeHeaders: BvhSubtreeInfoArray,
    pub m_subtreeHeaderCount: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u32,
}
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS: btQuantizedBvh_btTraversalMode = 0;
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS_CACHE_FRIENDLY:
    btQuantizedBvh_btTraversalMode = 1;
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_RECURSIVE: btQuantizedBvh_btTraversalMode = 2;
pub type btQuantizedBvh_btTraversalMode = i32;
extern "C" {
    #[link_name = "\u{1}?swapLeafNodes@btQuantizedBvh@@IEAAXHH@Z"]
    pub fn btQuantizedBvh_swapLeafNodes(
        this: *mut btQuantizedBvh,
        firstIndex: ::std::os::raw::c_int,
        secondIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?assignInternalNodeFromLeafNode@btQuantizedBvh@@IEAAXHH@Z"]
    pub fn btQuantizedBvh_assignInternalNodeFromLeafNode(
        this: *mut btQuantizedBvh,
        internalNode: ::std::os::raw::c_int,
        leafNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildTree@btQuantizedBvh@@IEAAXHH@Z"]
    pub fn btQuantizedBvh_buildTree(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calcSplittingAxis@btQuantizedBvh@@IEAAHHH@Z"]
    pub fn btQuantizedBvh_calcSplittingAxis(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?sortAndCalcSplittingIndex@btQuantizedBvh@@IEAAHHHH@Z"]
    pub fn btQuantizedBvh_sortAndCalcSplittingIndex(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?walkStacklessTree@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z"]
    pub fn btQuantizedBvh_walkStacklessTree(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?walkStacklessQuantizedTreeAgainstRay@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111HH@Z"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?walkStacklessQuantizedTree@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@PEAG1HH@Z"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTree(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?walkStacklessTreeAgainstRay@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111HH@Z"]
    pub fn btQuantizedBvh_walkStacklessTreeAgainstRay(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// tree traversal designed for small-memory processors like PS3 SPU
    #[link_name = "\u{1}?walkStacklessQuantizedTreeCacheFriendly@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@PEAG1@Z"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    );
}
extern "C" {
    /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
    #[link_name = "\u{1}?walkRecursiveQuantizedTreeAgainstQueryAabb@btQuantizedBvh@@IEBAXPEBUbtQuantizedBvhNode@@PEAVbtNodeOverlapCallback@@PEAG2@Z"]
    pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
        this: *const btQuantizedBvh,
        currentNode: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    );
}
extern "C" {
    /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
    #[link_name = "\u{1}?walkRecursiveQuantizedTreeAgainstQuantizedTree@btQuantizedBvh@@IEBAXPEBUbtQuantizedBvhNode@@0PEAVbtNodeOverlapCallback@@@Z"]
    pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
        this: *const btQuantizedBvh,
        treeNodeA: *const btQuantizedBvhNode,
        treeNodeB: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateSubtreeHeaders@btQuantizedBvh@@IEAAXHH@Z"]
    pub fn btQuantizedBvh_updateSubtreeHeaders(
        this: *mut btQuantizedBvh,
        leftChildNodexIndex: ::std::os::raw::c_int,
        rightChildNodexIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// ***************************************** expert/internal use only *************************
    #[link_name = "\u{1}?setQuantizationValues@btQuantizedBvh@@QEAAXAEBVbtVector3@@0N@Z"]
    pub fn btQuantizedBvh_setQuantizationValues(
        this: *mut btQuantizedBvh,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        quantizationMargin: btScalar,
    );
}
extern "C" {
    /// buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized
    #[link_name = "\u{1}?buildInternal@btQuantizedBvh@@QEAAXXZ"]
    pub fn btQuantizedBvh_buildInternal(this: *mut btQuantizedBvh);
}
extern "C" {
    /// ***************************************** expert/internal use only *************************
    #[link_name = "\u{1}?reportAabbOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z"]
    pub fn btQuantizedBvh_reportAabbOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?reportRayOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z"]
    pub fn btQuantizedBvh_reportRayOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?reportBoxCastOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111@Z"]
    pub fn btQuantizedBvh_reportBoxCastOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    /// Calculate space needed to store BVH for serialization
    #[link_name = "\u{1}?calculateSerializeBufferSize@btQuantizedBvh@@QEBAIXZ"]
    pub fn btQuantizedBvh_calculateSerializeBufferSize(
        this: *const btQuantizedBvh,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
    #[link_name = "\u{1}?deSerializeInPlace@btQuantizedBvh@@SAPEAV1@PEAXI_N@Z"]
    pub fn btQuantizedBvh_deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btQuantizedBvh;
}
extern "C" {
    #[link_name = "\u{1}?getAlignmentSerializationPadding@btQuantizedBvh@@SAIXZ"]
    pub fn btQuantizedBvh_getAlignmentSerializationPadding() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}??0btQuantizedBvh@@QEAA@XZ"]
    pub fn btQuantizedBvh_btQuantizedBvh(this: *mut btQuantizedBvh);
}
impl btQuantizedBvh {
    #[inline]
    pub unsafe fn swapLeafNodes(
        &mut self,
        firstIndex: ::std::os::raw::c_int,
        secondIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_swapLeafNodes(self, firstIndex, secondIndex)
    }
    #[inline]
    pub unsafe fn assignInternalNodeFromLeafNode(
        &mut self,
        internalNode: ::std::os::raw::c_int,
        leafNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_assignInternalNodeFromLeafNode(self, internalNode, leafNodeIndex)
    }
    #[inline]
    pub unsafe fn buildTree(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_buildTree(self, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn calcSplittingAxis(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvh_calcSplittingAxis(self, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn sortAndCalcSplittingIndex(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvh_sortAndCalcSplittingIndex(self, startIndex, endIndex, splitAxis)
    }
    #[inline]
    pub unsafe fn walkStacklessTree(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_walkStacklessTree(self, nodeCallback, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTreeAgainstRay(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTree(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTree(
            self,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessTreeAgainstRay(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessTreeAgainstRay(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTreeCacheFriendly(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
            self,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
        )
    }
    #[inline]
    pub unsafe fn walkRecursiveQuantizedTreeAgainstQueryAabb(
        &self,
        currentNode: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    ) {
        btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
            self,
            currentNode,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
        )
    }
    #[inline]
    pub unsafe fn walkRecursiveQuantizedTreeAgainstQuantizedTree(
        &self,
        treeNodeA: *const btQuantizedBvhNode,
        treeNodeB: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
    ) {
        btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
            self,
            treeNodeA,
            treeNodeB,
            nodeCallback,
        )
    }
    #[inline]
    pub unsafe fn updateSubtreeHeaders(
        &mut self,
        leftChildNodexIndex: ::std::os::raw::c_int,
        rightChildNodexIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_updateSubtreeHeaders(self, leftChildNodexIndex, rightChildNodexIndex)
    }
    #[inline]
    pub unsafe fn setQuantizationValues(
        &mut self,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        quantizationMargin: btScalar,
    ) {
        btQuantizedBvh_setQuantizationValues(self, bvhAabbMin, bvhAabbMax, quantizationMargin)
    }
    #[inline]
    pub unsafe fn buildInternal(&mut self) {
        btQuantizedBvh_buildInternal(self)
    }
    #[inline]
    pub unsafe fn reportAabbOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_reportAabbOverlappingNodex(self, nodeCallback, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn reportRayOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    ) {
        btQuantizedBvh_reportRayOverlappingNodex(self, nodeCallback, raySource, rayTarget)
    }
    #[inline]
    pub unsafe fn reportBoxCastOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_reportBoxCastOverlappingNodex(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
        )
    }
    #[inline]
    pub unsafe fn calculateSerializeBufferSize(&self) -> ::std::os::raw::c_uint {
        btQuantizedBvh_calculateSerializeBufferSize(self)
    }
    #[inline]
    pub unsafe fn deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btQuantizedBvh {
        btQuantizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
    }
    #[inline]
    pub unsafe fn getAlignmentSerializationPadding() -> ::std::os::raw::c_uint {
        btQuantizedBvh_getAlignmentSerializationPadding()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuantizedBvh_btQuantizedBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtQuantizedBvh@@QEAAXXZ"]
    pub fn btQuantizedBvh_btQuantizedBvh_destructor(this: *mut btQuantizedBvh);
}
extern "C" {
    /// Data buffer MUST be 16 byte aligned
    #[link_name = "\u{1}?serialize@btQuantizedBvh@@UEBA_NPEAXI_N@Z"]
    pub fn btQuantizedBvh_serialize(
        this: *mut ::std::os::raw::c_void,
        o_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> bool;
}
extern "C" {
    ///
    #[link_name = "\u{1}?calculateSerializeBufferSizeNew@btQuantizedBvh@@UEBAHXZ"]
    pub fn btQuantizedBvh_calculateSerializeBufferSizeNew(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btQuantizedBvh@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btQuantizedBvh_serialize1(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?deSerializeFloat@btQuantizedBvh@@UEAAXAEAUbtQuantizedBvhFloatData@@@Z"]
    pub fn btQuantizedBvh_deSerializeFloat(
        this: *mut ::std::os::raw::c_void,
        quantizedBvhFloatData: *mut btQuantizedBvhFloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}?deSerializeDouble@btQuantizedBvh@@UEAAXAEAUbtQuantizedBvhDoubleData@@@Z"]
    pub fn btQuantizedBvh_deSerializeDouble(
        this: *mut ::std::os::raw::c_void,
        quantizedBvhDoubleData: *mut btQuantizedBvhDoubleData,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBvhSubtreeInfoData {
    pub m_rootNodeIndex: ::std::os::raw::c_int,
    pub m_subtreeSize: ::std::os::raw::c_int,
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNodeFloatData {
    pub m_aabbMinOrg: btVector3FloatData,
    pub m_aabbMaxOrg: btVector3FloatData,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNodeDoubleData {
    pub m_aabbMinOrg: btVector3DoubleData,
    pub m_aabbMaxOrg: btVector3DoubleData,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhNodeData {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhFloatData {
    pub m_bvhAabbMin: btVector3FloatData,
    pub m_bvhAabbMax: btVector3FloatData,
    pub m_bvhQuantization: btVector3FloatData,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: ::std::os::raw::c_int,
    pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
    pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
    pub m_contiguousNodesPtr: *mut btOptimizedBvhNodeFloatData,
    pub m_quantizedContiguousNodesPtr: *mut btQuantizedBvhNodeData,
    pub m_subTreeInfoPtr: *mut btBvhSubtreeInfoData,
    pub m_traversalMode: ::std::os::raw::c_int,
    pub m_numSubtreeHeaders: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhDoubleData {
    pub m_bvhAabbMin: btVector3DoubleData,
    pub m_bvhAabbMax: btVector3DoubleData,
    pub m_bvhQuantization: btVector3DoubleData,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: ::std::os::raw::c_int,
    pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
    pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
    pub m_contiguousNodesPtr: *mut btOptimizedBvhNodeDoubleData,
    pub m_quantizedContiguousNodesPtr: *mut btQuantizedBvhNodeData,
    pub m_traversalMode: ::std::os::raw::c_int,
    pub m_numSubtreeHeaders: ::std::os::raw::c_int,
    pub m_subTreeInfoPtr: *mut btBvhSubtreeInfoData,
}
/// The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
#[repr(C)]
#[derive(Debug)]
pub struct btOptimizedBvh {
    pub _base: btQuantizedBvh,
}
extern "C" {
    #[link_name = "\u{1}?build@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@_NAEBVbtVector3@@2@Z"]
    pub fn btOptimizedBvh_build(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?refit@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@AEBVbtVector3@@1@Z"]
    pub fn btOptimizedBvh_refit(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?refitPartial@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@AEBVbtVector3@@1@Z"]
    pub fn btOptimizedBvh_refitPartial(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateBvhNodes@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@HHH@Z"]
    pub fn btOptimizedBvh_updateBvhNodes(
        this: *mut btOptimizedBvh,
        meshInterface: *mut btStridingMeshInterface,
        firstNode: ::std::os::raw::c_int,
        endNode: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
    #[link_name = "\u{1}?deSerializeInPlace@btOptimizedBvh@@SAPEAV1@PEAXI_N@Z"]
    pub fn btOptimizedBvh_deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btOptimizedBvh;
}
extern "C" {
    #[link_name = "\u{1}??0btOptimizedBvh@@QEAA@XZ"]
    pub fn btOptimizedBvh_btOptimizedBvh(this: *mut btOptimizedBvh);
}
impl btOptimizedBvh {
    #[inline]
    pub unsafe fn build(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
    ) {
        btOptimizedBvh_build(
            self,
            triangles,
            useQuantizedAabbCompression,
            bvhAabbMin,
            bvhAabbMax,
        )
    }
    #[inline]
    pub unsafe fn refit(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btOptimizedBvh_refit(self, triangles, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn refitPartial(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btOptimizedBvh_refitPartial(self, triangles, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn updateBvhNodes(
        &mut self,
        meshInterface: *mut btStridingMeshInterface,
        firstNode: ::std::os::raw::c_int,
        endNode: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    ) {
        btOptimizedBvh_updateBvhNodes(self, meshInterface, firstNode, endNode, index)
    }
    #[inline]
    pub unsafe fn deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btOptimizedBvh {
        btOptimizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btOptimizedBvh_btOptimizedBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtOptimizedBvh@@QEAAXXZ"]
    pub fn btOptimizedBvh_btOptimizedBvh_destructor(this: *mut btOptimizedBvh);
}
/// The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
/// If you required moving concave triangle meshes, it is recommended to perform convex decomposition
/// using HACD, see Bullet/Demos/ConvexDecompositionDemo.
/// Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
/// btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
/// cache friendly traversal for PlayStation 3 Cell SPU.
/// It is recommended to enable useQuantizedAabbCompression for better memory usage.
/// It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
/// Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
/// See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
#[repr(C)]
#[derive(Debug)]
pub struct btBvhTriangleMeshShape {
    pub _base: btTriangleMeshShape,
    pub m_bvh: *mut btOptimizedBvh,
    pub m_triangleInfoMap: *mut btTriangleInfoMap,
    pub m_useQuantizedAabbCompression: bool,
    pub m_ownsBvh: bool,
    pub m_pad: [bool; 11usize],
    pub __bindgen_padding_0: [u8; 3usize],
}
extern "C" {
    #[link_name = "\u{1}?performRaycast@btBvhTriangleMeshShape@@QEAAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btBvhTriangleMeshShape_performRaycast(
        this: *mut btBvhTriangleMeshShape,
        callback: *mut btTriangleCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?performConvexcast@btBvhTriangleMeshShape@@QEAAXPEAVbtTriangleCallback@@AEBVbtVector3@@111@Z"]
    pub fn btBvhTriangleMeshShape_performConvexcast(
        this: *mut btBvhTriangleMeshShape,
        callback: *mut btTriangleCallback,
        boxSource: *const btVector3,
        boxTarget: *const btVector3,
        boxMin: *const btVector3,
        boxMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?refitTree@btBvhTriangleMeshShape@@QEAAXAEBVbtVector3@@0@Z"]
    pub fn btBvhTriangleMeshShape_refitTree(
        this: *mut btBvhTriangleMeshShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    /// for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks
    #[link_name = "\u{1}?partialRefitTree@btBvhTriangleMeshShape@@QEAAXAEBVbtVector3@@0@Z"]
    pub fn btBvhTriangleMeshShape_partialRefitTree(
        this: *mut btBvhTriangleMeshShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setOptimizedBvh@btBvhTriangleMeshShape@@QEAAXPEAVbtOptimizedBvh@@AEBVbtVector3@@@Z"]
    pub fn btBvhTriangleMeshShape_setOptimizedBvh(
        this: *mut btBvhTriangleMeshShape,
        bvh: *mut btOptimizedBvh,
        localScaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildOptimizedBvh@btBvhTriangleMeshShape@@QEAAXXZ"]
    pub fn btBvhTriangleMeshShape_buildOptimizedBvh(this: *mut btBvhTriangleMeshShape);
}
extern "C" {
    #[link_name = "\u{1}??0btBvhTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_N1@Z"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape(
        this: *mut btBvhTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        buildBvh: bool,
    );
}
extern "C" {
    /// optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
    #[link_name = "\u{1}??0btBvhTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_NAEBVbtVector3@@21@Z"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
        this: *mut btBvhTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        buildBvh: bool,
    );
}
impl btBvhTriangleMeshShape {
    #[inline]
    pub unsafe fn performRaycast(
        &mut self,
        callback: *mut btTriangleCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    ) {
        btBvhTriangleMeshShape_performRaycast(self, callback, raySource, rayTarget)
    }
    #[inline]
    pub unsafe fn performConvexcast(
        &mut self,
        callback: *mut btTriangleCallback,
        boxSource: *const btVector3,
        boxTarget: *const btVector3,
        boxMin: *const btVector3,
        boxMax: *const btVector3,
    ) {
        btBvhTriangleMeshShape_performConvexcast(
            self, callback, boxSource, boxTarget, boxMin, boxMax,
        )
    }
    #[inline]
    pub unsafe fn refitTree(&mut self, aabbMin: *const btVector3, aabbMax: *const btVector3) {
        btBvhTriangleMeshShape_refitTree(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn partialRefitTree(
        &mut self,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btBvhTriangleMeshShape_partialRefitTree(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn setOptimizedBvh(
        &mut self,
        bvh: *mut btOptimizedBvh,
        localScaling: *const btVector3,
    ) {
        btBvhTriangleMeshShape_setOptimizedBvh(self, bvh, localScaling)
    }
    #[inline]
    pub unsafe fn buildOptimizedBvh(&mut self) {
        btBvhTriangleMeshShape_buildOptimizedBvh(self)
    }
    #[inline]
    pub unsafe fn new(
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        buildBvh: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBvhTriangleMeshShape_btBvhTriangleMeshShape(
            &mut __bindgen_tmp,
            meshInterface,
            useQuantizedAabbCompression,
            buildBvh,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        buildBvh: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
            &mut __bindgen_tmp,
            meshInterface,
            useQuantizedAabbCompression,
            bvhAabbMin,
            bvhAabbMax,
            buildBvh,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtBvhTriangleMeshShape@@QEAAXXZ"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape_destructor(
        this: *mut btBvhTriangleMeshShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btBvhTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btBvhTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btBvhTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btBvhTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btBvhTriangleMeshShape@@UEBAHXZ"]
    pub fn btBvhTriangleMeshShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btBvhTriangleMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btBvhTriangleMeshShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?serializeSingleBvh@btBvhTriangleMeshShape@@UEBAXPEAVbtSerializer@@@Z"]
    pub fn btBvhTriangleMeshShape_serializeSingleBvh(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeSingleTriangleInfoMap@btBvhTriangleMeshShape@@UEBAXPEAVbtSerializer@@@Z"]
    pub fn btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleMeshShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_meshInterface: btStridingMeshInterfaceData,
    pub m_quantizedFloatBvh: *mut btQuantizedBvhFloatData,
    pub m_quantizedDoubleBvh: *mut btQuantizedBvhDoubleData,
    pub m_triangleInfoMap: *mut btTriangleInfoMapData,
    pub m_collisionMargin: f32,
    pub m_pad3: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMaterial {
    pub m_friction: btScalar,
    pub m_restitution: btScalar,
    pub pad: [::std::os::raw::c_int; 2usize],
}
/// The BvhTriangleMaterialMeshShape extends the btBvhTriangleMeshShape. Its main contribution is the interface into a material array, which allows per-triangle friction and restitution.
#[repr(C)]
#[derive(Debug)]
pub struct btMultimaterialTriangleMeshShape {
    pub _base: btBvhTriangleMeshShape,
    pub m_materialList: btAlignedObjectArray<*mut btMaterial>,
}
extern "C" {
    /// Obtains the material for a specific triangle
    #[link_name = "\u{1}?getMaterialProperties@btMultimaterialTriangleMeshShape@@QEAAPEBVbtMaterial@@HH@Z"]
    pub fn btMultimaterialTriangleMeshShape_getMaterialProperties(
        this: *mut btMultimaterialTriangleMeshShape,
        partID: ::std::os::raw::c_int,
        triIndex: ::std::os::raw::c_int,
    ) -> *const btMaterial;
}
impl btMultimaterialTriangleMeshShape {
    #[inline]
    pub unsafe fn getMaterialProperties(
        &mut self,
        partID: ::std::os::raw::c_int,
        triIndex: ::std::os::raw::c_int,
    ) -> *const btMaterial {
        btMultimaterialTriangleMeshShape_getMaterialProperties(self, partID, triIndex)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btSdfCollisionShape {
    pub _base: btConcaveShape,
    pub m_data: *mut btSdfCollisionShapeInternalData,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?initializeSDF@btSdfCollisionShape@@QEAA_NPEBDH@Z"]
    pub fn btSdfCollisionShape_initializeSDF(
        this: *mut btSdfCollisionShape,
        sdfData: *const ::std::os::raw::c_char,
        sizeInBytes: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?queryPoint@btSdfCollisionShape@@QEAA_NAEBVbtVector3@@AEANAEAV2@@Z"]
    pub fn btSdfCollisionShape_queryPoint(
        this: *mut btSdfCollisionShape,
        ptInSDF: *const btVector3,
        distOut: *mut btScalar,
        normal: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0btSdfCollisionShape@@QEAA@XZ"]
    pub fn btSdfCollisionShape_btSdfCollisionShape(this: *mut btSdfCollisionShape);
}
impl btSdfCollisionShape {
    #[inline]
    pub unsafe fn initializeSDF(
        &mut self,
        sdfData: *const ::std::os::raw::c_char,
        sizeInBytes: ::std::os::raw::c_int,
    ) -> bool {
        btSdfCollisionShape_initializeSDF(self, sdfData, sizeInBytes)
    }
    #[inline]
    pub unsafe fn queryPoint(
        &mut self,
        ptInSDF: *const btVector3,
        distOut: *mut btScalar,
        normal: *mut btVector3,
    ) -> bool {
        btSdfCollisionShape_queryPoint(self, ptInSDF, distOut, normal)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSdfCollisionShape_btSdfCollisionShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSdfCollisionShape@@QEAAXXZ"]
    pub fn btSdfCollisionShape_btSdfCollisionShape_destructor(this: *mut btSdfCollisionShape);
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btSdfCollisionShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btSdfCollisionShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btSdfCollisionShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btSdfCollisionShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btSdfCollisionShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btSdfCollisionShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btSdfCollisionShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btSdfCollisionShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getName@btSdfCollisionShape@@UEBAPEBDXZ"]
    pub fn btSdfCollisionShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setMargin@btSdfCollisionShape@@UEAAXN@Z"]
    pub fn btSdfCollisionShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?getMargin@btSdfCollisionShape@@UEBANXZ"]
    pub fn btSdfCollisionShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btSdfCollisionShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btSdfCollisionShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
/// The btShapeHull class takes a btConvexShape, builds a simplified convex hull using btConvexHull and provides triangle indices and vertices.
/// It can be useful for to simplify a complex convex object and for visualization of a non-polyhedral convex object.
/// It approximates the convex hull using the supporting vertex of 42 directions.
#[repr(C)]
#[derive(Debug)]
pub struct btShapeHull {
    pub m_vertices: btAlignedObjectArray<btVector3>,
    pub m_indices: btAlignedObjectArray<::std::os::raw::c_uint>,
    pub m_numIndices: ::std::os::raw::c_uint,
    pub m_shape: *const btConvexShape,
}
extern "C" {
    #[link_name = "\u{1}?getUnitSpherePoints@btShapeHull@@KAPEAVbtVector3@@H@Z"]
    pub fn btShapeHull_getUnitSpherePoints(highres: ::std::os::raw::c_int) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}?buildHull@btShapeHull@@QEAA_NNH@Z"]
    pub fn btShapeHull_buildHull(
        this: *mut btShapeHull,
        margin: btScalar,
        highres: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?numTriangles@btShapeHull@@QEBAHXZ"]
    pub fn btShapeHull_numTriangles(this: *const btShapeHull) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?numVertices@btShapeHull@@QEBAHXZ"]
    pub fn btShapeHull_numVertices(this: *const btShapeHull) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?numIndices@btShapeHull@@QEBAHXZ"]
    pub fn btShapeHull_numIndices(this: *const btShapeHull) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}??0btShapeHull@@QEAA@PEBVbtConvexShape@@@Z"]
    pub fn btShapeHull_btShapeHull(this: *mut btShapeHull, shape: *const btConvexShape);
}
extern "C" {
    #[link_name = "\u{1}??_DbtShapeHull@@QEAAXXZ"]
    pub fn btShapeHull_btShapeHull_destructor(this: *mut btShapeHull);
}
impl btShapeHull {
    #[inline]
    pub unsafe fn getUnitSpherePoints(highres: ::std::os::raw::c_int) -> *mut btVector3 {
        btShapeHull_getUnitSpherePoints(highres)
    }
    #[inline]
    pub unsafe fn buildHull(&mut self, margin: btScalar, highres: ::std::os::raw::c_int) -> bool {
        btShapeHull_buildHull(self, margin, highres)
    }
    #[inline]
    pub unsafe fn numTriangles(&self) -> ::std::os::raw::c_int {
        btShapeHull_numTriangles(self)
    }
    #[inline]
    pub unsafe fn numVertices(&self) -> ::std::os::raw::c_int {
        btShapeHull_numVertices(self)
    }
    #[inline]
    pub unsafe fn numIndices(&self) -> ::std::os::raw::c_int {
        btShapeHull_numIndices(self)
    }
    #[inline]
    pub unsafe fn new(shape: *const btConvexShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btShapeHull_btShapeHull(&mut __bindgen_tmp, shape);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btShapeHull_btShapeHull_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangle {
    pub m_vertex0: btVector3,
    pub m_vertex1: btVector3,
    pub m_vertex2: btVector3,
    pub m_partId: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
/// The btTriangleBuffer callback can be useful to collect and store overlapping triangles between AABB and concave objects that support 'processAllTriangles'
/// Example usage of this class:
/// btTriangleBuffer	triBuf;
/// concaveShape->processAllTriangles(&triBuf,aabbMin, aabbMax);
/// for (int i=0;i<triBuf.getNumTriangles();i++)
/// {
/// const btTriangle& tri = triBuf.getTriangle(i);
/// //do something useful here with the triangle
/// }
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleBuffer {
    pub _base: btTriangleCallback,
    pub m_triangleBuffer: btAlignedObjectArray<btTriangle>,
}
extern "C" {
    #[link_name = "\u{1}?processTriangle@btTriangleBuffer@@UEAAXPEAVbtVector3@@HH@Z"]
    pub fn btTriangleBuffer_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
/// The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
/// Instead of the number of indices, we pass the number of triangles.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIndexedMesh {
    pub m_numTriangles: ::std::os::raw::c_int,
    pub m_triangleIndexBase: *const ::std::os::raw::c_uchar,
    pub m_triangleIndexStride: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertexBase: *const ::std::os::raw::c_uchar,
    pub m_vertexStride: ::std::os::raw::c_int,
    pub m_indexType: PHY_ScalarType,
    pub m_vertexType: PHY_ScalarType,
    pub __bindgen_padding_0: u32,
}
pub type IndexedMeshArray = btAlignedObjectArray<btIndexedMesh>;
/// The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
/// Additional meshes can be added using addIndexedMesh
/// No duplicate is made of the vertex/index data, it only indexes into external vertex/index arrays.
/// So keep those arrays around during the lifetime of this btTriangleIndexVertexArray.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleIndexVertexArray {
    pub _base: btStridingMeshInterface,
    pub m_indexedMeshes: IndexedMeshArray,
    pub m_pad: [::std::os::raw::c_int; 2usize],
    pub m_hasAabb: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btTriangleIndexVertexArray@@QEAA@HPEAHHHPEANH@Z"]
    pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray(
        this: *mut btTriangleIndexVertexArray,
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
    );
}
impl btTriangleIndexVertexArray {
    #[inline]
    pub unsafe fn new(
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleIndexVertexArray_btTriangleIndexVertexArray(
            &mut __bindgen_tmp,
            numTriangles,
            triangleIndexBase,
            triangleIndexStride,
            numVertices,
            vertexBase,
            vertexStride,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtTriangleIndexVertexArray@@QEAAXXZ"]
    pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray_destructor(
        this: *mut btTriangleIndexVertexArray,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLockedVertexIndexBase@btTriangleIndexVertexArray@@UEAAXPEAPEAEAEAHAEAW4PHY_ScalarType@@10112H@Z"]
    pub fn btTriangleIndexVertexArray_getLockedVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *mut ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        vertexStride: *mut ::std::os::raw::c_int,
        indexbase: *mut *mut ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLockedReadOnlyVertexIndexBase@btTriangleIndexVertexArray@@UEBAXPEAPEBEAEAHAEAW4PHY_ScalarType@@10112H@Z"]
    pub fn btTriangleIndexVertexArray_getLockedReadOnlyVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *const ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        vertexStride: *mut ::std::os::raw::c_int,
        indexbase: *mut *const ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?hasPremadeAabb@btTriangleIndexVertexArray@@UEBA_NXZ"]
    pub fn btTriangleIndexVertexArray_hasPremadeAabb(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setPremadeAabb@btTriangleIndexVertexArray@@UEBAXAEBVbtVector3@@0@Z"]
    pub fn btTriangleIndexVertexArray_setPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getPremadeAabb@btTriangleIndexVertexArray@@UEBAXPEAVbtVector3@@0@Z"]
    pub fn btTriangleIndexVertexArray_getPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMaterialProperties {
    /// m_materialBase ==========> 2 btScalar values make up one material, friction then restitution
    pub m_numMaterials: ::std::os::raw::c_int,
    pub m_materialBase: *const ::std::os::raw::c_uchar,
    pub m_materialStride: ::std::os::raw::c_int,
    pub m_materialType: PHY_ScalarType,
    /// m_numTriangles <=========== This exists in the btIndexedMesh object for the same subpart, but since we're
    /// ///                           padding the structure, it can be reproduced at no real cost
    /// ///m_triangleMaterials =====> 1 integer value makes up one entry
    /// ///                           eg: m_triangleMaterials[1] = 5; // This will set triangle 2 to use material 5
    pub m_numTriangles: ::std::os::raw::c_int,
    pub m_triangleMaterialsBase: *const ::std::os::raw::c_uchar,
    pub m_triangleMaterialStride: ::std::os::raw::c_int,
    /// m_triangleType <========== Automatically set in addMaterialProperties
    pub m_triangleType: PHY_ScalarType,
}
pub type MaterialArray = btAlignedObjectArray<btMaterialProperties>;
/// Teh btTriangleIndexVertexMaterialArray is built on TriangleIndexVertexArray
/// The addition of a material array allows for the utilization of the partID and
/// triangleIndex that are returned in the ContactAddedCallback.  As with
/// TriangleIndexVertexArray, no duplicate is made of the material data, so it
/// is the users responsibility to maintain the array during the lifetime of the
/// TriangleIndexVertexMaterialArray.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleIndexVertexMaterialArray {
    pub _base: btTriangleIndexVertexArray,
    pub m_materials: MaterialArray,
}
extern "C" {
    #[link_name = "\u{1}??0btTriangleIndexVertexMaterialArray@@QEAA@HPEAHHHPEANHHPEAEH0H@Z"]
    pub fn btTriangleIndexVertexMaterialArray_btTriangleIndexVertexMaterialArray(
        this: *mut btTriangleIndexVertexMaterialArray,
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
        numMaterials: ::std::os::raw::c_int,
        materialBase: *mut ::std::os::raw::c_uchar,
        materialStride: ::std::os::raw::c_int,
        triangleMaterialsBase: *mut ::std::os::raw::c_int,
        materialIndexStride: ::std::os::raw::c_int,
    );
}
impl btTriangleIndexVertexMaterialArray {
    #[inline]
    pub unsafe fn new(
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
        numMaterials: ::std::os::raw::c_int,
        materialBase: *mut ::std::os::raw::c_uchar,
        materialStride: ::std::os::raw::c_int,
        triangleMaterialsBase: *mut ::std::os::raw::c_int,
        materialIndexStride: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleIndexVertexMaterialArray_btTriangleIndexVertexMaterialArray(
            &mut __bindgen_tmp,
            numTriangles,
            triangleIndexBase,
            triangleIndexStride,
            numVertices,
            vertexBase,
            vertexStride,
            numMaterials,
            materialBase,
            materialStride,
            triangleMaterialsBase,
            materialIndexStride,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getLockedMaterialBase@btTriangleIndexVertexMaterialArray@@UEAAXPEAPEAEAEAHAEAW4PHY_ScalarType@@10112H@Z"]
    pub fn btTriangleIndexVertexMaterialArray_getLockedMaterialBase(
        this: *mut ::std::os::raw::c_void,
        materialBase: *mut *mut ::std::os::raw::c_uchar,
        numMaterials: *mut ::std::os::raw::c_int,
        materialType: *mut PHY_ScalarType,
        materialStride: *mut ::std::os::raw::c_int,
        triangleMaterialBase: *mut *mut ::std::os::raw::c_uchar,
        numTriangles: *mut ::std::os::raw::c_int,
        triangleMaterialStride: *mut ::std::os::raw::c_int,
        triangleType: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLockedReadOnlyMaterialBase@btTriangleIndexVertexMaterialArray@@UEAAXPEAPEBEAEAHAEAW4PHY_ScalarType@@10112H@Z"]
    pub fn btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase(
        this: *mut ::std::os::raw::c_void,
        materialBase: *mut *const ::std::os::raw::c_uchar,
        numMaterials: *mut ::std::os::raw::c_int,
        materialType: *mut PHY_ScalarType,
        materialStride: *mut ::std::os::raw::c_int,
        triangleMaterialBase: *mut *const ::std::os::raw::c_uchar,
        numTriangles: *mut ::std::os::raw::c_int,
        triangleMaterialStride: *mut ::std::os::raw::c_int,
        triangleType: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeChild {
    pub m_transform: btTransform,
    pub m_childShape: *mut btCollisionShape,
    pub m_childShapeType: ::std::os::raw::c_int,
    pub m_childMargin: btScalar,
    pub m_node: *mut btDbvtNode,
}
/// The btCompoundShape allows to store multiple other btCollisionShapes
/// This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
/// It has an (optional) dynamic aabb tree to accelerate early rejection tests.
/// @todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
/// Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape)
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundShape {
    pub _base: btCollisionShape,
    pub m_children: btAlignedObjectArray<btCompoundShapeChild>,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_dynamicAabbTree: *mut btDbvt,
    /// increment m_updateRevision when adding/removing/replacing child shapes, so that some caches can be updated
    pub m_updateRevision: ::std::os::raw::c_int,
    pub m_collisionMargin: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_localScaling: btVector3,
}
extern "C" {
    #[link_name = "\u{1}?addChildShape@btCompoundShape@@QEAAXAEBVbtTransform@@PEAVbtCollisionShape@@@Z"]
    pub fn btCompoundShape_addChildShape(
        this: *mut btCompoundShape,
        localTransform: *const btTransform,
        shape: *mut btCollisionShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeChildShapeByIndex@btCompoundShape@@QEAAXH@Z"]
    pub fn btCompoundShape_removeChildShapeByIndex(
        this: *mut btCompoundShape,
        childShapeindex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// set a new transform for a child, and update internal data structures (local aabb and dynamic tree)
    #[link_name = "\u{1}?updateChildTransform@btCompoundShape@@QEAAXHAEBVbtTransform@@_N@Z"]
    pub fn btCompoundShape_updateChildTransform(
        this: *mut btCompoundShape,
        childIndex: ::std::os::raw::c_int,
        newChildTransform: *const btTransform,
        shouldRecalculateLocalAabb: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?createAabbTreeFromChildren@btCompoundShape@@QEAAXXZ"]
    pub fn btCompoundShape_createAabbTreeFromChildren(this: *mut btCompoundShape);
}
extern "C" {
    /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    /// ///and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
    /// ///"principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
    /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    /// ///of the collision object by the principal transform.
    #[link_name = "\u{1}?calculatePrincipalAxisTransform@btCompoundShape@@QEBAXPEBNAEAVbtTransform@@AEAVbtVector3@@@Z"]
    pub fn btCompoundShape_calculatePrincipalAxisTransform(
        this: *const btCompoundShape,
        masses: *const btScalar,
        principal: *mut btTransform,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btCompoundShape@@QEAA@_NH@Z"]
    pub fn btCompoundShape_btCompoundShape(
        this: *mut btCompoundShape,
        enableDynamicAabbTree: bool,
        initialChildCapacity: ::std::os::raw::c_int,
    );
}
impl btCompoundShape {
    #[inline]
    pub unsafe fn addChildShape(
        &mut self,
        localTransform: *const btTransform,
        shape: *mut btCollisionShape,
    ) {
        btCompoundShape_addChildShape(self, localTransform, shape)
    }
    #[inline]
    pub unsafe fn removeChildShapeByIndex(&mut self, childShapeindex: ::std::os::raw::c_int) {
        btCompoundShape_removeChildShapeByIndex(self, childShapeindex)
    }
    #[inline]
    pub unsafe fn updateChildTransform(
        &mut self,
        childIndex: ::std::os::raw::c_int,
        newChildTransform: *const btTransform,
        shouldRecalculateLocalAabb: bool,
    ) {
        btCompoundShape_updateChildTransform(
            self,
            childIndex,
            newChildTransform,
            shouldRecalculateLocalAabb,
        )
    }
    #[inline]
    pub unsafe fn createAabbTreeFromChildren(&mut self) {
        btCompoundShape_createAabbTreeFromChildren(self)
    }
    #[inline]
    pub unsafe fn calculatePrincipalAxisTransform(
        &self,
        masses: *const btScalar,
        principal: *mut btTransform,
        inertia: *mut btVector3,
    ) {
        btCompoundShape_calculatePrincipalAxisTransform(self, masses, principal, inertia)
    }
    #[inline]
    pub unsafe fn new(
        enableDynamicAabbTree: bool,
        initialChildCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCompoundShape_btCompoundShape(
            &mut __bindgen_tmp,
            enableDynamicAabbTree,
            initialChildCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtCompoundShape@@QEAAXXZ"]
    pub fn btCompoundShape_btCompoundShape_destructor(this: *mut btCompoundShape);
}
extern "C" {
    /// Remove all children shapes that contain the specified shape
    #[link_name = "\u{1}?removeChildShape@btCompoundShape@@UEAAXPEAVbtCollisionShape@@@Z"]
    pub fn btCompoundShape_removeChildShape(
        this: *mut ::std::os::raw::c_void,
        shape: *mut btCollisionShape,
    );
}
extern "C" {
    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    #[link_name = "\u{1}?getAabb@btCompoundShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btCompoundShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    /// Re-calculate the local Aabb. Is called at the end of removeChildShapes.
    /// Use this yourself if you modify the children or their transforms.
    #[link_name = "\u{1}?recalculateLocalAabb@btCompoundShape@@UEAAXXZ"]
    pub fn btCompoundShape_recalculateLocalAabb(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btCompoundShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btCompoundShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btCompoundShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btCompoundShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btCompoundShape@@UEBAHXZ"]
    pub fn btCompoundShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btCompoundShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btCompoundShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeChildData {
    pub m_transform: btTransformFloatData,
    pub m_childShape: *mut btCollisionShapeData,
    pub m_childShapeType: ::std::os::raw::c_int,
    pub m_childMargin: f32,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_childShapePtr: *mut btCompoundShapeChildData,
    pub m_numChildShapes: ::std::os::raw::c_int,
    pub m_collisionMargin: f32,
}
/// The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
#[repr(C)]
#[derive(Debug)]
pub struct btBoxShape {
    pub _base: btPolyhedralConvexShape,
}
extern "C" {
    #[link_name = "\u{1}??0btBoxShape@@QEAA@AEBVbtVector3@@@Z"]
    pub fn btBoxShape_btBoxShape(this: *mut btBoxShape, boxHalfExtents: *const btVector3);
}
impl btBoxShape {
    #[inline]
    pub unsafe fn new(boxHalfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBoxShape_btBoxShape(&mut __bindgen_tmp, boxHalfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btBoxShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btBoxShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btBoxShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btBoxShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleShape {
    pub _base: btPolyhedralConvexShape,
    pub m_vertices1: [btVector3; 3usize],
}
/// The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btBU_Simplex1to4 {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_numVertices: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_vertices: [btVector3; 4usize],
}
extern "C" {
    #[link_name = "\u{1}?addVertex@btBU_Simplex1to4@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btBU_Simplex1to4_addVertex(this: *mut btBU_Simplex1to4, pt: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}??0btBU_Simplex1to4@@QEAA@XZ"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to4(this: *mut btBU_Simplex1to4);
}
extern "C" {
    #[link_name = "\u{1}??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@@Z"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to41(this: *mut btBU_Simplex1to4, pt0: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@0@Z"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to42(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@00@Z"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to43(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@000@Z"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to44(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
        pt3: *const btVector3,
    );
}
impl btBU_Simplex1to4 {
    #[inline]
    pub unsafe fn addVertex(&mut self, pt: *const btVector3) {
        btBU_Simplex1to4_addVertex(self, pt)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to4(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(pt0: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to41(&mut __bindgen_tmp, pt0);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(pt0: *const btVector3, pt1: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to42(&mut __bindgen_tmp, pt0, pt1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to43(&mut __bindgen_tmp, pt0, pt1, pt2);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
        pt3: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to44(&mut __bindgen_tmp, pt0, pt1, pt2, pt3);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btBU_Simplex1to4@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btBU_Simplex1to4_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumVertices@btBU_Simplex1to4@@UEBAHXZ"]
    pub fn btBU_Simplex1to4_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getNumEdges@btBU_Simplex1to4@@UEBAHXZ"]
    pub fn btBU_Simplex1to4_getNumEdges(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getEdge@btBU_Simplex1to4@@UEBAXHAEAVbtVector3@@0@Z"]
    pub fn btBU_Simplex1to4_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVertex@btBU_Simplex1to4@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btBU_Simplex1to4_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumPlanes@btBU_Simplex1to4@@UEBAHXZ"]
    pub fn btBU_Simplex1to4_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPlane@btBU_Simplex1to4@@UEBAXAEAVbtVector3@@0H@Z"]
    pub fn btBU_Simplex1to4_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getIndex@btBU_Simplex1to4@@UEBAHH@Z"]
    pub fn btBU_Simplex1to4_getIndex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?isInside@btBU_Simplex1to4@@UEBA_NAEBVbtVector3@@N@Z"]
    pub fn btBU_Simplex1to4_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
pub const eBT_PLANE_INTERSECTION_TYPE_BT_CONST_BACK_PLANE: eBT_PLANE_INTERSECTION_TYPE = 0;
pub const eBT_PLANE_INTERSECTION_TYPE_BT_CONST_COLLIDE_PLANE: eBT_PLANE_INTERSECTION_TYPE = 1;
pub const eBT_PLANE_INTERSECTION_TYPE_BT_CONST_FRONT_PLANE: eBT_PLANE_INTERSECTION_TYPE = 2;
pub type eBT_PLANE_INTERSECTION_TYPE = i32;
/// !  Class for transforming a model1 to the space of model0
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BT_BOX_BOX_TRANSFORM_CACHE {
    /// !< Transforms translation of model1 to model 0
    pub m_T1to0: btVector3,
    /// !< Transforms Rotation of model1 to model 0, equal  to R0' * R1
    pub m_R1to0: btMatrix3x3,
    /// !< Absolute value of m_R1to0
    pub m_AR: btMatrix3x3,
}
/// ! Axis aligned box
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAABB {
    pub m_min: btVector3,
    pub m_max: btVector3,
}
/// The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeometryUtil {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?getPlaneEquationsFromVertices@btGeometryUtil@@SAXAEAV?$btAlignedObjectArray@VbtVector3@@@@0@Z"]
    pub fn btGeometryUtil_getPlaneEquationsFromVertices(
        vertices: *mut btAlignedObjectArray<btVector3>,
        planeEquationsOut: *mut btAlignedObjectArray<btVector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVerticesFromPlaneEquations@btGeometryUtil@@SAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z"]
    pub fn btGeometryUtil_getVerticesFromPlaneEquations(
        planeEquations: *const btAlignedObjectArray<btVector3>,
        verticesOut: *mut btAlignedObjectArray<btVector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?isInside@btGeometryUtil@@SA_NAEBV?$btAlignedObjectArray@VbtVector3@@@@AEBVbtVector3@@N@Z"]
    pub fn btGeometryUtil_isInside(
        vertices: *const btAlignedObjectArray<btVector3>,
        planeNormal: *const btVector3,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?isPointInsidePlanes@btGeometryUtil@@SA_NAEBV?$btAlignedObjectArray@VbtVector3@@@@AEBVbtVector3@@N@Z"]
    pub fn btGeometryUtil_isPointInsidePlanes(
        planeEquations: *const btAlignedObjectArray<btVector3>,
        point: *const btVector3,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?areVerticesBehindPlane@btGeometryUtil@@SA_NAEBVbtVector3@@AEBV?$btAlignedObjectArray@VbtVector3@@@@N@Z"]
    pub fn btGeometryUtil_areVerticesBehindPlane(
        planeNormal: *const btVector3,
        vertices: *const btAlignedObjectArray<btVector3>,
        margin: btScalar,
    ) -> bool;
}
impl btGeometryUtil {
    #[inline]
    pub unsafe fn getPlaneEquationsFromVertices(
        vertices: *mut btAlignedObjectArray<btVector3>,
        planeEquationsOut: *mut btAlignedObjectArray<btVector3>,
    ) {
        btGeometryUtil_getPlaneEquationsFromVertices(vertices, planeEquationsOut)
    }
    #[inline]
    pub unsafe fn getVerticesFromPlaneEquations(
        planeEquations: *const btAlignedObjectArray<btVector3>,
        verticesOut: *mut btAlignedObjectArray<btVector3>,
    ) {
        btGeometryUtil_getVerticesFromPlaneEquations(planeEquations, verticesOut)
    }
    #[inline]
    pub unsafe fn isInside(
        vertices: *const btAlignedObjectArray<btVector3>,
        planeNormal: *const btVector3,
        margin: btScalar,
    ) -> bool {
        btGeometryUtil_isInside(vertices, planeNormal, margin)
    }
    #[inline]
    pub unsafe fn isPointInsidePlanes(
        planeEquations: *const btAlignedObjectArray<btVector3>,
        point: *const btVector3,
        margin: btScalar,
    ) -> bool {
        btGeometryUtil_isPointInsidePlanes(planeEquations, point, margin)
    }
    #[inline]
    pub unsafe fn areVerticesBehindPlane(
        planeNormal: *const btVector3,
        vertices: *const btAlignedObjectArray<btVector3>,
        margin: btScalar,
    ) -> bool {
        btGeometryUtil_areVerticesBehindPlane(planeNormal, vertices, margin)
    }
}
/// ! Structure for collision
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIM_TRIANGLE_CONTACT {
    pub m_penetration_depth: btScalar,
    pub m_point_count: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_separating_normal: btVector4,
    pub m_points: [btVector3; 16usize],
}
extern "C" {
    /// ! classify points that are closer
    #[link_name = "\u{1}?merge_points@GIM_TRIANGLE_CONTACT@@QEAAXAEBVbtVector4@@NPEBVbtVector3@@H@Z"]
    pub fn GIM_TRIANGLE_CONTACT_merge_points(
        this: *mut GIM_TRIANGLE_CONTACT,
        plane: *const btVector4,
        margin: btScalar,
        points: *const btVector3,
        point_count: ::std::os::raw::c_int,
    );
}
impl GIM_TRIANGLE_CONTACT {
    #[inline]
    pub unsafe fn merge_points(
        &mut self,
        plane: *const btVector4,
        margin: btScalar,
        points: *const btVector3,
        point_count: ::std::os::raw::c_int,
    ) {
        GIM_TRIANGLE_CONTACT_merge_points(self, plane, margin, points, point_count)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPrimitiveTriangle {
    pub m_vertices: [btVector3; 3usize],
    pub m_plane: btVector4,
    pub m_margin: btScalar,
    pub m_dummy: btScalar,
}
extern "C" {
    /// ! Test if triangles could collide
    #[link_name = "\u{1}?overlap_test_conservative@btPrimitiveTriangle@@QEAA_NAEBV1@@Z"]
    pub fn btPrimitiveTriangle_overlap_test_conservative(
        this: *mut btPrimitiveTriangle,
        other: *const btPrimitiveTriangle,
    ) -> bool;
}
extern "C" {
    /// ! Clips the triangle against this
    /// /*!
    /// \pre clipped_points must have MAX_TRI_CLIPPING size, and this triangle must have its plane calculated.
    /// \return the number of clipped points
    /// */
    #[link_name = "\u{1}?clip_triangle@btPrimitiveTriangle@@QEAAHAEAV1@PEAVbtVector3@@@Z"]
    pub fn btPrimitiveTriangle_clip_triangle(
        this: *mut btPrimitiveTriangle,
        other: *mut btPrimitiveTriangle,
        clipped_points: *mut btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ! Find collision using the clipping method
    /// /*!
    /// \pre this triangle and other must have their triangles calculated
    /// */
    #[link_name = "\u{1}?find_triangle_collision_clip_method@btPrimitiveTriangle@@QEAA_NAEAV1@AEAUGIM_TRIANGLE_CONTACT@@@Z"]
    pub fn btPrimitiveTriangle_find_triangle_collision_clip_method(
        this: *mut btPrimitiveTriangle,
        other: *mut btPrimitiveTriangle,
        contacts: *mut GIM_TRIANGLE_CONTACT,
    ) -> bool;
}
impl btPrimitiveTriangle {
    #[inline]
    pub unsafe fn overlap_test_conservative(&mut self, other: *const btPrimitiveTriangle) -> bool {
        btPrimitiveTriangle_overlap_test_conservative(self, other)
    }
    #[inline]
    pub unsafe fn clip_triangle(
        &mut self,
        other: *mut btPrimitiveTriangle,
        clipped_points: *mut btVector3,
    ) -> ::std::os::raw::c_int {
        btPrimitiveTriangle_clip_triangle(self, other, clipped_points)
    }
    #[inline]
    pub unsafe fn find_triangle_collision_clip_method(
        &mut self,
        other: *mut btPrimitiveTriangle,
        contacts: *mut GIM_TRIANGLE_CONTACT,
    ) -> bool {
        btPrimitiveTriangle_find_triangle_collision_clip_method(self, other, contacts)
    }
}
/// ! Helper class for colliding Bullet Triangle Shapes
/// *!
/// This class implements a better getAabb method than the previous btTriangleShape class
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleShapeEx {
    pub _base: btTriangleShape,
}
extern "C" {
    #[link_name = "\u{1}?overlap_test_conservative@btTriangleShapeEx@@QEAA_NAEBV1@@Z"]
    pub fn btTriangleShapeEx_overlap_test_conservative(
        this: *mut btTriangleShapeEx,
        other: *const btTriangleShapeEx,
    ) -> bool;
}
impl btTriangleShapeEx {
    #[inline]
    pub unsafe fn overlap_test_conservative(&mut self, other: *const btTriangleShapeEx) -> bool {
        btTriangleShapeEx_overlap_test_conservative(self, other)
    }
}
/// ! Overlapping pair
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIM_PAIR {
    pub m_index1: ::std::os::raw::c_int,
    pub m_index2: ::std::os::raw::c_int,
}
/// GIM_BVH_DATA is an internal GIMPACT collision structure to contain axis aligned bounding box
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIM_BVH_DATA {
    pub m_bound: btAABB,
    pub m_data: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
/// ! Node Structure for trees
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIM_BVH_TREE_NODE {
    pub m_bound: btAABB,
    pub m_escapeIndexOrDataIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
/// ! A pairset array
#[repr(C)]
#[derive(Debug)]
pub struct btPairSet {
    pub _base: btAlignedObjectArray<GIM_PAIR>,
}
#[repr(C)]
#[derive(Debug)]
pub struct GIM_BVH_DATA_ARRAY {
    pub _base: btAlignedObjectArray<GIM_BVH_DATA>,
}
#[repr(C)]
#[derive(Debug)]
pub struct GIM_BVH_TREE_NODE_ARRAY {
    pub _base: btAlignedObjectArray<GIM_BVH_TREE_NODE>,
}
/// ! Basic Box tree structure
#[repr(C)]
#[derive(Debug)]
pub struct btBvhTree {
    pub m_num_nodes: ::std::os::raw::c_int,
    pub m_node_array: GIM_BVH_TREE_NODE_ARRAY,
}
extern "C" {
    #[link_name = "\u{1}?_sort_and_calc_splitting_index@btBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HHH@Z"]
    pub fn btBvhTree__sort_and_calc_splitting_index(
        this: *mut btBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_calc_splitting_axis@btBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HH@Z"]
    pub fn btBvhTree__calc_splitting_axis(
        this: *mut btBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_build_sub_tree@btBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@HH@Z"]
    pub fn btBvhTree__build_sub_tree(
        this: *mut btBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// ! prototype functions for box tree management
    /// //!@{
    #[link_name = "\u{1}?build_tree@btBvhTree@@QEAAXAEAVGIM_BVH_DATA_ARRAY@@@Z"]
    pub fn btBvhTree_build_tree(this: *mut btBvhTree, primitive_boxes: *mut GIM_BVH_DATA_ARRAY);
}
impl btBvhTree {
    #[inline]
    pub unsafe fn _sort_and_calc_splitting_index(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btBvhTree__sort_and_calc_splitting_index(
            self,
            primitive_boxes,
            startIndex,
            endIndex,
            splitAxis,
        )
    }
    #[inline]
    pub unsafe fn _calc_splitting_axis(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btBvhTree__calc_splitting_axis(self, primitive_boxes, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn _build_sub_tree(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) {
        btBvhTree__build_sub_tree(self, primitive_boxes, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn build_tree(&mut self, primitive_boxes: *mut GIM_BVH_DATA_ARRAY) {
        btBvhTree_build_tree(self, primitive_boxes)
    }
}
#[repr(C)]
pub struct btPrimitiveManagerBase__bindgen_vtable(::std::os::raw::c_void);
/// ! Prototype Base class for primitive classification
/// *!
/// This class is a wrapper for primitive collections.
/// This tells relevant info for the Bounding Box set classes, which take care of space classification.
/// This class can manage Compound shapes and trimeshes, and if it is managing trimesh then the  Hierarchy Bounding Box classes will take advantage of primitive Vs Box overlapping tests for getting optimal results and less Per Box compairisons.
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btPrimitiveManagerBase {
    pub vtable_: *const btPrimitiveManagerBase__bindgen_vtable,
}
/// ! Structure for containing Boxes
/// *!
/// This class offers an structure for managing a box tree of primitives.
/// Requires a Primitive prototype (like btPrimitiveManagerBase )
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactBvh {
    pub m_box_tree: btBvhTree,
    pub m_primitive_manager: *mut btPrimitiveManagerBase,
}
extern "C" {
    #[link_name = "\u{1}?refit@btGImpactBvh@@IEAAXXZ"]
    pub fn btGImpactBvh_refit(this: *mut btGImpactBvh);
}
extern "C" {
    /// ! this rebuild the entire set
    #[link_name = "\u{1}?buildSet@btGImpactBvh@@QEAAXXZ"]
    pub fn btGImpactBvh_buildSet(this: *mut btGImpactBvh);
}
extern "C" {
    /// ! returns the indices of the primitives in the m_primitive_manager
    #[link_name = "\u{1}?boxQuery@btGImpactBvh@@QEBA_NAEBVbtAABB@@AEAV?$btAlignedObjectArray@H@@@Z"]
    pub fn btGImpactBvh_boxQuery(
        this: *const btGImpactBvh,
        box_: *const btAABB,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool;
}
extern "C" {
    /// ! returns the indices of the primitives in the m_primitive_manager
    #[link_name = "\u{1}?rayQuery@btGImpactBvh@@QEBA_NAEBVbtVector3@@0AEAV?$btAlignedObjectArray@H@@@Z"]
    pub fn btGImpactBvh_rayQuery(
        this: *const btGImpactBvh,
        ray_dir: *const btVector3,
        ray_origin: *const btVector3,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?find_collision@btGImpactBvh@@SAXPEAV1@AEBVbtTransform@@01AEAVbtPairSet@@@Z"]
    pub fn btGImpactBvh_find_collision(
        boxset1: *mut btGImpactBvh,
        trans1: *const btTransform,
        boxset2: *mut btGImpactBvh,
        trans2: *const btTransform,
        collision_pairs: *mut btPairSet,
    );
}
impl btGImpactBvh {
    #[inline]
    pub unsafe fn refit(&mut self) {
        btGImpactBvh_refit(self)
    }
    #[inline]
    pub unsafe fn buildSet(&mut self) {
        btGImpactBvh_buildSet(self)
    }
    #[inline]
    pub unsafe fn boxQuery(
        &self,
        box_: *const btAABB,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool {
        btGImpactBvh_boxQuery(self, box_, collided_results)
    }
    #[inline]
    pub unsafe fn rayQuery(
        &self,
        ray_dir: *const btVector3,
        ray_origin: *const btVector3,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool {
        btGImpactBvh_rayQuery(self, ray_dir, ray_origin, collided_results)
    }
    #[inline]
    pub unsafe fn find_collision(
        boxset1: *mut btGImpactBvh,
        trans1: *const btTransform,
        boxset2: *mut btGImpactBvh,
        trans2: *const btTransform,
        collision_pairs: *mut btPairSet,
    ) {
        btGImpactBvh_find_collision(boxset1, trans1, boxset2, trans2, collision_pairs)
    }
}
/// btQuantizedBvhNode is a compressed aabb node, 16 bytes.
/// Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BT_QUANTIZED_BVH_NODE {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_escapeIndexOrDataIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct GIM_QUANTIZED_BVH_NODE_ARRAY {
    pub _base: btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>,
}
/// ! Basic Box tree structure
#[repr(C)]
#[derive(Debug)]
pub struct btQuantizedBvhTree {
    pub m_num_nodes: ::std::os::raw::c_int,
    pub m_node_array: GIM_QUANTIZED_BVH_NODE_ARRAY,
    pub __bindgen_padding_0: u64,
    pub m_global_bound: btAABB,
    pub m_bvhQuantization: btVector3,
}
extern "C" {
    #[link_name = "\u{1}?calc_quantization@btQuantizedBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@N@Z"]
    pub fn btQuantizedBvhTree_calc_quantization(
        this: *mut btQuantizedBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        boundMargin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?_sort_and_calc_splitting_index@btQuantizedBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HHH@Z"]
    pub fn btQuantizedBvhTree__sort_and_calc_splitting_index(
        this: *mut btQuantizedBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_calc_splitting_axis@btQuantizedBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HH@Z"]
    pub fn btQuantizedBvhTree__calc_splitting_axis(
        this: *mut btQuantizedBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_build_sub_tree@btQuantizedBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@HH@Z"]
    pub fn btQuantizedBvhTree__build_sub_tree(
        this: *mut btQuantizedBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// ! prototype functions for box tree management
    /// //!@{
    #[link_name = "\u{1}?build_tree@btQuantizedBvhTree@@QEAAXAEAVGIM_BVH_DATA_ARRAY@@@Z"]
    pub fn btQuantizedBvhTree_build_tree(
        this: *mut btQuantizedBvhTree,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
    );
}
impl btQuantizedBvhTree {
    #[inline]
    pub unsafe fn calc_quantization(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        boundMargin: btScalar,
    ) {
        btQuantizedBvhTree_calc_quantization(self, primitive_boxes, boundMargin)
    }
    #[inline]
    pub unsafe fn _sort_and_calc_splitting_index(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvhTree__sort_and_calc_splitting_index(
            self,
            primitive_boxes,
            startIndex,
            endIndex,
            splitAxis,
        )
    }
    #[inline]
    pub unsafe fn _calc_splitting_axis(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvhTree__calc_splitting_axis(self, primitive_boxes, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn _build_sub_tree(
        &mut self,
        primitive_boxes: *mut GIM_BVH_DATA_ARRAY,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvhTree__build_sub_tree(self, primitive_boxes, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn build_tree(&mut self, primitive_boxes: *mut GIM_BVH_DATA_ARRAY) {
        btQuantizedBvhTree_build_tree(self, primitive_boxes)
    }
}
/// ! Structure for containing Boxes
/// *!
/// This class offers an structure for managing a box tree of primitives.
/// Requires a Primitive prototype (like btPrimitiveManagerBase )
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactQuantizedBvh {
    pub m_box_tree: btQuantizedBvhTree,
    pub m_primitive_manager: *mut btPrimitiveManagerBase,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?refit@btGImpactQuantizedBvh@@IEAAXXZ"]
    pub fn btGImpactQuantizedBvh_refit(this: *mut btGImpactQuantizedBvh);
}
extern "C" {
    /// ! this rebuild the entire set
    #[link_name = "\u{1}?buildSet@btGImpactQuantizedBvh@@QEAAXXZ"]
    pub fn btGImpactQuantizedBvh_buildSet(this: *mut btGImpactQuantizedBvh);
}
extern "C" {
    /// ! returns the indices of the primitives in the m_primitive_manager
    #[link_name = "\u{1}?boxQuery@btGImpactQuantizedBvh@@QEBA_NAEBVbtAABB@@AEAV?$btAlignedObjectArray@H@@@Z"]
    pub fn btGImpactQuantizedBvh_boxQuery(
        this: *const btGImpactQuantizedBvh,
        box_: *const btAABB,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool;
}
extern "C" {
    /// ! returns the indices of the primitives in the m_primitive_manager
    #[link_name = "\u{1}?rayQuery@btGImpactQuantizedBvh@@QEBA_NAEBVbtVector3@@0AEAV?$btAlignedObjectArray@H@@@Z"]
    pub fn btGImpactQuantizedBvh_rayQuery(
        this: *const btGImpactQuantizedBvh,
        ray_dir: *const btVector3,
        ray_origin: *const btVector3,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?find_collision@btGImpactQuantizedBvh@@SAXPEBV1@AEBVbtTransform@@01AEAVbtPairSet@@@Z"]
    pub fn btGImpactQuantizedBvh_find_collision(
        boxset1: *const btGImpactQuantizedBvh,
        trans1: *const btTransform,
        boxset2: *const btGImpactQuantizedBvh,
        trans2: *const btTransform,
        collision_pairs: *mut btPairSet,
    );
}
impl btGImpactQuantizedBvh {
    #[inline]
    pub unsafe fn refit(&mut self) {
        btGImpactQuantizedBvh_refit(self)
    }
    #[inline]
    pub unsafe fn buildSet(&mut self) {
        btGImpactQuantizedBvh_buildSet(self)
    }
    #[inline]
    pub unsafe fn boxQuery(
        &self,
        box_: *const btAABB,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool {
        btGImpactQuantizedBvh_boxQuery(self, box_, collided_results)
    }
    #[inline]
    pub unsafe fn rayQuery(
        &self,
        ray_dir: *const btVector3,
        ray_origin: *const btVector3,
        collided_results: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool {
        btGImpactQuantizedBvh_rayQuery(self, ray_dir, ray_origin, collided_results)
    }
    #[inline]
    pub unsafe fn find_collision(
        boxset1: *const btGImpactQuantizedBvh,
        trans1: *const btTransform,
        boxset2: *const btGImpactQuantizedBvh,
        trans2: *const btTransform,
        collision_pairs: *mut btPairSet,
    ) {
        btGImpactQuantizedBvh_find_collision(boxset1, trans1, boxset2, trans2, collision_pairs)
    }
}
/// ! declare Quantized trees, (you can change to float based trees)
pub type btGImpactBoxSet = btGImpactQuantizedBvh;
pub const eGIMPACT_SHAPE_TYPE_CONST_GIMPACT_COMPOUND_SHAPE: eGIMPACT_SHAPE_TYPE = 0;
pub const eGIMPACT_SHAPE_TYPE_CONST_GIMPACT_TRIMESH_SHAPE_PART: eGIMPACT_SHAPE_TYPE = 1;
pub const eGIMPACT_SHAPE_TYPE_CONST_GIMPACT_TRIMESH_SHAPE: eGIMPACT_SHAPE_TYPE = 2;
pub type eGIMPACT_SHAPE_TYPE = i32;
/// ! Helper class for tetrahedrons
#[repr(C)]
#[derive(Debug)]
pub struct btTetrahedronShapeEx {
    pub _base: btBU_Simplex1to4,
}
/// ! Base class for gimpact shapes
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactShapeInterface {
    pub _base: btConcaveShape,
    pub m_localAABB: btAABB,
    pub m_needs_update: bool,
    pub __bindgen_padding_0: u64,
    pub localScaling: btVector3,
    pub m_box_set: btGImpactBoxSet,
}
/// ! btGImpactCompoundShape allows to handle multiple btCollisionShape objects at once
/// *!
/// This class only can manage Convex subshapes
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactCompoundShape {
    pub _base: btGImpactShapeInterface,
    pub m_primitive_manager: btGImpactCompoundShape_CompoundPrimitiveManager,
    pub m_childTransforms: btAlignedObjectArray<btTransform>,
    pub m_childShapes: btAlignedObjectArray<*mut btCollisionShape>,
}
/// ! compound primitive manager
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactCompoundShape_CompoundPrimitiveManager {
    pub _base: btPrimitiveManagerBase,
    pub m_compoundShape: *mut btGImpactCompoundShape,
}
extern "C" {
    /// ! Calculates the exact inertia tensor for this shape
    #[link_name = "\u{1}?calculateLocalInertia@btGImpactCompoundShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btGImpactCompoundShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
/// ! This class manages a sub part of a mesh supplied by the btStridingMeshInterface interface.
/// *!
/// - Simply create this shape by passing the btStridingMeshInterface to the constructor btGImpactMeshShapePart, then you must call updateBound() after creating the mesh
/// - When making operations with this shape, you must call <b>lock</b> before accessing to the trimesh primitives, and then call <b>unlock</b>
/// - You can handle deformable meshes with this shape, by calling postUpdate() every time when changing the mesh vertices.
///
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactMeshShapePart {
    pub _base: btGImpactShapeInterface,
    pub m_primitive_manager: btGImpactMeshShapePart_TrimeshPrimitiveManager,
}
/// ! Trimesh primitive manager
/// /*!
/// Manages the info from btStridingMeshInterface object and controls the Lock/Unlock mechanism
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactMeshShapePart_TrimeshPrimitiveManager {
    pub _base: btPrimitiveManagerBase,
    pub m_margin: btScalar,
    pub m_meshInterface: *mut btStridingMeshInterface,
    pub __bindgen_padding_0: u64,
    pub m_scale: btVector3,
    pub m_part: ::std::os::raw::c_int,
    pub m_lock_count: ::std::os::raw::c_int,
    pub vertexbase: *const ::std::os::raw::c_uchar,
    pub numverts: ::std::os::raw::c_int,
    pub type_: PHY_ScalarType,
    pub stride: ::std::os::raw::c_int,
    pub indexbase: *const ::std::os::raw::c_uchar,
    pub indexstride: ::std::os::raw::c_int,
    pub numfaces: ::std::os::raw::c_int,
    pub indicestype: PHY_ScalarType,
    pub __bindgen_padding_1: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}??0btGImpactMeshShapePart@@QEAA@PEAVbtStridingMeshInterface@@H@Z"]
    pub fn btGImpactMeshShapePart_btGImpactMeshShapePart(
        this: *mut btGImpactMeshShapePart,
        meshInterface: *mut btStridingMeshInterface,
        part: ::std::os::raw::c_int,
    );
}
impl btGImpactMeshShapePart {
    #[inline]
    pub unsafe fn new(
        meshInterface: *mut btStridingMeshInterface,
        part: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGImpactMeshShapePart_btGImpactMeshShapePart(&mut __bindgen_tmp, meshInterface, part);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtGImpactMeshShapePart@@QEAAXXZ"]
    pub fn btGImpactMeshShapePart_btGImpactMeshShapePart_destructor(
        this: *mut btGImpactMeshShapePart,
    );
}
extern "C" {
    /// ! call when reading child shapes
    #[link_name = "\u{1}?lockChildShapes@btGImpactMeshShapePart@@UEBAXXZ"]
    pub fn btGImpactMeshShapePart_lockChildShapes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?unlockChildShapes@btGImpactMeshShapePart@@UEBAXXZ"]
    pub fn btGImpactMeshShapePart_unlockChildShapes(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btGImpactMeshShapePart@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btGImpactMeshShapePart_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btGImpactMeshShapePart@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btGImpactMeshShapePart_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTrianglesRay@btGImpactMeshShapePart@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btGImpactMeshShapePart_processAllTrianglesRay(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
    );
}
/// ! This class manages a mesh supplied by the btStridingMeshInterface interface.
/// *!
/// Set of btGImpactMeshShapePart parts
/// - Simply create this shape by passing the btStridingMeshInterface to the constructor btGImpactMeshShape, then you must call updateBound() after creating the mesh
///
/// - You can handle deformable meshes with this shape, by calling postUpdate() every time when changing the mesh vertices.
///
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactMeshShape {
    pub _base: btGImpactShapeInterface,
    pub m_meshInterface: *mut btStridingMeshInterface,
    pub m_mesh_parts: btAlignedObjectArray<*mut btGImpactMeshShapePart>,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btGImpactMeshShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btGImpactMeshShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btGImpactMeshShape@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btGImpactMeshShape_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    /// ! Function for retrieve triangles.
    /// /*!
    /// It gives the triangles in local space
    /// */
    #[link_name = "\u{1}?processAllTriangles@btGImpactMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btGImpactMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTrianglesRay@btGImpactMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btGImpactMeshShape_processAllTrianglesRay(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btGImpactMeshShape@@UEBAHXZ"]
    pub fn btGImpactMeshShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btGImpactMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btGImpactMeshShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGImpactMeshShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_meshInterface: btStridingMeshInterfaceData,
    pub m_localScaling: btVector3FloatData,
    pub m_collisionMargin: f32,
    pub m_gimpactSubType: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleRaycastCallback {
    pub _base: btTriangleCallback,
    pub __bindgen_padding_0: u64,
    pub m_from: btVector3,
    pub m_to: btVector3,
    pub m_flags: ::std::os::raw::c_uint,
    pub m_hitFraction: btScalar,
}
pub const btTriangleRaycastCallback_EFlags_kF_None: btTriangleRaycastCallback_EFlags = 0;
pub const btTriangleRaycastCallback_EFlags_kF_FilterBackfaces: btTriangleRaycastCallback_EFlags = 1;
pub const btTriangleRaycastCallback_EFlags_kF_KeepUnflippedNormal:
    btTriangleRaycastCallback_EFlags = 2;
/// SubSimplexConvexCastRaytest is the default, even if kF_None is set.
pub const btTriangleRaycastCallback_EFlags_kF_UseSubSimplexConvexCastRaytest:
    btTriangleRaycastCallback_EFlags = 4;
/// SubSimplexConvexCastRaytest is the default, even if kF_None is set.
pub const btTriangleRaycastCallback_EFlags_kF_UseGjkConvexCastRaytest:
    btTriangleRaycastCallback_EFlags = 8;
/// SubSimplexConvexCastRaytest is the default, even if kF_None is set.
pub const btTriangleRaycastCallback_EFlags_kF_Terminator: btTriangleRaycastCallback_EFlags = -1;
pub type btTriangleRaycastCallback_EFlags = i32;
extern "C" {
    #[link_name = "\u{1}??0btTriangleRaycastCallback@@QEAA@AEBVbtVector3@@0I@Z"]
    pub fn btTriangleRaycastCallback_btTriangleRaycastCallback(
        this: *mut btTriangleRaycastCallback,
        from: *const btVector3,
        to: *const btVector3,
        flags: ::std::os::raw::c_uint,
    );
}
impl btTriangleRaycastCallback {
    #[inline]
    pub unsafe fn new(
        from: *const btVector3,
        to: *const btVector3,
        flags: ::std::os::raw::c_uint,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleRaycastCallback_btTriangleRaycastCallback(&mut __bindgen_tmp, from, to, flags);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processTriangle@btTriangleRaycastCallback@@UEAAXPEAVbtVector3@@HH@Z"]
    pub fn btTriangleRaycastCallback_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleConvexcastCallback {
    pub _base: btTriangleCallback,
    pub m_convexShape: *const btConvexShape,
    pub m_convexShapeFrom: btTransform,
    pub m_convexShapeTo: btTransform,
    pub m_triangleToWorld: btTransform,
    pub m_hitFraction: btScalar,
    pub m_triangleCollisionMargin: btScalar,
    pub m_allowedPenetration: btScalar,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btTriangleConvexcastCallback@@QEAA@PEBVbtConvexShape@@AEBVbtTransform@@11N@Z"]
    pub fn btTriangleConvexcastCallback_btTriangleConvexcastCallback(
        this: *mut btTriangleConvexcastCallback,
        convexShape: *const btConvexShape,
        convexShapeFrom: *const btTransform,
        convexShapeTo: *const btTransform,
        triangleToWorld: *const btTransform,
        triangleCollisionMargin: btScalar,
    );
}
impl btTriangleConvexcastCallback {
    #[inline]
    pub unsafe fn new(
        convexShape: *const btConvexShape,
        convexShapeFrom: *const btTransform,
        convexShapeTo: *const btTransform,
        triangleToWorld: *const btTransform,
        triangleCollisionMargin: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleConvexcastCallback_btTriangleConvexcastCallback(
            &mut __bindgen_tmp,
            convexShape,
            convexShapeFrom,
            convexShapeTo,
            triangleToWorld,
            triangleCollisionMargin,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processTriangle@btTriangleConvexcastCallback@@UEAAXPEAVbtVector3@@HH@Z"]
    pub fn btTriangleConvexcastCallback_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundFromGimpactShape {
    pub _base: btCompoundShape,
}
extern "C" {
    #[link_name = "\u{1}?btCreateCompoundFromGimpactShape@@YAPEAVbtCompoundShape@@PEBVbtGImpactMeshShape@@N@Z"]
    pub fn btCreateCompoundFromGimpactShape(
        gimpactMesh: *const btGImpactMeshShape,
        depth: btScalar,
    ) -> *mut btCompoundShape;
}
/// The GIM_CONTACT is an internal GIMPACT structure, similar to btManifoldPoint.
/// @todo: remove and replace GIM_CONTACT by btManifoldPoint.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIM_CONTACT {
    pub m_point: btVector3,
    pub m_normal: btVector3,
    pub m_depth: btScalar,
    pub m_distance: btScalar,
    pub m_feature1: ::std::os::raw::c_int,
    pub m_feature2: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btContactArray {
    pub _base: btAlignedObjectArray<GIM_CONTACT>,
}
extern "C" {
    #[link_name = "\u{1}?merge_contacts@btContactArray@@QEAAXAEBV1@_N@Z"]
    pub fn btContactArray_merge_contacts(
        this: *mut btContactArray,
        contacts: *const btContactArray,
        normal_contact_average: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?merge_contacts_unique@btContactArray@@QEAAXAEBV1@@Z"]
    pub fn btContactArray_merge_contacts_unique(
        this: *mut btContactArray,
        contacts: *const btContactArray,
    );
}
impl btContactArray {
    #[inline]
    pub unsafe fn merge_contacts(
        &mut self,
        contacts: *const btContactArray,
        normal_contact_average: bool,
    ) {
        btContactArray_merge_contacts(self, contacts, normal_contact_average)
    }
    #[inline]
    pub unsafe fn merge_contacts_unique(&mut self, contacts: *const btContactArray) {
        btContactArray_merge_contacts_unique(self, contacts)
    }
}
/// The btStaticPlaneShape simulates an infinite non-moving (static) collision plane.
#[repr(C)]
#[derive(Debug)]
pub struct btStaticPlaneShape {
    pub _base: btConcaveShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_planeNormal: btVector3,
    pub m_planeConstant: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_localScaling: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btStaticPlaneShape@@QEAA@AEBVbtVector3@@N@Z"]
    pub fn btStaticPlaneShape_btStaticPlaneShape(
        this: *mut btStaticPlaneShape,
        planeNormal: *const btVector3,
        planeConstant: btScalar,
    );
}
impl btStaticPlaneShape {
    #[inline]
    pub unsafe fn new(planeNormal: *const btVector3, planeConstant: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btStaticPlaneShape_btStaticPlaneShape(&mut __bindgen_tmp, planeNormal, planeConstant);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtStaticPlaneShape@@QEAAXXZ"]
    pub fn btStaticPlaneShape_btStaticPlaneShape_destructor(this: *mut btStaticPlaneShape);
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btStaticPlaneShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btStaticPlaneShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btStaticPlaneShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btStaticPlaneShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btStaticPlaneShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btStaticPlaneShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btStaticPlaneShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btStaticPlaneShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btStaticPlaneShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btStaticPlaneShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btStaticPlaneShape@@UEBAHXZ"]
    pub fn btStaticPlaneShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btStaticPlaneShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btStaticPlaneShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btStaticPlaneShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_localScaling: btVector3FloatData,
    pub m_planeNormal: btVector3FloatData,
    pub m_planeConstant: f32,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
pub type btVertexArray = btAlignedObjectArray<btVector3>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPolyhedralContactClipping {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?clipHullAgainstHull@btPolyhedralContactClipping@@SAXAEBVbtVector3@@AEBVbtConvexPolyhedron@@1AEBVbtTransform@@2NNAEAV?$btAlignedObjectArray@VbtVector3@@@@3AEAUResult@btDiscreteCollisionDetectorInterface@@@Z"]
    pub fn btPolyhedralContactClipping_clipHullAgainstHull(
        separatingNormal1: *const btVector3,
        hullA: *const btConvexPolyhedron,
        hullB: *const btConvexPolyhedron,
        transA: *const btTransform,
        transB: *const btTransform,
        minDist: btScalar,
        maxDist: btScalar,
        worldVertsB1: *mut btVertexArray,
        worldVertsB2: *mut btVertexArray,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    );
}
extern "C" {
    #[link_name = "\u{1}?clipFaceAgainstHull@btPolyhedralContactClipping@@SAXAEBVbtVector3@@AEBVbtConvexPolyhedron@@AEBVbtTransform@@AEAV?$btAlignedObjectArray@VbtVector3@@@@3NNAEAUResult@btDiscreteCollisionDetectorInterface@@@Z"]
    pub fn btPolyhedralContactClipping_clipFaceAgainstHull(
        separatingNormal: *const btVector3,
        hullA: *const btConvexPolyhedron,
        transA: *const btTransform,
        worldVertsB1: *mut btVertexArray,
        worldVertsB2: *mut btVertexArray,
        minDist: btScalar,
        maxDist: btScalar,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    );
}
extern "C" {
    #[link_name = "\u{1}?findSeparatingAxis@btPolyhedralContactClipping@@SA_NAEBVbtConvexPolyhedron@@0AEBVbtTransform@@1AEAVbtVector3@@AEAUResult@btDiscreteCollisionDetectorInterface@@@Z"]
    pub fn btPolyhedralContactClipping_findSeparatingAxis(
        hullA: *const btConvexPolyhedron,
        hullB: *const btConvexPolyhedron,
        transA: *const btTransform,
        transB: *const btTransform,
        sep: *mut btVector3,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    ) -> bool;
}
extern "C" {
    /// the clipFace method is used internally
    #[link_name = "\u{1}?clipFace@btPolyhedralContactClipping@@SAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@AEBVbtVector3@@N@Z"]
    pub fn btPolyhedralContactClipping_clipFace(
        pVtxIn: *const btVertexArray,
        ppVtxOut: *mut btVertexArray,
        planeNormalWS: *const btVector3,
        planeEqWS: btScalar,
    );
}
impl btPolyhedralContactClipping {
    #[inline]
    pub unsafe fn clipHullAgainstHull(
        separatingNormal1: *const btVector3,
        hullA: *const btConvexPolyhedron,
        hullB: *const btConvexPolyhedron,
        transA: *const btTransform,
        transB: *const btTransform,
        minDist: btScalar,
        maxDist: btScalar,
        worldVertsB1: *mut btVertexArray,
        worldVertsB2: *mut btVertexArray,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    ) {
        btPolyhedralContactClipping_clipHullAgainstHull(
            separatingNormal1,
            hullA,
            hullB,
            transA,
            transB,
            minDist,
            maxDist,
            worldVertsB1,
            worldVertsB2,
            resultOut,
        )
    }
    #[inline]
    pub unsafe fn clipFaceAgainstHull(
        separatingNormal: *const btVector3,
        hullA: *const btConvexPolyhedron,
        transA: *const btTransform,
        worldVertsB1: *mut btVertexArray,
        worldVertsB2: *mut btVertexArray,
        minDist: btScalar,
        maxDist: btScalar,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    ) {
        btPolyhedralContactClipping_clipFaceAgainstHull(
            separatingNormal,
            hullA,
            transA,
            worldVertsB1,
            worldVertsB2,
            minDist,
            maxDist,
            resultOut,
        )
    }
    #[inline]
    pub unsafe fn findSeparatingAxis(
        hullA: *const btConvexPolyhedron,
        hullB: *const btConvexPolyhedron,
        transA: *const btTransform,
        transB: *const btTransform,
        sep: *mut btVector3,
        resultOut: *mut btDiscreteCollisionDetectorInterface_Result,
    ) -> bool {
        btPolyhedralContactClipping_findSeparatingAxis(hullA, hullB, transA, transB, sep, resultOut)
    }
    #[inline]
    pub unsafe fn clipFace(
        pVtxIn: *const btVertexArray,
        ppVtxOut: *mut btVertexArray,
        planeNormalWS: *const btVector3,
        planeEqWS: btScalar,
    ) {
        btPolyhedralContactClipping_clipFace(pVtxIn, ppVtxOut, planeNormalWS, planeEqWS)
    }
}
/// The convexConvexAlgorithm collision algorithm implements time of impact, convex closest points and penetration depth calculations between two convex objects.
/// Multiple contact points are calculated by perturbing the orientation of the smallest object orthogonal to the separating normal.
/// This idea was described by Gino van den Bergen in this forum topic http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=4&t=288&p=888#p888
#[repr(C)]
#[derive(Debug)]
pub struct btConvexConvexAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub worldVertsB1: btVertexArray,
    pub worldVertsB2: btVertexArray,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_lowLevelOfDetail: bool,
    pub m_numPerturbationIterations: ::std::os::raw::c_int,
    pub m_minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btConvexConvexAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub m_numPerturbationIterations: ::std::os::raw::c_int,
    pub m_minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}??0CreateFunc@btConvexConvexAlgorithm@@QEAA@PEAVbtConvexPenetrationDepthSolver@@@Z"]
    pub fn btConvexConvexAlgorithm_CreateFunc_CreateFunc(
        this: *mut btConvexConvexAlgorithm_CreateFunc,
        pdSolver: *mut btConvexPenetrationDepthSolver,
    );
}
impl btConvexConvexAlgorithm_CreateFunc {
    #[inline]
    pub unsafe fn new(pdSolver: *mut btConvexPenetrationDepthSolver) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexConvexAlgorithm_CreateFunc_CreateFunc(&mut __bindgen_tmp, pdSolver);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?setLowLevelOfDetail@btConvexConvexAlgorithm@@QEAAX_N@Z"]
    pub fn btConvexConvexAlgorithm_setLowLevelOfDetail(
        this: *mut btConvexConvexAlgorithm,
        useLowLevel: bool,
    );
}
extern "C" {
    /// cache separating vector to speedup collision detection
    #[link_name = "\u{1}??0btConvexConvexAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2PEAVbtConvexPenetrationDepthSolver@@HH@Z"]
    pub fn btConvexConvexAlgorithm_btConvexConvexAlgorithm(
        this: *mut btConvexConvexAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        pdSolver: *mut btConvexPenetrationDepthSolver,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
impl btConvexConvexAlgorithm {
    #[inline]
    pub unsafe fn setLowLevelOfDetail(&mut self, useLowLevel: bool) {
        btConvexConvexAlgorithm_setLowLevelOfDetail(self, useLowLevel)
    }
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        pdSolver: *mut btConvexPenetrationDepthSolver,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexConvexAlgorithm_btConvexConvexAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
            pdSolver,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexConvexAlgorithm@@QEAAXXZ"]
    pub fn btConvexConvexAlgorithm_btConvexConvexAlgorithm_destructor(
        this: *mut btConvexConvexAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btConvexConvexAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexConvexAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btConvexConvexAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btConvexConvexAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DCreateFunc@btConvexConvexAlgorithm@@QEAAXXZ"]
    pub fn btConvexConvexAlgorithm_CreateFunc_CreateFunc_destructor(
        this: *mut btConvexConvexAlgorithm_CreateFunc,
    );
}
#[repr(C)]
pub struct btIDebugDraw__bindgen_vtable(::std::os::raw::c_void);
/// The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
/// Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
/// A class that implements the btIDebugDraw interface has to implement the drawLine method at a minimum.
/// For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]
#[repr(C)]
#[derive(Debug)]
pub struct btIDebugDraw {
    pub vtable_: *const btIDebugDraw__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIDebugDraw_DefaultColors {
    pub m_activeObject: btVector3,
    pub m_deactivatedObject: btVector3,
    pub m_wantsDeactivationObject: btVector3,
    pub m_disabledDeactivationObject: btVector3,
    pub m_disabledSimulationObject: btVector3,
    pub m_aabb: btVector3,
    pub m_contactPoint: btVector3,
}
pub const btIDebugDraw_DebugDrawModes_DBG_NoDebug: btIDebugDraw_DebugDrawModes = 0;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawWireframe: btIDebugDraw_DebugDrawModes = 1;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawAabb: btIDebugDraw_DebugDrawModes = 2;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawFeaturesText: btIDebugDraw_DebugDrawModes = 4;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawContactPoints: btIDebugDraw_DebugDrawModes = 8;
pub const btIDebugDraw_DebugDrawModes_DBG_NoDeactivation: btIDebugDraw_DebugDrawModes = 16;
pub const btIDebugDraw_DebugDrawModes_DBG_NoHelpText: btIDebugDraw_DebugDrawModes = 32;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawText: btIDebugDraw_DebugDrawModes = 64;
pub const btIDebugDraw_DebugDrawModes_DBG_ProfileTimings: btIDebugDraw_DebugDrawModes = 128;
pub const btIDebugDraw_DebugDrawModes_DBG_EnableSatComparison: btIDebugDraw_DebugDrawModes = 256;
pub const btIDebugDraw_DebugDrawModes_DBG_DisableBulletLCP: btIDebugDraw_DebugDrawModes = 512;
pub const btIDebugDraw_DebugDrawModes_DBG_EnableCCD: btIDebugDraw_DebugDrawModes = 1024;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraints: btIDebugDraw_DebugDrawModes = 2048;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraintLimits: btIDebugDraw_DebugDrawModes = 4096;
pub const btIDebugDraw_DebugDrawModes_DBG_FastWireframe: btIDebugDraw_DebugDrawModes = 8192;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawNormals: btIDebugDraw_DebugDrawModes = 16384;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawFrames: btIDebugDraw_DebugDrawModes = 32768;
pub const btIDebugDraw_DebugDrawModes_DBG_MAX_DEBUG_DRAW_MODE: btIDebugDraw_DebugDrawModes = 32769;
pub type btIDebugDraw_DebugDrawModes = i32;
/// ! Collision Algorithm for GImpact Shapes
/// *!
/// For register this algorithm in Bullet, proceed as following:
/// \code
/// btCollisionDispatcher * dispatcher = static_cast<btCollisionDispatcher *>(m_dynamicsWorld ->getDispatcher());
/// btGImpactCollisionAlgorithm::registerAlgorithm(dispatcher);
/// \endcode
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_convex_algorithm: *mut btCollisionAlgorithm,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_resultOut: *mut btManifoldResult,
    pub m_dispatchInfo: *const btDispatcherInfo,
    pub m_triface0: ::std::os::raw::c_int,
    pub m_part0: ::std::os::raw::c_int,
    pub m_triface1: ::std::os::raw::c_int,
    pub m_part1: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct btGImpactCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}?addContactPoint@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0AEBVbtVector3@@1N@Z"]
    pub fn btGImpactCollisionAlgorithm_addContactPoint(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        point: *const btVector3,
        normal: *const btVector3,
        distance: btScalar,
    );
}
extern "C" {
    /// ! Collision routines
    /// !@{
    #[link_name = "\u{1}?collide_gjk_triangles@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@1PEBHH@Z"]
    pub fn btGImpactCollisionAlgorithm_collide_gjk_triangles(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btGImpactMeshShapePart,
        pairs: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?collide_sat_triangles@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@1PEBHH@Z"]
    pub fn btGImpactCollisionAlgorithm_collide_sat_triangles(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btGImpactMeshShapePart,
        pairs: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?shape_vs_shape_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtCollisionShape@@1@Z"]
    pub fn btGImpactCollisionAlgorithm_shape_vs_shape_collision(
        this: *mut btGImpactCollisionAlgorithm,
        body0: *const btCollisionObjectWrapper,
        body1: *const btCollisionObjectWrapper,
        shape0: *const btCollisionShape,
        shape1: *const btCollisionShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?convex_vs_convex_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtCollisionShape@@1@Z"]
    pub fn btGImpactCollisionAlgorithm_convex_vs_convex_collision(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btCollisionShape,
        shape1: *const btCollisionShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpact_vs_gimpact_find_pairs@btGImpactCollisionAlgorithm@@IEAAXAEBVbtTransform@@0PEBVbtGImpactShapeInterface@@1AEAVbtPairSet@@@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_gimpact_find_pairs(
        this: *mut btGImpactCollisionAlgorithm,
        trans0: *const btTransform,
        trans1: *const btTransform,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btGImpactShapeInterface,
        pairset: *mut btPairSet,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpact_vs_shape_find_pairs@btGImpactCollisionAlgorithm@@IEAAXAEBVbtTransform@@0PEBVbtGImpactShapeInterface@@PEBVbtCollisionShape@@AEAV?$btAlignedObjectArray@H@@@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_shape_find_pairs(
        this: *mut btGImpactCollisionAlgorithm,
        trans0: *const btTransform,
        trans1: *const btTransform,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCollisionShape,
        collided_primitives: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpacttrimeshpart_vs_plane_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@PEBVbtStaticPlaneShape@@_N@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpacttrimeshpart_vs_plane_collision(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btStaticPlaneShape,
        swapped: bool,
    );
}
extern "C" {
    /// ! Use this function for register the algorithm externally
    #[link_name = "\u{1}?registerAlgorithm@btGImpactCollisionAlgorithm@@SAXPEAVbtCollisionDispatcher@@@Z"]
    pub fn btGImpactCollisionAlgorithm_registerAlgorithm(dispatcher: *mut btCollisionDispatcher);
}
extern "C" {
    /// ! Collides two gimpact shapes
    /// /*!
    /// \pre shape0 and shape1 couldn't be btGImpactMeshShape objects
    /// */
    #[link_name = "\u{1}?gimpact_vs_gimpact@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@1@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_gimpact(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btGImpactShapeInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpact_vs_shape@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtCollisionShape@@_N@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_shape(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCollisionShape,
        swapped: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpact_vs_compoundshape@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtCompoundShape@@_N@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCompoundShape,
        swapped: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?gimpact_vs_concave@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtConcaveShape@@_N@Z"]
    pub fn btGImpactCollisionAlgorithm_gimpact_vs_concave(
        this: *mut btGImpactCollisionAlgorithm,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btConcaveShape,
        swapped: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGImpactCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1@Z"]
    pub fn btGImpactCollisionAlgorithm_btGImpactCollisionAlgorithm(
        this: *mut btGImpactCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btGImpactCollisionAlgorithm {
    #[inline]
    pub unsafe fn addContactPoint(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        point: *const btVector3,
        normal: *const btVector3,
        distance: btScalar,
    ) {
        btGImpactCollisionAlgorithm_addContactPoint(
            self, body0Wrap, body1Wrap, point, normal, distance,
        )
    }
    #[inline]
    pub unsafe fn collide_gjk_triangles(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btGImpactMeshShapePart,
        pairs: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    ) {
        btGImpactCollisionAlgorithm_collide_gjk_triangles(
            self, body0Wrap, body1Wrap, shape0, shape1, pairs, pair_count,
        )
    }
    #[inline]
    pub unsafe fn collide_sat_triangles(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btGImpactMeshShapePart,
        pairs: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    ) {
        btGImpactCollisionAlgorithm_collide_sat_triangles(
            self, body0Wrap, body1Wrap, shape0, shape1, pairs, pair_count,
        )
    }
    #[inline]
    pub unsafe fn shape_vs_shape_collision(
        &mut self,
        body0: *const btCollisionObjectWrapper,
        body1: *const btCollisionObjectWrapper,
        shape0: *const btCollisionShape,
        shape1: *const btCollisionShape,
    ) {
        btGImpactCollisionAlgorithm_shape_vs_shape_collision(self, body0, body1, shape0, shape1)
    }
    #[inline]
    pub unsafe fn convex_vs_convex_collision(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btCollisionShape,
        shape1: *const btCollisionShape,
    ) {
        btGImpactCollisionAlgorithm_convex_vs_convex_collision(
            self, body0Wrap, body1Wrap, shape0, shape1,
        )
    }
    #[inline]
    pub unsafe fn gimpact_vs_gimpact_find_pairs(
        &mut self,
        trans0: *const btTransform,
        trans1: *const btTransform,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btGImpactShapeInterface,
        pairset: *mut btPairSet,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_gimpact_find_pairs(
            self, trans0, trans1, shape0, shape1, pairset,
        )
    }
    #[inline]
    pub unsafe fn gimpact_vs_shape_find_pairs(
        &mut self,
        trans0: *const btTransform,
        trans1: *const btTransform,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCollisionShape,
        collided_primitives: *mut btAlignedObjectArray<::std::os::raw::c_int>,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_shape_find_pairs(
            self,
            trans0,
            trans1,
            shape0,
            shape1,
            collided_primitives,
        )
    }
    #[inline]
    pub unsafe fn gimpacttrimeshpart_vs_plane_collision(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactMeshShapePart,
        shape1: *const btStaticPlaneShape,
        swapped: bool,
    ) {
        btGImpactCollisionAlgorithm_gimpacttrimeshpart_vs_plane_collision(
            self, body0Wrap, body1Wrap, shape0, shape1, swapped,
        )
    }
    #[inline]
    pub unsafe fn registerAlgorithm(dispatcher: *mut btCollisionDispatcher) {
        btGImpactCollisionAlgorithm_registerAlgorithm(dispatcher)
    }
    #[inline]
    pub unsafe fn gimpact_vs_gimpact(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btGImpactShapeInterface,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_gimpact(self, body0Wrap, body1Wrap, shape0, shape1)
    }
    #[inline]
    pub unsafe fn gimpact_vs_shape(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCollisionShape,
        swapped: bool,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_shape(
            self, body0Wrap, body1Wrap, shape0, shape1, swapped,
        )
    }
    #[inline]
    pub unsafe fn gimpact_vs_compoundshape(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btCompoundShape,
        swapped: bool,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(
            self, body0Wrap, body1Wrap, shape0, shape1, swapped,
        )
    }
    #[inline]
    pub unsafe fn gimpact_vs_concave(
        &mut self,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        shape0: *const btGImpactShapeInterface,
        shape1: *const btConcaveShape,
        swapped: bool,
    ) {
        btGImpactCollisionAlgorithm_gimpact_vs_concave(
            self, body0Wrap, body1Wrap, shape0, shape1, swapped,
        )
    }
    #[inline]
    pub unsafe fn new(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGImpactCollisionAlgorithm_btGImpactCollisionAlgorithm(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtGImpactCollisionAlgorithm@@QEAAXXZ"]
    pub fn btGImpactCollisionAlgorithm_btGImpactCollisionAlgorithm_destructor(
        this: *mut btGImpactCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btGImpactCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btGImpactCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btGImpactCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btGImpactCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
/// ! Generic Pool class
#[repr(C)]
#[derive(Debug)]
pub struct btGenericMemoryPool {
    pub m_pool: *mut ::std::os::raw::c_uchar,
    pub m_free_nodes: *mut usize,
    pub m_allocated_sizes: *mut usize,
    pub m_allocated_count: usize,
    pub m_free_nodes_count: usize,
    pub m_element_size: usize,
    pub m_max_element_count: usize,
}
extern "C" {
    #[link_name = "\u{1}?allocate_from_free_nodes@btGenericMemoryPool@@IEAA_K_K@Z"]
    pub fn btGenericMemoryPool_allocate_from_free_nodes(
        this: *mut btGenericMemoryPool,
        num_elements: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?allocate_from_pool@btGenericMemoryPool@@IEAA_K_K@Z"]
    pub fn btGenericMemoryPool_allocate_from_pool(
        this: *mut btGenericMemoryPool,
        num_elements: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?init_pool@btGenericMemoryPool@@QEAAX_K0@Z"]
    pub fn btGenericMemoryPool_init_pool(
        this: *mut btGenericMemoryPool,
        element_size: usize,
        element_count: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}?end_pool@btGenericMemoryPool@@QEAAXXZ"]
    pub fn btGenericMemoryPool_end_pool(this: *mut btGenericMemoryPool);
}
extern "C" {
    /// ! Allocates memory in pool
    /// /*!
    /// \param size_bytes size in bytes of the buffer
    /// */
    #[link_name = "\u{1}?allocate@btGenericMemoryPool@@QEAAPEAX_K@Z"]
    pub fn btGenericMemoryPool_allocate(
        this: *mut btGenericMemoryPool,
        size_bytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?freeMemory@btGenericMemoryPool@@QEAA_NPEAX@Z"]
    pub fn btGenericMemoryPool_freeMemory(
        this: *mut btGenericMemoryPool,
        pointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
impl btGenericMemoryPool {
    #[inline]
    pub unsafe fn allocate_from_free_nodes(&mut self, num_elements: usize) -> usize {
        btGenericMemoryPool_allocate_from_free_nodes(self, num_elements)
    }
    #[inline]
    pub unsafe fn allocate_from_pool(&mut self, num_elements: usize) -> usize {
        btGenericMemoryPool_allocate_from_pool(self, num_elements)
    }
    #[inline]
    pub unsafe fn init_pool(&mut self, element_size: usize, element_count: usize) {
        btGenericMemoryPool_init_pool(self, element_size, element_count)
    }
    #[inline]
    pub unsafe fn end_pool(&mut self) {
        btGenericMemoryPool_end_pool(self)
    }
    #[inline]
    pub unsafe fn allocate(&mut self, size_bytes: usize) -> *mut ::std::os::raw::c_void {
        btGenericMemoryPool_allocate(self, size_bytes)
    }
    #[inline]
    pub unsafe fn freeMemory(&mut self, pointer: *mut ::std::os::raw::c_void) -> bool {
        btGenericMemoryPool_freeMemory(self, pointer)
    }
}
#[repr(C)]
pub struct btGenericPoolAllocator__bindgen_vtable(::std::os::raw::c_void);
/// ! Generic Allocator with pools
/// *!
/// General purpose Allocator which can create Memory Pools dynamiacally as needed.
/// */
#[repr(C)]
#[derive(Debug)]
pub struct btGenericPoolAllocator {
    pub vtable_: *const btGenericPoolAllocator__bindgen_vtable,
    pub m_pool_element_size: usize,
    pub m_pool_element_count: usize,
    pub m_pools: [*mut btGenericMemoryPool; 16usize],
    pub m_pool_count: usize,
}
extern "C" {
    #[link_name = "\u{1}?push_new_pool@btGenericPoolAllocator@@IEAAPEAVbtGenericMemoryPool@@XZ"]
    pub fn btGenericPoolAllocator_push_new_pool(
        this: *mut btGenericPoolAllocator,
    ) -> *mut btGenericMemoryPool;
}
extern "C" {
    #[link_name = "\u{1}?failback_alloc@btGenericPoolAllocator@@IEAAPEAX_K@Z"]
    pub fn btGenericPoolAllocator_failback_alloc(
        this: *mut btGenericPoolAllocator,
        size_bytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?failback_free@btGenericPoolAllocator@@IEAA_NPEAX@Z"]
    pub fn btGenericPoolAllocator_failback_free(
        this: *mut btGenericPoolAllocator,
        pointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    /// ! Allocates memory in pool
    /// /*!
    /// \param size_bytes size in bytes of the buffer
    /// */
    #[link_name = "\u{1}?allocate@btGenericPoolAllocator@@QEAAPEAX_K@Z"]
    pub fn btGenericPoolAllocator_allocate(
        this: *mut btGenericPoolAllocator,
        size_bytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?freeMemory@btGenericPoolAllocator@@QEAA_NPEAX@Z"]
    pub fn btGenericPoolAllocator_freeMemory(
        this: *mut btGenericPoolAllocator,
        pointer: *mut ::std::os::raw::c_void,
    ) -> bool;
}
impl btGenericPoolAllocator {
    #[inline]
    pub unsafe fn push_new_pool(&mut self) -> *mut btGenericMemoryPool {
        btGenericPoolAllocator_push_new_pool(self)
    }
    #[inline]
    pub unsafe fn failback_alloc(&mut self, size_bytes: usize) -> *mut ::std::os::raw::c_void {
        btGenericPoolAllocator_failback_alloc(self, size_bytes)
    }
    #[inline]
    pub unsafe fn failback_free(&mut self, pointer: *mut ::std::os::raw::c_void) -> bool {
        btGenericPoolAllocator_failback_free(self, pointer)
    }
    #[inline]
    pub unsafe fn allocate(&mut self, size_bytes: usize) -> *mut ::std::os::raw::c_void {
        btGenericPoolAllocator_allocate(self, size_bytes)
    }
    #[inline]
    pub unsafe fn freeMemory(&mut self, pointer: *mut ::std::os::raw::c_void) -> bool {
        btGenericPoolAllocator_freeMemory(self, pointer)
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtGenericPoolAllocator@@QEAAXXZ"]
    pub fn btGenericPoolAllocator_btGenericPoolAllocator_destructor(
        this: *mut btGenericPoolAllocator,
    );
}
extern "C" {
    #[link_name = "\u{1}?btPoolAlloc@@YAPEAX_K@Z"]
    pub fn btPoolAlloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?btPoolRealloc@@YAPEAXPEAX_K1@Z"]
    pub fn btPoolRealloc(
        ptr: *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?btPoolFree@@YAXPEAX@Z"]
    pub fn btPoolFree(ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct btGjkCollisionDescription__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btGjkCollisionDescription {
    pub vtable_: *const btGjkCollisionDescription__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_firstDir: btVector3,
    pub m_maxGjkIterations: ::std::os::raw::c_int,
    pub m_maximumDistanceSquared: btScalar,
    pub m_gjkRelError2: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGjkEpaSolver3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGjkEpaSolver3_sResults {
    pub status: btGjkEpaSolver3_sResults_eStatus,
    pub __bindgen_padding_0: u64,
    pub witnesses: [btVector3; 2usize],
    pub normal: btVector3,
    pub distance: btScalar,
    pub __bindgen_padding_1: u64,
}
pub const btGjkEpaSolver3_sResults_eStatus_Separated: btGjkEpaSolver3_sResults_eStatus = 0;
pub const btGjkEpaSolver3_sResults_eStatus_Penetrating: btGjkEpaSolver3_sResults_eStatus = 1;
pub const btGjkEpaSolver3_sResults_eStatus_GJK_Failed: btGjkEpaSolver3_sResults_eStatus = 2;
pub const btGjkEpaSolver3_sResults_eStatus_EPA_Failed: btGjkEpaSolver3_sResults_eStatus = 3;
pub type btGjkEpaSolver3_sResults_eStatus = i32;
#[repr(C)]
pub struct btConvexCast__bindgen_vtable(::std::os::raw::c_void);
/// btConvexCast is an interface for Casting
#[repr(C)]
#[derive(Debug)]
pub struct btConvexCast {
    pub vtable_: *const btConvexCast__bindgen_vtable,
}
#[repr(C)]
pub struct btConvexCast_CastResult__bindgen_vtable(::std::os::raw::c_void);
/// RayResult stores the closest result
/// /// alternatively, add a callback method to decide about closest/all results
#[repr(C)]
#[derive(Debug)]
pub struct btConvexCast_CastResult {
    pub vtable_: *const btConvexCast_CastResult__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_hitTransformA: btTransform,
    pub m_hitTransformB: btTransform,
    pub m_normal: btVector3,
    pub m_hitPoint: btVector3,
    pub m_fraction: btScalar,
    pub m_debugDrawer: *mut btIDebugDraw,
    pub m_allowedPenetration: btScalar,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}??_DbtConvexCast@@QEAAXXZ"]
    pub fn btConvexCast_btConvexCast_destructor(this: *mut btConvexCast);
}
/// btContinuousConvexCollision implements angular and linear time of impact for convex objects.
/// Based on Brian Mirtich's Conservative Advancement idea (PhD thesis).
/// Algorithm operates in worldspace, in order to keep in between motion globally consistent.
/// It uses GJK at the moment. Future improvement would use minkowski sum / supporting vertex, merging innerloops
#[repr(C)]
#[derive(Debug)]
pub struct btContinuousConvexCollision {
    pub _base: btConvexCast,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    pub m_convexA: *const btConvexShape,
    pub m_convexB1: *const btConvexShape,
    pub m_planeShape: *const btStaticPlaneShape,
}
extern "C" {
    #[link_name = "\u{1}??0btContinuousConvexCollision@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z"]
    pub fn btContinuousConvexCollision_btContinuousConvexCollision(
        this: *mut btContinuousConvexCollision,
        shapeA: *const btConvexShape,
        shapeB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btContinuousConvexCollision@@QEAA@PEBVbtConvexShape@@PEBVbtStaticPlaneShape@@@Z"]
    pub fn btContinuousConvexCollision_btContinuousConvexCollision1(
        this: *mut btContinuousConvexCollision,
        shapeA: *const btConvexShape,
        plane: *const btStaticPlaneShape,
    );
}
impl btContinuousConvexCollision {
    #[inline]
    pub unsafe fn new(
        shapeA: *const btConvexShape,
        shapeB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
        penetrationDepthSolver: *mut btConvexPenetrationDepthSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btContinuousConvexCollision_btContinuousConvexCollision(
            &mut __bindgen_tmp,
            shapeA,
            shapeB,
            simplexSolver,
            penetrationDepthSolver,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(shapeA: *const btConvexShape, plane: *const btStaticPlaneShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btContinuousConvexCollision_btContinuousConvexCollision1(&mut __bindgen_tmp, shapeA, plane);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?calcTimeOfImpact@btContinuousConvexCollision@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z"]
    pub fn btContinuousConvexCollision_calcTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        fromA: *const btTransform,
        toA: *const btTransform,
        fromB: *const btTransform,
        toB: *const btTransform,
        result: *mut btConvexCast_CastResult,
    ) -> bool;
}
/// GjkConvexCast performs a raycast on a convex object using support mapping.
#[repr(C)]
#[derive(Debug)]
pub struct btGjkConvexCast {
    pub _base: btConvexCast,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_convexA: *const btConvexShape,
    pub m_convexB: *const btConvexShape,
}
extern "C" {
    #[link_name = "\u{1}??0btGjkConvexCast@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@@Z"]
    pub fn btGjkConvexCast_btGjkConvexCast(
        this: *mut btGjkConvexCast,
        convexA: *const btConvexShape,
        convexB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
    );
}
impl btGjkConvexCast {
    #[inline]
    pub unsafe fn new(
        convexA: *const btConvexShape,
        convexB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGjkConvexCast_btGjkConvexCast(&mut __bindgen_tmp, convexA, convexB, simplexSolver);
        __bindgen_tmp
    }
}
extern "C" {
    /// cast a convex against another convex object
    #[link_name = "\u{1}?calcTimeOfImpact@btGjkConvexCast@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z"]
    pub fn btGjkConvexCast_calcTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        fromA: *const btTransform,
        toA: *const btTransform,
        fromB: *const btTransform,
        toB: *const btTransform,
        result: *mut btConvexCast_CastResult,
    ) -> bool;
}
#[repr(C)]
pub struct btConvexPenetrationDepthSolver__bindgen_vtable(::std::os::raw::c_void);
/// ConvexPenetrationDepthSolver provides an interface for penetration depth calculation.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexPenetrationDepthSolver {
    pub vtable_: *const btConvexPenetrationDepthSolver__bindgen_vtable,
}
/// EpaPenetrationDepthSolver uses the Expanding Polytope Algorithm to
/// calculate the penetration depth between two convex shapes.
#[repr(C)]
#[derive(Debug)]
pub struct btGjkEpaPenetrationDepthSolver {
    pub _base: btConvexPenetrationDepthSolver,
}
extern "C" {
    #[link_name = "\u{1}?calcPenDepth@btGjkEpaPenetrationDepthSolver@@UEAA_NAEAVbtVoronoiSimplexSolver@@PEBVbtConvexShape@@1AEBVbtTransform@@2AEAVbtVector3@@33PEAVbtIDebugDraw@@@Z"]
    pub fn btGjkEpaPenetrationDepthSolver_calcPenDepth(
        this: *mut ::std::os::raw::c_void,
        simplexSolver: *mut btVoronoiSimplexSolver,
        pConvexA: *const btConvexShape,
        pConvexB: *const btConvexShape,
        transformA: *const btTransform,
        transformB: *const btTransform,
        v: *mut btVector3,
        wWitnessOnA: *mut btVector3,
        wWitnessOnB: *mut btVector3,
        debugDraw: *mut btIDebugDraw,
    ) -> bool;
}
/// MinkowskiPenetrationDepthSolver implements bruteforce penetration depth estimation.
/// Implementation is based on sampling the depth using support mapping, and using GJK step to get the witness points.
#[repr(C)]
#[derive(Debug)]
pub struct btMinkowskiPenetrationDepthSolver {
    pub _base: btConvexPenetrationDepthSolver,
}
extern "C" {
    #[link_name = "\u{1}?getPenetrationDirections@btMinkowskiPenetrationDepthSolver@@KAPEAVbtVector3@@XZ"]
    pub fn btMinkowskiPenetrationDepthSolver_getPenetrationDirections() -> *mut btVector3;
}
impl btMinkowskiPenetrationDepthSolver {
    #[inline]
    pub unsafe fn getPenetrationDirections() -> *mut btVector3 {
        btMinkowskiPenetrationDepthSolver_getPenetrationDirections()
    }
}
extern "C" {
    #[link_name = "\u{1}?calcPenDepth@btMinkowskiPenetrationDepthSolver@@UEAA_NAEAVbtVoronoiSimplexSolver@@PEBVbtConvexShape@@1AEBVbtTransform@@2AEAVbtVector3@@33PEAVbtIDebugDraw@@@Z"]
    pub fn btMinkowskiPenetrationDepthSolver_calcPenDepth(
        this: *mut ::std::os::raw::c_void,
        simplexSolver: *mut btVoronoiSimplexSolver,
        convexA: *const btConvexShape,
        convexB: *const btConvexShape,
        transA: *const btTransform,
        transB: *const btTransform,
        v: *mut btVector3,
        pa: *mut btVector3,
        pb: *mut btVector3,
        debugDraw: *mut btIDebugDraw,
    ) -> bool;
}
#[repr(C)]
pub struct btMprCollisionDescription__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btMprCollisionDescription {
    pub vtable_: *const btMprCollisionDescription__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_firstDir: btVector3,
    pub m_maxGjkIterations: ::std::os::raw::c_int,
    pub m_maximumDistanceSquared: btScalar,
    pub m_gjkRelError2: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMprDistanceInfo {
    pub m_pointOnA: btVector3,
    pub m_pointOnB: btVector3,
    pub m_normalBtoA: btVector3,
    pub m_distance: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _btMprSupport_t {
    /// !< Support point in minkowski sum
    pub v: btVector3,
    /// !< Support point in obj1
    pub v1: btVector3,
    /// !< Support point in obj2
    pub v2: btVector3,
}
pub type btMprSupport_t = _btMprSupport_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _btMprSimplex_t {
    pub ps: [btMprSupport_t; 4usize],
    /// !< index of last added point
    pub last: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
pub type btMprSimplex_t = _btMprSimplex_t;
#[repr(C)]
#[derive(Debug)]
pub struct btPointCollector {
    pub _base: btDiscreteCollisionDetectorInterface_Result,
    pub __bindgen_padding_0: u64,
    pub m_normalOnBInWorld: btVector3,
    pub m_pointInWorld: btVector3,
    pub m_distance: btScalar,
    pub m_hasResult: bool,
    pub __bindgen_padding_1: [u8; 7usize],
}
/// btSubsimplexConvexCast implements Gino van den Bergens' paper
/// "Ray Casting against bteral Convex Objects with Application to Continuous Collision Detection"
/// GJK based Ray Cast, optimized version
/// Objects should not start in overlap, otherwise results are not defined.
#[repr(C)]
#[derive(Debug)]
pub struct btSubsimplexConvexCast {
    pub _base: btConvexCast,
    pub m_simplexSolver: *mut btVoronoiSimplexSolver,
    pub m_convexA: *const btConvexShape,
    pub m_convexB: *const btConvexShape,
}
extern "C" {
    #[link_name = "\u{1}??0btSubsimplexConvexCast@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@@Z"]
    pub fn btSubsimplexConvexCast_btSubsimplexConvexCast(
        this: *mut btSubsimplexConvexCast,
        shapeA: *const btConvexShape,
        shapeB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
    );
}
impl btSubsimplexConvexCast {
    #[inline]
    pub unsafe fn new(
        shapeA: *const btConvexShape,
        shapeB: *const btConvexShape,
        simplexSolver: *mut btVoronoiSimplexSolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSubsimplexConvexCast_btSubsimplexConvexCast(
            &mut __bindgen_tmp,
            shapeA,
            shapeB,
            simplexSolver,
        );
        __bindgen_tmp
    }
}
extern "C" {
    /// SimsimplexConvexCast calculateTimeOfImpact calculates the time of impact+normal for the linear cast (sweep) between two moving objects.
    /// ///Precondition is that objects should not penetration/overlap at the start from the interval. Overlap can be tested using btGjkPairDetector.
    #[link_name = "\u{1}?calcTimeOfImpact@btSubsimplexConvexCast@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z"]
    pub fn btSubsimplexConvexCast_calcTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        fromA: *const btTransform,
        toA: *const btTransform,
        fromB: *const btTransform,
        toB: *const btTransform,
        result: *mut btConvexCast_CastResult,
    ) -> bool;
}
pub const btRigidBodyFlags_BT_DISABLE_WORLD_GRAVITY: btRigidBodyFlags = 1;
/// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
/// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
/// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT: btRigidBodyFlags = 2;
/// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
/// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
/// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD: btRigidBodyFlags = 4;
/// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
/// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
/// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY: btRigidBodyFlags = 8;
/// BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
/// ///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
/// ///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
pub const btRigidBodyFlags_BT_ENABLE_GYROPSCOPIC_FORCE: btRigidBodyFlags = 8;
pub type btRigidBodyFlags = i32;
/// The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
/// It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
/// There are 3 types of rigid bodies:
/// - A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
/// - B) Fixed objects with zero mass. They are not moving (basically collision objects)
/// - C) Kinematic objects, which are objects without mass, but the user can move them. There is on-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
/// Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
/// Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
#[repr(C)]
#[derive(Debug)]
pub struct btRigidBody {
    pub _base: btCollisionObject,
    pub m_invInertiaTensorWorld: btMatrix3x3,
    pub m_linearVelocity: btVector3,
    pub m_angularVelocity: btVector3,
    pub m_inverseMass: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_linearFactor: btVector3,
    pub m_gravity: btVector3,
    pub m_gravity_acceleration: btVector3,
    pub m_invInertiaLocal: btVector3,
    pub m_totalForce: btVector3,
    pub m_totalTorque: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_optionalMotionState: *mut btMotionState,
    pub m_constraintRefs: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_rigidbodyFlags: ::std::os::raw::c_int,
    pub m_debugBodyId: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u64,
    pub m_deltaLinearVelocity: btVector3,
    pub m_deltaAngularVelocity: btVector3,
    pub m_angularFactor: btVector3,
    pub m_invMass: btVector3,
    pub m_pushVelocity: btVector3,
    pub m_turnVelocity: btVector3,
    pub m_contactSolverType: ::std::os::raw::c_int,
    pub m_frictionSolverType: ::std::os::raw::c_int,
    pub __bindgen_padding_2: u64,
}
/// The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
/// ///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
/// ///You can use the motion state to synchronize the world transform between physics and graphics objects.
/// ///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
/// ///m_startWorldTransform is only used when you don't provide a motion state.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBody_btRigidBodyConstructionInfo {
    pub m_mass: btScalar,
    /// When a motionState is provided, the rigid body will initialize its world transform from the motion state
    /// ///In this case, m_startWorldTransform is ignored.
    pub m_motionState: *mut btMotionState,
    pub m_startWorldTransform: btTransform,
    pub m_collisionShape: *mut btCollisionShape,
    pub __bindgen_padding_0: u64,
    pub m_localInertia: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    /// best simulation results when friction is non-zero
    pub m_friction: btScalar,
    /// the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
    /// ///See Bullet/Demos/RollingFrictionDemo for usage
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    /// best simulation results using zero restitution.
    pub m_restitution: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    /// setupRigidBody is only used internally by the constructor
    #[link_name = "\u{1}?setupRigidBody@btRigidBody@@IEAAXAEBUbtRigidBodyConstructionInfo@1@@Z"]
    pub fn btRigidBody_setupRigidBody(
        this: *mut btRigidBody,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?proceedToTransform@btRigidBody@@QEAAXAEBVbtTransform@@@Z"]
    pub fn btRigidBody_proceedToTransform(this: *mut btRigidBody, newTrans: *const btTransform);
}
extern "C" {
    /// continuous collision detection needs prediction
    #[link_name = "\u{1}?predictIntegratedTransform@btRigidBody@@QEAAXNAEAVbtTransform@@@Z"]
    pub fn btRigidBody_predictIntegratedTransform(
        this: *mut btRigidBody,
        step: btScalar,
        predictedTransform: *mut btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?saveKinematicState@btRigidBody@@QEAAXN@Z"]
    pub fn btRigidBody_saveKinematicState(this: *mut btRigidBody, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?applyGravity@btRigidBody@@QEAAXXZ"]
    pub fn btRigidBody_applyGravity(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}?setGravity@btRigidBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btRigidBody_setGravity(this: *mut btRigidBody, acceleration: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?setDamping@btRigidBody@@QEAAXNN@Z"]
    pub fn btRigidBody_setDamping(
        this: *mut btRigidBody,
        lin_damping: btScalar,
        ang_damping: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?applyDamping@btRigidBody@@QEAAXN@Z"]
    pub fn btRigidBody_applyDamping(this: *mut btRigidBody, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setMassProps@btRigidBody@@QEAAXNAEBVbtVector3@@@Z"]
    pub fn btRigidBody_setMassProps(
        this: *mut btRigidBody,
        mass: btScalar,
        inertia: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?integrateVelocities@btRigidBody@@QEAAXN@Z"]
    pub fn btRigidBody_integrateVelocities(this: *mut btRigidBody, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setCenterOfMassTransform@btRigidBody@@QEAAXAEBVbtTransform@@@Z"]
    pub fn btRigidBody_setCenterOfMassTransform(this: *mut btRigidBody, xform: *const btTransform);
}
extern "C" {
    #[link_name = "\u{1}?updateInertiaTensor@btRigidBody@@QEAAXXZ"]
    pub fn btRigidBody_updateInertiaTensor(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}?getOrientation@btRigidBody@@QEBA?AVbtQuaternion@@XZ"]
    pub fn btRigidBody_getOrientation(this: *const btRigidBody) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btRigidBody@@QEBAXAEAVbtVector3@@0@Z"]
    pub fn btRigidBody_getAabb(
        this: *const btRigidBody,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?addConstraintRef@btRigidBody@@QEAAXPEAVbtTypedConstraint@@@Z"]
    pub fn btRigidBody_addConstraintRef(this: *mut btRigidBody, c: *mut btTypedConstraint);
}
extern "C" {
    #[link_name = "\u{1}?removeConstraintRef@btRigidBody@@QEAAXPEAVbtTypedConstraint@@@Z"]
    pub fn btRigidBody_removeConstraintRef(this: *mut btRigidBody, c: *mut btTypedConstraint);
}
extern "C" {
    /// perform implicit force computation in world space
    #[link_name = "\u{1}?computeGyroscopicImpulseImplicit_World@btRigidBody@@QEBA?AVbtVector3@@N@Z"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_World(
        this: *const btRigidBody,
        dt: btScalar,
    ) -> btVector3;
}
extern "C" {
    /// perform implicit force computation in body space (inertial frame)
    #[link_name = "\u{1}?computeGyroscopicImpulseImplicit_Body@btRigidBody@@QEBA?AVbtVector3@@N@Z"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_Body(
        this: *const btRigidBody,
        step: btScalar,
    ) -> btVector3;
}
extern "C" {
    /// explicit version is best avoided, it gains energy
    #[link_name = "\u{1}?computeGyroscopicForceExplicit@btRigidBody@@QEBA?AVbtVector3@@N@Z"]
    pub fn btRigidBody_computeGyroscopicForceExplicit(
        this: *const btRigidBody,
        maxGyroscopicForce: btScalar,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getLocalInertia@btRigidBody@@QEBA?AVbtVector3@@XZ"]
    pub fn btRigidBody_getLocalInertia(this: *const btRigidBody) -> btVector3;
}
extern "C" {
    /// btRigidBody constructor using construction info
    #[link_name = "\u{1}??0btRigidBody@@QEAA@AEBUbtRigidBodyConstructionInfo@0@@Z"]
    pub fn btRigidBody_btRigidBody(
        this: *mut btRigidBody,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    );
}
extern "C" {
    /// btRigidBody constructor for backwards compatibility.
    /// ///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
    #[link_name = "\u{1}??0btRigidBody@@QEAA@NPEAVbtMotionState@@PEAVbtCollisionShape@@AEBVbtVector3@@@Z"]
    pub fn btRigidBody_btRigidBody1(
        this: *mut btRigidBody,
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    );
}
impl btRigidBody {
    #[inline]
    pub unsafe fn setupRigidBody(
        &mut self,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    ) {
        btRigidBody_setupRigidBody(self, constructionInfo)
    }
    #[inline]
    pub unsafe fn proceedToTransform(&mut self, newTrans: *const btTransform) {
        btRigidBody_proceedToTransform(self, newTrans)
    }
    #[inline]
    pub unsafe fn predictIntegratedTransform(
        &mut self,
        step: btScalar,
        predictedTransform: *mut btTransform,
    ) {
        btRigidBody_predictIntegratedTransform(self, step, predictedTransform)
    }
    #[inline]
    pub unsafe fn saveKinematicState(&mut self, step: btScalar) {
        btRigidBody_saveKinematicState(self, step)
    }
    #[inline]
    pub unsafe fn applyGravity(&mut self) {
        btRigidBody_applyGravity(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, acceleration: *const btVector3) {
        btRigidBody_setGravity(self, acceleration)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, lin_damping: btScalar, ang_damping: btScalar) {
        btRigidBody_setDamping(self, lin_damping, ang_damping)
    }
    #[inline]
    pub unsafe fn applyDamping(&mut self, timeStep: btScalar) {
        btRigidBody_applyDamping(self, timeStep)
    }
    #[inline]
    pub unsafe fn setMassProps(&mut self, mass: btScalar, inertia: *const btVector3) {
        btRigidBody_setMassProps(self, mass, inertia)
    }
    #[inline]
    pub unsafe fn integrateVelocities(&mut self, step: btScalar) {
        btRigidBody_integrateVelocities(self, step)
    }
    #[inline]
    pub unsafe fn setCenterOfMassTransform(&mut self, xform: *const btTransform) {
        btRigidBody_setCenterOfMassTransform(self, xform)
    }
    #[inline]
    pub unsafe fn updateInertiaTensor(&mut self) {
        btRigidBody_updateInertiaTensor(self)
    }
    #[inline]
    pub unsafe fn getOrientation(&self) -> btQuaternion {
        btRigidBody_getOrientation(self)
    }
    #[inline]
    pub unsafe fn getAabb(&self, aabbMin: *mut btVector3, aabbMax: *mut btVector3) {
        btRigidBody_getAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn addConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_addConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn removeConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_removeConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_World(&self, dt: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_World(self, dt)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_Body(&self, step: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_Body(self, step)
    }
    #[inline]
    pub unsafe fn computeGyroscopicForceExplicit(&self, maxGyroscopicForce: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicForceExplicit(self, maxGyroscopicForce)
    }
    #[inline]
    pub unsafe fn getLocalInertia(&self) -> btVector3 {
        btRigidBody_getLocalInertia(self)
    }
    #[inline]
    pub unsafe fn new(constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody(&mut __bindgen_tmp, constructionInfo);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody1(
            &mut __bindgen_tmp,
            mass,
            motionState,
            collisionShape,
            localInertia,
        );
        __bindgen_tmp
    }
}
extern "C" {
    ///
    #[link_name = "\u{1}?calculateSerializeBufferSize@btRigidBody@@UEBAHXZ"]
    pub fn btRigidBody_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btRigidBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btRigidBody_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?serializeSingleObject@btRigidBody@@UEBAXPEAVbtSerializer@@@Z"]
    pub fn btRigidBody_serializeSingleObject(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBodyFloatData {
    pub m_collisionObjectData: btCollisionObjectFloatData,
    pub m_invInertiaTensorWorld: btMatrix3x3FloatData,
    pub m_linearVelocity: btVector3FloatData,
    pub m_angularVelocity: btVector3FloatData,
    pub m_angularFactor: btVector3FloatData,
    pub m_linearFactor: btVector3FloatData,
    pub m_gravity: btVector3FloatData,
    pub m_gravity_acceleration: btVector3FloatData,
    pub m_invInertiaLocal: btVector3FloatData,
    pub m_totalForce: btVector3FloatData,
    pub m_totalTorque: btVector3FloatData,
    pub m_inverseMass: f32,
    pub m_linearDamping: f32,
    pub m_angularDamping: f32,
    pub m_additionalDampingFactor: f32,
    pub m_additionalLinearDampingThresholdSqr: f32,
    pub m_additionalAngularDampingThresholdSqr: f32,
    pub m_additionalAngularDampingFactor: f32,
    pub m_linearSleepingThreshold: f32,
    pub m_angularSleepingThreshold: f32,
    pub m_additionalDamping: ::std::os::raw::c_int,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBodyDoubleData {
    pub m_collisionObjectData: btCollisionObjectDoubleData,
    pub m_invInertiaTensorWorld: btMatrix3x3DoubleData,
    pub m_linearVelocity: btVector3DoubleData,
    pub m_angularVelocity: btVector3DoubleData,
    pub m_angularFactor: btVector3DoubleData,
    pub m_linearFactor: btVector3DoubleData,
    pub m_gravity: btVector3DoubleData,
    pub m_gravity_acceleration: btVector3DoubleData,
    pub m_invInertiaLocal: btVector3DoubleData,
    pub m_totalForce: btVector3DoubleData,
    pub m_totalTorque: btVector3DoubleData,
    pub m_inverseMass: f64,
    pub m_linearDamping: f64,
    pub m_angularDamping: f64,
    pub m_additionalDampingFactor: f64,
    pub m_additionalLinearDampingThresholdSqr: f64,
    pub m_additionalAngularDampingThresholdSqr: f64,
    pub m_additionalAngularDampingFactor: f64,
    pub m_linearSleepingThreshold: f64,
    pub m_angularSleepingThreshold: f64,
    pub m_additionalDamping: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
pub struct btActionInterface__bindgen_vtable(::std::os::raw::c_void);
/// Basic interface to allow actions such as vehicles and characters to be updated inside a btDynamicsWorld
#[repr(C)]
#[derive(Debug)]
pub struct btActionInterface {
    pub vtable_: *const btActionInterface__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}?getFixedBody@btActionInterface@@KAAEAVbtRigidBody@@XZ"]
    pub fn btActionInterface_getFixedBody() -> *mut btRigidBody;
}
impl btActionInterface {
    #[inline]
    pub unsafe fn getFixedBody() -> *mut btRigidBody {
        btActionInterface_getFixedBody()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btCharacterControllerInterface {
    pub _base: btActionInterface,
}
/// btKinematicCharacterController is an object that supports a sliding motion in a world.
/// It uses a ghost object and convex sweep test to test for upcoming collisions. This is combined with discrete collision detection to recover from penetrations.
/// Interaction between btKinematicCharacterController and dynamic rigid bodies needs to be explicity implemented by the user.
#[repr(C)]
#[derive(Debug)]
pub struct btKinematicCharacterController {
    pub _base: btCharacterControllerInterface,
    pub m_halfHeight: btScalar,
    pub m_ghostObject: *mut btPairCachingGhostObject,
    pub m_convexShape: *mut btConvexShape,
    pub m_maxPenetrationDepth: btScalar,
    pub m_verticalVelocity: btScalar,
    pub m_verticalOffset: btScalar,
    pub m_fallSpeed: btScalar,
    pub m_jumpSpeed: btScalar,
    pub m_SetjumpSpeed: btScalar,
    pub m_maxJumpHeight: btScalar,
    pub m_maxSlopeRadians: btScalar,
    pub m_maxSlopeCosine: btScalar,
    pub m_gravity: btScalar,
    pub m_turnAngle: btScalar,
    pub m_stepHeight: btScalar,
    pub m_addedMargin: btScalar,
    pub __bindgen_padding_0: u64,
    /// this is the desired walk direction, set by the user
    pub m_walkDirection: btVector3,
    pub m_normalizedDirection: btVector3,
    pub m_AngVel: btVector3,
    pub m_jumpPosition: btVector3,
    pub m_currentPosition: btVector3,
    pub m_currentStepOffset: btScalar,
    pub __bindgen_padding_1: u64,
    pub m_targetPosition: btVector3,
    pub m_currentOrientation: btQuaternion,
    pub m_targetOrientation: btQuaternion,
    /// keep track of the contact manifolds
    pub m_manifoldArray: btManifoldArray,
    pub m_touchingContact: bool,
    pub __bindgen_padding_2: u64,
    pub m_touchingNormal: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    pub m_wasOnGround: bool,
    pub m_wasJumping: bool,
    pub m_useGhostObjectSweepTest: bool,
    pub m_useWalkDirection: bool,
    pub m_velocityTimeInterval: btScalar,
    pub m_up: btVector3,
    pub m_jumpAxis: btVector3,
    pub m_interpolateUp: bool,
    pub full_drop: bool,
    pub bounce_fix: bool,
    pub __bindgen_padding_3: [u8; 13usize],
}
extern "C" {
    #[link_name = "\u{1}?getUpAxisDirections@btKinematicCharacterController@@KAPEAVbtVector3@@XZ"]
    pub fn btKinematicCharacterController_getUpAxisDirections() -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}?computeReflectionDirection@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z"]
    pub fn btKinematicCharacterController_computeReflectionDirection(
        this: *mut btKinematicCharacterController,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?parallelComponent@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z"]
    pub fn btKinematicCharacterController_parallelComponent(
        this: *mut btKinematicCharacterController,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?perpindicularComponent@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z"]
    pub fn btKinematicCharacterController_perpindicularComponent(
        this: *mut btKinematicCharacterController,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?recoverFromPenetration@btKinematicCharacterController@@IEAA_NPEAVbtCollisionWorld@@@Z"]
    pub fn btKinematicCharacterController_recoverFromPenetration(
        this: *mut btKinematicCharacterController,
        collisionWorld: *mut btCollisionWorld,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?stepUp@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@@Z"]
    pub fn btKinematicCharacterController_stepUp(
        this: *mut btKinematicCharacterController,
        collisionWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateTargetPositionBasedOnCollision@btKinematicCharacterController@@IEAAXAEBVbtVector3@@NN@Z"]
    pub fn btKinematicCharacterController_updateTargetPositionBasedOnCollision(
        this: *mut btKinematicCharacterController,
        hit_normal: *const btVector3,
        tangentMag: btScalar,
        normalMag: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?stepForwardAndStrafe@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@AEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_stepForwardAndStrafe(
        this: *mut btKinematicCharacterController,
        collisionWorld: *mut btCollisionWorld,
        walkMove: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?stepDown@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@N@Z"]
    pub fn btKinematicCharacterController_stepDown(
        this: *mut btKinematicCharacterController,
        collisionWorld: *mut btCollisionWorld,
        dt: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setUpVector@btKinematicCharacterController@@IEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setUpVector(
        this: *mut btKinematicCharacterController,
        up: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getRotation@btKinematicCharacterController@@IEBA?AVbtQuaternion@@AEAVbtVector3@@0@Z"]
    pub fn btKinematicCharacterController_getRotation(
        this: *const btKinematicCharacterController,
        v0: *mut btVector3,
        v1: *mut btVector3,
    ) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}?setUp@btKinematicCharacterController@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setUp(
        this: *mut btKinematicCharacterController,
        up: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStepHeight@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setStepHeight(
        this: *mut btKinematicCharacterController,
        h: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFallSpeed@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setFallSpeed(
        this: *mut btKinematicCharacterController,
        fallSpeed: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setJumpSpeed@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setJumpSpeed(
        this: *mut btKinematicCharacterController,
        jumpSpeed: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMaxJumpHeight@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setMaxJumpHeight(
        this: *mut btKinematicCharacterController,
        maxJumpHeight: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setGravity@btKinematicCharacterController@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setGravity(
        this: *mut btKinematicCharacterController,
        gravity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getGravity@btKinematicCharacterController@@QEBA?AVbtVector3@@XZ"]
    pub fn btKinematicCharacterController_getGravity(
        this: *const btKinematicCharacterController,
    ) -> btVector3;
}
extern "C" {
    /// The max slope determines the maximum angle that the controller can walk up.
    /// /// The slope angle is measured in radians.
    #[link_name = "\u{1}?setMaxSlope@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setMaxSlope(
        this: *mut btKinematicCharacterController,
        slopeRadians: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?getMaxSlope@btKinematicCharacterController@@QEBANXZ"]
    pub fn btKinematicCharacterController_getMaxSlope(
        this: *const btKinematicCharacterController,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setMaxPenetrationDepth@btKinematicCharacterController@@QEAAXN@Z"]
    pub fn btKinematicCharacterController_setMaxPenetrationDepth(
        this: *mut btKinematicCharacterController,
        d: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?getMaxPenetrationDepth@btKinematicCharacterController@@QEBANXZ"]
    pub fn btKinematicCharacterController_getMaxPenetrationDepth(
        this: *const btKinematicCharacterController,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getGhostObject@btKinematicCharacterController@@QEAAPEAVbtPairCachingGhostObject@@XZ"]
    pub fn btKinematicCharacterController_getGhostObject(
        this: *mut btKinematicCharacterController,
    ) -> *mut btPairCachingGhostObject;
}
extern "C" {
    #[link_name = "\u{1}??0btKinematicCharacterController@@QEAA@PEAVbtPairCachingGhostObject@@PEAVbtConvexShape@@NAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_btKinematicCharacterController(
        this: *mut btKinematicCharacterController,
        ghostObject: *mut btPairCachingGhostObject,
        convexShape: *mut btConvexShape,
        stepHeight: btScalar,
        up: *const btVector3,
    );
}
impl btKinematicCharacterController {
    #[inline]
    pub unsafe fn getUpAxisDirections() -> *mut btVector3 {
        btKinematicCharacterController_getUpAxisDirections()
    }
    #[inline]
    pub unsafe fn computeReflectionDirection(
        &mut self,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3 {
        btKinematicCharacterController_computeReflectionDirection(self, direction, normal)
    }
    #[inline]
    pub unsafe fn parallelComponent(
        &mut self,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3 {
        btKinematicCharacterController_parallelComponent(self, direction, normal)
    }
    #[inline]
    pub unsafe fn perpindicularComponent(
        &mut self,
        direction: *const btVector3,
        normal: *const btVector3,
    ) -> btVector3 {
        btKinematicCharacterController_perpindicularComponent(self, direction, normal)
    }
    #[inline]
    pub unsafe fn recoverFromPenetration(&mut self, collisionWorld: *mut btCollisionWorld) -> bool {
        btKinematicCharacterController_recoverFromPenetration(self, collisionWorld)
    }
    #[inline]
    pub unsafe fn stepUp(&mut self, collisionWorld: *mut btCollisionWorld) {
        btKinematicCharacterController_stepUp(self, collisionWorld)
    }
    #[inline]
    pub unsafe fn updateTargetPositionBasedOnCollision(
        &mut self,
        hit_normal: *const btVector3,
        tangentMag: btScalar,
        normalMag: btScalar,
    ) {
        btKinematicCharacterController_updateTargetPositionBasedOnCollision(
            self, hit_normal, tangentMag, normalMag,
        )
    }
    #[inline]
    pub unsafe fn stepForwardAndStrafe(
        &mut self,
        collisionWorld: *mut btCollisionWorld,
        walkMove: *const btVector3,
    ) {
        btKinematicCharacterController_stepForwardAndStrafe(self, collisionWorld, walkMove)
    }
    #[inline]
    pub unsafe fn stepDown(&mut self, collisionWorld: *mut btCollisionWorld, dt: btScalar) {
        btKinematicCharacterController_stepDown(self, collisionWorld, dt)
    }
    #[inline]
    pub unsafe fn setUpVector(&mut self, up: *const btVector3) {
        btKinematicCharacterController_setUpVector(self, up)
    }
    #[inline]
    pub unsafe fn getRotation(&self, v0: *mut btVector3, v1: *mut btVector3) -> btQuaternion {
        btKinematicCharacterController_getRotation(self, v0, v1)
    }
    #[inline]
    pub unsafe fn setUp(&mut self, up: *const btVector3) {
        btKinematicCharacterController_setUp(self, up)
    }
    #[inline]
    pub unsafe fn setStepHeight(&mut self, h: btScalar) {
        btKinematicCharacterController_setStepHeight(self, h)
    }
    #[inline]
    pub unsafe fn setFallSpeed(&mut self, fallSpeed: btScalar) {
        btKinematicCharacterController_setFallSpeed(self, fallSpeed)
    }
    #[inline]
    pub unsafe fn setJumpSpeed(&mut self, jumpSpeed: btScalar) {
        btKinematicCharacterController_setJumpSpeed(self, jumpSpeed)
    }
    #[inline]
    pub unsafe fn setMaxJumpHeight(&mut self, maxJumpHeight: btScalar) {
        btKinematicCharacterController_setMaxJumpHeight(self, maxJumpHeight)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, gravity: *const btVector3) {
        btKinematicCharacterController_setGravity(self, gravity)
    }
    #[inline]
    pub unsafe fn getGravity(&self) -> btVector3 {
        btKinematicCharacterController_getGravity(self)
    }
    #[inline]
    pub unsafe fn setMaxSlope(&mut self, slopeRadians: btScalar) {
        btKinematicCharacterController_setMaxSlope(self, slopeRadians)
    }
    #[inline]
    pub unsafe fn getMaxSlope(&self) -> btScalar {
        btKinematicCharacterController_getMaxSlope(self)
    }
    #[inline]
    pub unsafe fn setMaxPenetrationDepth(&mut self, d: btScalar) {
        btKinematicCharacterController_setMaxPenetrationDepth(self, d)
    }
    #[inline]
    pub unsafe fn getMaxPenetrationDepth(&self) -> btScalar {
        btKinematicCharacterController_getMaxPenetrationDepth(self)
    }
    #[inline]
    pub unsafe fn getGhostObject(&mut self) -> *mut btPairCachingGhostObject {
        btKinematicCharacterController_getGhostObject(self)
    }
    #[inline]
    pub unsafe fn new(
        ghostObject: *mut btPairCachingGhostObject,
        convexShape: *mut btConvexShape,
        stepHeight: btScalar,
        up: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btKinematicCharacterController_btKinematicCharacterController(
            &mut __bindgen_tmp,
            ghostObject,
            convexShape,
            stepHeight,
            up,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?needsCollision@btKinematicCharacterController@@MEAA_NPEBVbtCollisionObject@@0@Z"]
    pub fn btKinematicCharacterController_needsCollision(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??_DbtKinematicCharacterController@@QEAAXXZ"]
    pub fn btKinematicCharacterController_btKinematicCharacterController_destructor(
        this: *mut btKinematicCharacterController,
    );
}
extern "C" {
    /// btActionInterface interface
    #[link_name = "\u{1}?debugDraw@btKinematicCharacterController@@UEAAXPEAVbtIDebugDraw@@@Z"]
    pub fn btKinematicCharacterController_debugDraw(
        this: *mut ::std::os::raw::c_void,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    /// This should probably be called setPositionIncrementPerSimulatorStep.
    /// /// This is neither a direction nor a velocity, but the amount to
    /// ///	increment the position each simulation iteration, regardless
    /// ///	of dt.
    /// /// This call will reset any velocity set by setVelocityForTimeInterval().
    #[link_name = "\u{1}?setWalkDirection@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setWalkDirection(
        this: *mut ::std::os::raw::c_void,
        walkDirection: *const btVector3,
    );
}
extern "C" {
    /// Caller provides a velocity with which the character should move for
    /// ///	the given time period.  After the time period, velocity is reset
    /// ///	to zero.
    /// /// This call will reset any walk direction set by setWalkDirection().
    /// /// Negative time intervals will result in no motion.
    #[link_name = "\u{1}?setVelocityForTimeInterval@btKinematicCharacterController@@UEAAXAEBVbtVector3@@N@Z"]
    pub fn btKinematicCharacterController_setVelocityForTimeInterval(
        this: *mut ::std::os::raw::c_void,
        velocity: *const btVector3,
        timeInterval: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAngularVelocity@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setAngularVelocity(
        this: *mut ::std::os::raw::c_void,
        velocity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAngularVelocity@btKinematicCharacterController@@UEBAAEBVbtVector3@@XZ"]
    pub fn btKinematicCharacterController_getAngularVelocity(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?setLinearVelocity@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_setLinearVelocity(
        this: *mut ::std::os::raw::c_void,
        velocity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLinearVelocity@btKinematicCharacterController@@UEBA?AVbtVector3@@XZ"]
    pub fn btKinematicCharacterController_getLinearVelocity(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?reset@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@@Z"]
    pub fn btKinematicCharacterController_reset(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?warp@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_warp(
        this: *mut ::std::os::raw::c_void,
        origin: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?preStep@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@@Z"]
    pub fn btKinematicCharacterController_preStep(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?playerStep@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@N@Z"]
    pub fn btKinematicCharacterController_playerStep(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
        dt: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?canJump@btKinematicCharacterController@@UEBA_NXZ"]
    pub fn btKinematicCharacterController_canJump(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?jump@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btKinematicCharacterController_jump(
        this: *mut ::std::os::raw::c_void,
        v: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?onGround@btKinematicCharacterController@@UEBA_NXZ"]
    pub fn btKinematicCharacterController_onGround(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setUpInterpolate@btKinematicCharacterController@@UEAAX_N@Z"]
    pub fn btKinematicCharacterController_setUpInterpolate(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btJacobianEntry {
    pub m_linearJointAxis: btVector3,
    pub m_aJ: btVector3,
    pub m_bJ: btVector3,
    pub m_0MinvJt: btVector3,
    pub m_1MinvJt: btVector3,
    pub m_Adiag: btScalar,
    pub __bindgen_padding_0: u64,
}
/// The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSolverBody {
    pub m_worldTransform: btTransform,
    pub m_deltaLinearVelocity: btVector3,
    pub m_deltaAngularVelocity: btVector3,
    pub m_angularFactor: btVector3,
    pub m_linearFactor: btVector3,
    pub m_invMass: btVector3,
    pub m_pushVelocity: btVector3,
    pub m_turnVelocity: btVector3,
    pub m_linearVelocity: btVector3,
    pub m_angularVelocity: btVector3,
    pub m_externalForceImpulse: btVector3,
    pub m_externalTorqueImpulse: btVector3,
    pub m_originalBody: *mut btRigidBody,
    pub __bindgen_padding_0: u64,
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btSolverConstraint {
    pub m_relpos1CrossNormal: btVector3,
    pub m_contactNormal1: btVector3,
    pub m_relpos2CrossNormal: btVector3,
    pub m_contactNormal2: btVector3,
    pub m_angularComponentA: btVector3,
    pub m_angularComponentB: btVector3,
    pub m_appliedPushImpulse: btScalar,
    pub m_appliedImpulse: btScalar,
    pub m_friction: btScalar,
    pub m_jacDiagABInv: btScalar,
    pub m_rhs: btScalar,
    pub m_cfm: btScalar,
    pub m_lowerLimit: btScalar,
    pub m_upperLimit: btScalar,
    pub m_rhsPenetration: btScalar,
    pub __bindgen_anon_1: btSolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btSolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_unusedPadding4: btScalar,
    pub m_numRowsForNonContactConstraint: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_CONTACT_1D:
    btSolverConstraint_btSolverConstraintType = 0;
pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_FRICTION_1D:
    btSolverConstraint_btSolverConstraintType = 1;
pub type btSolverConstraint_btSolverConstraintType = i32;
pub type btConstraintArray = btAlignedObjectArray<btSolverConstraint>;
pub const btTypedConstraintType_POINT2POINT_CONSTRAINT_TYPE: btTypedConstraintType = 3;
pub const btTypedConstraintType_HINGE_CONSTRAINT_TYPE: btTypedConstraintType = 4;
pub const btTypedConstraintType_CONETWIST_CONSTRAINT_TYPE: btTypedConstraintType = 5;
pub const btTypedConstraintType_D6_CONSTRAINT_TYPE: btTypedConstraintType = 6;
pub const btTypedConstraintType_SLIDER_CONSTRAINT_TYPE: btTypedConstraintType = 7;
pub const btTypedConstraintType_CONTACT_CONSTRAINT_TYPE: btTypedConstraintType = 8;
pub const btTypedConstraintType_D6_SPRING_CONSTRAINT_TYPE: btTypedConstraintType = 9;
pub const btTypedConstraintType_GEAR_CONSTRAINT_TYPE: btTypedConstraintType = 10;
pub const btTypedConstraintType_FIXED_CONSTRAINT_TYPE: btTypedConstraintType = 11;
pub const btTypedConstraintType_D6_SPRING_2_CONSTRAINT_TYPE: btTypedConstraintType = 12;
pub const btTypedConstraintType_MAX_CONSTRAINT_TYPE: btTypedConstraintType = 13;
pub type btTypedConstraintType = i32;
pub const btConstraintParams_BT_CONSTRAINT_ERP: btConstraintParams = 1;
pub const btConstraintParams_BT_CONSTRAINT_STOP_ERP: btConstraintParams = 2;
pub const btConstraintParams_BT_CONSTRAINT_CFM: btConstraintParams = 3;
pub const btConstraintParams_BT_CONSTRAINT_STOP_CFM: btConstraintParams = 4;
pub type btConstraintParams = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btJointFeedback {
    pub m_appliedForceBodyA: btVector3,
    pub m_appliedTorqueBodyA: btVector3,
    pub m_appliedForceBodyB: btVector3,
    pub m_appliedTorqueBodyB: btVector3,
}
#[repr(C)]
pub struct btTypedConstraint__bindgen_vtable(::std::os::raw::c_void);
/// TypedConstraint is the baseclass for Bullet constraints and vehicles
#[repr(C)]
pub struct btTypedConstraint {
    pub vtable_: *const btTypedConstraint__bindgen_vtable,
    pub _base: btTypedObject,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub __bindgen_anon_1: btTypedConstraint__bindgen_ty_1,
    pub m_breakingImpulseThreshold: btScalar,
    pub m_isEnabled: bool,
    pub m_needsFeedback: bool,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_rbA: *mut btRigidBody,
    pub m_rbB: *mut btRigidBody,
    pub m_appliedImpulse: btScalar,
    pub m_dbgDrawSize: btScalar,
    pub m_jointFeedback: *mut btJointFeedback,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btTypedConstraint__bindgen_ty_1 {
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_userConstraintPtr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraint_btConstraintInfo1 {
    pub m_numConstraintRows: ::std::os::raw::c_int,
    pub nub: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraint_btConstraintInfo2 {
    pub fps: btScalar,
    pub erp: btScalar,
    pub m_J1linearAxis: *mut btScalar,
    pub m_J1angularAxis: *mut btScalar,
    pub m_J2linearAxis: *mut btScalar,
    pub m_J2angularAxis: *mut btScalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut btScalar,
    pub cfm: *mut btScalar,
    pub m_lowerLimit: *mut btScalar,
    pub m_upperLimit: *mut btScalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: btScalar,
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getMotorFactor@btTypedConstraint@@IEAANNNNNN@Z"]
    pub fn btTypedConstraint_getMotorFactor(
        this: *mut btTypedConstraint,
        pos: btScalar,
        lowLim: btScalar,
        uppLim: btScalar,
        vel: btScalar,
        timeFact: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getFixedBody@btTypedConstraint@@SAAEAVbtRigidBody@@XZ"]
    pub fn btTypedConstraint_getFixedBody() -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}??0btTypedConstraint@@QEAA@W4btTypedConstraintType@@AEAVbtRigidBody@@@Z"]
    pub fn btTypedConstraint_btTypedConstraint(
        this: *mut btTypedConstraint,
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btTypedConstraint@@QEAA@W4btTypedConstraintType@@AEAVbtRigidBody@@1@Z"]
    pub fn btTypedConstraint_btTypedConstraint1(
        this: *mut btTypedConstraint,
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    );
}
impl btTypedConstraint {
    #[inline]
    pub unsafe fn getMotorFactor(
        &mut self,
        pos: btScalar,
        lowLim: btScalar,
        uppLim: btScalar,
        vel: btScalar,
        timeFact: btScalar,
    ) -> btScalar {
        btTypedConstraint_getMotorFactor(self, pos, lowLim, uppLim, vel, timeFact)
    }
    #[inline]
    pub unsafe fn getFixedBody() -> *mut btRigidBody {
        btTypedConstraint_getFixedBody()
    }
    #[inline]
    pub unsafe fn new(type_: btTypedConstraintType, rbA: *mut btRigidBody) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTypedConstraint_btTypedConstraint(&mut __bindgen_tmp, type_, rbA);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTypedConstraint_btTypedConstraint1(&mut __bindgen_tmp, type_, rbA, rbB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btTypedConstraint@@UEBAHXZ"]
    pub fn btTypedConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btTypedConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btTypedConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintFloatData {
    pub m_rbA: *mut btRigidBodyFloatData,
    pub m_rbB: *mut btRigidBodyFloatData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintData {
    pub m_rbA: *mut btRigidBodyDoubleData,
    pub m_rbB: *mut btRigidBodyDoubleData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintDoubleData {
    pub m_rbA: *mut btRigidBodyDoubleData,
    pub m_rbB: *mut btRigidBodyDoubleData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f64,
    pub m_dbgDrawSize: f64,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f64,
    pub m_isEnabled: ::std::os::raw::c_int,
    pub padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAngularLimit {
    pub m_center: btScalar,
    pub m_halfRange: btScalar,
    pub m_softness: btScalar,
    pub m_biasFactor: btScalar,
    pub m_relaxationFactor: btScalar,
    pub m_correction: btScalar,
    pub m_sign: btScalar,
    pub m_solveLimit: bool,
}
extern "C" {
    /// Sets all limit's parameters.
    /// /// When low > high limit becomes inactive.
    /// /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
    #[link_name = "\u{1}?set@btAngularLimit@@QEAAXNNNNN@Z"]
    pub fn btAngularLimit_set(
        this: *mut btAngularLimit,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    );
}
extern "C" {
    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// /// correction is calculated.
    #[link_name = "\u{1}?test@btAngularLimit@@QEAAXN@Z"]
    pub fn btAngularLimit_test(this: *mut btAngularLimit, angle: btScalar);
}
extern "C" {
    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// /// returned is modified so it equals to the limit closest to given angle.
    #[link_name = "\u{1}?fit@btAngularLimit@@QEBAXAEAN@Z"]
    pub fn btAngularLimit_fit(this: *const btAngularLimit, angle: *mut btScalar);
}
extern "C" {
    /// Returns correction value multiplied by sign value
    #[link_name = "\u{1}?getError@btAngularLimit@@QEBANXZ"]
    pub fn btAngularLimit_getError(this: *const btAngularLimit) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getLow@btAngularLimit@@QEBANXZ"]
    pub fn btAngularLimit_getLow(this: *const btAngularLimit) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getHigh@btAngularLimit@@QEBANXZ"]
    pub fn btAngularLimit_getHigh(this: *const btAngularLimit) -> btScalar;
}
impl btAngularLimit {
    #[inline]
    pub unsafe fn set(
        &mut self,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    ) {
        btAngularLimit_set(self, low, high, _softness, _biasFactor, _relaxationFactor)
    }
    #[inline]
    pub unsafe fn test(&mut self, angle: btScalar) {
        btAngularLimit_test(self, angle)
    }
    #[inline]
    pub unsafe fn fit(&self, angle: *mut btScalar) {
        btAngularLimit_fit(self, angle)
    }
    #[inline]
    pub unsafe fn getError(&self) -> btScalar {
        btAngularLimit_getError(self)
    }
    #[inline]
    pub unsafe fn getLow(&self) -> btScalar {
        btAngularLimit_getLow(self)
    }
    #[inline]
    pub unsafe fn getHigh(&self) -> btScalar {
        btAngularLimit_getHigh(self)
    }
}
/// btContactConstraint can be automatically created to solve contact constraints using the unified btTypedConstraint interface
#[repr(C)]
pub struct btContactConstraint {
    pub _base: btTypedConstraint,
    pub m_contactManifold: btPersistentManifold,
}
extern "C" {
    #[link_name = "\u{1}?setContactManifold@btContactConstraint@@QEAAXPEAVbtPersistentManifold@@@Z"]
    pub fn btContactConstraint_setContactManifold(
        this: *mut btContactConstraint,
        contactManifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btContactConstraint@@IEAA@PEAVbtPersistentManifold@@AEAVbtRigidBody@@1@Z"]
    pub fn btContactConstraint_btContactConstraint(
        this: *mut btContactConstraint,
        contactManifold: *mut btPersistentManifold,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    );
}
impl btContactConstraint {
    #[inline]
    pub unsafe fn setContactManifold(&mut self, contactManifold: *mut btPersistentManifold) {
        btContactConstraint_setContactManifold(self, contactManifold)
    }
    #[inline]
    pub unsafe fn new(
        contactManifold: *mut btPersistentManifold,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btContactConstraint_btContactConstraint(&mut __bindgen_tmp, contactManifold, rbA, rbB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtContactConstraint@@QEAAXXZ"]
    pub fn btContactConstraint_btContactConstraint_destructor(this: *mut btContactConstraint);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btContactConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btContactConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btContactConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btContactConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    /// obsolete methods
    #[link_name = "\u{1}?buildJacobian@btContactConstraint@@UEAAXXZ"]
    pub fn btContactConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
pub const btSolverMode_SOLVER_RANDMIZE_ORDER: btSolverMode = 1;
pub const btSolverMode_SOLVER_FRICTION_SEPARATE: btSolverMode = 2;
pub const btSolverMode_SOLVER_USE_WARMSTARTING: btSolverMode = 4;
pub const btSolverMode_SOLVER_USE_2_FRICTION_DIRECTIONS: btSolverMode = 16;
pub const btSolverMode_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING: btSolverMode = 32;
pub const btSolverMode_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION: btSolverMode = 64;
pub const btSolverMode_SOLVER_CACHE_FRIENDLY: btSolverMode = 128;
pub const btSolverMode_SOLVER_SIMD: btSolverMode = 256;
pub const btSolverMode_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: btSolverMode = 512;
pub const btSolverMode_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: btSolverMode = 1024;
pub const btSolverMode_SOLVER_DISABLE_IMPLICIT_CONE_FRICTION: btSolverMode = 2048;
pub type btSolverMode = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoData {
    pub m_tau: btScalar,
    pub m_damping: btScalar,
    pub m_friction: btScalar,
    pub m_timeStep: btScalar,
    pub m_restitution: btScalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_maxErrorReduction: btScalar,
    pub m_sor: btScalar,
    pub m_erp: btScalar,
    pub m_erp2: btScalar,
    pub m_globalCfm: btScalar,
    pub m_frictionERP: btScalar,
    pub m_frictionCFM: btScalar,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_splitImpulsePenetrationThreshold: btScalar,
    pub m_splitImpulseTurnErp: btScalar,
    pub m_linearSlop: btScalar,
    pub m_warmstartingFactor: btScalar,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_maxGyroscopicForce: btScalar,
    pub m_singleAxisRollingFrictionThreshold: btScalar,
    pub m_leastSquaresResidualThreshold: btScalar,
    pub m_restitutionVelocityThreshold: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfo {
    pub _base: btContactSolverInfoData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoDoubleData {
    pub m_tau: f64,
    pub m_damping: f64,
    pub m_friction: f64,
    pub m_timeStep: f64,
    pub m_restitution: f64,
    pub m_maxErrorReduction: f64,
    pub m_sor: f64,
    pub m_erp: f64,
    pub m_erp2: f64,
    pub m_globalCfm: f64,
    pub m_splitImpulsePenetrationThreshold: f64,
    pub m_splitImpulseTurnErp: f64,
    pub m_linearSlop: f64,
    pub m_warmstartingFactor: f64,
    pub m_maxGyroscopicForce: f64,
    /// it is only used for 'explicit' version of gyroscopic force
    pub m_singleAxisRollingFrictionThreshold: f64,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoFloatData {
    pub m_tau: f32,
    pub m_damping: f32,
    pub m_friction: f32,
    pub m_timeStep: f32,
    pub m_restitution: f32,
    pub m_maxErrorReduction: f32,
    pub m_sor: f32,
    pub m_erp: f32,
    pub m_erp2: f32,
    pub m_globalCfm: f32,
    pub m_splitImpulsePenetrationThreshold: f32,
    pub m_splitImpulseTurnErp: f32,
    pub m_linearSlop: f32,
    pub m_warmstartingFactor: f32,
    pub m_maxGyroscopicForce: f32,
    pub m_singleAxisRollingFrictionThreshold: f32,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
pub const btConstraintSolverType_BT_SEQUENTIAL_IMPULSE_SOLVER: btConstraintSolverType = 1;
pub const btConstraintSolverType_BT_MLCP_SOLVER: btConstraintSolverType = 2;
pub const btConstraintSolverType_BT_NNCG_SOLVER: btConstraintSolverType = 4;
/// btConstraintSolver provides solver interface
pub type btConstraintSolverType = i32;
#[repr(C)]
pub struct btConstraintSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btConstraintSolver {
    pub vtable_: *const btConstraintSolver__bindgen_vtable,
}
pub type btSingleConstraintRowSolver = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut btSolverBody,
        arg2: *mut btSolverBody,
        arg3: *const btSolverConstraint,
    ) -> btScalar,
>;
/// The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
#[repr(C)]
pub struct btSequentialImpulseConstraintSolver {
    pub _base: btConstraintSolver,
    pub m_tmpSolverBodyPool: btAlignedObjectArray<btSolverBody>,
    pub m_tmpSolverContactConstraintPool: btConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: btConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: btConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: btConstraintArray,
    pub m_orderTmpConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderNonContactConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderFrictionConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_tmpConstraintSizesPool: btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_fixedBodyId: ::std::os::raw::c_int,
    pub m_kinematicBodyUniqueIdToSolverBodyTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_resolveSingleConstraintRowGeneric: btSingleConstraintRowSolver,
    pub m_resolveSingleConstraintRowLowerLimit: btSingleConstraintRowSolver,
    pub m_resolveSplitPenetrationImpulse: btSingleConstraintRowSolver,
    pub m_cachedSolverMode: ::std::os::raw::c_int,
    pub m_leastSquaresResidual: btScalar,
    /// m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    pub m_btSeed2: ::std::os::raw::c_ulong,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}?setupSolverFunctions@btSequentialImpulseConstraintSolver@@IEAAX_N@Z"]
    pub fn btSequentialImpulseConstraintSolver_setupSolverFunctions(
        this: *mut btSequentialImpulseConstraintSolver,
        useSimd: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@AEBVbtVector3@@HHAEAVbtManifoldPoint@@11PEAVbtCollisionObject@@3NAEBUbtContactSolverInfo@@NN@Z"]
    pub fn btSequentialImpulseConstraintSolver_setupFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupTorsionalFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@AEBVbtVector3@@HHAEAVbtManifoldPoint@@N11PEAVbtCollisionObject@@3NNN@Z"]
    pub fn btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?addFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAAEAUbtSolverConstraint@@AEBVbtVector3@@HHHAEAVbtManifoldPoint@@00PEAVbtCollisionObject@@2NAEBUbtContactSolverInfo@@NN@Z"]
    pub fn btSequentialImpulseConstraintSolver_addFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?addTorsionalFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAAEAUbtSolverConstraint@@AEBVbtVector3@@HHHAEAVbtManifoldPoint@@N00PEAVbtCollisionObject@@2NNN@Z"]
    pub fn btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        torsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?setupContactConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@HHAEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@AEANAEBVbtVector3@@4@Z"]
    pub fn btSequentialImpulseConstraintSolver_setupContactConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?applyAnisotropicFriction@btSequentialImpulseConstraintSolver@@KAXPEAVbtCollisionObject@@AEAVbtVector3@@H@Z"]
    pub fn btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
        colObj: *mut btCollisionObject,
        frictionDirection: *mut btVector3,
        frictionMode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFrictionConstraintImpulse@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@HHAEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?restitutionCurve@btSequentialImpulseConstraintSolver@@IEAANNNN@Z"]
    pub fn btSequentialImpulseConstraintSolver_restitutionCurve(
        this: *mut btSequentialImpulseConstraintSolver,
        rel_vel: btScalar,
        restitution: btScalar,
        velocityThreshold: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?convertContact@btSequentialImpulseConstraintSolver@@IEAAXPEAVbtPersistentManifold@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_convertContact(
        this: *mut btSequentialImpulseConstraintSolver,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertJoint@btSequentialImpulseConstraintSolver@@IEAAXPEAUbtSolverConstraint@@PEAVbtTypedConstraint@@AEBUbtConstraintInfo1@3@HHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_convertJoint(
        this: *mut btSequentialImpulseConstraintSolver,
        currentConstraintRow: *mut btSolverConstraint,
        constraint: *mut btTypedConstraint,
        info1: *const btTypedConstraint_btConstraintInfo1,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOrInitSolverBody@btSequentialImpulseConstraintSolver@@IEAAHAEAVbtCollisionObject@@N@Z"]
    pub fn btSequentialImpulseConstraintSolver_getOrInitSolverBody(
        this: *mut btSequentialImpulseConstraintSolver,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?initSolverBody@btSequentialImpulseConstraintSolver@@IEAAXPEAUbtSolverBody@@PEAVbtCollisionObject@@N@Z"]
    pub fn btSequentialImpulseConstraintSolver_initSolverBody(
        this: *mut btSequentialImpulseConstraintSolver,
        solverBody: *mut btSolverBody,
        collisionObject: *mut btCollisionObject,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowGeneric@btSequentialImpulseConstraintSolver@@IEAANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowGenericSIMD@btSequentialImpulseConstraintSolver@@IEAANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowLowerLimit@btSequentialImpulseConstraintSolver@@IEAANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowLowerLimitSIMD@btSequentialImpulseConstraintSolver@@IEAANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?writeBackContacts@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_writeBackContacts(
        this: *mut btSequentialImpulseConstraintSolver,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeBackJoints@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_writeBackJoints(
        this: *mut btSequentialImpulseConstraintSolver,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeBackBodies@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_writeBackBodies(
        this: *mut btSequentialImpulseConstraintSolver,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?btRand2@btSequentialImpulseConstraintSolver@@QEAAKXZ"]
    pub fn btSequentialImpulseConstraintSolver_btRand2(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?btRandInt2@btSequentialImpulseConstraintSolver@@QEAAHH@Z"]
    pub fn btSequentialImpulseConstraintSolver_btRandInt2(
        this: *mut btSequentialImpulseConstraintSolver,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4
    #[link_name = "\u{1}?getScalarConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}?getSSE2ConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}?getSSE4_1ConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    /// Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4
    #[link_name = "\u{1}?getScalarConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}?getSSE2ConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}?getSSE4_1ConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6ANAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ"]
    pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}??0btSequentialImpulseConstraintSolver@@QEAA@XZ"]
    pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(
        this: *mut btSequentialImpulseConstraintSolver,
    );
}
impl btSequentialImpulseConstraintSolver {
    #[inline]
    pub unsafe fn setupSolverFunctions(&mut self, useSimd: bool) {
        btSequentialImpulseConstraintSolver_setupSolverFunctions(self, useSimd)
    }
    #[inline]
    pub unsafe fn setupFrictionConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_setupFrictionConstraint(
            self,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupTorsionalFrictionConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
            self,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            combinedTorsionalFriction,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint {
        btSequentialImpulseConstraintSolver_addFrictionConstraint(
            self,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addTorsionalFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        torsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint {
        btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
            self,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            torsionalFriction,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupContactConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
    ) {
        btSequentialImpulseConstraintSolver_setupContactConstraint(
            self,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
            relaxation,
            rel_pos1,
            rel_pos2,
        )
    }
    #[inline]
    pub unsafe fn applyAnisotropicFriction(
        colObj: *mut btCollisionObject,
        frictionDirection: *mut btVector3,
        frictionMode: ::std::os::raw::c_int,
    ) {
        btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
            colObj,
            frictionDirection,
            frictionMode,
        )
    }
    #[inline]
    pub unsafe fn setFrictionConstraintImpulse(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
            self,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn restitutionCurve(
        &mut self,
        rel_vel: btScalar,
        restitution: btScalar,
        velocityThreshold: btScalar,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_restitutionCurve(
            self,
            rel_vel,
            restitution,
            velocityThreshold,
        )
    }
    #[inline]
    pub unsafe fn convertContact(
        &mut self,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_convertContact(self, manifold, infoGlobal)
    }
    #[inline]
    pub unsafe fn convertJoint(
        &mut self,
        currentConstraintRow: *mut btSolverConstraint,
        constraint: *mut btTypedConstraint,
        info1: *const btTypedConstraint_btConstraintInfo1,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_convertJoint(
            self,
            currentConstraintRow,
            constraint,
            info1,
            solverBodyIdA,
            solverBodyIdB,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn getOrInitSolverBody(
        &mut self,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int {
        btSequentialImpulseConstraintSolver_getOrInitSolverBody(self, body, timeStep)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        solverBody: *mut btSolverBody,
        collisionObject: *mut btCollisionObject,
        timeStep: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_initSolverBody(
            self,
            solverBody,
            collisionObject,
            timeStep,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGeneric(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGenericSIMD(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimit(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimitSIMD(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn writeBackContacts(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_writeBackContacts(self, iBegin, iEnd, infoGlobal)
    }
    #[inline]
    pub unsafe fn writeBackJoints(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_writeBackJoints(self, iBegin, iEnd, infoGlobal)
    }
    #[inline]
    pub unsafe fn writeBackBodies(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_writeBackBodies(self, iBegin, iEnd, infoGlobal)
    }
    #[inline]
    pub unsafe fn btRand2(&mut self) -> ::std::os::raw::c_ulong {
        btSequentialImpulseConstraintSolver_btRand2(self)
    }
    #[inline]
    pub unsafe fn btRandInt2(&mut self, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        btSequentialImpulseConstraintSolver_btRandInt2(self, n)
    }
    #[inline]
    pub unsafe fn getScalarConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getSSE2ConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getSSE4_1ConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getScalarConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn getSSE2ConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn getSSE4_1ConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?convertContacts@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_convertContacts(
        this: *mut ::std::os::raw::c_void,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertJoints@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_convertJoints(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertBodies@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_convertBodies(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySplitImpulseIterations@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySplitImpulseIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@btSequentialImpulseConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveSingleIteration@btSequentialImpulseConstraintSolver@@MEAANHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveSingleIteration(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@btSequentialImpulseConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyIterations@btSequentialImpulseConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtSequentialImpulseConstraintSolver@@QEAAXXZ"]
    pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_destructor(
        this: *mut btSequentialImpulseConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroup@btSequentialImpulseConstraintSolver@@UEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z"]
    pub fn btSequentialImpulseConstraintSolver_solveGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifold: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    ) -> btScalar;
}
extern "C" {
    /// clear internal cached data and reset random seed
    #[link_name = "\u{1}?reset@btSequentialImpulseConstraintSolver@@UEAAXXZ"]
    pub fn btSequentialImpulseConstraintSolver_reset(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct btNNCGConstraintSolver {
    pub _base: btSequentialImpulseConstraintSolver,
    pub m_deltafLengthSqrPrev: btScalar,
    pub m_pNC: btAlignedObjectArray<btScalar>,
    pub m_pC: btAlignedObjectArray<btScalar>,
    pub m_pCF: btAlignedObjectArray<btScalar>,
    pub m_pCRF: btAlignedObjectArray<btScalar>,
    pub m_deltafNC: btAlignedObjectArray<btScalar>,
    pub m_deltafC: btAlignedObjectArray<btScalar>,
    pub m_deltafCF: btAlignedObjectArray<btScalar>,
    pub m_deltafCRF: btAlignedObjectArray<btScalar>,
    pub m_onlyForNoneContact: bool,
    pub __bindgen_padding_0: [u8; 7usize],
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@btNNCGConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btNNCGConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveSingleIteration@btNNCGConstraintSolver@@MEAANHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btNNCGConstraintSolver_solveSingleIteration(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@btNNCGConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btNNCGConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Debug)]
pub struct btBatchedConstraints {
    pub m_constraintIndices: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_batches: btAlignedObjectArray<btBatchedConstraints_Range>,
    pub m_phases: btAlignedObjectArray<btBatchedConstraints_Range>,
    pub m_phaseGrainSize: btAlignedObjectArray<::std::os::raw::c_char>,
    pub m_phaseOrder: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_debugDrawer: *mut btIDebugDraw,
}
pub const btBatchedConstraints_BatchingMethod_BATCHING_METHOD_SPATIAL_GRID_2D:
    btBatchedConstraints_BatchingMethod = 0;
pub const btBatchedConstraints_BatchingMethod_BATCHING_METHOD_SPATIAL_GRID_3D:
    btBatchedConstraints_BatchingMethod = 1;
pub const btBatchedConstraints_BatchingMethod_BATCHING_METHOD_COUNT:
    btBatchedConstraints_BatchingMethod = 2;
pub type btBatchedConstraints_BatchingMethod = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBatchedConstraints_Range {
    pub begin: ::std::os::raw::c_int,
    pub end: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?s_debugDrawBatches@btBatchedConstraints@@2_NA"]
    pub static mut btBatchedConstraints_s_debugDrawBatches: bool;
}
extern "C" {
    #[link_name = "\u{1}?setup@btBatchedConstraints@@QEAAXPEAV?$btAlignedObjectArray@UbtSolverConstraint@@@@AEBV?$btAlignedObjectArray@UbtSolverBody@@@@W4BatchingMethod@1@HHPEAV?$btAlignedObjectArray@D@@@Z"]
    pub fn btBatchedConstraints_setup(
        this: *mut btBatchedConstraints,
        constraints: *mut btConstraintArray,
        bodies: *const btAlignedObjectArray<btSolverBody>,
        batchingMethod: btBatchedConstraints_BatchingMethod,
        minBatchSize: ::std::os::raw::c_int,
        maxBatchSize: ::std::os::raw::c_int,
        scratchMemory: *mut btAlignedObjectArray<::std::os::raw::c_char>,
    );
}
extern "C" {
    #[link_name = "\u{1}?validate@btBatchedConstraints@@QEBA_NPEAV?$btAlignedObjectArray@UbtSolverConstraint@@@@AEBV?$btAlignedObjectArray@UbtSolverBody@@@@@Z"]
    pub fn btBatchedConstraints_validate(
        this: *const btBatchedConstraints,
        constraints: *mut btConstraintArray,
        bodies: *const btAlignedObjectArray<btSolverBody>,
    ) -> bool;
}
impl btBatchedConstraints {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        constraints: *mut btConstraintArray,
        bodies: *const btAlignedObjectArray<btSolverBody>,
        batchingMethod: btBatchedConstraints_BatchingMethod,
        minBatchSize: ::std::os::raw::c_int,
        maxBatchSize: ::std::os::raw::c_int,
        scratchMemory: *mut btAlignedObjectArray<::std::os::raw::c_char>,
    ) {
        btBatchedConstraints_setup(
            self,
            constraints,
            bodies,
            batchingMethod,
            minBatchSize,
            maxBatchSize,
            scratchMemory,
        )
    }
    #[inline]
    pub unsafe fn validate(
        &self,
        constraints: *mut btConstraintArray,
        bodies: *const btAlignedObjectArray<btSolverBody>,
    ) -> bool {
        btBatchedConstraints_validate(self, constraints, bodies)
    }
}
///
/// btSequentialImpulseConstraintSolverMt
///
/// A multithreaded variant of the sequential impulse constraint solver. The constraints to be solved are grouped into
/// batches and phases where each batch of constraints within a given phase can be solved in parallel with the rest.
/// Ideally we want as few phases as possible, and each phase should have many batches, and all of the batches should
/// have about the same number of constraints.
/// This method works best on a large island of many constraints.
///
/// Supports all of the features of the normal sequential impulse solver such as:
/// - split penetration impulse
/// - rolling friction
/// - interleaving constraints
/// - warmstarting
/// - 2 friction directions
/// - randomized constraint ordering
/// - early termination when leastSquaresResidualThreshold is satisfied
///
/// When the SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS flag is enabled, unlike the normal SequentialImpulse solver,
/// the rolling friction is interleaved as well.
/// Interleaving the contact penetration constraints with friction reduces the number of parallel loops that need to be done,
/// which reduces threading overhead so it can be a performance win, however, it does seem to produce a less stable simulation,
/// at least on stacks of blocks.
///
/// When the SOLVER_RANDMIZE_ORDER flag is enabled, the ordering of phases, and the ordering of constraints within each batch
/// is randomized, however it does not swap constraints between batches.
/// This is to avoid regenerating the batches for each solver iteration which would be quite costly in performance.
///
/// Note that a non-zero leastSquaresResidualThreshold could possibly affect the determinism of the simulation
/// if the task scheduler's parallelSum operation is non-deterministic. The parallelSum operation can be non-deterministic
/// because floating point addition is not associative due to rounding errors.
/// The task scheduler can and should ensure that the result of any parallelSum operation is deterministic.
///
#[repr(C)]
pub struct btSequentialImpulseConstraintSolverMt {
    pub _base: btSequentialImpulseConstraintSolver,
    pub m_batchedContactConstraints: btBatchedConstraints,
    pub m_batchedJointConstraints: btBatchedConstraints,
    pub m_numFrictionDirections: ::std::os::raw::c_int,
    pub m_useBatching: bool,
    pub m_useObsoleteJointConstraints: bool,
    pub m_manifoldCachedInfoArray:
        btAlignedObjectArray<btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo>,
    pub m_rollingFrictionIndexTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_bodySolverArrayMutex: btSpinMutex,
    pub m_antiFalseSharingPadding: [::std::os::raw::c_char; 64usize],
    pub m_kinematicBodyUniqueIdToSolverBodyTableMutex: btSpinMutex,
    pub m_scratchMemory: btAlignedObjectArray<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo {
    pub numTouchingContacts: ::std::os::raw::c_int,
    pub solverBodyIds: [::std::os::raw::c_int; 2usize],
    pub contactIndex: ::std::os::raw::c_int,
    pub rollingFrictionIndex: ::std::os::raw::c_int,
    pub contactHasRollingFriction: [bool; 4usize],
    pub contactPoints: [*mut btManifoldPoint; 4usize],
}
pub const btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo_MAX_NUM_CONTACT_POINTS : :: std :: os :: raw :: c_int = 4 ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSequentialImpulseConstraintSolverMt_JointParams {
    pub m_solverConstraint: ::std::os::raw::c_int,
    pub m_solverBodyA: ::std::os::raw::c_int,
    pub m_solverBodyB: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?s_allowNestedParallelForLoops@btSequentialImpulseConstraintSolverMt@@2_NA"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_allowNestedParallelForLoops: bool;
}
extern "C" {
    #[link_name = "\u{1}?s_minimumContactManifoldsForBatching@btSequentialImpulseConstraintSolverMt@@2HA"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_minimumContactManifoldsForBatching:
        ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?s_contactBatchingMethod@btSequentialImpulseConstraintSolverMt@@2W4BatchingMethod@btBatchedConstraints@@A"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_contactBatchingMethod:
        btBatchedConstraints_BatchingMethod;
}
extern "C" {
    #[link_name = "\u{1}?s_jointBatchingMethod@btSequentialImpulseConstraintSolverMt@@2W4BatchingMethod@btBatchedConstraints@@A"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_jointBatchingMethod:
        btBatchedConstraints_BatchingMethod;
}
extern "C" {
    #[link_name = "\u{1}?s_minBatchSize@btSequentialImpulseConstraintSolverMt@@2HA"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_minBatchSize: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?s_maxBatchSize@btSequentialImpulseConstraintSolverMt@@2HA"]
    pub static mut btSequentialImpulseConstraintSolverMt_s_maxBatchSize: ::std::os::raw::c_int;
}
pub const btSequentialImpulseConstraintSolverMt_CACHE_LINE_SIZE: ::std::os::raw::c_int = 64;
extern "C" {
    #[link_name = "\u{1}?internalInitMultipleJoints@btSequentialImpulseConstraintSolverMt@@QEAAXPEAPEAVbtTypedConstraint@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalInitMultipleJoints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        constraints: *mut *mut btTypedConstraint,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalConvertMultipleJoints@btSequentialImpulseConstraintSolverMt@@QEAAXAEBV?$btAlignedObjectArray@UJointParams@btSequentialImpulseConstraintSolverMt@@@@PEAPEAVbtTypedConstraint@@HHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalConvertMultipleJoints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        jointParamsArray: *const btAlignedObjectArray<
            btSequentialImpulseConstraintSolverMt_JointParams,
        >,
        constraints: *mut *mut btTypedConstraint,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOrInitSolverBodyThreadsafe@btSequentialImpulseConstraintSolverMt@@IEAAHAEAVbtCollisionObject@@N@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_getOrInitSolverBodyThreadsafe(
        this: *mut btSequentialImpulseConstraintSolverMt,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?allocAllContactConstraints@btSequentialImpulseConstraintSolverMt@@IEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_allocAllContactConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupAllContactConstraints@btSequentialImpulseConstraintSolverMt@@IEAAXAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_setupAllContactConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?randomizeBatchedConstraintOrdering@btSequentialImpulseConstraintSolverMt@@IEAAXPEAUbtBatchedConstraints@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_randomizeBatchedConstraintOrdering(
        this: *mut btSequentialImpulseConstraintSolverMt,
        batchedConstraints: *mut btBatchedConstraints,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleJointConstraints@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HHH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleJointConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
        iteration: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleContactConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleContactSplitPenetrationImpulseConstraints@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleContactSplitPenetrationImpulseConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleContactFrictionConstraints@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleContactFrictionConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleContactRollingFrictionConstraints@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleContactRollingFrictionConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveMultipleContactConstraintsInterleaved@btSequentialImpulseConstraintSolverMt@@QEAANAEBV?$btAlignedObjectArray@H@@HH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveMultipleContactConstraintsInterleaved(
        this: *mut btSequentialImpulseConstraintSolverMt,
        contactIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?internalCollectContactManifoldCachedInfo@btSequentialImpulseConstraintSolverMt@@QEAAXPEAUbtContactManifoldCachedInfo@1@PEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalCollectContactManifoldCachedInfo(
        this: *mut btSequentialImpulseConstraintSolverMt,
        cachedInfoArray: *mut btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalAllocContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAAXPEBUbtContactManifoldCachedInfo@1@H@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalAllocContactConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        cachedInfoArray: *const btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo,
        numManifolds: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalSetupContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAAXHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalSetupContactConstraints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        iContactConstraint: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalConvertBodies@btSequentialImpulseConstraintSolverMt@@QEAAXPEAPEAVbtCollisionObject@@HHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalConvertBodies(
        this: *mut btSequentialImpulseConstraintSolverMt,
        bodies: *mut *mut btCollisionObject,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalWriteBackContacts@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalWriteBackContacts(
        this: *mut btSequentialImpulseConstraintSolverMt,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalWriteBackJoints@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalWriteBackJoints(
        this: *mut btSequentialImpulseConstraintSolverMt,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalWriteBackBodies@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_internalWriteBackBodies(
        this: *mut btSequentialImpulseConstraintSolverMt,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSequentialImpulseConstraintSolverMt@@QEAA@XZ"]
    pub fn btSequentialImpulseConstraintSolverMt_btSequentialImpulseConstraintSolverMt(
        this: *mut btSequentialImpulseConstraintSolverMt,
    );
}
impl btSequentialImpulseConstraintSolverMt {
    #[inline]
    pub unsafe fn internalInitMultipleJoints(
        &mut self,
        constraints: *mut *mut btTypedConstraint,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
    ) {
        btSequentialImpulseConstraintSolverMt_internalInitMultipleJoints(
            self,
            constraints,
            iBegin,
            iEnd,
        )
    }
    #[inline]
    pub unsafe fn internalConvertMultipleJoints(
        &mut self,
        jointParamsArray: *const btAlignedObjectArray<
            btSequentialImpulseConstraintSolverMt_JointParams,
        >,
        constraints: *mut *mut btTypedConstraint,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalConvertMultipleJoints(
            self,
            jointParamsArray,
            constraints,
            iBegin,
            iEnd,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn getOrInitSolverBodyThreadsafe(
        &mut self,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int {
        btSequentialImpulseConstraintSolverMt_getOrInitSolverBodyThreadsafe(self, body, timeStep)
    }
    #[inline]
    pub unsafe fn allocAllContactConstraints(
        &mut self,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_allocAllContactConstraints(
            self,
            manifoldPtr,
            numManifolds,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn setupAllContactConstraints(&mut self, infoGlobal: *const btContactSolverInfo) {
        btSequentialImpulseConstraintSolverMt_setupAllContactConstraints(self, infoGlobal)
    }
    #[inline]
    pub unsafe fn randomizeBatchedConstraintOrdering(
        &mut self,
        batchedConstraints: *mut btBatchedConstraints,
    ) {
        btSequentialImpulseConstraintSolverMt_randomizeBatchedConstraintOrdering(
            self,
            batchedConstraints,
        )
    }
    #[inline]
    pub unsafe fn resolveMultipleJointConstraints(
        &mut self,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
        iteration: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleJointConstraints(
            self,
            consIndices,
            batchBegin,
            batchEnd,
            iteration,
        )
    }
    #[inline]
    pub unsafe fn resolveMultipleContactConstraints(
        &mut self,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleContactConstraints(
            self,
            consIndices,
            batchBegin,
            batchEnd,
        )
    }
    #[inline]
    pub unsafe fn resolveMultipleContactSplitPenetrationImpulseConstraints(
        &mut self,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleContactSplitPenetrationImpulseConstraints ( self , consIndices , batchBegin , batchEnd )
    }
    #[inline]
    pub unsafe fn resolveMultipleContactFrictionConstraints(
        &mut self,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleContactFrictionConstraints(
            self,
            consIndices,
            batchBegin,
            batchEnd,
        )
    }
    #[inline]
    pub unsafe fn resolveMultipleContactRollingFrictionConstraints(
        &mut self,
        consIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleContactRollingFrictionConstraints(
            self,
            consIndices,
            batchBegin,
            batchEnd,
        )
    }
    #[inline]
    pub unsafe fn resolveMultipleContactConstraintsInterleaved(
        &mut self,
        contactIndices: *const btAlignedObjectArray<::std::os::raw::c_int>,
        batchBegin: ::std::os::raw::c_int,
        batchEnd: ::std::os::raw::c_int,
    ) -> btScalar {
        btSequentialImpulseConstraintSolverMt_resolveMultipleContactConstraintsInterleaved(
            self,
            contactIndices,
            batchBegin,
            batchEnd,
        )
    }
    #[inline]
    pub unsafe fn internalCollectContactManifoldCachedInfo(
        &mut self,
        cachedInfoArray: *mut btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalCollectContactManifoldCachedInfo(
            self,
            cachedInfoArray,
            manifoldPtr,
            numManifolds,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn internalAllocContactConstraints(
        &mut self,
        cachedInfoArray: *const btSequentialImpulseConstraintSolverMt_btContactManifoldCachedInfo,
        numManifolds: ::std::os::raw::c_int,
    ) {
        btSequentialImpulseConstraintSolverMt_internalAllocContactConstraints(
            self,
            cachedInfoArray,
            numManifolds,
        )
    }
    #[inline]
    pub unsafe fn internalSetupContactConstraints(
        &mut self,
        iContactConstraint: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalSetupContactConstraints(
            self,
            iContactConstraint,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn internalConvertBodies(
        &mut self,
        bodies: *mut *mut btCollisionObject,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalConvertBodies(
            self, bodies, iBegin, iEnd, infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn internalWriteBackContacts(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalWriteBackContacts(
            self, iBegin, iEnd, infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn internalWriteBackJoints(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalWriteBackJoints(
            self, iBegin, iEnd, infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn internalWriteBackBodies(
        &mut self,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolverMt_internalWriteBackBodies(
            self, iBegin, iEnd, infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSequentialImpulseConstraintSolverMt_btSequentialImpulseConstraintSolverMt(
            &mut __bindgen_tmp,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySplitImpulseIterations@btSequentialImpulseConstraintSolverMt@@UEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_solveGroupCacheFriendlySplitImpulseIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveSingleIteration@btSequentialImpulseConstraintSolverMt@@UEAANHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_solveSingleIteration(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@btSequentialImpulseConstraintSolverMt@@UEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@btSequentialImpulseConstraintSolverMt@@UEAANPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?randomizeConstraintOrdering@btSequentialImpulseConstraintSolverMt@@MEAAXHH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_randomizeConstraintOrdering(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        numIterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveAllJointConstraints@btSequentialImpulseConstraintSolverMt@@MEAANH@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveAllJointConstraints(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveAllContactConstraints@btSequentialImpulseConstraintSolverMt@@MEAANXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveAllContactConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveAllContactFrictionConstraints@btSequentialImpulseConstraintSolverMt@@MEAANXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveAllContactFrictionConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveAllContactConstraintsInterleaved@btSequentialImpulseConstraintSolverMt@@MEAANXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveAllContactConstraintsInterleaved(
        this: *mut ::std::os::raw::c_void,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveAllRollingFrictionConstraints@btSequentialImpulseConstraintSolverMt@@MEAANXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_resolveAllRollingFrictionConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setupBatchedContactConstraints@btSequentialImpulseConstraintSolverMt@@MEAAXXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_setupBatchedContactConstraints(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupBatchedJointConstraints@btSequentialImpulseConstraintSolverMt@@MEAAXXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_setupBatchedJointConstraints(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertJoints@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_convertJoints(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertContacts@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_convertContacts(
        this: *mut ::std::os::raw::c_void,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertBodies@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btSequentialImpulseConstraintSolverMt_convertBodies(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtSequentialImpulseConstraintSolverMt@@QEAAXXZ"]
    pub fn btSequentialImpulseConstraintSolverMt_btSequentialImpulseConstraintSolverMt_destructor(
        this: *mut btSequentialImpulseConstraintSolverMt,
    );
}
/// constraint class used for lateral tyre friction.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSolve2LinearConstraint {
    pub m_tau: btScalar,
    pub m_damping: btScalar,
}
extern "C" {
    #[link_name = "\u{1}?resolveUnilateralPairConstraint@btSolve2LinearConstraint@@QEAAXPEAVbtRigidBody@@0AEBVbtMatrix3x3@@1AEBVbtVector3@@N2222N222N222N2AEAN3@Z"]
    pub fn btSolve2LinearConstraint_resolveUnilateralPairConstraint(
        this: *mut btSolve2LinearConstraint,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        invInertiaADiag: *const btVector3,
        invMassA: btScalar,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        rel_posA1: *const btVector3,
        invInertiaBDiag: *const btVector3,
        invMassB: btScalar,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
        rel_posA2: *const btVector3,
        depthA: btScalar,
        normalA: *const btVector3,
        rel_posB1: *const btVector3,
        rel_posB2: *const btVector3,
        depthB: btScalar,
        normalB: *const btVector3,
        imp0: *mut btScalar,
        imp1: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?resolveBilateralPairConstraint@btSolve2LinearConstraint@@QEAAXPEAVbtRigidBody@@0AEBVbtMatrix3x3@@1AEBVbtVector3@@N2222N222N222N2AEAN3@Z"]
    pub fn btSolve2LinearConstraint_resolveBilateralPairConstraint(
        this: *mut btSolve2LinearConstraint,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        invInertiaADiag: *const btVector3,
        invMassA: btScalar,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        rel_posA1: *const btVector3,
        invInertiaBDiag: *const btVector3,
        invMassB: btScalar,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
        rel_posA2: *const btVector3,
        depthA: btScalar,
        normalA: *const btVector3,
        rel_posB1: *const btVector3,
        rel_posB2: *const btVector3,
        depthB: btScalar,
        normalB: *const btVector3,
        imp0: *mut btScalar,
        imp1: *mut btScalar,
    );
}
impl btSolve2LinearConstraint {
    #[inline]
    pub unsafe fn resolveUnilateralPairConstraint(
        &mut self,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        invInertiaADiag: *const btVector3,
        invMassA: btScalar,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        rel_posA1: *const btVector3,
        invInertiaBDiag: *const btVector3,
        invMassB: btScalar,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
        rel_posA2: *const btVector3,
        depthA: btScalar,
        normalA: *const btVector3,
        rel_posB1: *const btVector3,
        rel_posB2: *const btVector3,
        depthB: btScalar,
        normalB: *const btVector3,
        imp0: *mut btScalar,
        imp1: *mut btScalar,
    ) {
        btSolve2LinearConstraint_resolveUnilateralPairConstraint(
            self,
            body0,
            body1,
            world2A,
            world2B,
            invInertiaADiag,
            invMassA,
            linvelA,
            angvelA,
            rel_posA1,
            invInertiaBDiag,
            invMassB,
            linvelB,
            angvelB,
            rel_posA2,
            depthA,
            normalA,
            rel_posB1,
            rel_posB2,
            depthB,
            normalB,
            imp0,
            imp1,
        )
    }
    #[inline]
    pub unsafe fn resolveBilateralPairConstraint(
        &mut self,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        invInertiaADiag: *const btVector3,
        invMassA: btScalar,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        rel_posA1: *const btVector3,
        invInertiaBDiag: *const btVector3,
        invMassB: btScalar,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
        rel_posA2: *const btVector3,
        depthA: btScalar,
        normalA: *const btVector3,
        rel_posB1: *const btVector3,
        rel_posB2: *const btVector3,
        depthB: btScalar,
        normalB: *const btVector3,
        imp0: *mut btScalar,
        imp1: *mut btScalar,
    ) {
        btSolve2LinearConstraint_resolveBilateralPairConstraint(
            self,
            body0,
            body1,
            world2A,
            world2B,
            invInertiaADiag,
            invMassA,
            linvelA,
            angvelA,
            rel_posA1,
            invInertiaBDiag,
            invMassB,
            linvelB,
            angvelB,
            rel_posA2,
            depthA,
            normalA,
            rel_posB1,
            rel_posB2,
            depthB,
            normalB,
            imp0,
            imp1,
        )
    }
}
/// Type for the callback for each tick
pub type btInternalTickCallback =
    ::std::option::Option<unsafe extern "C" fn(world: *mut btDynamicsWorld, timeStep: btScalar)>;
pub const btDynamicsWorldType_BT_SIMPLE_DYNAMICS_WORLD: btDynamicsWorldType = 1;
pub const btDynamicsWorldType_BT_DISCRETE_DYNAMICS_WORLD: btDynamicsWorldType = 2;
pub const btDynamicsWorldType_BT_CONTINUOUS_DYNAMICS_WORLD: btDynamicsWorldType = 3;
pub const btDynamicsWorldType_BT_SOFT_RIGID_DYNAMICS_WORLD: btDynamicsWorldType = 4;
pub const btDynamicsWorldType_BT_GPU_DYNAMICS_WORLD: btDynamicsWorldType = 5;
pub const btDynamicsWorldType_BT_SOFT_MULTIBODY_DYNAMICS_WORLD: btDynamicsWorldType = 6;
pub type btDynamicsWorldType = i32;
/// The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
#[repr(C)]
#[derive(Debug)]
pub struct btDynamicsWorld {
    pub _base: btCollisionWorld,
    pub m_internalTickCallback: btInternalTickCallback,
    pub m_internalPreTickCallback: btInternalTickCallback,
    pub m_worldUserInfo: *mut ::std::os::raw::c_void,
    pub m_solverInfo: btContactSolverInfo,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDynamicsWorldDoubleData {
    pub m_solverInfo: btContactSolverInfoDoubleData,
    pub m_gravity: btVector3DoubleData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDynamicsWorldFloatData {
    pub m_solverInfo: btContactSolverInfoFloatData,
    pub m_gravity: btVector3FloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InplaceSolverIslandCallback {
    _unused: [u8; 0],
}
/// btDiscreteDynamicsWorld provides discrete rigid body simulation
/// those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteDynamicsWorld {
    pub _base: btDynamicsWorld,
    pub m_sortedConstraints: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_solverIslandCallback: *mut InplaceSolverIslandCallback,
    pub m_constraintSolver: *mut btConstraintSolver,
    pub m_islandManager: *mut btSimulationIslandManager,
    pub m_constraints: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_nonStaticRigidBodies: btAlignedObjectArray<*mut btRigidBody>,
    pub __bindgen_padding_0: u64,
    pub m_gravity: btVector3,
    pub m_localTime: btScalar,
    pub m_fixedTimeStep: btScalar,
    pub m_ownsIslandManager: bool,
    pub m_ownsConstraintSolver: bool,
    pub m_synchronizeAllMotionStates: bool,
    pub m_applySpeculativeContactRestitution: bool,
    pub m_actions: btAlignedObjectArray<*mut btActionInterface>,
    pub m_profileTimings: ::std::os::raw::c_int,
    pub m_latencyMotionStateInterpolation: bool,
    pub m_predictiveManifolds: btAlignedObjectArray<*mut btPersistentManifold>,
    pub m_predictiveManifoldsMutex: btSpinMutex,
    pub __bindgen_padding_1: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}?integrateTransformsInternal@btDiscreteDynamicsWorld@@IEAAXPEAPEAVbtRigidBody@@HN@Z"]
    pub fn btDiscreteDynamicsWorld_integrateTransformsInternal(
        this: *mut btDiscreteDynamicsWorld,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateActions@btDiscreteDynamicsWorld@@IEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_updateActions(
        this: *mut btDiscreteDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?startProfiling@btDiscreteDynamicsWorld@@IEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_startProfiling(
        this: *mut btDiscreteDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?releasePredictiveContacts@btDiscreteDynamicsWorld@@IEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_releasePredictiveContacts(this: *mut btDiscreteDynamicsWorld);
}
extern "C" {
    #[link_name = "\u{1}?createPredictiveContactsInternal@btDiscreteDynamicsWorld@@IEAAXPEAPEAVbtRigidBody@@HN@Z"]
    pub fn btDiscreteDynamicsWorld_createPredictiveContactsInternal(
        this: *mut btDiscreteDynamicsWorld,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeRigidBodies@btDiscreteDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btDiscreteDynamicsWorld_serializeRigidBodies(
        this: *mut btDiscreteDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeDynamicsWorldInfo@btDiscreteDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(
        this: *mut btDiscreteDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    /// this can be useful to synchronize a single rigid body -> graphics object
    #[link_name = "\u{1}?synchronizeSingleMotionState@btDiscreteDynamicsWorld@@QEAAXPEAVbtRigidBody@@@Z"]
    pub fn btDiscreteDynamicsWorld_synchronizeSingleMotionState(
        this: *mut btDiscreteDynamicsWorld,
        body: *mut btRigidBody,
    );
}
extern "C" {
    /// this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
    #[link_name = "\u{1}??0btDiscreteDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
        this: *mut btDiscreteDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btDiscreteDynamicsWorld {
    #[inline]
    pub unsafe fn integrateTransformsInternal(
        &mut self,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    ) {
        btDiscreteDynamicsWorld_integrateTransformsInternal(self, bodies, numBodies, timeStep)
    }
    #[inline]
    pub unsafe fn updateActions(&mut self, timeStep: btScalar) {
        btDiscreteDynamicsWorld_updateActions(self, timeStep)
    }
    #[inline]
    pub unsafe fn startProfiling(&mut self, timeStep: btScalar) {
        btDiscreteDynamicsWorld_startProfiling(self, timeStep)
    }
    #[inline]
    pub unsafe fn releasePredictiveContacts(&mut self) {
        btDiscreteDynamicsWorld_releasePredictiveContacts(self)
    }
    #[inline]
    pub unsafe fn createPredictiveContactsInternal(
        &mut self,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    ) {
        btDiscreteDynamicsWorld_createPredictiveContactsInternal(self, bodies, numBodies, timeStep)
    }
    #[inline]
    pub unsafe fn serializeRigidBodies(&mut self, serializer: *mut btSerializer) {
        btDiscreteDynamicsWorld_serializeRigidBodies(self, serializer)
    }
    #[inline]
    pub unsafe fn serializeDynamicsWorldInfo(&mut self, serializer: *mut btSerializer) {
        btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(self, serializer)
    }
    #[inline]
    pub unsafe fn synchronizeSingleMotionState(&mut self, body: *mut btRigidBody) {
        btDiscreteDynamicsWorld_synchronizeSingleMotionState(self, body)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?predictUnconstraintMotion@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_predictUnconstraintMotion(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?integrateTransforms@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_integrateTransforms(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSimulationIslands@btDiscreteDynamicsWorld@@MEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_calculateSimulationIslands(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?solveConstraints@btDiscreteDynamicsWorld@@MEAAXAEAUbtContactSolverInfo@@@Z"]
    pub fn btDiscreteDynamicsWorld_solveConstraints(
        this: *mut ::std::os::raw::c_void,
        solverInfo: *mut btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateActivationState@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_updateActivationState(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalSingleStepSimulation@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_internalSingleStepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?createPredictiveContacts@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_createPredictiveContacts(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?saveKinematicState@btDiscreteDynamicsWorld@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorld_saveKinematicState(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtDiscreteDynamicsWorld@@QEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_destructor(
        this: *mut btDiscreteDynamicsWorld,
    );
}
extern "C" {
    /// if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's
    #[link_name = "\u{1}?stepSimulation@btDiscreteDynamicsWorld@@UEAAHNHN@Z"]
    pub fn btDiscreteDynamicsWorld_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?synchronizeMotionStates@btDiscreteDynamicsWorld@@UEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?addConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@_N@Z"]
    pub fn btDiscreteDynamicsWorld_addConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
        disableCollisionsBetweenLinkedBodies: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?addAction@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_addAction(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAction@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeAction(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}?setGravity@btDiscreteDynamicsWorld@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btDiscreteDynamicsWorld_setGravity(
        this: *mut ::std::os::raw::c_void,
        gravity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getGravity@btDiscreteDynamicsWorld@@UEBA?AVbtVector3@@XZ"]
    pub fn btDiscreteDynamicsWorld_getGravity(this: *mut ::std::os::raw::c_void) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?addCollisionObject@btDiscreteDynamicsWorld@@UEAAXPEAVbtCollisionObject@@HH@Z"]
    pub fn btDiscreteDynamicsWorld_addCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z"]
    pub fn btDiscreteDynamicsWorld_addRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?addRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@HH@Z"]
    pub fn btDiscreteDynamicsWorld_addRigidBody1(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
    #[link_name = "\u{1}?removeCollisionObject@btDiscreteDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@@Z"]
    pub fn btDiscreteDynamicsWorld_debugDrawConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btDiscreteDynamicsWorld@@UEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setConstraintSolver@btDiscreteDynamicsWorld@@UEAAXPEAVbtConstraintSolver@@@Z"]
    pub fn btDiscreteDynamicsWorld_setConstraintSolver(
        this: *mut ::std::os::raw::c_void,
        solver: *mut btConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}?getConstraintSolver@btDiscreteDynamicsWorld@@UEAAPEAVbtConstraintSolver@@XZ"]
    pub fn btDiscreteDynamicsWorld_getConstraintSolver(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConstraintSolver;
}
extern "C" {
    #[link_name = "\u{1}?getNumConstraints@btDiscreteDynamicsWorld@@UEBAHXZ"]
    pub fn btDiscreteDynamicsWorld_getNumConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getConstraint@btDiscreteDynamicsWorld@@UEAAPEAVbtTypedConstraint@@H@Z"]
    pub fn btDiscreteDynamicsWorld_getConstraint(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}?getConstraint@btDiscreteDynamicsWorld@@UEBAPEBVbtTypedConstraint@@H@Z"]
    pub fn btDiscreteDynamicsWorld_getConstraint1(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *const btTypedConstraint;
}
extern "C" {
    /// the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
    #[link_name = "\u{1}?clearForces@btDiscreteDynamicsWorld@@UEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// apply gravity, call this once per timestep
    #[link_name = "\u{1}?applyGravity@btDiscreteDynamicsWorld@@UEAAXXZ"]
    pub fn btDiscreteDynamicsWorld_applyGravity(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// obsolete, use addAction instead
    #[link_name = "\u{1}?addVehicle@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_addVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {
    /// obsolete, use removeAction instead
    #[link_name = "\u{1}?removeVehicle@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {
    /// obsolete, use addAction instead
    #[link_name = "\u{1}?addCharacter@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_addCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
extern "C" {
    /// obsolete, use removeAction instead
    #[link_name = "\u{1}?removeCharacter@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btDiscreteDynamicsWorld_removeCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
extern "C" {
    /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
    #[link_name = "\u{1}?serialize@btDiscreteDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z"]
    pub fn btDiscreteDynamicsWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btElement {
    pub m_id: ::std::os::raw::c_int,
    pub m_sz: ::std::os::raw::c_int,
}
/// UnionFind calculates connected subsets
#[repr(C)]
#[derive(Debug)]
pub struct btUnionFind {
    pub m_elements: btAlignedObjectArray<btElement>,
}
extern "C" {
    #[link_name = "\u{1}?sortIslands@btUnionFind@@QEAAXXZ"]
    pub fn btUnionFind_sortIslands(this: *mut btUnionFind);
}
extern "C" {
    #[link_name = "\u{1}?reset@btUnionFind@@QEAAXH@Z"]
    pub fn btUnionFind_reset(this: *mut btUnionFind, N: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?allocate@btUnionFind@@QEAAXH@Z"]
    pub fn btUnionFind_allocate(this: *mut btUnionFind, N: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?Free@btUnionFind@@QEAAXXZ"]
    pub fn btUnionFind_Free(this: *mut btUnionFind);
}
extern "C" {
    #[link_name = "\u{1}??0btUnionFind@@QEAA@XZ"]
    pub fn btUnionFind_btUnionFind(this: *mut btUnionFind);
}
extern "C" {
    #[link_name = "\u{1}??_DbtUnionFind@@QEAAXXZ"]
    pub fn btUnionFind_btUnionFind_destructor(this: *mut btUnionFind);
}
impl btUnionFind {
    #[inline]
    pub unsafe fn sortIslands(&mut self) {
        btUnionFind_sortIslands(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, N: ::std::os::raw::c_int) {
        btUnionFind_reset(self, N)
    }
    #[inline]
    pub unsafe fn allocate(&mut self, N: ::std::os::raw::c_int) {
        btUnionFind_allocate(self, N)
    }
    #[inline]
    pub unsafe fn Free(&mut self) {
        btUnionFind_Free(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btUnionFind_btUnionFind(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btUnionFind_btUnionFind_destructor(self)
    }
}
#[repr(C)]
pub struct btSimulationIslandManager__bindgen_vtable(::std::os::raw::c_void);
/// SimulationIslandManager creates and handles simulation islands, using btUnionFind
#[repr(C)]
#[derive(Debug)]
pub struct btSimulationIslandManager {
    pub vtable_: *const btSimulationIslandManager__bindgen_vtable,
    pub m_unionFind: btUnionFind,
    pub m_islandmanifold: btAlignedObjectArray<*mut btPersistentManifold>,
    pub m_islandBodies: btAlignedObjectArray<*mut btCollisionObject>,
    pub m_splitIslands: bool,
}
#[repr(C)]
pub struct btSimulationIslandManager_IslandCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSimulationIslandManager_IslandCallback {
    pub vtable_: *const btSimulationIslandManager_IslandCallback__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}?initUnionFind@btSimulationIslandManager@@QEAAXH@Z"]
    pub fn btSimulationIslandManager_initUnionFind(
        this: *mut btSimulationIslandManager,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?findUnions@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z"]
    pub fn btSimulationIslandManager_findUnions(
        this: *mut btSimulationIslandManager,
        dispatcher: *mut btDispatcher,
        colWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildAndProcessIslands@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@PEAUIslandCallback@1@@Z"]
    pub fn btSimulationIslandManager_buildAndProcessIslands(
        this: *mut btSimulationIslandManager,
        dispatcher: *mut btDispatcher,
        collisionWorld: *mut btCollisionWorld,
        callback: *mut btSimulationIslandManager_IslandCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildIslands@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z"]
    pub fn btSimulationIslandManager_buildIslands(
        this: *mut btSimulationIslandManager,
        dispatcher: *mut btDispatcher,
        colWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSimulationIslandManager@@QEAA@XZ"]
    pub fn btSimulationIslandManager_btSimulationIslandManager(
        this: *mut btSimulationIslandManager,
    );
}
impl btSimulationIslandManager {
    #[inline]
    pub unsafe fn initUnionFind(&mut self, n: ::std::os::raw::c_int) {
        btSimulationIslandManager_initUnionFind(self, n)
    }
    #[inline]
    pub unsafe fn findUnions(
        &mut self,
        dispatcher: *mut btDispatcher,
        colWorld: *mut btCollisionWorld,
    ) {
        btSimulationIslandManager_findUnions(self, dispatcher, colWorld)
    }
    #[inline]
    pub unsafe fn buildAndProcessIslands(
        &mut self,
        dispatcher: *mut btDispatcher,
        collisionWorld: *mut btCollisionWorld,
        callback: *mut btSimulationIslandManager_IslandCallback,
    ) {
        btSimulationIslandManager_buildAndProcessIslands(self, dispatcher, collisionWorld, callback)
    }
    #[inline]
    pub unsafe fn buildIslands(
        &mut self,
        dispatcher: *mut btDispatcher,
        colWorld: *mut btCollisionWorld,
    ) {
        btSimulationIslandManager_buildIslands(self, dispatcher, colWorld)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimulationIslandManager_btSimulationIslandManager(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSimulationIslandManager@@QEAAXXZ"]
    pub fn btSimulationIslandManager_btSimulationIslandManager_destructor(
        this: *mut btSimulationIslandManager,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateActivationState@btSimulationIslandManager@@UEAAXPEAVbtCollisionWorld@@PEAVbtDispatcher@@@Z"]
    pub fn btSimulationIslandManager_updateActivationState(
        this: *mut ::std::os::raw::c_void,
        colWorld: *mut btCollisionWorld,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?storeIslandActivationState@btSimulationIslandManager@@UEAAXPEAVbtCollisionWorld@@@Z"]
    pub fn btSimulationIslandManager_storeIslandActivationState(
        this: *mut ::std::os::raw::c_void,
        world: *mut btCollisionWorld,
    );
}
///
/// SimulationIslandManagerMt -- Multithread capable version of SimulationIslandManager
/// Splits the world up into islands which can be solved in parallel.
/// In order to solve islands in parallel, an IslandDispatch function
/// must be provided which will dispatch calls to multiple threads.
/// The amount of parallelism that can be achieved depends on the number
/// of islands. If only a single island exists, then no parallelism is
/// possible.
///
#[repr(C)]
#[derive(Debug)]
pub struct btSimulationIslandManagerMt {
    pub _base: btSimulationIslandManager,
    pub m_allocatedIslands: btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
    pub m_activeIslands: btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
    pub m_freeIslands: btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
    pub m_lookupIslandFromId: btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
    pub m_batchIsland: *mut btSimulationIslandManagerMt_Island,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_batchIslandMinBodyCount: ::std::os::raw::c_int,
    pub m_islandDispatch: btSimulationIslandManagerMt_IslandDispatchFunc,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSimulationIslandManagerMt_Island {
    pub bodyArray: btAlignedObjectArray<*mut btCollisionObject>,
    pub manifoldArray: btAlignedObjectArray<*mut btPersistentManifold>,
    pub constraintArray: btAlignedObjectArray<*mut btTypedConstraint>,
    pub id: ::std::os::raw::c_int,
    pub isSleeping: bool,
}
extern "C" {
    #[link_name = "\u{1}?append@Island@btSimulationIslandManagerMt@@QEAAXAEBU12@@Z"]
    pub fn btSimulationIslandManagerMt_Island_append(
        this: *mut btSimulationIslandManagerMt_Island,
        other: *const btSimulationIslandManagerMt_Island,
    );
}
impl btSimulationIslandManagerMt_Island {
    #[inline]
    pub unsafe fn append(&mut self, other: *const btSimulationIslandManagerMt_Island) {
        btSimulationIslandManagerMt_Island_append(self, other)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSimulationIslandManagerMt_SolverParams {
    pub m_solverPool: *mut btConstraintSolver,
    pub m_solverMt: *mut btConstraintSolver,
    pub m_solverInfo: *mut btContactSolverInfo,
    pub m_debugDrawer: *mut btIDebugDraw,
    pub m_dispatcher: *mut btDispatcher,
}
pub type btSimulationIslandManagerMt_IslandDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        islands: *mut btAlignedObjectArray<
            *mut btSimulationIslandManagerMt_Island,
        >,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?solveIsland@btSimulationIslandManagerMt@@SAXPEAVbtConstraintSolver@@AEAUIsland@1@AEBUSolverParams@1@@Z"]
    pub fn btSimulationIslandManagerMt_solveIsland(
        solver: *mut btConstraintSolver,
        island: *mut btSimulationIslandManagerMt_Island,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    );
}
extern "C" {
    #[link_name = "\u{1}?serialIslandDispatch@btSimulationIslandManagerMt@@SAXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@Z"]
    pub fn btSimulationIslandManagerMt_serialIslandDispatch(
        islandsPtr: *mut btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    );
}
extern "C" {
    #[link_name = "\u{1}?parallelIslandDispatch@btSimulationIslandManagerMt@@SAXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@Z"]
    pub fn btSimulationIslandManagerMt_parallelIslandDispatch(
        islandsPtr: *mut btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    );
}
extern "C" {
    #[link_name = "\u{1}?getIsland@btSimulationIslandManagerMt@@IEAAPEAUIsland@1@H@Z"]
    pub fn btSimulationIslandManagerMt_getIsland(
        this: *mut btSimulationIslandManagerMt,
        id: ::std::os::raw::c_int,
    ) -> *mut btSimulationIslandManagerMt_Island;
}
extern "C" {
    #[link_name = "\u{1}??0btSimulationIslandManagerMt@@QEAA@XZ"]
    pub fn btSimulationIslandManagerMt_btSimulationIslandManagerMt(
        this: *mut btSimulationIslandManagerMt,
    );
}
impl btSimulationIslandManagerMt {
    #[inline]
    pub unsafe fn solveIsland(
        solver: *mut btConstraintSolver,
        island: *mut btSimulationIslandManagerMt_Island,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    ) {
        btSimulationIslandManagerMt_solveIsland(solver, island, solverParams)
    }
    #[inline]
    pub unsafe fn serialIslandDispatch(
        islandsPtr: *mut btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    ) {
        btSimulationIslandManagerMt_serialIslandDispatch(islandsPtr, solverParams)
    }
    #[inline]
    pub unsafe fn parallelIslandDispatch(
        islandsPtr: *mut btAlignedObjectArray<*mut btSimulationIslandManagerMt_Island>,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    ) {
        btSimulationIslandManagerMt_parallelIslandDispatch(islandsPtr, solverParams)
    }
    #[inline]
    pub unsafe fn getIsland(
        &mut self,
        id: ::std::os::raw::c_int,
    ) -> *mut btSimulationIslandManagerMt_Island {
        btSimulationIslandManagerMt_getIsland(self, id)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimulationIslandManagerMt_btSimulationIslandManagerMt(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?allocateIsland@btSimulationIslandManagerMt@@MEAAPEAUIsland@1@HH@Z"]
    pub fn btSimulationIslandManagerMt_allocateIsland(
        this: *mut ::std::os::raw::c_void,
        id: ::std::os::raw::c_int,
        numBodies: ::std::os::raw::c_int,
    ) -> *mut btSimulationIslandManagerMt_Island;
}
extern "C" {
    #[link_name = "\u{1}?initIslandPools@btSimulationIslandManagerMt@@MEAAXXZ"]
    pub fn btSimulationIslandManagerMt_initIslandPools(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?addBodiesToIslands@btSimulationIslandManagerMt@@MEAAXPEAVbtCollisionWorld@@@Z"]
    pub fn btSimulationIslandManagerMt_addBodiesToIslands(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?addManifoldsToIslands@btSimulationIslandManagerMt@@MEAAXPEAVbtDispatcher@@@Z"]
    pub fn btSimulationIslandManagerMt_addManifoldsToIslands(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?addConstraintsToIslands@btSimulationIslandManagerMt@@MEAAXAEAV?$btAlignedObjectArray@PEAVbtTypedConstraint@@@@@Z"]
    pub fn btSimulationIslandManagerMt_addConstraintsToIslands(
        this: *mut ::std::os::raw::c_void,
        constraints: *mut btAlignedObjectArray<*mut btTypedConstraint>,
    );
}
extern "C" {
    #[link_name = "\u{1}?mergeIslands@btSimulationIslandManagerMt@@MEAAXXZ"]
    pub fn btSimulationIslandManagerMt_mergeIslands(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}??_DbtSimulationIslandManagerMt@@QEAAXXZ"]
    pub fn btSimulationIslandManagerMt_btSimulationIslandManagerMt_destructor(
        this: *mut btSimulationIslandManagerMt,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildAndProcessIslands@btSimulationIslandManagerMt@@UEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@AEAV?$btAlignedObjectArray@PEAVbtTypedConstraint@@@@AEBUSolverParams@1@@Z"]
    pub fn btSimulationIslandManagerMt_buildAndProcessIslands(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
        collisionWorld: *mut btCollisionWorld,
        constraints: *mut btAlignedObjectArray<*mut btTypedConstraint>,
        solverParams: *const btSimulationIslandManagerMt_SolverParams,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildIslands@btSimulationIslandManagerMt@@UEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z"]
    pub fn btSimulationIslandManagerMt_buildIslands(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
        colWorld: *mut btCollisionWorld,
    );
}
///
/// btConstraintSolverPoolMt - masquerades as a constraint solver, but really it is a threadsafe pool of them.
///
/// Each solver in the pool is protected by a mutex.  When solveGroup is called from a thread,
/// the pool looks for a solver that isn't being used by another thread, locks it, and dispatches the
/// call to the solver.
/// So long as there are at least as many solvers as there are hardware threads, it should never need to
/// spin wait.
///
#[repr(C)]
pub struct btConstraintSolverPoolMt {
    pub _base: btConstraintSolver,
    pub m_solvers: btAlignedObjectArray<btConstraintSolverPoolMt_ThreadSolver>,
    pub m_solverType: btConstraintSolverType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btConstraintSolverPoolMt_ThreadSolver {
    pub solver: *mut btConstraintSolver,
    pub mutex: btSpinMutex,
    pub _cachelinePadding: [::std::os::raw::c_char; 116usize],
}
pub const btConstraintSolverPoolMt_kCacheLineSize: usize = 128;
extern "C" {
    #[link_name = "\u{1}??0btConstraintSolverPoolMt@@QEAA@H@Z"]
    pub fn btConstraintSolverPoolMt_btConstraintSolverPoolMt(
        this: *mut btConstraintSolverPoolMt,
        numSolvers: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConstraintSolverPoolMt@@QEAA@PEAPEAVbtConstraintSolver@@H@Z"]
    pub fn btConstraintSolverPoolMt_btConstraintSolverPoolMt1(
        this: *mut btConstraintSolverPoolMt,
        solvers: *mut *mut btConstraintSolver,
        numSolvers: ::std::os::raw::c_int,
    );
}
impl btConstraintSolverPoolMt {
    #[inline]
    pub unsafe fn new(numSolvers: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConstraintSolverPoolMt_btConstraintSolverPoolMt(&mut __bindgen_tmp, numSolvers);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        solvers: *mut *mut btConstraintSolver,
        numSolvers: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConstraintSolverPoolMt_btConstraintSolverPoolMt1(&mut __bindgen_tmp, solvers, numSolvers);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtConstraintSolverPoolMt@@QEAAXXZ"]
    pub fn btConstraintSolverPoolMt_btConstraintSolverPoolMt_destructor(
        this: *mut btConstraintSolverPoolMt,
    );
}
extern "C" {
    /// solve a group of constraints
    #[link_name = "\u{1}?solveGroup@btConstraintSolverPoolMt@@UEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z"]
    pub fn btConstraintSolverPoolMt_solveGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifolds: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?reset@btConstraintSolverPoolMt@@UEAAXXZ"]
    pub fn btConstraintSolverPoolMt_reset(this: *mut ::std::os::raw::c_void);
}
///
/// btDiscreteDynamicsWorldMt -- a version of DiscreteDynamicsWorld with some minor changes to support
/// solving simulation islands on multiple threads.
///
/// Should function exactly like btDiscreteDynamicsWorld.
/// Also 3 methods that iterate over all of the rigidbodies can run in parallel:
/// - predictUnconstraintMotion
/// - integrateTransforms
/// - createPredictiveContacts
///
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteDynamicsWorldMt {
    pub _base: btDiscreteDynamicsWorld,
    pub m_constraintSolverMt: *mut btConstraintSolver,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteDynamicsWorldMt_UpdaterCreatePredictiveContacts {
    pub _base: btIParallelForBody,
    pub timeStep: btScalar,
    pub rigidBodies: *mut *mut btRigidBody,
    pub world: *mut btDiscreteDynamicsWorldMt,
}
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteDynamicsWorldMt_UpdaterIntegrateTransforms {
    pub _base: btIParallelForBody,
    pub timeStep: btScalar,
    pub rigidBodies: *mut *mut btRigidBody,
    pub world: *mut btDiscreteDynamicsWorldMt,
}
extern "C" {
    #[link_name = "\u{1}??0btDiscreteDynamicsWorldMt@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolverPoolMt@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btDiscreteDynamicsWorldMt_btDiscreteDynamicsWorldMt(
        this: *mut btDiscreteDynamicsWorldMt,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolverPoolMt,
        constraintSolverMt: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btDiscreteDynamicsWorldMt {
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolverPoolMt,
        constraintSolverMt: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDiscreteDynamicsWorldMt_btDiscreteDynamicsWorldMt(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            constraintSolverMt,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?solveConstraints@btDiscreteDynamicsWorldMt@@MEAAXAEAUbtContactSolverInfo@@@Z"]
    pub fn btDiscreteDynamicsWorldMt_solveConstraints(
        this: *mut ::std::os::raw::c_void,
        solverInfo: *mut btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?predictUnconstraintMotion@btDiscreteDynamicsWorldMt@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorldMt_predictUnconstraintMotion(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?createPredictiveContacts@btDiscreteDynamicsWorldMt@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorldMt_createPredictiveContacts(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?integrateTransforms@btDiscreteDynamicsWorldMt@@MEAAXN@Z"]
    pub fn btDiscreteDynamicsWorldMt_integrateTransforms(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtDiscreteDynamicsWorldMt@@QEAAXXZ"]
    pub fn btDiscreteDynamicsWorldMt_btDiscreteDynamicsWorldMt_destructor(
        this: *mut btDiscreteDynamicsWorldMt,
    );
}
extern "C" {
    #[link_name = "\u{1}?stepSimulation@btDiscreteDynamicsWorldMt@@UEAAHNHN@Z"]
    pub fn btDiscreteDynamicsWorldMt_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btMultiBodySolverConstraint {
    pub m_deltaVelAindex: ::std::os::raw::c_int,
    pub m_jacAindex: ::std::os::raw::c_int,
    pub m_deltaVelBindex: ::std::os::raw::c_int,
    pub m_jacBindex: ::std::os::raw::c_int,
    pub m_relpos1CrossNormal: btVector3,
    pub m_contactNormal1: btVector3,
    pub m_relpos2CrossNormal: btVector3,
    pub m_contactNormal2: btVector3,
    pub m_angularComponentA: btVector3,
    pub m_angularComponentB: btVector3,
    pub m_appliedPushImpulse: btScalar,
    pub m_appliedImpulse: btScalar,
    pub m_friction: btScalar,
    pub m_jacDiagABInv: btScalar,
    pub m_rhs: btScalar,
    pub m_cfm: btScalar,
    pub m_lowerLimit: btScalar,
    pub m_upperLimit: btScalar,
    pub m_rhsPenetration: btScalar,
    pub __bindgen_anon_1: btMultiBodySolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_multiBodyA: *mut btMultiBody,
    pub m_linkA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
    pub m_multiBodyB: *mut btMultiBody,
    pub m_linkB: ::std::os::raw::c_int,
    pub m_orgConstraint: *mut btMultiBodyConstraint,
    pub m_orgDofIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btMultiBodySolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_unusedPadding4: btScalar,
    _bindgen_union_align: u64,
}
pub const btMultiBodySolverConstraint_btSolverConstraintType_BT_SOLVER_CONTACT_1D:
    btMultiBodySolverConstraint_btSolverConstraintType = 0;
pub const btMultiBodySolverConstraint_btSolverConstraintType_BT_SOLVER_FRICTION_1D:
    btMultiBodySolverConstraint_btSolverConstraintType = 1;
pub type btMultiBodySolverConstraint_btSolverConstraintType = i32;
pub type btMultiBodyConstraintArray = btAlignedObjectArray<btMultiBodySolverConstraint>;
pub const btMultiBodyLinkFlags_BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION:
    btMultiBodyLinkFlags = 1;
pub const btMultiBodyLinkFlags_BT_MULTIBODYLINKFLAGS_DISABLE_ALL_PARENT_COLLISION:
    btMultiBodyLinkFlags = 2;
pub type btMultiBodyLinkFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSpatialForceVector {
    pub m_topVec: btVector3,
    pub m_bottomVec: btVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSpatialMotionVector {
    pub m_topVec: btVector3,
    pub m_bottomVec: btVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSymmetricSpatialDyad {
    pub m_topLeftMat: btMatrix3x3,
    pub m_topRightMat: btMatrix3x3,
    pub m_bottomLeftMat: btMatrix3x3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSpatialTransformationMatrix {
    pub m_rotMat: btMatrix3x3,
    pub m_trnVec: btVector3,
}
pub const btSpatialTransformationMatrix_eOutputOperation_None:
    btSpatialTransformationMatrix_eOutputOperation = 0;
pub const btSpatialTransformationMatrix_eOutputOperation_Add:
    btSpatialTransformationMatrix_eOutputOperation = 1;
pub const btSpatialTransformationMatrix_eOutputOperation_Subtract:
    btSpatialTransformationMatrix_eOutputOperation = 2;
pub type btSpatialTransformationMatrix_eOutputOperation = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultibodyLink {
    pub m_mass: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_inertiaLocal: btVector3,
    pub m_parent: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u64,
    pub m_zeroRotParentToThis: btQuaternion,
    pub m_dVector: btVector3,
    pub m_eVector: btVector3,
    pub m_absFrameTotVelocity: btSpatialMotionVector,
    pub m_absFrameLocVelocity: btSpatialMotionVector,
    pub m_axes: [btSpatialMotionVector; 6usize],
    pub m_dofOffset: ::std::os::raw::c_int,
    pub m_cfgOffset: ::std::os::raw::c_int,
    pub __bindgen_padding_2: u64,
    pub m_cachedRotParentToThis: btQuaternion,
    pub m_cachedRVector: btVector3,
    pub m_appliedForce: btVector3,
    pub m_appliedTorque: btVector3,
    pub m_appliedConstraintForce: btVector3,
    pub m_appliedConstraintTorque: btVector3,
    pub m_jointPos: [btScalar; 7usize],
    pub m_jointTorque: [btScalar; 6usize],
    pub m_collider: *mut btMultiBodyLinkCollider,
    pub m_flags: ::std::os::raw::c_int,
    pub m_dofCount: ::std::os::raw::c_int,
    pub m_posVarCount: ::std::os::raw::c_int,
    pub m_jointType: btMultibodyLink_eFeatherstoneJointType,
    pub m_jointFeedback: *mut btMultiBodyJointFeedback,
    pub __bindgen_padding_3: u64,
    pub m_cachedWorldTransform: btTransform,
    pub m_linkName: *const ::std::os::raw::c_char,
    pub m_jointName: *const ::std::os::raw::c_char,
    pub m_userPtr: *const ::std::os::raw::c_void,
    pub m_jointDamping: btScalar,
    pub m_jointFriction: btScalar,
    pub m_jointLowerLimit: btScalar,
    pub m_jointUpperLimit: btScalar,
    pub m_jointMaxForce: btScalar,
    pub m_jointMaxVelocity: btScalar,
    pub __bindgen_padding_4: u64,
}
pub const btMultibodyLink_eFeatherstoneJointType_eRevolute: btMultibodyLink_eFeatherstoneJointType =
    0;
pub const btMultibodyLink_eFeatherstoneJointType_ePrismatic:
    btMultibodyLink_eFeatherstoneJointType = 1;
pub const btMultibodyLink_eFeatherstoneJointType_eSpherical:
    btMultibodyLink_eFeatherstoneJointType = 2;
pub const btMultibodyLink_eFeatherstoneJointType_ePlanar: btMultibodyLink_eFeatherstoneJointType =
    3;
pub const btMultibodyLink_eFeatherstoneJointType_eFixed: btMultibodyLink_eFeatherstoneJointType = 4;
pub const btMultibodyLink_eFeatherstoneJointType_eInvalid: btMultibodyLink_eFeatherstoneJointType =
    5;
pub type btMultibodyLink_eFeatherstoneJointType = i32;
#[repr(C)]
pub struct btMultiBody__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBody {
    pub vtable_: *const btMultiBody__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_baseCollider: *mut btMultiBodyLinkCollider,
    pub m_baseName: *const ::std::os::raw::c_char,
    pub m_basePos: btVector3,
    pub m_baseQuat: btQuaternion,
    pub m_baseMass: btScalar,
    pub __bindgen_padding_1: u64,
    pub m_baseInertia: btVector3,
    pub m_baseForce: btVector3,
    pub m_baseTorque: btVector3,
    pub m_baseConstraintForce: btVector3,
    pub m_baseConstraintTorque: btVector3,
    pub m_links: btAlignedObjectArray<btMultibodyLink>,
    pub m_deltaV: btAlignedObjectArray<btScalar>,
    pub m_realBuf: btAlignedObjectArray<btScalar>,
    pub m_vectorBuf: btAlignedObjectArray<btVector3>,
    pub m_matrixBuf: btAlignedObjectArray<btMatrix3x3>,
    pub m_cachedInertiaTopLeft: btMatrix3x3,
    pub m_cachedInertiaTopRight: btMatrix3x3,
    pub m_cachedInertiaLowerLeft: btMatrix3x3,
    pub m_cachedInertiaLowerRight: btMatrix3x3,
    pub m_cachedInertiaValid: bool,
    pub m_fixedBase: bool,
    pub m_awake: bool,
    pub m_canSleep: bool,
    pub m_sleepTimer: btScalar,
    pub m_userObjectPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex2: ::std::os::raw::c_int,
    pub m_userIndex: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    pub m_useGyroTerm: bool,
    pub m_maxAppliedImpulse: btScalar,
    pub m_maxCoordinateVelocity: btScalar,
    pub m_hasSelfCollision: bool,
    pub __posUpdated: bool,
    pub m_dofCount: ::std::os::raw::c_int,
    pub m_posVarCnt: ::std::os::raw::c_int,
    pub m_useRK4: bool,
    pub m_useGlobalVelocities: bool,
    /// the m_needsJointFeedback gets updated/computed during the stepVelocitiesMultiDof and it for internal usage only
    pub m_internalNeedsJointFeedback: bool,
    pub __bindgen_padding_2: u8,
}
extern "C" {
    #[link_name = "\u{1}?setupFixed@btMultiBody@@QEAAXHNAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z"]
    pub fn btMultiBody_setupFixed(
        this: *mut btMultiBody,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        deprecatedDisableParentCollision: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupPrismatic@btMultiBody@@QEAAXHNAEBVbtVector3@@HAEBVbtQuaternion@@000_N@Z"]
    pub fn btMultiBody_setupPrismatic(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        jointAxis: *const btVector3,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupRevolute@btMultiBody@@QEAAXHNAEBVbtVector3@@HAEBVbtQuaternion@@000_N@Z"]
    pub fn btMultiBody_setupRevolute(
        this: *mut btMultiBody,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parentIndex: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        jointAxis: *const btVector3,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupSpherical@btMultiBody@@QEAAXHNAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z"]
    pub fn btMultiBody_setupSpherical(
        this: *mut btMultiBody,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupPlanar@btMultiBody@@QEAAXHNAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z"]
    pub fn btMultiBody_setupPlanar(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        rotationAxis: *const btVector3,
        parentComToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?getParent@btMultiBody@@QEBAHH@Z"]
    pub fn btMultiBody_getParent(
        this: *const btMultiBody,
        link_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getLinkMass@btMultiBody@@QEBANH@Z"]
    pub fn btMultiBody_getLinkMass(this: *const btMultiBody, i: ::std::os::raw::c_int) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getLinkInertia@btMultiBody@@QEBAAEBVbtVector3@@H@Z"]
    pub fn btMultiBody_getLinkInertia(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getJointPos@btMultiBody@@QEBANH@Z"]
    pub fn btMultiBody_getJointPos(this: *const btMultiBody, i: ::std::os::raw::c_int) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointVel@btMultiBody@@QEBANH@Z"]
    pub fn btMultiBody_getJointVel(this: *const btMultiBody, i: ::std::os::raw::c_int) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointVelMultiDof@btMultiBody@@QEAAPEANH@Z"]
    pub fn btMultiBody_getJointVelMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *mut btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointPosMultiDof@btMultiBody@@QEAAPEANH@Z"]
    pub fn btMultiBody_getJointPosMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *mut btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointVelMultiDof@btMultiBody@@QEBAPEBNH@Z"]
    pub fn btMultiBody_getJointVelMultiDof1(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointPosMultiDof@btMultiBody@@QEBAPEBNH@Z"]
    pub fn btMultiBody_getJointPosMultiDof1(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setJointPos@btMultiBody@@QEAAXHN@Z"]
    pub fn btMultiBody_setJointPos(this: *mut btMultiBody, i: ::std::os::raw::c_int, q: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setJointVel@btMultiBody@@QEAAXHN@Z"]
    pub fn btMultiBody_setJointVel(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        qdot: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setJointPosMultiDof@btMultiBody@@QEAAXHPEAN@Z"]
    pub fn btMultiBody_setJointPosMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        q: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setJointVelMultiDof@btMultiBody@@QEAAXHPEAN@Z"]
    pub fn btMultiBody_setJointVelMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        qdot: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?getRVector@btMultiBody@@QEBAAEBVbtVector3@@H@Z"]
    pub fn btMultiBody_getRVector(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getParentToLocalRot@btMultiBody@@QEBAAEBVbtQuaternion@@H@Z"]
    pub fn btMultiBody_getParentToLocalRot(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}?localPosToWorld@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z"]
    pub fn btMultiBody_localPosToWorld(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localDirToWorld@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z"]
    pub fn btMultiBody_localDirToWorld(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?worldPosToLocal@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z"]
    pub fn btMultiBody_worldPosToLocal(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?worldDirToLocal@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z"]
    pub fn btMultiBody_worldDirToLocal(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localFrameToWorld@btMultiBody@@QEBA?AVbtMatrix3x3@@HAEBV2@@Z"]
    pub fn btMultiBody_localFrameToWorld(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
        mat: *const btMatrix3x3,
    ) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}?getKineticEnergy@btMultiBody@@QEBANXZ"]
    pub fn btMultiBody_getKineticEnergy(this: *const btMultiBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getAngularMomentum@btMultiBody@@QEBA?AVbtVector3@@XZ"]
    pub fn btMultiBody_getAngularMomentum(this: *const btMultiBody) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?clearForcesAndTorques@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_clearForcesAndTorques(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?clearConstraintForces@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_clearConstraintForces(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?clearVelocities@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_clearVelocities(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?addLinkForce@btMultiBody@@QEAAXHAEBVbtVector3@@@Z"]
    pub fn btMultiBody_addLinkForce(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        f: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?addLinkTorque@btMultiBody@@QEAAXHAEBVbtVector3@@@Z"]
    pub fn btMultiBody_addLinkTorque(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        t: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?addLinkConstraintForce@btMultiBody@@QEAAXHAEBVbtVector3@@@Z"]
    pub fn btMultiBody_addLinkConstraintForce(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        f: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?addLinkConstraintTorque@btMultiBody@@QEAAXHAEBVbtVector3@@@Z"]
    pub fn btMultiBody_addLinkConstraintTorque(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        t: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?addJointTorque@btMultiBody@@QEAAXHN@Z"]
    pub fn btMultiBody_addJointTorque(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        Q: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?addJointTorqueMultiDof@btMultiBody@@QEAAXHHN@Z"]
    pub fn btMultiBody_addJointTorqueMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        dof: ::std::os::raw::c_int,
        Q: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?addJointTorqueMultiDof@btMultiBody@@QEAAXHPEBN@Z"]
    pub fn btMultiBody_addJointTorqueMultiDof1(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
        Q: *const btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLinkForce@btMultiBody@@QEBAAEBVbtVector3@@H@Z"]
    pub fn btMultiBody_getLinkForce(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getLinkTorque@btMultiBody@@QEBAAEBVbtVector3@@H@Z"]
    pub fn btMultiBody_getLinkTorque(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getJointTorque@btMultiBody@@QEBANH@Z"]
    pub fn btMultiBody_getJointTorque(
        this: *const btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getJointTorqueMultiDof@btMultiBody@@QEAAPEANH@Z"]
    pub fn btMultiBody_getJointTorqueMultiDof(
        this: *mut btMultiBody,
        i: ::std::os::raw::c_int,
    ) -> *mut btScalar;
}
extern "C" {
    #[link_name = "\u{1}?computeAccelerationsArticulatedBodyAlgorithmMultiDof@btMultiBody@@QEAAXNAEAV?$btAlignedObjectArray@N@@AEAV?$btAlignedObjectArray@VbtVector3@@@@AEAV?$btAlignedObjectArray@VbtMatrix3x3@@@@_N@Z"]
    pub fn btMultiBody_computeAccelerationsArticulatedBodyAlgorithmMultiDof(
        this: *mut btMultiBody,
        dt: btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
        scratch_m: *mut btAlignedObjectArray<btMatrix3x3>,
        isConstraintPass: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?calcAccelerationDeltasMultiDof@btMultiBody@@QEBAXPEBNPEANAEAV?$btAlignedObjectArray@N@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z"]
    pub fn btMultiBody_calcAccelerationDeltasMultiDof(
        this: *const btMultiBody,
        force: *const btScalar,
        output: *mut btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?stepPositionsMultiDof@btMultiBody@@QEAAXNPEAN0@Z"]
    pub fn btMultiBody_stepPositionsMultiDof(
        this: *mut btMultiBody,
        dt: btScalar,
        pq: *mut btScalar,
        pqd: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?fillConstraintJacobianMultiDof@btMultiBody@@QEBAXHAEBVbtVector3@@00PEANAEAV?$btAlignedObjectArray@N@@AEAV?$btAlignedObjectArray@VbtVector3@@@@AEAV?$btAlignedObjectArray@VbtMatrix3x3@@@@@Z"]
    pub fn btMultiBody_fillConstraintJacobianMultiDof(
        this: *const btMultiBody,
        link: ::std::os::raw::c_int,
        contact_point: *const btVector3,
        normal_ang: *const btVector3,
        normal_lin: *const btVector3,
        jac: *mut btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
        scratch_m: *mut btAlignedObjectArray<btMatrix3x3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?wakeUp@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_wakeUp(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?goToSleep@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_goToSleep(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?checkMotionAndSleepIfRequired@btMultiBody@@QEAAXN@Z"]
    pub fn btMultiBody_checkMotionAndSleepIfRequired(this: *mut btMultiBody, timestep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_finalizeMultiDof(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?forwardKinematics@btMultiBody@@QEAAXAEAV?$btAlignedObjectArray@VbtQuaternion@@@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z"]
    pub fn btMultiBody_forwardKinematics(
        this: *mut btMultiBody,
        scratch_q: *mut btAlignedObjectArray<btQuaternion>,
        scratch_m: *mut btAlignedObjectArray<btVector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}?compTreeLinkVelocities@btMultiBody@@QEBAXPEAVbtVector3@@0@Z"]
    pub fn btMultiBody_compTreeLinkVelocities(
        this: *const btMultiBody,
        omega: *mut btVector3,
        vel: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateCollisionObjectWorldTransforms@btMultiBody@@QEAAXAEAV?$btAlignedObjectArray@VbtQuaternion@@@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z"]
    pub fn btMultiBody_updateCollisionObjectWorldTransforms(
        this: *mut btMultiBody,
        scratch_q: *mut btAlignedObjectArray<btQuaternion>,
        scratch_m: *mut btAlignedObjectArray<btVector3>,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBody@@QEAA@HNAEBVbtVector3@@_N11@Z"]
    pub fn btMultiBody_btMultiBody(
        this: *mut btMultiBody,
        n_links: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        fixedBase: bool,
        canSleep: bool,
        deprecatedMultiDof: bool,
    );
}
impl btMultiBody {
    #[inline]
    pub unsafe fn setupFixed(
        &mut self,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        deprecatedDisableParentCollision: bool,
    ) {
        btMultiBody_setupFixed(
            self,
            linkIndex,
            mass,
            inertia,
            parent,
            rotParentToThis,
            parentComToThisPivotOffset,
            thisPivotToThisComOffset,
            deprecatedDisableParentCollision,
        )
    }
    #[inline]
    pub unsafe fn setupPrismatic(
        &mut self,
        i: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        jointAxis: *const btVector3,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    ) {
        btMultiBody_setupPrismatic(
            self,
            i,
            mass,
            inertia,
            parent,
            rotParentToThis,
            jointAxis,
            parentComToThisPivotOffset,
            thisPivotToThisComOffset,
            disableParentCollision,
        )
    }
    #[inline]
    pub unsafe fn setupRevolute(
        &mut self,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parentIndex: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        jointAxis: *const btVector3,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    ) {
        btMultiBody_setupRevolute(
            self,
            linkIndex,
            mass,
            inertia,
            parentIndex,
            rotParentToThis,
            jointAxis,
            parentComToThisPivotOffset,
            thisPivotToThisComOffset,
            disableParentCollision,
        )
    }
    #[inline]
    pub unsafe fn setupSpherical(
        &mut self,
        linkIndex: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        parentComToThisPivotOffset: *const btVector3,
        thisPivotToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    ) {
        btMultiBody_setupSpherical(
            self,
            linkIndex,
            mass,
            inertia,
            parent,
            rotParentToThis,
            parentComToThisPivotOffset,
            thisPivotToThisComOffset,
            disableParentCollision,
        )
    }
    #[inline]
    pub unsafe fn setupPlanar(
        &mut self,
        i: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        parent: ::std::os::raw::c_int,
        rotParentToThis: *const btQuaternion,
        rotationAxis: *const btVector3,
        parentComToThisComOffset: *const btVector3,
        disableParentCollision: bool,
    ) {
        btMultiBody_setupPlanar(
            self,
            i,
            mass,
            inertia,
            parent,
            rotParentToThis,
            rotationAxis,
            parentComToThisComOffset,
            disableParentCollision,
        )
    }
    #[inline]
    pub unsafe fn getParent(&self, link_num: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        btMultiBody_getParent(self, link_num)
    }
    #[inline]
    pub unsafe fn getLinkMass(&self, i: ::std::os::raw::c_int) -> btScalar {
        btMultiBody_getLinkMass(self, i)
    }
    #[inline]
    pub unsafe fn getLinkInertia(&self, i: ::std::os::raw::c_int) -> *const btVector3 {
        btMultiBody_getLinkInertia(self, i)
    }
    #[inline]
    pub unsafe fn getJointPos(&self, i: ::std::os::raw::c_int) -> btScalar {
        btMultiBody_getJointPos(self, i)
    }
    #[inline]
    pub unsafe fn getJointVel(&self, i: ::std::os::raw::c_int) -> btScalar {
        btMultiBody_getJointVel(self, i)
    }
    #[inline]
    pub unsafe fn getJointVelMultiDof(&mut self, i: ::std::os::raw::c_int) -> *mut btScalar {
        btMultiBody_getJointVelMultiDof(self, i)
    }
    #[inline]
    pub unsafe fn getJointPosMultiDof(&mut self, i: ::std::os::raw::c_int) -> *mut btScalar {
        btMultiBody_getJointPosMultiDof(self, i)
    }
    #[inline]
    pub unsafe fn getJointVelMultiDof1(&self, i: ::std::os::raw::c_int) -> *const btScalar {
        btMultiBody_getJointVelMultiDof1(self, i)
    }
    #[inline]
    pub unsafe fn getJointPosMultiDof1(&self, i: ::std::os::raw::c_int) -> *const btScalar {
        btMultiBody_getJointPosMultiDof1(self, i)
    }
    #[inline]
    pub unsafe fn setJointPos(&mut self, i: ::std::os::raw::c_int, q: btScalar) {
        btMultiBody_setJointPos(self, i, q)
    }
    #[inline]
    pub unsafe fn setJointVel(&mut self, i: ::std::os::raw::c_int, qdot: btScalar) {
        btMultiBody_setJointVel(self, i, qdot)
    }
    #[inline]
    pub unsafe fn setJointPosMultiDof(&mut self, i: ::std::os::raw::c_int, q: *mut btScalar) {
        btMultiBody_setJointPosMultiDof(self, i, q)
    }
    #[inline]
    pub unsafe fn setJointVelMultiDof(&mut self, i: ::std::os::raw::c_int, qdot: *mut btScalar) {
        btMultiBody_setJointVelMultiDof(self, i, qdot)
    }
    #[inline]
    pub unsafe fn getRVector(&self, i: ::std::os::raw::c_int) -> *const btVector3 {
        btMultiBody_getRVector(self, i)
    }
    #[inline]
    pub unsafe fn getParentToLocalRot(&self, i: ::std::os::raw::c_int) -> *const btQuaternion {
        btMultiBody_getParentToLocalRot(self, i)
    }
    #[inline]
    pub unsafe fn localPosToWorld(
        &self,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3 {
        btMultiBody_localPosToWorld(self, i, vec)
    }
    #[inline]
    pub unsafe fn localDirToWorld(
        &self,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3 {
        btMultiBody_localDirToWorld(self, i, vec)
    }
    #[inline]
    pub unsafe fn worldPosToLocal(
        &self,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3 {
        btMultiBody_worldPosToLocal(self, i, vec)
    }
    #[inline]
    pub unsafe fn worldDirToLocal(
        &self,
        i: ::std::os::raw::c_int,
        vec: *const btVector3,
    ) -> btVector3 {
        btMultiBody_worldDirToLocal(self, i, vec)
    }
    #[inline]
    pub unsafe fn localFrameToWorld(
        &self,
        i: ::std::os::raw::c_int,
        mat: *const btMatrix3x3,
    ) -> btMatrix3x3 {
        btMultiBody_localFrameToWorld(self, i, mat)
    }
    #[inline]
    pub unsafe fn getKineticEnergy(&self) -> btScalar {
        btMultiBody_getKineticEnergy(self)
    }
    #[inline]
    pub unsafe fn getAngularMomentum(&self) -> btVector3 {
        btMultiBody_getAngularMomentum(self)
    }
    #[inline]
    pub unsafe fn clearForcesAndTorques(&mut self) {
        btMultiBody_clearForcesAndTorques(self)
    }
    #[inline]
    pub unsafe fn clearConstraintForces(&mut self) {
        btMultiBody_clearConstraintForces(self)
    }
    #[inline]
    pub unsafe fn clearVelocities(&mut self) {
        btMultiBody_clearVelocities(self)
    }
    #[inline]
    pub unsafe fn addLinkForce(&mut self, i: ::std::os::raw::c_int, f: *const btVector3) {
        btMultiBody_addLinkForce(self, i, f)
    }
    #[inline]
    pub unsafe fn addLinkTorque(&mut self, i: ::std::os::raw::c_int, t: *const btVector3) {
        btMultiBody_addLinkTorque(self, i, t)
    }
    #[inline]
    pub unsafe fn addLinkConstraintForce(&mut self, i: ::std::os::raw::c_int, f: *const btVector3) {
        btMultiBody_addLinkConstraintForce(self, i, f)
    }
    #[inline]
    pub unsafe fn addLinkConstraintTorque(
        &mut self,
        i: ::std::os::raw::c_int,
        t: *const btVector3,
    ) {
        btMultiBody_addLinkConstraintTorque(self, i, t)
    }
    #[inline]
    pub unsafe fn addJointTorque(&mut self, i: ::std::os::raw::c_int, Q: btScalar) {
        btMultiBody_addJointTorque(self, i, Q)
    }
    #[inline]
    pub unsafe fn addJointTorqueMultiDof(
        &mut self,
        i: ::std::os::raw::c_int,
        dof: ::std::os::raw::c_int,
        Q: btScalar,
    ) {
        btMultiBody_addJointTorqueMultiDof(self, i, dof, Q)
    }
    #[inline]
    pub unsafe fn addJointTorqueMultiDof1(&mut self, i: ::std::os::raw::c_int, Q: *const btScalar) {
        btMultiBody_addJointTorqueMultiDof1(self, i, Q)
    }
    #[inline]
    pub unsafe fn getLinkForce(&self, i: ::std::os::raw::c_int) -> *const btVector3 {
        btMultiBody_getLinkForce(self, i)
    }
    #[inline]
    pub unsafe fn getLinkTorque(&self, i: ::std::os::raw::c_int) -> *const btVector3 {
        btMultiBody_getLinkTorque(self, i)
    }
    #[inline]
    pub unsafe fn getJointTorque(&self, i: ::std::os::raw::c_int) -> btScalar {
        btMultiBody_getJointTorque(self, i)
    }
    #[inline]
    pub unsafe fn getJointTorqueMultiDof(&mut self, i: ::std::os::raw::c_int) -> *mut btScalar {
        btMultiBody_getJointTorqueMultiDof(self, i)
    }
    #[inline]
    pub unsafe fn computeAccelerationsArticulatedBodyAlgorithmMultiDof(
        &mut self,
        dt: btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
        scratch_m: *mut btAlignedObjectArray<btMatrix3x3>,
        isConstraintPass: bool,
    ) {
        btMultiBody_computeAccelerationsArticulatedBodyAlgorithmMultiDof(
            self,
            dt,
            scratch_r,
            scratch_v,
            scratch_m,
            isConstraintPass,
        )
    }
    #[inline]
    pub unsafe fn calcAccelerationDeltasMultiDof(
        &self,
        force: *const btScalar,
        output: *mut btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
    ) {
        btMultiBody_calcAccelerationDeltasMultiDof(self, force, output, scratch_r, scratch_v)
    }
    #[inline]
    pub unsafe fn stepPositionsMultiDof(
        &mut self,
        dt: btScalar,
        pq: *mut btScalar,
        pqd: *mut btScalar,
    ) {
        btMultiBody_stepPositionsMultiDof(self, dt, pq, pqd)
    }
    #[inline]
    pub unsafe fn fillConstraintJacobianMultiDof(
        &self,
        link: ::std::os::raw::c_int,
        contact_point: *const btVector3,
        normal_ang: *const btVector3,
        normal_lin: *const btVector3,
        jac: *mut btScalar,
        scratch_r: *mut btAlignedObjectArray<btScalar>,
        scratch_v: *mut btAlignedObjectArray<btVector3>,
        scratch_m: *mut btAlignedObjectArray<btMatrix3x3>,
    ) {
        btMultiBody_fillConstraintJacobianMultiDof(
            self,
            link,
            contact_point,
            normal_ang,
            normal_lin,
            jac,
            scratch_r,
            scratch_v,
            scratch_m,
        )
    }
    #[inline]
    pub unsafe fn wakeUp(&mut self) {
        btMultiBody_wakeUp(self)
    }
    #[inline]
    pub unsafe fn goToSleep(&mut self) {
        btMultiBody_goToSleep(self)
    }
    #[inline]
    pub unsafe fn checkMotionAndSleepIfRequired(&mut self, timestep: btScalar) {
        btMultiBody_checkMotionAndSleepIfRequired(self, timestep)
    }
    #[inline]
    pub unsafe fn finalizeMultiDof(&mut self) {
        btMultiBody_finalizeMultiDof(self)
    }
    #[inline]
    pub unsafe fn forwardKinematics(
        &mut self,
        scratch_q: *mut btAlignedObjectArray<btQuaternion>,
        scratch_m: *mut btAlignedObjectArray<btVector3>,
    ) {
        btMultiBody_forwardKinematics(self, scratch_q, scratch_m)
    }
    #[inline]
    pub unsafe fn compTreeLinkVelocities(&self, omega: *mut btVector3, vel: *mut btVector3) {
        btMultiBody_compTreeLinkVelocities(self, omega, vel)
    }
    #[inline]
    pub unsafe fn updateCollisionObjectWorldTransforms(
        &mut self,
        scratch_q: *mut btAlignedObjectArray<btQuaternion>,
        scratch_m: *mut btAlignedObjectArray<btVector3>,
    ) {
        btMultiBody_updateCollisionObjectWorldTransforms(self, scratch_q, scratch_m)
    }
    #[inline]
    pub unsafe fn new(
        n_links: ::std::os::raw::c_int,
        mass: btScalar,
        inertia: *const btVector3,
        fixedBase: bool,
        canSleep: bool,
        deprecatedMultiDof: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBody_btMultiBody(
            &mut __bindgen_tmp,
            n_links,
            mass,
            inertia,
            fixedBase,
            canSleep,
            deprecatedMultiDof,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBody@@QEAAXXZ"]
    pub fn btMultiBody_btMultiBody_destructor(this: *mut btMultiBody);
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btMultiBody@@UEBAHXZ"]
    pub fn btMultiBody_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btMultiBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btMultiBody_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyLinkDoubleData {
    pub m_zeroRotParentToThis: btQuaternionDoubleData,
    pub m_parentComToThisPivotOffset: btVector3DoubleData,
    pub m_thisPivotToThisComOffset: btVector3DoubleData,
    pub m_jointAxisTop: [btVector3DoubleData; 6usize],
    pub m_jointAxisBottom: [btVector3DoubleData; 6usize],
    pub m_linkInertia: btVector3DoubleData,
    pub m_absFrameTotVelocityTop: btVector3DoubleData,
    pub m_absFrameTotVelocityBottom: btVector3DoubleData,
    pub m_absFrameLocVelocityTop: btVector3DoubleData,
    pub m_absFrameLocVelocityBottom: btVector3DoubleData,
    pub m_linkMass: f64,
    pub m_parentIndex: ::std::os::raw::c_int,
    pub m_jointType: ::std::os::raw::c_int,
    pub m_dofCount: ::std::os::raw::c_int,
    pub m_posVarCount: ::std::os::raw::c_int,
    pub m_jointPos: [f64; 7usize],
    pub m_jointVel: [f64; 6usize],
    pub m_jointTorque: [f64; 6usize],
    pub m_jointDamping: f64,
    pub m_jointFriction: f64,
    pub m_jointLowerLimit: f64,
    pub m_jointUpperLimit: f64,
    pub m_jointMaxForce: f64,
    pub m_jointMaxVelocity: f64,
    pub m_linkName: *mut ::std::os::raw::c_char,
    pub m_jointName: *mut ::std::os::raw::c_char,
    pub m_linkCollider: *mut btCollisionObjectDoubleData,
    pub m_paddingPtr: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyLinkFloatData {
    pub m_zeroRotParentToThis: btQuaternionFloatData,
    pub m_parentComToThisPivotOffset: btVector3FloatData,
    pub m_thisPivotToThisComOffset: btVector3FloatData,
    pub m_jointAxisTop: [btVector3FloatData; 6usize],
    pub m_jointAxisBottom: [btVector3FloatData; 6usize],
    pub m_linkInertia: btVector3FloatData,
    pub m_absFrameTotVelocityTop: btVector3FloatData,
    pub m_absFrameTotVelocityBottom: btVector3FloatData,
    pub m_absFrameLocVelocityTop: btVector3FloatData,
    pub m_absFrameLocVelocityBottom: btVector3FloatData,
    pub m_dofCount: ::std::os::raw::c_int,
    pub m_linkMass: f32,
    pub m_parentIndex: ::std::os::raw::c_int,
    pub m_jointType: ::std::os::raw::c_int,
    pub m_jointPos: [f32; 7usize],
    pub m_jointVel: [f32; 6usize],
    pub m_jointTorque: [f32; 6usize],
    pub m_posVarCount: ::std::os::raw::c_int,
    pub m_jointDamping: f32,
    pub m_jointFriction: f32,
    pub m_jointLowerLimit: f32,
    pub m_jointUpperLimit: f32,
    pub m_jointMaxForce: f32,
    pub m_jointMaxVelocity: f32,
    pub m_linkName: *mut ::std::os::raw::c_char,
    pub m_jointName: *mut ::std::os::raw::c_char,
    pub m_linkCollider: *mut btCollisionObjectFloatData,
    pub m_paddingPtr: *mut ::std::os::raw::c_char,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyDoubleData {
    pub m_baseWorldPosition: btVector3DoubleData,
    pub m_baseWorldOrientation: btQuaternionDoubleData,
    pub m_baseLinearVelocity: btVector3DoubleData,
    pub m_baseAngularVelocity: btVector3DoubleData,
    pub m_baseInertia: btVector3DoubleData,
    pub m_baseMass: f64,
    pub m_numLinks: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
    pub m_baseName: *mut ::std::os::raw::c_char,
    pub m_links: *mut btMultiBodyLinkDoubleData,
    pub m_baseCollider: *mut btCollisionObjectDoubleData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyFloatData {
    pub m_baseWorldPosition: btVector3FloatData,
    pub m_baseWorldOrientation: btQuaternionFloatData,
    pub m_baseLinearVelocity: btVector3FloatData,
    pub m_baseAngularVelocity: btVector3FloatData,
    pub m_baseInertia: btVector3FloatData,
    pub m_baseMass: f32,
    pub m_numLinks: ::std::os::raw::c_int,
    pub m_baseName: *mut ::std::os::raw::c_char,
    pub m_links: *mut btMultiBodyLinkFloatData,
    pub m_baseCollider: *mut btCollisionObjectFloatData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSolverInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyJacobianData {
    pub m_jacobians: btAlignedObjectArray<btScalar>,
    pub m_deltaVelocitiesUnitImpulse: btAlignedObjectArray<btScalar>,
    pub m_deltaVelocities: btAlignedObjectArray<btScalar>,
    pub scratch_r: btAlignedObjectArray<btScalar>,
    pub scratch_v: btAlignedObjectArray<btVector3>,
    pub scratch_m: btAlignedObjectArray<btMatrix3x3>,
    pub m_solverBodyPool: *mut btAlignedObjectArray<btSolverBody>,
    pub m_fixedBodyId: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct btMultiBodyConstraint__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyConstraint {
    pub vtable_: *const btMultiBodyConstraint__bindgen_vtable,
    pub m_bodyA: *mut btMultiBody,
    pub m_bodyB: *mut btMultiBody,
    pub m_linkA: ::std::os::raw::c_int,
    pub m_linkB: ::std::os::raw::c_int,
    pub m_numRows: ::std::os::raw::c_int,
    pub m_jacSizeA: ::std::os::raw::c_int,
    pub m_jacSizeBoth: ::std::os::raw::c_int,
    pub m_posOffset: ::std::os::raw::c_int,
    pub m_isUnilateral: bool,
    pub m_numDofsFinalized: ::std::os::raw::c_int,
    pub m_maxAppliedImpulse: btScalar,
    pub m_data: btAlignedObjectArray<btScalar>,
}
extern "C" {
    #[link_name = "\u{1}?applyDeltaVee@btMultiBodyConstraint@@IEAAXAEAUbtMultiBodyJacobianData@@PEANNHH@Z"]
    pub fn btMultiBodyConstraint_applyDeltaVee(
        this: *mut btMultiBodyConstraint,
        data: *mut btMultiBodyJacobianData,
        delta_vee: *mut btScalar,
        impulse: btScalar,
        velocityIndex: ::std::os::raw::c_int,
        ndof: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?fillMultiBodyConstraint@btMultiBodyConstraint@@IEAANAEAUbtMultiBodySolverConstraint@@AEAUbtMultiBodyJacobianData@@PEAN2AEBVbtVector3@@333NAEBUbtContactSolverInfo@@NN_NN5NN@Z"]
    pub fn btMultiBodyConstraint_fillMultiBodyConstraint(
        this: *mut btMultiBodyConstraint,
        solverConstraint: *mut btMultiBodySolverConstraint,
        data: *mut btMultiBodyJacobianData,
        jacOrgA: *mut btScalar,
        jacOrgB: *mut btScalar,
        constraintNormalAng: *const btVector3,
        constraintNormalLin: *const btVector3,
        posAworld: *const btVector3,
        posBworld: *const btVector3,
        posError: btScalar,
        infoGlobal: *const btContactSolverInfo,
        lowerLimit: btScalar,
        upperLimit: btScalar,
        angConstraint: bool,
        relaxation: btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?updateJacobianSizes@btMultiBodyConstraint@@QEAAXXZ"]
    pub fn btMultiBodyConstraint_updateJacobianSizes(this: *mut btMultiBodyConstraint);
}
extern "C" {
    #[link_name = "\u{1}?allocateJacobiansMultiDof@btMultiBodyConstraint@@QEAAXXZ"]
    pub fn btMultiBodyConstraint_allocateJacobiansMultiDof(this: *mut btMultiBodyConstraint);
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyConstraint@@QEAA@PEAVbtMultiBody@@0HHH_N@Z"]
    pub fn btMultiBodyConstraint_btMultiBodyConstraint(
        this: *mut btMultiBodyConstraint,
        bodyA: *mut btMultiBody,
        bodyB: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        linkB: ::std::os::raw::c_int,
        numRows: ::std::os::raw::c_int,
        isUnilateral: bool,
    );
}
impl btMultiBodyConstraint {
    #[inline]
    pub unsafe fn applyDeltaVee(
        &mut self,
        data: *mut btMultiBodyJacobianData,
        delta_vee: *mut btScalar,
        impulse: btScalar,
        velocityIndex: ::std::os::raw::c_int,
        ndof: ::std::os::raw::c_int,
    ) {
        btMultiBodyConstraint_applyDeltaVee(self, data, delta_vee, impulse, velocityIndex, ndof)
    }
    #[inline]
    pub unsafe fn fillMultiBodyConstraint(
        &mut self,
        solverConstraint: *mut btMultiBodySolverConstraint,
        data: *mut btMultiBodyJacobianData,
        jacOrgA: *mut btScalar,
        jacOrgB: *mut btScalar,
        constraintNormalAng: *const btVector3,
        constraintNormalLin: *const btVector3,
        posAworld: *const btVector3,
        posBworld: *const btVector3,
        posError: btScalar,
        infoGlobal: *const btContactSolverInfo,
        lowerLimit: btScalar,
        upperLimit: btScalar,
        angConstraint: bool,
        relaxation: btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> btScalar {
        btMultiBodyConstraint_fillMultiBodyConstraint(
            self,
            solverConstraint,
            data,
            jacOrgA,
            jacOrgB,
            constraintNormalAng,
            constraintNormalLin,
            posAworld,
            posBworld,
            posError,
            infoGlobal,
            lowerLimit,
            upperLimit,
            angConstraint,
            relaxation,
            isFriction,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn updateJacobianSizes(&mut self) {
        btMultiBodyConstraint_updateJacobianSizes(self)
    }
    #[inline]
    pub unsafe fn allocateJacobiansMultiDof(&mut self) {
        btMultiBodyConstraint_allocateJacobiansMultiDof(self)
    }
    #[inline]
    pub unsafe fn new(
        bodyA: *mut btMultiBody,
        bodyB: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        linkB: ::std::os::raw::c_int,
        numRows: ::std::os::raw::c_int,
        isUnilateral: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyConstraint_btMultiBodyConstraint(
            &mut __bindgen_tmp,
            bodyA,
            bodyB,
            linkA,
            linkB,
            numRows,
            isUnilateral,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyConstraint@@QEAAXXZ"]
    pub fn btMultiBodyConstraint_btMultiBodyConstraint_destructor(this: *mut btMultiBodyConstraint);
}
#[repr(C)]
pub struct btMultiBodyConstraintSolver {
    pub _base: btSequentialImpulseConstraintSolver,
    pub m_multiBodyNonContactConstraints: btMultiBodyConstraintArray,
    pub m_multiBodyNormalContactConstraints: btMultiBodyConstraintArray,
    pub m_multiBodyFrictionContactConstraints: btMultiBodyConstraintArray,
    pub m_multiBodyTorsionalFrictionContactConstraints: btMultiBodyConstraintArray,
    pub m_data: btMultiBodyJacobianData,
    pub m_tmpMultiBodyConstraints: *mut *mut btMultiBodyConstraint,
    pub m_tmpNumMultiBodyConstraints: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}?resolveSingleConstraintRowGeneric@btMultiBodyConstraintSolver@@IEAANAEBUbtMultiBodySolverConstraint@@@Z"]
    pub fn btMultiBodyConstraintSolver_resolveSingleConstraintRowGeneric(
        this: *mut btMultiBodyConstraintSolver,
        c: *const btMultiBodySolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resolveConeFrictionConstraintRows@btMultiBodyConstraintSolver@@IEAANAEBUbtMultiBodySolverConstraint@@0@Z"]
    pub fn btMultiBodyConstraintSolver_resolveConeFrictionConstraintRows(
        this: *mut btMultiBodyConstraintSolver,
        cA1: *const btMultiBodySolverConstraint,
        cB: *const btMultiBodySolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?addMultiBodyFrictionConstraint@btMultiBodyConstraintSolver@@IEAAAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@PEAVbtPersistentManifold@@HAEAVbtManifoldPoint@@PEAVbtCollisionObject@@3NAEBUbtContactSolverInfo@@NN@Z"]
    pub fn btMultiBodyConstraintSolver_addMultiBodyFrictionConstraint(
        this: *mut btMultiBodyConstraintSolver,
        normalAxis: *const btVector3,
        manifold: *mut btPersistentManifold,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btMultiBodySolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?addMultiBodyTorsionalFrictionConstraint@btMultiBodyConstraintSolver@@IEAAAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@PEAVbtPersistentManifold@@HAEAVbtManifoldPoint@@NPEAVbtCollisionObject@@3NAEBUbtContactSolverInfo@@NN@Z"]
    pub fn btMultiBodyConstraintSolver_addMultiBodyTorsionalFrictionConstraint(
        this: *mut btMultiBodyConstraintSolver,
        normalAxis: *const btVector3,
        manifold: *mut btPersistentManifold,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btMultiBodySolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}?setupMultiBodyJointLimitConstraint@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@PEAN1NNNAEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyConstraintSolver_setupMultiBodyJointLimitConstraint(
        this: *mut btMultiBodyConstraintSolver,
        constraintRow: *mut btMultiBodySolverConstraint,
        jacA: *mut btScalar,
        jacB: *mut btScalar,
        penetration: btScalar,
        combinedFrictionCoeff: btScalar,
        combinedRestitutionCoeff: btScalar,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupMultiBodyContactConstraint@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@AEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@AEAN_NNN@Z"]
    pub fn btMultiBodyConstraintSolver_setupMultiBodyContactConstraint(
        this: *mut btMultiBodyConstraintSolver,
        solverConstraint: *mut btMultiBodySolverConstraint,
        contactNormal: *const btVector3,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setupMultiBodyTorsionalFrictionConstraint@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@AEAVbtManifoldPoint@@NAEBUbtContactSolverInfo@@AEAN_NNN@Z"]
    pub fn btMultiBodyConstraintSolver_setupMultiBodyTorsionalFrictionConstraint(
        this: *mut btMultiBodyConstraintSolver,
        solverConstraint: *mut btMultiBodySolverConstraint,
        contactNormal: *const btVector3,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?convertMultiBodyContact@btMultiBodyConstraintSolver@@IEAAXPEAVbtPersistentManifold@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyConstraintSolver_convertMultiBodyContact(
        this: *mut btMultiBodyConstraintSolver,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?applyDeltaVee@btMultiBodyConstraintSolver@@IEAAXPEANNHH@Z"]
    pub fn btMultiBodyConstraintSolver_applyDeltaVee(
        this: *mut btMultiBodyConstraintSolver,
        deltaV: *mut btScalar,
        impulse: btScalar,
        velocityIndex: ::std::os::raw::c_int,
        ndof: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?writeBackSolverBodyToMultiBody@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@N@Z"]
    pub fn btMultiBodyConstraintSolver_writeBackSolverBodyToMultiBody(
        this: *mut btMultiBodyConstraintSolver,
        constraint: *mut btMultiBodySolverConstraint,
        deltaTime: btScalar,
    );
}
impl btMultiBodyConstraintSolver {
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGeneric(
        &mut self,
        c: *const btMultiBodySolverConstraint,
    ) -> btScalar {
        btMultiBodyConstraintSolver_resolveSingleConstraintRowGeneric(self, c)
    }
    #[inline]
    pub unsafe fn resolveConeFrictionConstraintRows(
        &mut self,
        cA1: *const btMultiBodySolverConstraint,
        cB: *const btMultiBodySolverConstraint,
    ) -> btScalar {
        btMultiBodyConstraintSolver_resolveConeFrictionConstraintRows(self, cA1, cB)
    }
    #[inline]
    pub unsafe fn addMultiBodyFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        manifold: *mut btPersistentManifold,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btMultiBodySolverConstraint {
        btMultiBodyConstraintSolver_addMultiBodyFrictionConstraint(
            self,
            normalAxis,
            manifold,
            frictionIndex,
            cp,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addMultiBodyTorsionalFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        manifold: *mut btPersistentManifold,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btMultiBodySolverConstraint {
        btMultiBodyConstraintSolver_addMultiBodyTorsionalFrictionConstraint(
            self,
            normalAxis,
            manifold,
            frictionIndex,
            cp,
            combinedTorsionalFriction,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupMultiBodyJointLimitConstraint(
        &mut self,
        constraintRow: *mut btMultiBodySolverConstraint,
        jacA: *mut btScalar,
        jacB: *mut btScalar,
        penetration: btScalar,
        combinedFrictionCoeff: btScalar,
        combinedRestitutionCoeff: btScalar,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btMultiBodyConstraintSolver_setupMultiBodyJointLimitConstraint(
            self,
            constraintRow,
            jacA,
            jacB,
            penetration,
            combinedFrictionCoeff,
            combinedRestitutionCoeff,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn setupMultiBodyContactConstraint(
        &mut self,
        solverConstraint: *mut btMultiBodySolverConstraint,
        contactNormal: *const btVector3,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btMultiBodyConstraintSolver_setupMultiBodyContactConstraint(
            self,
            solverConstraint,
            contactNormal,
            cp,
            infoGlobal,
            relaxation,
            isFriction,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupMultiBodyTorsionalFrictionConstraint(
        &mut self,
        solverConstraint: *mut btMultiBodySolverConstraint,
        contactNormal: *const btVector3,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        isFriction: bool,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btMultiBodyConstraintSolver_setupMultiBodyTorsionalFrictionConstraint(
            self,
            solverConstraint,
            contactNormal,
            cp,
            combinedTorsionalFriction,
            infoGlobal,
            relaxation,
            isFriction,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn convertMultiBodyContact(
        &mut self,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btMultiBodyConstraintSolver_convertMultiBodyContact(self, manifold, infoGlobal)
    }
    #[inline]
    pub unsafe fn applyDeltaVee(
        &mut self,
        deltaV: *mut btScalar,
        impulse: btScalar,
        velocityIndex: ::std::os::raw::c_int,
        ndof: ::std::os::raw::c_int,
    ) {
        btMultiBodyConstraintSolver_applyDeltaVee(self, deltaV, impulse, velocityIndex, ndof)
    }
    #[inline]
    pub unsafe fn writeBackSolverBodyToMultiBody(
        &mut self,
        constraint: *mut btMultiBodySolverConstraint,
        deltaTime: btScalar,
    ) {
        btMultiBodyConstraintSolver_writeBackSolverBodyToMultiBody(self, constraint, deltaTime)
    }
}
extern "C" {
    #[link_name = "\u{1}?convertContacts@btMultiBodyConstraintSolver@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyConstraintSolver_convertContacts(
        this: *mut ::std::os::raw::c_void,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@btMultiBodyConstraintSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btMultiBodyConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveSingleIteration@btMultiBodyConstraintSolver@@MEAANHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btMultiBodyConstraintSolver_solveSingleIteration(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    /// this method should not be called, it was just used during porting/integration of Featherstone btMultiBody, providing backwards compatibility but no support for btMultiBodyConstraint (only contact constraints)
    #[link_name = "\u{1}?solveGroup@btMultiBodyConstraintSolver@@UEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z"]
    pub fn btMultiBodyConstraintSolver_solveGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifold: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyFinish@btMultiBodyConstraintSolver@@UEAANPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveMultiBodyGroup@btMultiBodyConstraintSolver@@UEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HPEAPEAVbtMultiBodyConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z"]
    pub fn btMultiBodyConstraintSolver_solveMultiBodyGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifold: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        multiBodyConstraints: *mut *mut btMultiBodyConstraint,
        numMultiBodyConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyFixedConstraint {
    pub _base: btMultiBodyConstraint,
    pub m_rigidBodyA: *mut btRigidBody,
    pub m_rigidBodyB: *mut btRigidBody,
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
    pub m_frameInA: btMatrix3x3,
    pub m_frameInB: btMatrix3x3,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyFixedConstraint@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2AEBVbtMatrix3x3@@3@Z"]
    pub fn btMultiBodyFixedConstraint_btMultiBodyFixedConstraint(
        this: *mut btMultiBodyFixedConstraint,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyFixedConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@2@Z"]
    pub fn btMultiBodyFixedConstraint_btMultiBodyFixedConstraint1(
        this: *mut btMultiBodyFixedConstraint,
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    );
}
impl btMultiBodyFixedConstraint {
    #[inline]
    pub unsafe fn new(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyFixedConstraint_btMultiBodyFixedConstraint(
            &mut __bindgen_tmp,
            body,
            link,
            bodyB,
            pivotInA,
            pivotInB,
            frameInA,
            frameInB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyFixedConstraint_btMultiBodyFixedConstraint1(
            &mut __bindgen_tmp,
            bodyA,
            linkA,
            bodyB,
            linkB,
            pivotInA,
            pivotInB,
            frameInA,
            frameInB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyFixedConstraint@@QEAAXXZ"]
    pub fn btMultiBodyFixedConstraint_btMultiBodyFixedConstraint_destructor(
        this: *mut btMultiBodyFixedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodyFixedConstraint@@UEAAXXZ"]
    pub fn btMultiBodyFixedConstraint_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodyFixedConstraint@@UEBAHXZ"]
    pub fn btMultiBodyFixedConstraint_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodyFixedConstraint@@UEBAHXZ"]
    pub fn btMultiBodyFixedConstraint_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodyFixedConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyFixedConstraint_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDraw@btMultiBodyFixedConstraint@@UEAAXPEAVbtIDebugDraw@@@Z"]
    pub fn btMultiBodyFixedConstraint_debugDraw(
        this: *mut ::std::os::raw::c_void,
        drawer: *mut btIDebugDraw,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyGearConstraint {
    pub _base: btMultiBodyConstraint,
    pub m_rigidBodyA: *mut btRigidBody,
    pub m_rigidBodyB: *mut btRigidBody,
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
    pub m_frameInA: btMatrix3x3,
    pub m_frameInB: btMatrix3x3,
    pub m_gearRatio: btScalar,
    pub m_gearAuxLink: ::std::os::raw::c_int,
    pub m_erp: btScalar,
    pub m_relativePositionTarget: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyGearConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@2@Z"]
    pub fn btMultiBodyGearConstraint_btMultiBodyGearConstraint(
        this: *mut btMultiBodyGearConstraint,
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    );
}
impl btMultiBodyGearConstraint {
    #[inline]
    pub unsafe fn new(
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyGearConstraint_btMultiBodyGearConstraint(
            &mut __bindgen_tmp,
            bodyA,
            linkA,
            bodyB,
            linkB,
            pivotInA,
            pivotInB,
            frameInA,
            frameInB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyGearConstraint@@QEAAXXZ"]
    pub fn btMultiBodyGearConstraint_btMultiBodyGearConstraint_destructor(
        this: *mut btMultiBodyGearConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodyGearConstraint@@UEAAXXZ"]
    pub fn btMultiBodyGearConstraint_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodyGearConstraint@@UEBAHXZ"]
    pub fn btMultiBodyGearConstraint_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodyGearConstraint@@UEBAHXZ"]
    pub fn btMultiBodyGearConstraint_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodyGearConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyGearConstraint_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyJointFeedback {
    pub m_reactionForces: btSpatialForceVector,
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyJointLimitConstraint {
    pub _base: btMultiBodyConstraint,
    pub m_lowerBound: btScalar,
    pub m_upperBound: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyJointLimitConstraint@@QEAA@PEAVbtMultiBody@@HNN@Z"]
    pub fn btMultiBodyJointLimitConstraint_btMultiBodyJointLimitConstraint(
        this: *mut btMultiBodyJointLimitConstraint,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        lower: btScalar,
        upper: btScalar,
    );
}
impl btMultiBodyJointLimitConstraint {
    #[inline]
    pub unsafe fn new(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        lower: btScalar,
        upper: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyJointLimitConstraint_btMultiBodyJointLimitConstraint(
            &mut __bindgen_tmp,
            body,
            link,
            lower,
            upper,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyJointLimitConstraint@@QEAAXXZ"]
    pub fn btMultiBodyJointLimitConstraint_btMultiBodyJointLimitConstraint_destructor(
        this: *mut btMultiBodyJointLimitConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodyJointLimitConstraint@@UEAAXXZ"]
    pub fn btMultiBodyJointLimitConstraint_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodyJointLimitConstraint@@UEBAHXZ"]
    pub fn btMultiBodyJointLimitConstraint_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodyJointLimitConstraint@@UEBAHXZ"]
    pub fn btMultiBodyJointLimitConstraint_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodyJointLimitConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyJointLimitConstraint_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyJointMotor {
    pub _base: btMultiBodyConstraint,
    pub m_desiredVelocity: btScalar,
    pub m_desiredPosition: btScalar,
    pub m_kd: btScalar,
    pub m_kp: btScalar,
    pub m_erp: btScalar,
    pub m_rhsClamp: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyJointMotor@@QEAA@PEAVbtMultiBody@@HNN@Z"]
    pub fn btMultiBodyJointMotor_btMultiBodyJointMotor(
        this: *mut btMultiBodyJointMotor,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        desiredVelocity: btScalar,
        maxMotorImpulse: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyJointMotor@@QEAA@PEAVbtMultiBody@@HHNN@Z"]
    pub fn btMultiBodyJointMotor_btMultiBodyJointMotor1(
        this: *mut btMultiBodyJointMotor,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        linkDoF: ::std::os::raw::c_int,
        desiredVelocity: btScalar,
        maxMotorImpulse: btScalar,
    );
}
impl btMultiBodyJointMotor {
    #[inline]
    pub unsafe fn new(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        desiredVelocity: btScalar,
        maxMotorImpulse: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyJointMotor_btMultiBodyJointMotor(
            &mut __bindgen_tmp,
            body,
            link,
            desiredVelocity,
            maxMotorImpulse,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        linkDoF: ::std::os::raw::c_int,
        desiredVelocity: btScalar,
        maxMotorImpulse: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyJointMotor_btMultiBodyJointMotor1(
            &mut __bindgen_tmp,
            body,
            link,
            linkDoF,
            desiredVelocity,
            maxMotorImpulse,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyJointMotor@@QEAAXXZ"]
    pub fn btMultiBodyJointMotor_btMultiBodyJointMotor_destructor(this: *mut btMultiBodyJointMotor);
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodyJointMotor@@UEAAXXZ"]
    pub fn btMultiBodyJointMotor_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodyJointMotor@@UEBAHXZ"]
    pub fn btMultiBodyJointMotor_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodyJointMotor@@UEBAHXZ"]
    pub fn btMultiBodyJointMotor_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodyJointMotor@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyJointMotor_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyLinkCollider {
    pub _base: btCollisionObject,
    pub m_multiBody: *mut btMultiBody,
    pub m_link: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btMultiBodyLinkCollider@@UEBAHXZ"]
    pub fn btMultiBodyLinkCollider_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btMultiBodyLinkCollider@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btMultiBodyLinkCollider_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyLinkColliderFloatData {
    pub m_colObjData: btCollisionObjectFloatData,
    pub m_multiBody: *mut btMultiBodyFloatData,
    pub m_link: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiBodyLinkColliderDoubleData {
    pub m_colObjData: btCollisionObjectDoubleData,
    pub m_multiBody: *mut btMultiBodyDoubleData,
    pub m_link: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyPoint2Point {
    pub _base: btMultiBodyConstraint,
    pub m_rigidBodyA: *mut btRigidBody,
    pub m_rigidBodyB: *mut btRigidBody,
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyPoint2Point@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2@Z"]
    pub fn btMultiBodyPoint2Point_btMultiBodyPoint2Point(
        this: *mut btMultiBodyPoint2Point,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyPoint2Point@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1@Z"]
    pub fn btMultiBodyPoint2Point_btMultiBodyPoint2Point1(
        this: *mut btMultiBodyPoint2Point,
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    );
}
impl btMultiBodyPoint2Point {
    #[inline]
    pub unsafe fn new(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyPoint2Point_btMultiBodyPoint2Point(
            &mut __bindgen_tmp,
            body,
            link,
            bodyB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyPoint2Point_btMultiBodyPoint2Point1(
            &mut __bindgen_tmp,
            bodyA,
            linkA,
            bodyB,
            linkB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyPoint2Point@@QEAAXXZ"]
    pub fn btMultiBodyPoint2Point_btMultiBodyPoint2Point_destructor(
        this: *mut btMultiBodyPoint2Point,
    );
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodyPoint2Point@@UEAAXXZ"]
    pub fn btMultiBodyPoint2Point_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodyPoint2Point@@UEBAHXZ"]
    pub fn btMultiBodyPoint2Point_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodyPoint2Point@@UEBAHXZ"]
    pub fn btMultiBodyPoint2Point_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodyPoint2Point@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyPoint2Point_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDraw@btMultiBodyPoint2Point@@UEAAXPEAVbtIDebugDraw@@@Z"]
    pub fn btMultiBodyPoint2Point_debugDraw(
        this: *mut ::std::os::raw::c_void,
        drawer: *mut btIDebugDraw,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodySliderConstraint {
    pub _base: btMultiBodyConstraint,
    pub m_rigidBodyA: *mut btRigidBody,
    pub m_rigidBodyB: *mut btRigidBody,
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
    pub m_frameInA: btMatrix3x3,
    pub m_frameInB: btMatrix3x3,
    pub m_jointAxis: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodySliderConstraint@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2AEBVbtMatrix3x3@@32@Z"]
    pub fn btMultiBodySliderConstraint_btMultiBodySliderConstraint(
        this: *mut btMultiBodySliderConstraint,
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
        jointAxis: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodySliderConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@21@Z"]
    pub fn btMultiBodySliderConstraint_btMultiBodySliderConstraint1(
        this: *mut btMultiBodySliderConstraint,
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
        jointAxis: *const btVector3,
    );
}
impl btMultiBodySliderConstraint {
    #[inline]
    pub unsafe fn new(
        body: *mut btMultiBody,
        link: ::std::os::raw::c_int,
        bodyB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
        jointAxis: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodySliderConstraint_btMultiBodySliderConstraint(
            &mut __bindgen_tmp,
            body,
            link,
            bodyB,
            pivotInA,
            pivotInB,
            frameInA,
            frameInB,
            jointAxis,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        bodyA: *mut btMultiBody,
        linkA: ::std::os::raw::c_int,
        bodyB: *mut btMultiBody,
        linkB: ::std::os::raw::c_int,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        frameInA: *const btMatrix3x3,
        frameInB: *const btMatrix3x3,
        jointAxis: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodySliderConstraint_btMultiBodySliderConstraint1(
            &mut __bindgen_tmp,
            bodyA,
            linkA,
            bodyB,
            linkB,
            pivotInA,
            pivotInB,
            frameInA,
            frameInB,
            jointAxis,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodySliderConstraint@@QEAAXXZ"]
    pub fn btMultiBodySliderConstraint_btMultiBodySliderConstraint_destructor(
        this: *mut btMultiBodySliderConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?finalizeMultiDof@btMultiBodySliderConstraint@@UEAAXXZ"]
    pub fn btMultiBodySliderConstraint_finalizeMultiDof(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdA@btMultiBodySliderConstraint@@UEBAHXZ"]
    pub fn btMultiBodySliderConstraint_getIslandIdA(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getIslandIdB@btMultiBodySliderConstraint@@UEBAHXZ"]
    pub fn btMultiBodySliderConstraint_getIslandIdB(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?createConstraintRows@btMultiBodySliderConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodySliderConstraint_createConstraintRows(
        this: *mut ::std::os::raw::c_void,
        constraintRows: *mut btMultiBodyConstraintArray,
        data: *mut btMultiBodyJacobianData,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDraw@btMultiBodySliderConstraint@@UEAAXPEAVbtIDebugDraw@@@Z"]
    pub fn btMultiBodySliderConstraint_debugDraw(
        this: *mut ::std::os::raw::c_void,
        drawer: *mut btIDebugDraw,
    );
}
/// The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
#[repr(C)]
#[derive(Debug)]
pub struct btClock {
    pub m_data: *mut btClockData,
}
extern "C" {
    /// Resets the initial reference time.
    #[link_name = "\u{1}?reset@btClock@@QEAAXXZ"]
    pub fn btClock_reset(this: *mut btClock);
}
extern "C" {
    /// Returns the time in ms since the last call to reset or since
    /// /// the btClock was created.
    #[link_name = "\u{1}?getTimeMilliseconds@btClock@@QEAA_KXZ"]
    pub fn btClock_getTimeMilliseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    /// Returns the time in us since the last call to reset or since
    /// /// the Clock was created.
    #[link_name = "\u{1}?getTimeMicroseconds@btClock@@QEAA_KXZ"]
    pub fn btClock_getTimeMicroseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?getTimeNanoseconds@btClock@@QEAA_KXZ"]
    pub fn btClock_getTimeNanoseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    /// Returns the time in s since the last call to reset or since
    /// /// the Clock was created.
    #[link_name = "\u{1}?getTimeSeconds@btClock@@QEAANXZ"]
    pub fn btClock_getTimeSeconds(this: *mut btClock) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??0btClock@@QEAA@XZ"]
    pub fn btClock_btClock(this: *mut btClock);
}
extern "C" {
    #[link_name = "\u{1}??0btClock@@QEAA@AEBV0@@Z"]
    pub fn btClock_btClock1(this: *mut btClock, other: *const btClock);
}
extern "C" {
    #[link_name = "\u{1}??_DbtClock@@QEAAXXZ"]
    pub fn btClock_btClock_destructor(this: *mut btClock);
}
impl btClock {
    #[inline]
    pub unsafe fn reset(&mut self) {
        btClock_reset(self)
    }
    #[inline]
    pub unsafe fn getTimeMilliseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeMilliseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeMicroseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeMicroseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeNanoseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeNanoseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeSeconds(&mut self) -> btScalar {
        btClock_getTimeSeconds(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btClock_btClock(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(other: *const btClock) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btClock_btClock1(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btClock_btClock_destructor(self)
    }
}
pub type btEnterProfileZoneFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type btLeaveProfileZoneFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}?btGetCurrentEnterProfileZoneFunc@@YAP6AXPEBD@ZXZ"]
    pub fn btGetCurrentEnterProfileZoneFunc() -> btEnterProfileZoneFunc;
}
extern "C" {
    #[link_name = "\u{1}?btGetCurrentLeaveProfileZoneFunc@@YAP6AXXZXZ"]
    pub fn btGetCurrentLeaveProfileZoneFunc() -> btLeaveProfileZoneFunc;
}
extern "C" {
    #[link_name = "\u{1}?btSetCustomEnterProfileZoneFunc@@YAXP6AXPEBD@Z@Z"]
    pub fn btSetCustomEnterProfileZoneFunc(enterFunc: btEnterProfileZoneFunc);
}
extern "C" {
    #[link_name = "\u{1}?btSetCustomLeaveProfileZoneFunc@@YAXP6AXXZ@Z"]
    pub fn btSetCustomLeaveProfileZoneFunc(leaveFunc: btLeaveProfileZoneFunc);
}
extern "C" {
    #[link_name = "\u{1}?btQuickprofGetCurrentThreadIndex2@@YAIXZ"]
    pub fn btQuickprofGetCurrentThreadIndex2() -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIntSortPredicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct btVectorX<T> {
    pub m_storage: btAlignedObjectArray<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btMatrixX<T> {
    pub m_rows: ::std::os::raw::c_int,
    pub m_cols: ::std::os::raw::c_int,
    pub m_operations: ::std::os::raw::c_int,
    pub m_resizeOperations: ::std::os::raw::c_int,
    pub m_setElemOperations: ::std::os::raw::c_int,
    pub m_storage: btAlignedObjectArray<T>,
    pub m_rowNonZeroElements1: btAlignedObjectArray<btAlignedObjectArray<::std::os::raw::c_int>>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type btMatrixXf = btMatrixX<f32>;
pub type btVectorXf = btVectorX<f32>;
pub type btMatrixXd = btMatrixX<f64>;
pub type btVectorXd = btVectorX<f64>;
#[repr(C)]
pub struct btMLCPSolverInterface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btMLCPSolverInterface {
    pub vtable_: *const btMLCPSolverInterface__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug)]
pub struct btDantzigScratchMemory {
    pub m_scratch: btAlignedObjectArray<btScalar>,
    pub L: btAlignedObjectArray<btScalar>,
    pub d: btAlignedObjectArray<btScalar>,
    pub delta_w: btAlignedObjectArray<btScalar>,
    pub delta_x: btAlignedObjectArray<btScalar>,
    pub Dell: btAlignedObjectArray<btScalar>,
    pub ell: btAlignedObjectArray<btScalar>,
    pub Arows: btAlignedObjectArray<*mut btScalar>,
    pub p: btAlignedObjectArray<::std::os::raw::c_int>,
    pub C: btAlignedObjectArray<::std::os::raw::c_int>,
    pub state: btAlignedObjectArray<bool>,
}
extern "C" {
    #[link_name = "\u{1}?btSolveDantzigLCP@@YA_NHPEAN000H00PEAHAEAUbtDantzigScratchMemory@@@Z"]
    pub fn btSolveDantzigLCP(
        n: ::std::os::raw::c_int,
        A: *mut btScalar,
        x: *mut btScalar,
        b: *mut btScalar,
        w: *mut btScalar,
        nub: ::std::os::raw::c_int,
        lo: *mut btScalar,
        hi: *mut btScalar,
        findex: *mut ::std::os::raw::c_int,
        scratch: *mut btDantzigScratchMemory,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct btDantzigSolver {
    pub _base: btMLCPSolverInterface,
    pub m_acceptableUpperLimitSolution: btScalar,
    pub m_tempBuffer: btAlignedObjectArray<::std::os::raw::c_char>,
    pub m_A: btAlignedObjectArray<btScalar>,
    pub m_b: btAlignedObjectArray<btScalar>,
    pub m_x: btAlignedObjectArray<btScalar>,
    pub m_lo: btAlignedObjectArray<btScalar>,
    pub m_hi: btAlignedObjectArray<btScalar>,
    pub m_dependencies: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_scratchMemory: btDantzigScratchMemory,
}
extern "C" {
    pub fn btowc(_Ch: ::std::os::raw::c_int) -> wint_t;
}
#[repr(C)]
pub struct btLemkeAlgorithm__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btLemkeAlgorithm {
    pub vtable_: *const btLemkeAlgorithm__bindgen_vtable,
    pub m_M: btMatrixXd,
    pub m_q: btVectorXd,
    /// \brief number of steps until the Lemke algorithm found a solution
    pub steps: ::std::os::raw::c_uint,
    /// \brief define level of debug output
    pub DEBUGLEVEL: ::std::os::raw::c_int,
    /// \brief did the algorithm find a solution
    ///
    /// -1 : not successful
    /// 0 : successful
    pub info: ::std::os::raw::c_int,
}
extern "C" {
    /// \brief solve algorithm adapted from : Fast Implementation of Lemke’s Algorithm for Rigid Body Contact Simulation (John E. Lloyd)
    #[link_name = "\u{1}?solve@btLemkeAlgorithm@@QEAA?AU?$btVectorX@N@@I@Z"]
    pub fn btLemkeAlgorithm_solve(
        this: *mut btLemkeAlgorithm,
        maxloops: ::std::os::raw::c_uint,
    ) -> btVectorXd;
}
extern "C" {
    #[link_name = "\u{1}?findLexicographicMinimum@btLemkeAlgorithm@@IEAAHAEBU?$btMatrixX@N@@AEBH@Z"]
    pub fn btLemkeAlgorithm_findLexicographicMinimum(
        this: *mut btLemkeAlgorithm,
        A: *const btMatrixXd,
        pivotColIndex: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?LexicographicPositive@btLemkeAlgorithm@@IEAA_NAEBU?$btVectorX@N@@@Z"]
    pub fn btLemkeAlgorithm_LexicographicPositive(
        this: *mut btLemkeAlgorithm,
        v: *const btVectorXd,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?GaussJordanEliminationStep@btLemkeAlgorithm@@IEAAXAEAU?$btMatrixX@N@@HHAEBV?$btAlignedObjectArray@H@@@Z"]
    pub fn btLemkeAlgorithm_GaussJordanEliminationStep(
        this: *mut btLemkeAlgorithm,
        A: *mut btMatrixXd,
        pivotRowIndex: ::std::os::raw::c_int,
        pivotColumnIndex: ::std::os::raw::c_int,
        basis: *const btAlignedObjectArray<::std::os::raw::c_int>,
    );
}
extern "C" {
    #[link_name = "\u{1}?greaterZero@btLemkeAlgorithm@@IEAA_NAEBU?$btVectorX@N@@@Z"]
    pub fn btLemkeAlgorithm_greaterZero(
        this: *mut btLemkeAlgorithm,
        vector: *const btVectorXd,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?validBasis@btLemkeAlgorithm@@IEAA_NAEBV?$btAlignedObjectArray@H@@@Z"]
    pub fn btLemkeAlgorithm_validBasis(
        this: *mut btLemkeAlgorithm,
        basis: *const btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool;
}
impl btLemkeAlgorithm {
    #[inline]
    pub unsafe fn solve(&mut self, maxloops: ::std::os::raw::c_uint) -> btVectorXd {
        btLemkeAlgorithm_solve(self, maxloops)
    }
    #[inline]
    pub unsafe fn findLexicographicMinimum(
        &mut self,
        A: *const btMatrixXd,
        pivotColIndex: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btLemkeAlgorithm_findLexicographicMinimum(self, A, pivotColIndex)
    }
    #[inline]
    pub unsafe fn LexicographicPositive(&mut self, v: *const btVectorXd) -> bool {
        btLemkeAlgorithm_LexicographicPositive(self, v)
    }
    #[inline]
    pub unsafe fn GaussJordanEliminationStep(
        &mut self,
        A: *mut btMatrixXd,
        pivotRowIndex: ::std::os::raw::c_int,
        pivotColumnIndex: ::std::os::raw::c_int,
        basis: *const btAlignedObjectArray<::std::os::raw::c_int>,
    ) {
        btLemkeAlgorithm_GaussJordanEliminationStep(self, A, pivotRowIndex, pivotColumnIndex, basis)
    }
    #[inline]
    pub unsafe fn greaterZero(&mut self, vector: *const btVectorXd) -> bool {
        btLemkeAlgorithm_greaterZero(self, vector)
    }
    #[inline]
    pub unsafe fn validBasis(
        &mut self,
        basis: *const btAlignedObjectArray<::std::os::raw::c_int>,
    ) -> bool {
        btLemkeAlgorithm_validBasis(self, basis)
    }
}
/// The btLemkeSolver is based on "Fast Implementation of Lemke�s Algorithm for Rigid Body Contact Simulation (John E. Lloyd) "
/// It is a slower but more accurate solver. Increase the m_maxLoops for better convergence, at the cost of more CPU time.
/// The original implementation of the btLemkeAlgorithm was done by Kilian Grundl from the MBSim team
#[repr(C)]
#[derive(Debug)]
pub struct btLemkeSolver {
    pub _base: btMLCPSolverInterface,
    pub m_maxValue: btScalar,
    pub m_debugLevel: ::std::os::raw::c_int,
    pub m_maxLoops: ::std::os::raw::c_int,
    pub m_useLoHighBounds: bool,
}
#[repr(C)]
pub struct btMLCPSolver {
    pub _base: btSequentialImpulseConstraintSolver,
    pub m_A: btMatrixXd,
    pub m_b: btVectorXd,
    pub m_x: btVectorXd,
    pub m_lo: btVectorXd,
    pub m_hi: btVectorXd,
    /// when using 'split impulse' we solve two separate (M)LCPs
    pub m_bSplit: btVectorXd,
    pub m_xSplit: btVectorXd,
    pub m_bSplit1: btVectorXd,
    pub m_xSplit2: btVectorXd,
    pub m_limitDependencies: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_allConstraintPtrArray: btAlignedObjectArray<*mut btSolverConstraint>,
    pub m_solver: *mut btMLCPSolverInterface,
    pub m_fallback: ::std::os::raw::c_int,
    /// The following scratch variables are not stateful -- contents are cleared prior to each use.
    /// /// They are only cached here to avoid extra memory allocations and deallocations and to ensure
    /// /// that multiple instances of the solver can be run in parallel.
    pub m_scratchJ3: btMatrixXd,
    pub m_scratchJInvM3: btMatrixXd,
    pub m_scratchOfs: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_scratchMInv: btMatrixXd,
    pub m_scratchJ: btMatrixXd,
    pub m_scratchJTranspose: btMatrixXd,
    pub m_scratchTmp: btMatrixXd,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btMLCPSolver@@QEAA@PEAVbtMLCPSolverInterface@@@Z"]
    pub fn btMLCPSolver_btMLCPSolver(this: *mut btMLCPSolver, solver: *mut btMLCPSolverInterface);
}
impl btMLCPSolver {
    #[inline]
    pub unsafe fn new(solver: *mut btMLCPSolverInterface) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMLCPSolver_btMLCPSolver(&mut __bindgen_tmp, solver);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlySetup@btMLCPSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btMLCPSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?solveGroupCacheFriendlyIterations@btMLCPSolver@@MEAANPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z"]
    pub fn btMLCPSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?createMLCP@btMLCPSolver@@MEAAXAEBUbtContactSolverInfo@@@Z"]
    pub fn btMLCPSolver_createMLCP(
        this: *mut ::std::os::raw::c_void,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?createMLCPFast@btMLCPSolver@@MEAAXAEBUbtContactSolverInfo@@@Z"]
    pub fn btMLCPSolver_createMLCPFast(
        this: *mut ::std::os::raw::c_void,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveMLCP@btMLCPSolver@@MEAA_NAEBUbtContactSolverInfo@@@Z"]
    pub fn btMLCPSolver_solveMLCP(
        this: *mut ::std::os::raw::c_void,
        infoGlobal: *const btContactSolverInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??_DbtMLCPSolver@@QEAAXXZ"]
    pub fn btMLCPSolver_btMLCPSolver_destructor(this: *mut btMLCPSolver);
}
/// This solver is mainly for debug/learning purposes: it is functionally equivalent to the btSequentialImpulseConstraintSolver solver, but much slower (it builds the full LCP matrix)
#[repr(C)]
#[derive(Debug)]
pub struct btSolveProjectedGaussSeidel {
    pub _base: btMLCPSolverInterface,
    pub m_leastSquaresResidualThreshold: btScalar,
    pub m_leastSquaresResidual: btScalar,
}
pub type idScalar = btScalar;
pub type btSizeType = ::std::os::raw::c_int;
pub type b3AlignedAllocator_self_type = u8;
pub type b3AlignedAllocator_const_pointer<T> = *const T;
pub type b3AlignedAllocator_const_reference<T> = *const T;
pub type b3AlignedAllocator_pointer<T> = *mut T;
pub type b3AlignedAllocator_reference<T> = *mut T;
pub type b3AlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedAllocator_rebind {
    pub _address: u8,
}
pub type b3AlignedAllocator_rebind_other = u8;
/// The b3AlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct b3AlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AlignedObjectArray_less {
    pub _address: u8,
}
pub type idArrayIdx = ::std::os::raw::c_int;
pub type btInverseDynamics_matxx = btMatrixX<idScalar>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btInverseDynamics_vec3 {
    pub _base: btVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btInverseDynamics_mat33 {
    pub _base: btMatrix3x3,
}
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_vecx {
    pub _base: btVectorX<idScalar>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_mat3x {
    pub _base: btInverseDynamics_matxx,
}
extern "C" {
    /// set all elements to zero
    #[link_name = "\u{1}?setZero@btInverseDynamicsBullet3@@YAXAEAVvec3@1@@Z"]
    pub fn btInverseDynamics_setZero(v: *mut btInverseDynamics_vec3);
}
extern "C" {
    /// set all elements to zero
    #[link_name = "\u{1}?setZero@btInverseDynamicsBullet3@@YAXAEAVvecx@1@@Z"]
    pub fn btInverseDynamics_setZero1(v: *mut btInverseDynamics_vecx);
}
extern "C" {
    /// set all elements to zero
    #[link_name = "\u{1}?setZero@btInverseDynamicsBullet3@@YAXAEAVmat33@1@@Z"]
    pub fn btInverseDynamics_setZero2(m: *mut btInverseDynamics_mat33);
}
extern "C" {
    /// create a skew symmetric matrix from a vector (useful for cross product abstraction, e.g. v x a = V * a)
    #[link_name = "\u{1}?skew@btInverseDynamicsBullet3@@YAXAEAVvec3@1@PEAVmat33@1@@Z"]
    pub fn btInverseDynamics_skew(
        v: *mut btInverseDynamics_vec3,
        result: *mut btInverseDynamics_mat33,
    );
}
extern "C" {
    /// return maximum absolute value
    #[link_name = "\u{1}?maxAbs@btInverseDynamicsBullet3@@YANAEBVvecx@1@@Z"]
    pub fn btInverseDynamics_maxAbs(v: *const btInverseDynamics_vecx) -> idScalar;
}
extern "C" {
    /// return maximum absolute value
    #[link_name = "\u{1}?maxAbs@btInverseDynamicsBullet3@@YANAEBVvec3@1@@Z"]
    pub fn btInverseDynamics_maxAbs1(v: *const btInverseDynamics_vec3) -> idScalar;
}
extern "C" {
    #[link_name = "\u{1}?maxAbsMat3x@btInverseDynamicsBullet3@@YANAEBVmat3x@1@@Z"]
    pub fn btInverseDynamics_maxAbsMat3x(m: *const btInverseDynamics_mat3x) -> idScalar;
}
extern "C" {
    #[link_name = "\u{1}?setZero@btInverseDynamicsBullet3@@YAXAEAVmat3x@1@@Z"]
    pub fn btInverseDynamics_setZero3(m: *mut btInverseDynamics_mat3x);
}
extern "C" {
    #[link_name = "\u{1}?mul@btInverseDynamicsBullet3@@YAXAEBVmat33@1@AEBVmat3x@1@PEAV31@@Z"]
    pub fn btInverseDynamics_mul(
        a: *const btInverseDynamics_mat33,
        b: *const btInverseDynamics_mat3x,
        result: *mut btInverseDynamics_mat3x,
    );
}
extern "C" {
    #[link_name = "\u{1}?add@btInverseDynamicsBullet3@@YAXAEBVmat3x@1@0PEAV21@@Z"]
    pub fn btInverseDynamics_add(
        a: *const btInverseDynamics_mat3x,
        b: *const btInverseDynamics_mat3x,
        result: *mut btInverseDynamics_mat3x,
    );
}
extern "C" {
    #[link_name = "\u{1}?sub@btInverseDynamicsBullet3@@YAXAEBVmat3x@1@0PEAV21@@Z"]
    pub fn btInverseDynamics_sub(
        a: *const btInverseDynamics_mat3x,
        b: *const btInverseDynamics_mat3x,
        result: *mut btInverseDynamics_mat3x,
    );
}
extern "C" {
    /// get offset vector & transform matrix from DH parameters
    /// TODO: add documentation
    #[link_name = "\u{1}?getVecMatFromDH@btInverseDynamicsBullet3@@YAXNNNNPEAVvec3@1@PEAVmat33@1@@Z"]
    pub fn btInverseDynamics_getVecMatFromDH(
        theta: idScalar,
        d: idScalar,
        a: idScalar,
        alpha: idScalar,
        r: *mut btInverseDynamics_vec3,
        T: *mut btInverseDynamics_mat33,
    );
}
extern "C" {
    /// Check if a 3x3 matrix is positive definite
    /// @param m a 3x3 matrix
    /// @return true if m>0, false otherwise
    #[link_name = "\u{1}?isPositiveDefinite@btInverseDynamicsBullet3@@YA_NAEBVmat33@1@@Z"]
    pub fn btInverseDynamics_isPositiveDefinite(m: *const btInverseDynamics_mat33) -> bool;
}
extern "C" {
    /// Check if a 3x3 matrix is positive semi definite
    /// @param m a 3x3 matrix
    /// @return true if m>=0, false otherwise
    #[link_name = "\u{1}?isPositiveSemiDefinite@btInverseDynamicsBullet3@@YA_NAEBVmat33@1@@Z"]
    pub fn btInverseDynamics_isPositiveSemiDefinite(m: *const btInverseDynamics_mat33) -> bool;
}
extern "C" {
    /// Check if a 3x3 matrix is positive semi definite within numeric limits
    /// @param m a 3x3 matrix
    /// @return true if m>=-eps, false otherwise
    #[link_name = "\u{1}?isPositiveSemiDefiniteFuzzy@btInverseDynamicsBullet3@@YA_NAEBVmat33@1@@Z"]
    pub fn btInverseDynamics_isPositiveSemiDefiniteFuzzy(m: *const btInverseDynamics_mat33)
        -> bool;
}
extern "C" {
    /// Determinant of 3x3 matrix
    /// NOTE: implemented here for portability, as determinant operation
    /// will be implemented differently for various matrix/vector libraries
    /// @param m a 3x3 matrix
    /// @return det(m)
    #[link_name = "\u{1}?determinant@btInverseDynamicsBullet3@@YANAEBVmat33@1@@Z"]
    pub fn btInverseDynamics_determinant(m: *const btInverseDynamics_mat33) -> idScalar;
}
extern "C" {
    /// Test if a 3x3 matrix satisfies some properties of inertia matrices
    /// @param I a 3x3 matrix
    /// @param index body index (for error messages)
    /// @param has_fixed_joint: if true, positive semi-definite matrices are accepted
    /// @return true if I satisfies inertia matrix properties, false otherwise.
    #[link_name = "\u{1}?isValidInertiaMatrix@btInverseDynamicsBullet3@@YA_NAEBVmat33@1@H_N@Z"]
    pub fn btInverseDynamics_isValidInertiaMatrix(
        I: *const btInverseDynamics_mat33,
        index: ::std::os::raw::c_int,
        has_fixed_joint: bool,
    ) -> bool;
}
extern "C" {
    /// Check if a 3x3 matrix is a valid transform (rotation) matrix
    /// @param m a 3x3 matrix
    /// @return true if m is a rotation matrix, false otherwise
    #[link_name = "\u{1}?isValidTransformMatrix@btInverseDynamicsBullet3@@YA_NAEBVmat33@1@@Z"]
    pub fn btInverseDynamics_isValidTransformMatrix(m: *const btInverseDynamics_mat33) -> bool;
}
extern "C" {
    /// Transform matrix from parent to child frame,
    /// when the child frame is rotated about @param axis by @angle
    /// (mathematically positive)
    /// @param axis the axis of rotation
    /// @param angle rotation angle
    /// @param T pointer to transform matrix
    #[link_name = "\u{1}?bodyTParentFromAxisAngle@btInverseDynamicsBullet3@@YAXAEBVvec3@1@AEBNPEAVmat33@1@@Z"]
    pub fn btInverseDynamics_bodyTParentFromAxisAngle(
        axis: *const btInverseDynamics_vec3,
        angle: *const idScalar,
        T: *mut btInverseDynamics_mat33,
    );
}
extern "C" {
    /// Check if this is a unit vector
    /// @param vector
    /// @return true if |vector|=1 within numeric limits
    #[link_name = "\u{1}?isUnitVector@btInverseDynamicsBullet3@@YA_NAEBVvec3@1@@Z"]
    pub fn btInverseDynamics_isUnitVector(vector: *const btInverseDynamics_vec3) -> bool;
}
extern "C" {
    /// @input a vector in R^3
    /// @returns corresponding spin tensor
    #[link_name = "\u{1}?tildeOperator@btInverseDynamicsBullet3@@YA?AVmat33@1@AEBVvec3@1@@Z"]
    pub fn btInverseDynamics_tildeOperator(
        v: *const btInverseDynamics_vec3,
    ) -> btInverseDynamics_mat33;
}
extern "C" {
    /// @param alpha angle in radians
    /// @returns transform matrix for ratation with @param alpha about x-axis
    #[link_name = "\u{1}?transformX@btInverseDynamicsBullet3@@YA?AVmat33@1@AEBN@Z"]
    pub fn btInverseDynamics_transformX(alpha: *const idScalar) -> btInverseDynamics_mat33;
}
extern "C" {
    /// @param beta angle in radians
    /// @returns transform matrix for ratation with @param beta about y-axis
    #[link_name = "\u{1}?transformY@btInverseDynamicsBullet3@@YA?AVmat33@1@AEBN@Z"]
    pub fn btInverseDynamics_transformY(beta: *const idScalar) -> btInverseDynamics_mat33;
}
extern "C" {
    /// @param gamma angle in radians
    /// @returns transform matrix for ratation with @param gamma about z-axis
    #[link_name = "\u{1}?transformZ@btInverseDynamicsBullet3@@YA?AVmat33@1@AEBN@Z"]
    pub fn btInverseDynamics_transformZ(gamma: *const idScalar) -> btInverseDynamics_mat33;
}
extern "C" {
    /// calculate rpy angles (x-y-z Euler angles) from a given rotation matrix
    /// @param rot rotation matrix
    /// @returns x-y-z Euler angles
    #[link_name = "\u{1}?rpyFromMatrix@btInverseDynamicsBullet3@@YA?AVvec3@1@AEBVmat33@1@@Z"]
    pub fn btInverseDynamics_rpyFromMatrix(
        rot: *const btInverseDynamics_mat33,
    ) -> btInverseDynamics_vec3;
}
/// no degree of freedom, moves with parent
pub const btInverseDynamics_JointType_FIXED: btInverseDynamics_JointType = 0;
/// one rotational degree of freedom relative to parent
pub const btInverseDynamics_JointType_REVOLUTE: btInverseDynamics_JointType = 1;
/// one translational degree of freedom relative to parent
pub const btInverseDynamics_JointType_PRISMATIC: btInverseDynamics_JointType = 2;
/// six degrees of freedom relative to parent
pub const btInverseDynamics_JointType_FLOATING: btInverseDynamics_JointType = 3;
/// Enumeration of supported joint types
pub type btInverseDynamics_JointType = i32;
/// Interface class for calculating inverse dynamics for tree structured
/// multibody systems
///
/// Note on degrees of freedom
/// The q vector contains the generalized coordinate set defining the tree's configuration.
/// Every joint adds elements that define the corresponding link's frame pose relative to
/// its parent. For the joint types that is:
/// - FIXED:	 none
/// - REVOLUTE:  angle of rotation [rad]
/// - PRISMATIC: displacement [m]
/// - FLOATING:  Euler x-y-z angles [rad] and displacement in body-fixed frame of parent [m]
/// (in that order)
/// The u vector contains the generalized speeds, which are
/// - FIXED:	 none
/// - REVOLUTE:  time derivative of angle of rotation [rad/s]
/// - PRISMATIC: time derivative of displacement [m/s]
/// - FLOATING:  angular velocity [rad/s] (*not* time derivative of rpy angles)
/// and time derivative of displacement in parent frame [m/s]
///
/// The q and u vectors are obtained by stacking contributions of all bodies in one
/// vector in the order of body indices.
///
/// Note on generalized forces: analogous to u, i.e.,
/// - FIXED:	 none
/// - REVOLUTE:  moment [Nm], about joint axis
/// - PRISMATIC: force  [N], along joint axis
/// - FLOATING:  moment vector [Nm] and force vector [N], both in body-fixed frame
/// (in that order)
///
/// TODO - force element interface (friction, springs, dampers, etc)
/// - gears and motor inertia
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_MultiBodyTree {
    pub m_is_finalized: bool,
    pub m_mass_parameters_are_valid: bool,
    pub m_accept_invalid_mass_parameters: bool,
    pub m_impl: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    pub m_init_cache: *mut btInverseDynamics_MultiBodyTree_InitCache,
}
extern "C" {
    /// Add body to the system. this allocates memory and not real-time safe.
    /// /// This only adds the data to an initial cache. After all bodies have been
    /// /// added,
    /// /// the system is setup using the buildSystem call
    /// /// @param body_index index of the body to be added. Must >=0, <number of bodies,
    /// ///		and index of parent must be < index of body
    /// /// @param parent_index index of the parent body
    /// ///		The root of the tree has index 0 and its parent (the world frame)
    /// ///		is assigned index -1
    /// ///		the rotation and translation relative to the parent are taken as
    /// ///		pose of the root body relative to the world frame. Other parameters
    /// ///		are ignored
    /// /// @param JointType type of joint connecting the body to the parent
    /// /// @param mass the mass of the body
    /// /// @param body_r_body_com the center of mass of the body relative to and
    /// /// described in
    /// ///		the body fixed frame, which is located in the joint axis connecting
    /// /// the body to its parent
    /// /// @param body_I_body the moment of inertia of the body w.r.t the body-fixed
    /// /// frame
    /// ///		(ie, the reference point is the origin of the body-fixed frame and
    /// /// the matrix is written
    /// ///		 w.r.t. those unit vectors)
    /// /// @param parent_r_parent_body_ref position of joint relative to the parent
    /// /// body's reference frame
    /// ///		for q=0, written in the parent bodies reference frame
    /// /// @param body_axis_of_motion translation/rotation axis in body-fixed frame.
    /// ///		Ignored for joints that are not revolute or prismatic.
    /// ///		must be a unit vector.
    /// /// @param body_T_parent_ref transform matrix from parent to body reference
    /// /// frame for q=0.
    /// ///		This is the matrix transforming a vector represented in the
    /// /// parent's reference frame into one represented
    /// ///		in this body's reference frame.
    /// ///		ie, if parent_vec is a vector in R^3 whose components are w.r.t to
    /// /// the parent's reference frame,
    /// ///		then the same vector written w.r.t. this body's frame (for q=0) is
    /// /// given by
    /// ///		body_vec = parent_R_body_ref * parent_vec
    /// /// @param user_ptr pointer to user data
    /// /// @param user_int pointer to user integer
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?addBody@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHHW4JointType@2@AEBVvec3@2@AEBVmat33@2@1N12HPEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_addBody(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        parent_index: ::std::os::raw::c_int,
        joint_type: btInverseDynamics_JointType,
        parent_r_parent_body_ref: *const btInverseDynamics_vec3,
        body_T_parent_ref: *const btInverseDynamics_mat33,
        body_axis_of_motion: *const btInverseDynamics_vec3,
        mass: idScalar,
        body_r_body_com: *const btInverseDynamics_vec3,
        body_I_body: *const btInverseDynamics_mat33,
        user_int: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set policy for invalid mass properties
    /// /// @param flag if true, invalid mass properties are accepted,
    /// ///		the default is false
    #[link_name = "\u{1}?setAcceptInvalidMassParameters@MultiBodyTree@btInverseDynamicsBullet3@@QEAAX_N@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setAcceptInvalidMassParameters(
        this: *mut btInverseDynamics_MultiBodyTree,
        flag: bool,
    );
}
extern "C" {
    /// @return the mass properties policy flag
    #[link_name = "\u{1}?getAcceptInvalidMassProperties@MultiBodyTree@btInverseDynamicsBullet3@@QEBA_NXZ"]
    pub fn btInverseDynamics_MultiBodyTree_getAcceptInvalidMassProperties(
        this: *const btInverseDynamics_MultiBodyTree,
    ) -> bool;
}
extern "C" {
    /// build internal data structures
    /// /// call this after all bodies have been added via addBody
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?finalize@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHXZ"]
    pub fn btInverseDynamics_MultiBodyTree_finalize(
        this: *mut btInverseDynamics_MultiBodyTree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// pretty print ascii description of tree to stdout
    #[link_name = "\u{1}?printTree@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_printTree(this: *mut btInverseDynamics_MultiBodyTree);
}
extern "C" {
    /// print tree data to stdout
    #[link_name = "\u{1}?printTreeData@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_printTreeData(
        this: *mut btInverseDynamics_MultiBodyTree,
    );
}
extern "C" {
    /// Calculate joint forces for given generalized state & derivatives.
    /// /// This also updates kinematic terms computed in calculateKinematics.
    /// /// If gravity is not set to zero, acceleration terms will contain
    /// /// gravitational acceleration.
    /// /// @param q generalized coordinates
    /// /// @param u generalized velocities. In the general case, u=T(q)*dot(q) and dim(q)>=dim(u)
    /// /// @param dot_u time derivative of u
    /// /// @param joint_forces this is where the resulting joint forces will be
    /// ///		stored. dim(joint_forces) = dim(u)
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?calculateInverseDynamics@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@00PEAV32@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateInverseDynamics(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        joint_forces: *mut btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate joint space mass matrix
    /// /// @param q generalized coordinates
    /// /// @param initialize_matrix if true, initialize mass matrix with zero.
    /// ///		If mass_matrix is initialized to zero externally and only used
    /// ///		for mass matrix computations for the same system, it is safe to
    /// ///		set this to false.
    /// /// @param set_lower_triangular_matrix if true, the lower triangular section of mass_matrix
    /// ///		is also populated, otherwise not.
    /// /// @param mass_matrix matrix for storing the output (should be dim(q)xdim(q))
    /// /// @return -1 on error, 0 on success
    #[link_name = "\u{1}?calculateMassMatrix@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@_N11PEAU?$btMatrixX@N@@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateMassMatrix(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        update_kinematics: bool,
        initialize_matrix: bool,
        set_lower_triangular_matrix: bool,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate joint space mass matrix.
    /// /// This version will update kinematics, initialize all mass_matrix elements to zero and
    /// /// populate all mass matrix entries.
    /// /// @param q generalized coordinates
    /// /// @param mass_matrix matrix for storing the output (should be dim(q)xdim(q))
    /// /// @return -1 on error, 0 on success
    #[link_name = "\u{1}?calculateMassMatrix@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@PEAU?$btMatrixX@N@@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateMassMatrix1(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates kinematics also calculated in calculateInverseDynamics,
    /// /// but not dynamics.
    /// /// This function ensures that correct accelerations are computed that do not
    /// /// contain gravitational acceleration terms.
    /// /// Does not calculate Jacobians, but only vector quantities (positions, velocities & accelerations)
    #[link_name = "\u{1}?calculateKinematics@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@00@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateKinematics(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate position kinematics
    #[link_name = "\u{1}?calculatePositionKinematics@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculatePositionKinematics(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate position and velocity kinematics
    #[link_name = "\u{1}?calculatePositionAndVelocityKinematics@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@0@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculatePositionAndVelocityKinematics(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate Jacobians (dvel/du), as well as velocity-dependent accelearation components
    /// /// d(Jacobian)/dt*u
    /// /// This function assumes that calculateInverseDynamics was called, or calculateKinematics,
    /// /// or calculatePositionAndVelocityKinematics
    #[link_name = "\u{1}?calculateJacobians@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@0@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateJacobians(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate Jacobians (dvel/du)
    /// /// This function assumes that calculateInverseDynamics was called, or
    /// /// one of the calculateKineamtics functions
    #[link_name = "\u{1}?calculateJacobians@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_calculateJacobians1(
        this: *mut btInverseDynamics_MultiBodyTree,
        q: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set gravitational acceleration
    /// /// the default is [0;0;-9.8] in the world frame
    /// /// @param gravity the gravitational acceleration in world frame
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?setGravityInWorldFrame@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setGravityInWorldFrame(
        this: *mut btInverseDynamics_MultiBodyTree,
        gravity: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// returns number of bodies in tree
    #[link_name = "\u{1}?numBodies@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHXZ"]
    pub fn btInverseDynamics_MultiBodyTree_numBodies(
        this: *const btInverseDynamics_MultiBodyTree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// returns number of mechanical degrees of freedom (dimension of q-vector)
    #[link_name = "\u{1}?numDoFs@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHXZ"]
    pub fn btInverseDynamics_MultiBodyTree_numDoFs(
        this: *const btInverseDynamics_MultiBodyTree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get origin of a body-fixed frame, represented in world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_origin pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyOrigin@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyOrigin(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get center of mass of a body, represented in world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_com pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyCoM@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyCoM(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_com: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get transform from of a body-fixed frame to the world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_T_body pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyTransform@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyTransform(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_T_body: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get absolute angular velocity for a body, represented in the world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_omega pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyAngularVelocity@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyAngularVelocity(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get linear velocity of a body, represented in world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_velocity pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyLinearVelocity@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyLinearVelocity(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get linear velocity of a body's CoM, represented in world frame
    /// /// (not required for inverse dynamics, provided for convenience)
    /// /// @param body_index index for frame/body
    /// /// @param world_vel_com pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyLinearVelocityCoM@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyLinearVelocityCoM(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get origin of a body-fixed frame, represented in world frame
    /// /// @param body_index index for frame/body
    /// /// @param world_origin pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyAngularAcceleration@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyAngularAcceleration(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_dot_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get origin of a body-fixed frame, represented in world frame
    /// /// NOTE: this will include the gravitational acceleration, so the actual acceleration is
    /// /// obtainened by setting gravitational acceleration to zero, or subtracting it.
    /// /// @param body_index index for frame/body
    /// /// @param world_origin pointer for return data
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getBodyLinearAcceleration@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyLinearAcceleration(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_acceleration: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBodyJacobianTrans@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat3x@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyJacobianTrans(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_jac_trans: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBodyJacobianRot@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat3x@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyJacobianRot(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_jac_rot: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBodyDotJacobianTransU@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyDotJacobianTransU(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_trans_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getBodyDotJacobianRotU@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyDotJacobianRotU(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_rot_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// returns the (internal) index of body
    /// /// @param body_index is the index of a body
    /// /// @param parent_index pointer to where parent index will be stored
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getParentIndex@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getParentIndex(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        parent_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get joint type
    /// /// @param body_index index of the body
    /// /// @param joint_type the corresponding joint type
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getJointType@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAW4JointType@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getJointType(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut btInverseDynamics_JointType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get joint type as string
    /// /// @param body_index index of the body
    /// /// @param joint_type string naming the corresponding joint type
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getJointTypeStr@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAPEBD@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getJointTypeStr(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get offset translation to parent body (see addBody)
    /// /// @param body_index index of the body
    /// /// @param r the offset translation (see above)
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getParentRParentBodyRef@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getParentRParentBodyRef(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        r: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get offset rotation to parent body (see addBody)
    /// /// @param body_index index of the body
    /// /// @param T the transform (see above)
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getBodyTParentRef@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyTParentRef(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        T: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get axis of motion (see addBody)
    /// /// @param body_index index of the body
    /// /// @param axis the axis (see above)
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getBodyAxisOfMotion@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyAxisOfMotion(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        axis: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get offset for degrees of freedom of this body into the q-vector
    /// /// @param body_index index of the body
    /// /// @param q_offset offset the q vector
    /// /// @return -1 on error, 0 on success
    #[link_name = "\u{1}?getDoFOffset@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getDoFOffset(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        q_offset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get user integer. not used by the library.
    /// /// @param body_index index of the body
    /// /// @param user_int   the user integer
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getUserInt@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getUserInt(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get user pointer. not used by the library.
    /// /// @param body_index index of the body
    /// /// @param user_ptr   the user pointer
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?getUserPtr@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAPEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getUserPtr(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set user integer. not used by the library.
    /// /// @param body_index index of the body
    /// /// @param user_int   the user integer
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?setUserInt@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setUserInt(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        user_int: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set user pointer. not used by the library.
    /// /// @param body_index index of the body
    /// /// @param user_ptr   the user pointer
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?setUserPtr@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHQEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setUserPtr(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set mass for a body
    /// /// @param body_index index of the body
    /// /// @param mass the mass to set
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?setBodyMass@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHN@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setBodyMass(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        mass: idScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set first moment of mass for a body
    /// /// (mass * center of mass, in body fixed frame, relative to joint)
    /// /// @param body_index index of the body
    /// /// @param first_mass_moment the vector to set
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?setBodyFirstMassMoment@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setBodyFirstMassMoment(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set second moment of mass for a body
    /// /// (moment of inertia, in body fixed frame, relative to joint)
    /// /// @param body_index index of the body
    /// /// @param second_mass_moment the inertia matrix
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?setBodySecondMassMoment@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVmat33@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_setBodySecondMassMoment(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *const btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get mass for a body
    /// /// @param body_index index of the body
    /// /// @param mass the mass
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getBodyMass@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAN@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyMass(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        mass: *mut idScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get first moment of mass for a body
    /// /// (mass * center of mass, in body fixed frame, relative to joint)
    /// /// @param body_index index of the body
    /// /// @param first_moment the vector
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getBodyFirstMassMoment@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodyFirstMassMoment(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get second moment of mass for a body
    /// /// (moment of inertia, in body fixed frame, relative to joint)
    /// /// @param body_index index of the body
    /// /// @param second_mass_moment the inertia matrix
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getBodySecondMassMoment@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_getBodySecondMassMoment(
        this: *const btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set all user forces and moments to zero
    #[link_name = "\u{1}?clearAllUserForcesAndMoments@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_clearAllUserForcesAndMoments(
        this: *mut btInverseDynamics_MultiBodyTree,
    );
}
extern "C" {
    /// Add an external force to a body, acting at the origin of the body-fixed frame.
    /// /// Calls to addUserForce are cumulative. Set the user force and moment to zero
    /// /// via clearAllUserForcesAndMoments()
    /// /// @param body_force the force represented in the body-fixed frame of reference
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?addUserForce@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_addUserForce(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        body_force: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add an external moment to a body.
    /// /// Calls to addUserMoment are cumulative. Set the user force and moment to zero
    /// /// via clearAllUserForcesAndMoments()
    /// /// @param body_moment the moment represented in the body-fixed frame of reference
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?addUserMoment@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@2@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_addUserMoment(
        this: *mut btInverseDynamics_MultiBodyTree,
        body_index: ::std::os::raw::c_int,
        body_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// The contructor.
    /// /// Initialization & allocation is via addBody and buildSystem calls.
    #[link_name = "\u{1}??0MultiBodyTree@btInverseDynamicsBullet3@@QEAA@XZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyTree(
        this: *mut btInverseDynamics_MultiBodyTree,
    );
}
extern "C" {
    /// the destructor. This also deallocates all memory
    #[link_name = "\u{1}??_DMultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyTree_destructor(
        this: *mut btInverseDynamics_MultiBodyTree,
    );
}
impl btInverseDynamics_MultiBodyTree {
    #[inline]
    pub unsafe fn addBody(
        &mut self,
        body_index: ::std::os::raw::c_int,
        parent_index: ::std::os::raw::c_int,
        joint_type: btInverseDynamics_JointType,
        parent_r_parent_body_ref: *const btInverseDynamics_vec3,
        body_T_parent_ref: *const btInverseDynamics_mat33,
        body_axis_of_motion: *const btInverseDynamics_vec3,
        mass: idScalar,
        body_r_body_com: *const btInverseDynamics_vec3,
        body_I_body: *const btInverseDynamics_mat33,
        user_int: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_addBody(
            self,
            body_index,
            parent_index,
            joint_type,
            parent_r_parent_body_ref,
            body_T_parent_ref,
            body_axis_of_motion,
            mass,
            body_r_body_com,
            body_I_body,
            user_int,
            user_ptr,
        )
    }
    #[inline]
    pub unsafe fn setAcceptInvalidMassParameters(&mut self, flag: bool) {
        btInverseDynamics_MultiBodyTree_setAcceptInvalidMassParameters(self, flag)
    }
    #[inline]
    pub unsafe fn getAcceptInvalidMassProperties(&self) -> bool {
        btInverseDynamics_MultiBodyTree_getAcceptInvalidMassProperties(self)
    }
    #[inline]
    pub unsafe fn finalize(&mut self) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_finalize(self)
    }
    #[inline]
    pub unsafe fn printTree(&mut self) {
        btInverseDynamics_MultiBodyTree_printTree(self)
    }
    #[inline]
    pub unsafe fn printTreeData(&mut self) {
        btInverseDynamics_MultiBodyTree_printTreeData(self)
    }
    #[inline]
    pub unsafe fn calculateInverseDynamics(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        joint_forces: *mut btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateInverseDynamics(self, q, u, dot_u, joint_forces)
    }
    #[inline]
    pub unsafe fn calculateMassMatrix(
        &mut self,
        q: *const btInverseDynamics_vecx,
        update_kinematics: bool,
        initialize_matrix: bool,
        set_lower_triangular_matrix: bool,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateMassMatrix(
            self,
            q,
            update_kinematics,
            initialize_matrix,
            set_lower_triangular_matrix,
            mass_matrix,
        )
    }
    #[inline]
    pub unsafe fn calculateMassMatrix1(
        &mut self,
        q: *const btInverseDynamics_vecx,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateMassMatrix1(self, q, mass_matrix)
    }
    #[inline]
    pub unsafe fn calculateKinematics(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateKinematics(self, q, u, dot_u)
    }
    #[inline]
    pub unsafe fn calculatePositionKinematics(
        &mut self,
        q: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculatePositionKinematics(self, q)
    }
    #[inline]
    pub unsafe fn calculatePositionAndVelocityKinematics(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculatePositionAndVelocityKinematics(self, q, u)
    }
    #[inline]
    pub unsafe fn calculateJacobians(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateJacobians(self, q, u)
    }
    #[inline]
    pub unsafe fn calculateJacobians1(
        &mut self,
        q: *const btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_calculateJacobians1(self, q)
    }
    #[inline]
    pub unsafe fn setGravityInWorldFrame(
        &mut self,
        gravity: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setGravityInWorldFrame(self, gravity)
    }
    #[inline]
    pub unsafe fn numBodies(&self) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_numBodies(self)
    }
    #[inline]
    pub unsafe fn numDoFs(&self) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_numDoFs(self)
    }
    #[inline]
    pub unsafe fn getBodyOrigin(
        &self,
        body_index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyOrigin(self, body_index, world_origin)
    }
    #[inline]
    pub unsafe fn getBodyCoM(
        &self,
        body_index: ::std::os::raw::c_int,
        world_com: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyCoM(self, body_index, world_com)
    }
    #[inline]
    pub unsafe fn getBodyTransform(
        &self,
        body_index: ::std::os::raw::c_int,
        world_T_body: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyTransform(self, body_index, world_T_body)
    }
    #[inline]
    pub unsafe fn getBodyAngularVelocity(
        &self,
        body_index: ::std::os::raw::c_int,
        world_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyAngularVelocity(self, body_index, world_omega)
    }
    #[inline]
    pub unsafe fn getBodyLinearVelocity(
        &self,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyLinearVelocity(self, body_index, world_velocity)
    }
    #[inline]
    pub unsafe fn getBodyLinearVelocityCoM(
        &self,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyLinearVelocityCoM(self, body_index, world_velocity)
    }
    #[inline]
    pub unsafe fn getBodyAngularAcceleration(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyAngularAcceleration(
            self,
            body_index,
            world_dot_omega,
        )
    }
    #[inline]
    pub unsafe fn getBodyLinearAcceleration(
        &self,
        body_index: ::std::os::raw::c_int,
        world_acceleration: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyLinearAcceleration(
            self,
            body_index,
            world_acceleration,
        )
    }
    #[inline]
    pub unsafe fn getBodyJacobianTrans(
        &self,
        body_index: ::std::os::raw::c_int,
        world_jac_trans: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyJacobianTrans(self, body_index, world_jac_trans)
    }
    #[inline]
    pub unsafe fn getBodyJacobianRot(
        &self,
        body_index: ::std::os::raw::c_int,
        world_jac_rot: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyJacobianRot(self, body_index, world_jac_rot)
    }
    #[inline]
    pub unsafe fn getBodyDotJacobianTransU(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_trans_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyDotJacobianTransU(
            self,
            body_index,
            world_dot_jac_trans_u,
        )
    }
    #[inline]
    pub unsafe fn getBodyDotJacobianRotU(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_rot_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyDotJacobianRotU(
            self,
            body_index,
            world_dot_jac_rot_u,
        )
    }
    #[inline]
    pub unsafe fn getParentIndex(
        &self,
        body_index: ::std::os::raw::c_int,
        parent_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getParentIndex(self, body_index, parent_index)
    }
    #[inline]
    pub unsafe fn getJointType(
        &self,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut btInverseDynamics_JointType,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getJointType(self, body_index, joint_type)
    }
    #[inline]
    pub unsafe fn getJointTypeStr(
        &self,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getJointTypeStr(self, body_index, joint_type)
    }
    #[inline]
    pub unsafe fn getParentRParentBodyRef(
        &self,
        body_index: ::std::os::raw::c_int,
        r: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getParentRParentBodyRef(self, body_index, r)
    }
    #[inline]
    pub unsafe fn getBodyTParentRef(
        &self,
        body_index: ::std::os::raw::c_int,
        T: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyTParentRef(self, body_index, T)
    }
    #[inline]
    pub unsafe fn getBodyAxisOfMotion(
        &self,
        body_index: ::std::os::raw::c_int,
        axis: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyAxisOfMotion(self, body_index, axis)
    }
    #[inline]
    pub unsafe fn getDoFOffset(
        &self,
        body_index: ::std::os::raw::c_int,
        q_offset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getDoFOffset(self, body_index, q_offset)
    }
    #[inline]
    pub unsafe fn getUserInt(
        &self,
        body_index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getUserInt(self, body_index, user_int)
    }
    #[inline]
    pub unsafe fn getUserPtr(
        &self,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getUserPtr(self, body_index, user_ptr)
    }
    #[inline]
    pub unsafe fn setUserInt(
        &mut self,
        body_index: ::std::os::raw::c_int,
        user_int: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setUserInt(self, body_index, user_int)
    }
    #[inline]
    pub unsafe fn setUserPtr(
        &mut self,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setUserPtr(self, body_index, user_ptr)
    }
    #[inline]
    pub unsafe fn setBodyMass(
        &mut self,
        body_index: ::std::os::raw::c_int,
        mass: idScalar,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setBodyMass(self, body_index, mass)
    }
    #[inline]
    pub unsafe fn setBodyFirstMassMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setBodyFirstMassMoment(self, body_index, first_mass_moment)
    }
    #[inline]
    pub unsafe fn setBodySecondMassMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *const btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_setBodySecondMassMoment(
            self,
            body_index,
            second_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn getBodyMass(
        &self,
        body_index: ::std::os::raw::c_int,
        mass: *mut idScalar,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyMass(self, body_index, mass)
    }
    #[inline]
    pub unsafe fn getBodyFirstMassMoment(
        &self,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodyFirstMassMoment(self, body_index, first_mass_moment)
    }
    #[inline]
    pub unsafe fn getBodySecondMassMoment(
        &self,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_getBodySecondMassMoment(
            self,
            body_index,
            second_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn clearAllUserForcesAndMoments(&mut self) {
        btInverseDynamics_MultiBodyTree_clearAllUserForcesAndMoments(self)
    }
    #[inline]
    pub unsafe fn addUserForce(
        &mut self,
        body_index: ::std::os::raw::c_int,
        body_force: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_addUserForce(self, body_index, body_force)
    }
    #[inline]
    pub unsafe fn addUserMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        body_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_addUserMoment(self, body_index, body_moment)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btInverseDynamics_MultiBodyTree_MultiBodyTree(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btInverseDynamics_MultiBodyTree_MultiBodyTree_destructor(self)
    }
}
/// Structure for for rigid body mass properties, connectivity and kinematic state
/// all vectors and matrices are in body-fixed frame, if not indicated otherwise.
/// The body-fixed frame is located in the joint connecting the body to its parent.
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_RigidBody {
    /// Mass
    pub m_mass: idScalar,
    pub __bindgen_padding_0: u64,
    /// Mass times center of gravity in body-fixed frame
    pub m_body_mass_com: btInverseDynamics_vec3,
    /// Moment of inertia w.r.t. body-fixed frame
    pub m_body_I_body: btInverseDynamics_mat33,
    /// Left-hand side of the body equation of motion, translational part
    pub m_eom_lhs_translational: btInverseDynamics_vec3,
    /// Left-hand side of the body equation of motion, rotational part
    pub m_eom_lhs_rotational: btInverseDynamics_vec3,
    /// Force acting at the joint when the body is cut from its parent;
    /// /// includes impressed joint force in J_JT direction,
    /// /// as well as constraint force,
    /// /// in body-fixed frame
    pub m_force_at_joint: btInverseDynamics_vec3,
    /// Moment acting at the joint when the body is cut from its parent;
    /// /// includes impressed joint moment in J_JR direction, and constraint moment
    /// /// in body-fixed frame
    pub m_moment_at_joint: btInverseDynamics_vec3,
    /// external (user provided) force acting at the body-fixed frame's origin, written in that
    /// /// frame
    pub m_body_force_user: btInverseDynamics_vec3,
    /// external (user provided) moment acting at the body-fixed frame's origin, written in that
    /// /// frame
    pub m_body_moment_user: btInverseDynamics_vec3,
    /// Position of body-fixed frame relative to world frame
    /// /// this is currently only for debugging purposes
    pub m_body_pos: btInverseDynamics_vec3,
    /// Absolute velocity of body-fixed frame
    pub m_body_vel: btInverseDynamics_vec3,
    /// Absolute acceleration of body-fixed frame
    /// /// NOTE: if gravitational acceleration is not zero, this is the accelation PLUS gravitational
    /// /// acceleration!
    pub m_body_acc: btInverseDynamics_vec3,
    /// Absolute angular velocity
    pub m_body_ang_vel: btInverseDynamics_vec3,
    /// Absolute angular acceleration
    /// /// NOTE: if gravitational acceleration is not zero, this is the accelation PLUS gravitational
    /// /// acceleration!
    pub m_body_ang_acc: btInverseDynamics_vec3,
    /// Transform from world to body-fixed frame;
    /// /// this is currently only for debugging purposes
    pub m_body_T_world: btInverseDynamics_mat33,
    /// Transform from parent to body-fixed frame
    pub m_body_T_parent: btInverseDynamics_mat33,
    /// Vector from parent to child frame in parent frame
    pub m_parent_pos_parent_body: btInverseDynamics_vec3,
    /// Relative angular velocity
    pub m_body_ang_vel_rel: btInverseDynamics_vec3,
    /// Relative linear velocity
    pub m_parent_vel_rel: btInverseDynamics_vec3,
    /// Relative angular acceleration
    pub m_body_ang_acc_rel: btInverseDynamics_vec3,
    /// Relative linear acceleration
    pub m_parent_acc_rel: btInverseDynamics_vec3,
    /// Type of joint
    pub m_joint_type: btInverseDynamics_JointType,
    pub __bindgen_padding_1: u64,
    /// Position of joint frame (body-fixed frame at q=0) relative to the parent frame
    /// /// Components are in body-fixed frame of the parent
    pub m_parent_pos_parent_body_ref: btInverseDynamics_vec3,
    /// Orientation of joint frame (body-fixed frame at q=0) relative to the parent frame
    pub m_body_T_parent_ref: btInverseDynamics_mat33,
    /// Joint rotational Jacobian, ie, the partial derivative of the body-fixed frames absolute
    /// /// angular velocity w.r.t. the generalized velocity of this body's relative degree of freedom.
    /// /// For revolute joints this is the joint axis, for prismatic joints it is a null matrix.
    /// /// (NOTE: dimensions will have to be dynamic for additional joint types!)
    pub m_Jac_JR: btInverseDynamics_vec3,
    /// Joint translational Jacobian, ie, the partial derivative of the body-fixed frames absolute
    /// /// linear velocity w.r.t. the generalized velocity of this body's relative degree of freedom.
    /// /// For prismatic joints this is the joint axis, for revolute joints it is a null matrix.
    /// /// (NOTE: dimensions might have to be dynamic for additional joint types!)
    pub m_Jac_JT: btInverseDynamics_vec3,
    /// m_Jac_JT in the parent frame, it, m_body_T_parent_ref.transpose()*m_Jac_JT
    pub m_parent_Jac_JT: btInverseDynamics_vec3,
    /// Start of index range for the position degree(s) of freedom describing this body's motion
    /// /// relative to
    /// /// its parent. The indices are wrt the multibody system's q-vector of generalized coordinates.
    pub m_q_index: ::std::os::raw::c_int,
    /// mass of the subtree rooted in this body
    pub m_subtree_mass: idScalar,
    /// center of mass * mass for subtree rooted in this body, in body-fixed frame
    pub m_body_subtree_mass_com: btInverseDynamics_vec3,
    /// moment of inertia of subtree rooted in this body, w.r.t. body origin, in body-fixed frame
    pub m_body_subtree_I_body: btInverseDynamics_mat33,
    /// translational jacobian in body-fixed frame d(m_body_vel)/du
    pub m_body_Jac_T: btInverseDynamics_mat3x,
    /// rotationsl jacobian in body-fixed frame d(m_body_ang_vel)/du
    pub m_body_Jac_R: btInverseDynamics_mat3x,
    /// components of linear acceleration depending on u
    /// /// (same as is d(m_Jac_T)/dt*u)
    pub m_body_dot_Jac_T_u: btInverseDynamics_vec3,
    /// components of angular acceleration depending on u
    /// /// (same as is d(m_Jac_T)/dt*u)
    pub m_body_dot_Jac_R_u: btInverseDynamics_vec3,
}
/// The MBS implements a tree structured multibody system
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_MultiBodyTree_MultiBodyImpl {
    pub m_num_bodies: ::std::os::raw::c_int,
    pub m_num_dofs: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_world_gravity: btInverseDynamics_vec3,
    pub m_body_list: b3AlignedObjectArray<btInverseDynamics_RigidBody>,
    pub m_parent_index: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_child_indices: b3AlignedObjectArray<[u64; 4usize]>,
    pub m_body_revolute_list: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_body_prismatic_list: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_body_floating_list: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_user_int: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_user_ptr: b3AlignedObjectArray<*mut ::std::os::raw::c_void>,
    pub m_m3x: btInverseDynamics_mat3x,
    pub __bindgen_padding_1: u64,
}
pub const btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType_POSITION_ONLY:
    btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType = 0;
pub const btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType_POSITION_VELOCITY:
    btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType = 1;
pub const btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType_POSITION_VELOCITY_ACCELERATION : btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType = 2 ;
pub type btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType = i32;
extern "C" {
    /// \copydoc MultiBodyTree::calculateInverseDynamics
    #[link_name = "\u{1}?calculateInverseDynamics@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@3@00PEAV43@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateInverseDynamics(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        joint_forces: *mut btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::calculateMassMatrix
    #[link_name = "\u{1}?calculateMassMatrix@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@3@_N11PEAU?$btMatrixX@N@@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateMassMatrix(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        q: *const btInverseDynamics_vecx,
        update_kinematics: bool,
        initialize_matrix: bool,
        set_lower_triangular_matrix: bool,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// calculate kinematics (vector quantities)
    /// /// Depending on type, update positions only, positions & velocities, or positions, velocities
    /// /// and accelerations.
    #[link_name = "\u{1}?calculateKinematics@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@3@00W4KinUpdateType@123@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateKinematics(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        type_: btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// calculate jacobians and (if type == POSITION_VELOCITY), also velocity-dependent accelration terms.
    #[link_name = "\u{1}?calculateJacobians@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvecx@3@0W4KinUpdateType@123@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateJacobians(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        type_: btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyDotJacobianTransU
    #[link_name = "\u{1}?getBodyDotJacobianTransU@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyDotJacobianTransU(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_trans_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyDotJacobianRotU
    #[link_name = "\u{1}?getBodyDotJacobianRotU@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyDotJacobianRotU(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_rot_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyJacobianTrans
    #[link_name = "\u{1}?getBodyJacobianTrans@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat3x@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyJacobianTrans(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_jac_trans: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyJacobianRot
    #[link_name = "\u{1}?getBodyJacobianRot@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat3x@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyJacobianRot(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_jac_rot: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add relative Jacobian component from motion relative to parent body
    /// /// @param body the body to add the Jacobian component for
    #[link_name = "\u{1}?addRelativeJacobianComponent@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXAEAURigidBody@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_addRelativeJacobianComponent(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body: *mut btInverseDynamics_RigidBody,
    );
}
extern "C" {
    /// generate additional index sets from the parent_index array
    /// /// @return -1 on error, 0 on success
    #[link_name = "\u{1}?generateIndexSets@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_generateIndexSets(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// set gravity acceleration in world frame
    /// /// @param gravity gravity vector in the world frame
    /// /// @return 0 on success, -1 on error
    #[link_name = "\u{1}?setGravityInWorldFrame@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHAEBVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setGravityInWorldFrame(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        gravity: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// pretty print tree
    #[link_name = "\u{1}?printTree@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_printTree(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    );
}
extern "C" {
    /// print tree data
    #[link_name = "\u{1}?printTreeData@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_printTreeData(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    );
}
extern "C" {
    /// initialize fixed data
    #[link_name = "\u{1}?calculateStaticData@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateStaticData(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    );
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyFrame
    #[link_name = "\u{1}?getBodyFrame@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@PEAVmat33@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyFrame(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
        body_T_world: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getParentIndex
    #[link_name = "\u{1}?getParentIndex@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getParentIndex(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        m_parent_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getJointType
    #[link_name = "\u{1}?getJointType@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAW4JointType@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getJointType(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut btInverseDynamics_JointType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getJointTypeStr
    #[link_name = "\u{1}?getJointTypeStr@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAPEBD@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getJointTypeStr(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getParentRParentBodyRef
    #[link_name = "\u{1}?getParentRParentBodyRef@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getParentRParentBodyRef(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        r: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyTParentRef
    #[link_name = "\u{1}?getBodyTParentRef@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyTParentRef(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        T: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyAxisOfMotion
    #[link_name = "\u{1}?getBodyAxisOfMotion@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAxisOfMotion(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        axis: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree:getDoFOffset
    #[link_name = "\u{1}?getDoFOffset@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getDoFOffset(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        q_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyOrigin
    #[link_name = "\u{1}?getBodyOrigin@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyOrigin(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyCoM
    #[link_name = "\u{1}?getBodyCoM@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyCoM(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_com: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyTransform
    #[link_name = "\u{1}?getBodyTransform@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyTransform(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_T_body: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyAngularVelocity
    #[link_name = "\u{1}?getBodyAngularVelocity@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAngularVelocity(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyLinearVelocity
    #[link_name = "\u{1}?getBodyLinearVelocity@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearVelocity(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyLinearVelocityCoM
    #[link_name = "\u{1}?getBodyLinearVelocityCoM@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearVelocityCoM(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyAngularAcceleration
    #[link_name = "\u{1}?getBodyAngularAcceleration@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAngularAcceleration(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_dot_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getBodyLinearAcceleration
    #[link_name = "\u{1}?getBodyLinearAcceleration@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearAcceleration(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        world_acceleration: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getUserInt
    #[link_name = "\u{1}?getUserInt@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getUserInt(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::getUserPtr
    #[link_name = "\u{1}?getUserPtr@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAPEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getUserPtr(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::setUserInt
    #[link_name = "\u{1}?setUserInt@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setUserInt(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        user_int: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::setUserPtr
    #[link_name = "\u{1}?setUserPtr@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHQEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setUserPtr(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::setBodyMass
    #[link_name = "\u{1}?setBodyMass@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHN@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodyMass(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        mass: idScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::setBodyFirstMassMoment
    #[link_name = "\u{1}?setBodyFirstMassMoment@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodyFirstMassMoment(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::setBodySecondMassMoment
    #[link_name = "\u{1}?setBodySecondMassMoment@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVmat33@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodySecondMassMoment(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *const btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::getBodyMass
    #[link_name = "\u{1}?getBodyMass@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAN@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyMass(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        mass: *mut idScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::getBodyFirstMassMoment
    #[link_name = "\u{1}?getBodyFirstMassMoment@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyFirstMassMoment(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodytTree::getBodySecondMassMoment
    #[link_name = "\u{1}?getBodySecondMassMoment@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAVmat33@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodySecondMassMoment(
        this: *const btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::clearAllUserForcesAndMoments
    #[link_name = "\u{1}?clearAllUserForcesAndMoments@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAXXZ"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_clearAllUserForcesAndMoments(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
    );
}
extern "C" {
    /// \copydoc MultiBodyTree::addUserForce
    #[link_name = "\u{1}?addUserForce@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_addUserForce(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        body_force: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \copydoc MultiBodyTree::addUserMoment
    #[link_name = "\u{1}?addUserMoment@MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHAEBVvec3@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_addUserMoment(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        body_index: ::std::os::raw::c_int,
        body_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// constructor
    /// /// @param num_bodies the number of bodies in the system
    /// /// @param num_dofs number of degrees of freedom in the system
    #[link_name = "\u{1}??0MultiBodyImpl@MultiBodyTree@btInverseDynamicsBullet3@@QEAA@HH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_MultiBodyImpl_MultiBodyImpl(
        this: *mut btInverseDynamics_MultiBodyTree_MultiBodyImpl,
        num_bodies_: ::std::os::raw::c_int,
        num_dofs_: ::std::os::raw::c_int,
    );
}
impl btInverseDynamics_MultiBodyTree_MultiBodyImpl {
    #[inline]
    pub unsafe fn calculateInverseDynamics(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        joint_forces: *mut btInverseDynamics_vecx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateInverseDynamics(
            self,
            q,
            u,
            dot_u,
            joint_forces,
        )
    }
    #[inline]
    pub unsafe fn calculateMassMatrix(
        &mut self,
        q: *const btInverseDynamics_vecx,
        update_kinematics: bool,
        initialize_matrix: bool,
        set_lower_triangular_matrix: bool,
        mass_matrix: *mut btInverseDynamics_matxx,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateMassMatrix(
            self,
            q,
            update_kinematics,
            initialize_matrix,
            set_lower_triangular_matrix,
            mass_matrix,
        )
    }
    #[inline]
    pub unsafe fn calculateKinematics(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        dot_u: *const btInverseDynamics_vecx,
        type_: btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateKinematics(self, q, u, dot_u, type_)
    }
    #[inline]
    pub unsafe fn calculateJacobians(
        &mut self,
        q: *const btInverseDynamics_vecx,
        u: *const btInverseDynamics_vecx,
        type_: btInverseDynamics_MultiBodyTree_MultiBodyImpl_KinUpdateType,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateJacobians(self, q, u, type_)
    }
    #[inline]
    pub unsafe fn getBodyDotJacobianTransU(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_trans_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyDotJacobianTransU(
            self,
            body_index,
            world_dot_jac_trans_u,
        )
    }
    #[inline]
    pub unsafe fn getBodyDotJacobianRotU(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_jac_rot_u: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyDotJacobianRotU(
            self,
            body_index,
            world_dot_jac_rot_u,
        )
    }
    #[inline]
    pub unsafe fn getBodyJacobianTrans(
        &self,
        body_index: ::std::os::raw::c_int,
        world_jac_trans: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyJacobianTrans(
            self,
            body_index,
            world_jac_trans,
        )
    }
    #[inline]
    pub unsafe fn getBodyJacobianRot(
        &self,
        body_index: ::std::os::raw::c_int,
        world_jac_rot: *mut btInverseDynamics_mat3x,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyJacobianRot(
            self,
            body_index,
            world_jac_rot,
        )
    }
    #[inline]
    pub unsafe fn addRelativeJacobianComponent(&mut self, body: *mut btInverseDynamics_RigidBody) {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_addRelativeJacobianComponent(self, body)
    }
    #[inline]
    pub unsafe fn generateIndexSets(&mut self) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_generateIndexSets(self)
    }
    #[inline]
    pub unsafe fn setGravityInWorldFrame(
        &mut self,
        gravity: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setGravityInWorldFrame(self, gravity)
    }
    #[inline]
    pub unsafe fn printTree(&mut self) {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_printTree(self)
    }
    #[inline]
    pub unsafe fn printTreeData(&mut self) {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_printTreeData(self)
    }
    #[inline]
    pub unsafe fn calculateStaticData(&mut self) {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_calculateStaticData(self)
    }
    #[inline]
    pub unsafe fn getBodyFrame(
        &self,
        index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
        body_T_world: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyFrame(
            self,
            index,
            world_origin,
            body_T_world,
        )
    }
    #[inline]
    pub unsafe fn getParentIndex(
        &mut self,
        body_index: ::std::os::raw::c_int,
        m_parent_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getParentIndex(
            self,
            body_index,
            m_parent_index,
        )
    }
    #[inline]
    pub unsafe fn getJointType(
        &self,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut btInverseDynamics_JointType,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getJointType(self, body_index, joint_type)
    }
    #[inline]
    pub unsafe fn getJointTypeStr(
        &self,
        body_index: ::std::os::raw::c_int,
        joint_type: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getJointTypeStr(self, body_index, joint_type)
    }
    #[inline]
    pub unsafe fn getParentRParentBodyRef(
        &self,
        body_index: ::std::os::raw::c_int,
        r: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getParentRParentBodyRef(self, body_index, r)
    }
    #[inline]
    pub unsafe fn getBodyTParentRef(
        &self,
        body_index: ::std::os::raw::c_int,
        T: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyTParentRef(self, body_index, T)
    }
    #[inline]
    pub unsafe fn getBodyAxisOfMotion(
        &self,
        body_index: ::std::os::raw::c_int,
        axis: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAxisOfMotion(self, body_index, axis)
    }
    #[inline]
    pub unsafe fn getDoFOffset(
        &self,
        body_index: ::std::os::raw::c_int,
        q_index: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getDoFOffset(self, body_index, q_index)
    }
    #[inline]
    pub unsafe fn getBodyOrigin(
        &self,
        body_index: ::std::os::raw::c_int,
        world_origin: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyOrigin(self, body_index, world_origin)
    }
    #[inline]
    pub unsafe fn getBodyCoM(
        &self,
        body_index: ::std::os::raw::c_int,
        world_com: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyCoM(self, body_index, world_com)
    }
    #[inline]
    pub unsafe fn getBodyTransform(
        &self,
        body_index: ::std::os::raw::c_int,
        world_T_body: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyTransform(
            self,
            body_index,
            world_T_body,
        )
    }
    #[inline]
    pub unsafe fn getBodyAngularVelocity(
        &self,
        body_index: ::std::os::raw::c_int,
        world_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAngularVelocity(
            self,
            body_index,
            world_omega,
        )
    }
    #[inline]
    pub unsafe fn getBodyLinearVelocity(
        &self,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearVelocity(
            self,
            body_index,
            world_velocity,
        )
    }
    #[inline]
    pub unsafe fn getBodyLinearVelocityCoM(
        &self,
        body_index: ::std::os::raw::c_int,
        world_velocity: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearVelocityCoM(
            self,
            body_index,
            world_velocity,
        )
    }
    #[inline]
    pub unsafe fn getBodyAngularAcceleration(
        &self,
        body_index: ::std::os::raw::c_int,
        world_dot_omega: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyAngularAcceleration(
            self,
            body_index,
            world_dot_omega,
        )
    }
    #[inline]
    pub unsafe fn getBodyLinearAcceleration(
        &self,
        body_index: ::std::os::raw::c_int,
        world_acceleration: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyLinearAcceleration(
            self,
            body_index,
            world_acceleration,
        )
    }
    #[inline]
    pub unsafe fn getUserInt(
        &self,
        body_index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getUserInt(self, body_index, user_int)
    }
    #[inline]
    pub unsafe fn getUserPtr(
        &self,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getUserPtr(self, body_index, user_ptr)
    }
    #[inline]
    pub unsafe fn setUserInt(
        &mut self,
        body_index: ::std::os::raw::c_int,
        user_int: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setUserInt(self, body_index, user_int)
    }
    #[inline]
    pub unsafe fn setUserPtr(
        &mut self,
        body_index: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setUserPtr(self, body_index, user_ptr)
    }
    #[inline]
    pub unsafe fn setBodyMass(
        &mut self,
        body_index: ::std::os::raw::c_int,
        mass: idScalar,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodyMass(self, body_index, mass)
    }
    #[inline]
    pub unsafe fn setBodyFirstMassMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodyFirstMassMoment(
            self,
            body_index,
            first_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn setBodySecondMassMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *const btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_setBodySecondMassMoment(
            self,
            body_index,
            second_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn getBodyMass(
        &self,
        body_index: ::std::os::raw::c_int,
        mass: *mut idScalar,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyMass(self, body_index, mass)
    }
    #[inline]
    pub unsafe fn getBodyFirstMassMoment(
        &self,
        body_index: ::std::os::raw::c_int,
        first_mass_moment: *mut btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodyFirstMassMoment(
            self,
            body_index,
            first_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn getBodySecondMassMoment(
        &self,
        body_index: ::std::os::raw::c_int,
        second_mass_moment: *mut btInverseDynamics_mat33,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_getBodySecondMassMoment(
            self,
            body_index,
            second_mass_moment,
        )
    }
    #[inline]
    pub unsafe fn clearAllUserForcesAndMoments(&mut self) {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_clearAllUserForcesAndMoments(self)
    }
    #[inline]
    pub unsafe fn addUserForce(
        &mut self,
        body_index: ::std::os::raw::c_int,
        body_force: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_addUserForce(self, body_index, body_force)
    }
    #[inline]
    pub unsafe fn addUserMoment(
        &mut self,
        body_index: ::std::os::raw::c_int,
        body_moment: *const btInverseDynamics_vec3,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_addUserMoment(self, body_index, body_moment)
    }
    #[inline]
    pub unsafe fn new(
        num_bodies_: ::std::os::raw::c_int,
        num_dofs_: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btInverseDynamics_MultiBodyTree_MultiBodyImpl_MultiBodyImpl(
            &mut __bindgen_tmp,
            num_bodies_,
            num_dofs_,
        );
        __bindgen_tmp
    }
}
/// Mass properties of a rigid body
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btInverseDynamics_InertiaData {
    /// mass
    pub m_mass: idScalar,
    pub __bindgen_padding_0: u64,
    /// vector from body-fixed frame to center of mass,
    /// /// in body-fixed frame, multiplied by the mass
    pub m_body_pos_body_com: btInverseDynamics_vec3,
    /// moment of inertia w.r.t. the origin of the body-fixed
    /// /// frame, represented in that frame
    pub m_body_I_body: btInverseDynamics_mat33,
}
/// Joint properties
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btInverseDynamics_JointData {
    /// type of joint
    pub m_type: btInverseDynamics_JointType,
    /// index of parent body
    pub m_parent: ::std::os::raw::c_int,
    /// index of child body
    pub m_child: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    /// vector from parent's body-fixed frame to child's body-fixed
    /// /// frame for q=0, written in the parent's body fixed frame
    pub m_parent_pos_parent_child_ref: btInverseDynamics_vec3,
    /// Transform matrix converting vectors written in the parent's frame
    /// /// into vectors written in the child's frame for q=0
    /// /// ie, child_vector = child_T_parent_ref * parent_vector;
    pub m_child_T_parent_ref: btInverseDynamics_mat33,
    /// Axis of motion for 1 degree-of-freedom joints,
    /// /// written in the child's frame
    /// /// For revolute joints, the q-value is positive for a positive
    /// /// rotation about this axis.
    /// /// For prismatic joints, the q-value is positive for a positive
    /// /// translation is this direction.
    pub m_child_axis_of_motion: btInverseDynamics_vec3,
}
/// Data structure to store data passed by the user.
/// This is used in MultiBodyTree::finalize to build internal data structures.
#[repr(C)]
#[derive(Debug)]
pub struct btInverseDynamics_MultiBodyTree_InitCache {
    pub m_inertias: b3AlignedObjectArray<btInverseDynamics_InertiaData>,
    pub m_joints: b3AlignedObjectArray<btInverseDynamics_JointData>,
    pub m_num_dofs: ::std::os::raw::c_int,
    pub m_parent_index: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_user_int: b3AlignedObjectArray<::std::os::raw::c_int>,
    pub m_user_ptr: b3AlignedObjectArray<*mut ::std::os::raw::c_void>,
    pub m_root_index: ::std::os::raw::c_int,
}
extern "C" {
    /// \copydoc MultiBodyTree::addBody
    #[link_name = "\u{1}?addBody@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHHHW4JointType@3@AEBVvec3@3@AEBVmat33@3@1N12HPEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_addBody(
        this: *mut btInverseDynamics_MultiBodyTree_InitCache,
        body_index: ::std::os::raw::c_int,
        parent_index: ::std::os::raw::c_int,
        joint_type: btInverseDynamics_JointType,
        parent_r_parent_body_ref: *const btInverseDynamics_vec3,
        body_T_parent_ref: *const btInverseDynamics_mat33,
        body_axis_of_motion: *const btInverseDynamics_vec3,
        mass: idScalar,
        body_r_body_com: *const btInverseDynamics_vec3,
        body_I_body: *const btInverseDynamics_mat33,
        user_int: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// build index arrays
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?buildIndexSets@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEAAHXZ"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_buildIndexSets(
        this: *mut btInverseDynamics_MultiBodyTree_InitCache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get inertia data for index
    /// /// @param index of the body
    /// /// @param inertia pointer for return data
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getInertiaData@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAUInertiaData@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_getInertiaData(
        this: *const btInverseDynamics_MultiBodyTree_InitCache,
        index: ::std::os::raw::c_int,
        inertia: *mut btInverseDynamics_InertiaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get joint data for index
    /// /// @param index of the body
    /// /// @param joint pointer for return data
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getJointData@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAUJointData@3@@Z"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_getJointData(
        this: *const btInverseDynamics_MultiBodyTree_InitCache,
        index: ::std::os::raw::c_int,
        joint: *mut btInverseDynamics_JointData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get user integer
    /// /// @param index body index
    /// /// @param user_int user integer
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getUserInt@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAH@Z"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_getUserInt(
        this: *const btInverseDynamics_MultiBodyTree_InitCache,
        index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get user pointer
    /// /// @param index body index
    /// /// @param user_int user pointer
    /// /// @return 0 on success, -1 on failure
    #[link_name = "\u{1}?getUserPtr@InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEBAHHPEAPEAX@Z"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_getUserPtr(
        this: *const btInverseDynamics_MultiBodyTree_InitCache,
        index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// constructor
    #[link_name = "\u{1}??0InitCache@MultiBodyTree@btInverseDynamicsBullet3@@QEAA@XZ"]
    pub fn btInverseDynamics_MultiBodyTree_InitCache_InitCache(
        this: *mut btInverseDynamics_MultiBodyTree_InitCache,
    );
}
impl btInverseDynamics_MultiBodyTree_InitCache {
    #[inline]
    pub unsafe fn addBody(
        &mut self,
        body_index: ::std::os::raw::c_int,
        parent_index: ::std::os::raw::c_int,
        joint_type: btInverseDynamics_JointType,
        parent_r_parent_body_ref: *const btInverseDynamics_vec3,
        body_T_parent_ref: *const btInverseDynamics_mat33,
        body_axis_of_motion: *const btInverseDynamics_vec3,
        mass: idScalar,
        body_r_body_com: *const btInverseDynamics_vec3,
        body_I_body: *const btInverseDynamics_mat33,
        user_int: ::std::os::raw::c_int,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_addBody(
            self,
            body_index,
            parent_index,
            joint_type,
            parent_r_parent_body_ref,
            body_T_parent_ref,
            body_axis_of_motion,
            mass,
            body_r_body_com,
            body_I_body,
            user_int,
            user_ptr,
        )
    }
    #[inline]
    pub unsafe fn buildIndexSets(&mut self) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_buildIndexSets(self)
    }
    #[inline]
    pub unsafe fn getInertiaData(
        &self,
        index: ::std::os::raw::c_int,
        inertia: *mut btInverseDynamics_InertiaData,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_getInertiaData(self, index, inertia)
    }
    #[inline]
    pub unsafe fn getJointData(
        &self,
        index: ::std::os::raw::c_int,
        joint: *mut btInverseDynamics_JointData,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_getJointData(self, index, joint)
    }
    #[inline]
    pub unsafe fn getUserInt(
        &self,
        index: ::std::os::raw::c_int,
        user_int: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_getUserInt(self, index, user_int)
    }
    #[inline]
    pub unsafe fn getUserPtr(
        &self,
        index: ::std::os::raw::c_int,
        user_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        btInverseDynamics_MultiBodyTree_InitCache_getUserPtr(self, index, user_ptr)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btInverseDynamics_MultiBodyTree_InitCache_InitCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyTriangleData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyLinkData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyVertexData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct btSoftBodySolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodySolver {
    pub vtable_: *const btSoftBodySolver__bindgen_vtable,
    pub m_numberOfPositionIterations: ::std::os::raw::c_int,
    pub m_numberOfVelocityIterations: ::std::os::raw::c_int,
    pub m_timeScale: f32,
}
pub const btSoftBodySolver_SolverTypes_DEFAULT_SOLVER: btSoftBodySolver_SolverTypes = 0;
pub const btSoftBodySolver_SolverTypes_CPU_SOLVER: btSoftBodySolver_SolverTypes = 1;
pub const btSoftBodySolver_SolverTypes_CL_SOLVER: btSoftBodySolver_SolverTypes = 2;
pub const btSoftBodySolver_SolverTypes_CL_SIMD_SOLVER: btSoftBodySolver_SolverTypes = 3;
pub const btSoftBodySolver_SolverTypes_DX_SOLVER: btSoftBodySolver_SolverTypes = 4;
pub const btSoftBodySolver_SolverTypes_DX_SIMD_SOLVER: btSoftBodySolver_SolverTypes = 5;
pub type btSoftBodySolver_SolverTypes = i32;
#[repr(C)]
pub struct btSoftBodySolverOutput__bindgen_vtable(::std::os::raw::c_void);
/// Class to manage movement of data from a solver to a given target.
/// This version is abstract. Subclasses will have custom pairings for different combinations.
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodySolverOutput {
    pub vtable_: *const btSoftBodySolverOutput__bindgen_vtable,
}
#[repr(C)]
pub struct btVertexBufferDescriptor__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btVertexBufferDescriptor {
    pub vtable_: *const btVertexBufferDescriptor__bindgen_vtable,
    pub m_hasVertexPositions: bool,
    pub m_hasNormals: bool,
    pub m_vertexOffset: ::std::os::raw::c_int,
    pub m_vertexStride: ::std::os::raw::c_int,
    pub m_normalOffset: ::std::os::raw::c_int,
    pub m_normalStride: ::std::os::raw::c_int,
}
pub const btVertexBufferDescriptor_BufferTypes_CPU_BUFFER: btVertexBufferDescriptor_BufferTypes = 0;
pub const btVertexBufferDescriptor_BufferTypes_DX11_BUFFER: btVertexBufferDescriptor_BufferTypes =
    1;
pub const btVertexBufferDescriptor_BufferTypes_OPENGL_BUFFER: btVertexBufferDescriptor_BufferTypes =
    2;
pub type btVertexBufferDescriptor_BufferTypes = i32;
#[repr(C)]
#[derive(Debug)]
pub struct btCPUVertexBufferDescriptor {
    pub _base: btVertexBufferDescriptor,
    pub m_basePointer: *mut f32,
}
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultSoftBodySolver {
    pub _base: btSoftBodySolver,
    /// Variable to define whether we need to update solver constants on the next iteration
    pub m_updateSolverConstants: bool,
    pub m_softBodySet: btAlignedObjectArray<*mut btSoftBody>,
}
extern "C" {
    #[link_name = "\u{1}??0btDefaultSoftBodySolver@@QEAA@XZ"]
    pub fn btDefaultSoftBodySolver_btDefaultSoftBodySolver(this: *mut btDefaultSoftBodySolver);
}
impl btDefaultSoftBodySolver {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultSoftBodySolver_btDefaultSoftBodySolver(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtDefaultSoftBodySolver@@QEAAXXZ"]
    pub fn btDefaultSoftBodySolver_btDefaultSoftBodySolver_destructor(
        this: *mut btDefaultSoftBodySolver,
    );
}
extern "C" {
    #[link_name = "\u{1}?checkInitialized@btDefaultSoftBodySolver@@UEAA_NXZ"]
    pub fn btDefaultSoftBodySolver_checkInitialized(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?updateSoftBodies@btDefaultSoftBodySolver@@UEAAXXZ"]
    pub fn btDefaultSoftBodySolver_updateSoftBodies(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?optimize@btDefaultSoftBodySolver@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@_N@Z"]
    pub fn btDefaultSoftBodySolver_optimize(
        this: *mut ::std::os::raw::c_void,
        softBodies: *mut btAlignedObjectArray<*mut btSoftBody>,
        forceUpdate: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?copyBackToSoftBodies@btDefaultSoftBodySolver@@UEAAX_N@Z"]
    pub fn btDefaultSoftBodySolver_copyBackToSoftBodies(
        this: *mut ::std::os::raw::c_void,
        bMove: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveConstraints@btDefaultSoftBodySolver@@UEAAXM@Z"]
    pub fn btDefaultSoftBodySolver_solveConstraints(
        this: *mut ::std::os::raw::c_void,
        solverdt: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?predictMotion@btDefaultSoftBodySolver@@UEAAXM@Z"]
    pub fn btDefaultSoftBodySolver_predictMotion(this: *mut ::std::os::raw::c_void, solverdt: f32);
}
extern "C" {
    #[link_name = "\u{1}?copySoftBodyToVertexBuffer@btDefaultSoftBodySolver@@UEAAXQEBVbtSoftBody@@PEAVbtVertexBufferDescriptor@@@Z"]
    pub fn btDefaultSoftBodySolver_copySoftBodyToVertexBuffer(
        this: *mut ::std::os::raw::c_void,
        softBody: *const btSoftBody,
        vertexBuffer: *mut btVertexBufferDescriptor,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btDefaultSoftBodySolver@@UEAAXPEAVbtSoftBody@@PEBUbtCollisionObjectWrapper@@@Z"]
    pub fn btDefaultSoftBodySolver_processCollision(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btSoftBody,
        arg2: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btDefaultSoftBodySolver@@UEAAXPEAVbtSoftBody@@0@Z"]
    pub fn btDefaultSoftBodySolver_processCollision1(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btSoftBody,
        arg2: *mut btSoftBody,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriIndex {
    pub m_PartIdTriangleIndex: ::std::os::raw::c_int,
    pub m_childShape: *mut btCollisionShape,
}
/// For each triangle in the concave mesh that overlaps with the AABB of a soft body (m_softBody), processTriangle is called.
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyTriangleCallback {
    pub _base: btTriangleCallback,
    pub m_softBody: *mut btSoftBody,
    pub m_triBody: *const btCollisionObject,
    pub __bindgen_padding_0: u64,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
    pub m_resultOut: *mut btManifoldResult,
    pub m_dispatcher: *mut btDispatcher,
    pub m_dispatchInfoPtr: *const btDispatcherInfo,
    pub m_collisionMarginTriangle: btScalar,
    pub m_shapeCache: btHashMap<btHashKey, btTriIndex>,
    pub m_triangleCount: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}?setTimeStepAndCounters@btSoftBodyTriangleCallback@@QEAAXNPEBUbtCollisionObjectWrapper@@AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftBodyTriangleCallback_setTimeStepAndCounters(
        this: *mut btSoftBodyTriangleCallback,
        collisionMarginTriangle: btScalar,
        triObjWrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?clearCache@btSoftBodyTriangleCallback@@QEAAXXZ"]
    pub fn btSoftBodyTriangleCallback_clearCache(this: *mut btSoftBodyTriangleCallback);
}
extern "C" {
    #[link_name = "\u{1}??0btSoftBodyTriangleCallback@@QEAA@PEAVbtDispatcher@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btSoftBodyTriangleCallback_btSoftBodyTriangleCallback(
        this: *mut btSoftBodyTriangleCallback,
        dispatcher: *mut btDispatcher,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btSoftBodyTriangleCallback {
    #[inline]
    pub unsafe fn setTimeStepAndCounters(
        &mut self,
        collisionMarginTriangle: btScalar,
        triObjWrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) {
        btSoftBodyTriangleCallback_setTimeStepAndCounters(
            self,
            collisionMarginTriangle,
            triObjWrap,
            dispatchInfo,
            resultOut,
        )
    }
    #[inline]
    pub unsafe fn clearCache(&mut self) {
        btSoftBodyTriangleCallback_clearCache(self)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBodyTriangleCallback_btSoftBodyTriangleCallback(
            &mut __bindgen_tmp,
            dispatcher,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftBodyTriangleCallback@@QEAAXXZ"]
    pub fn btSoftBodyTriangleCallback_btSoftBodyTriangleCallback_destructor(
        this: *mut btSoftBodyTriangleCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?processTriangle@btSoftBodyTriangleCallback@@UEAAXPEAVbtVector3@@HH@Z"]
    pub fn btSoftBodyTriangleCallback_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
/// btSoftBodyConcaveCollisionAlgorithm  supports collision between soft body shapes and (concave) trianges meshes.
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyConcaveCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
    pub m_isSwapped: bool,
    pub __bindgen_padding_0: u64,
    pub m_btSoftBodyTriangleCallback: btSoftBodyTriangleCallback,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyConcaveCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}?clearCache@btSoftBodyConcaveCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSoftBodyConcaveCollisionAlgorithm_clearCache(
        this: *mut btSoftBodyConcaveCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSoftBodyConcaveCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z"]
    pub fn btSoftBodyConcaveCollisionAlgorithm_btSoftBodyConcaveCollisionAlgorithm(
        this: *mut btSoftBodyConcaveCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btSoftBodyConcaveCollisionAlgorithm {
    #[inline]
    pub unsafe fn clearCache(&mut self) {
        btSoftBodyConcaveCollisionAlgorithm_clearCache(self)
    }
    #[inline]
    pub unsafe fn new(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBodyConcaveCollisionAlgorithm_btSoftBodyConcaveCollisionAlgorithm(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftBodyConcaveCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSoftBodyConcaveCollisionAlgorithm_btSoftBodyConcaveCollisionAlgorithm_destructor(
        this: *mut btSoftBodyConcaveCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSoftBodyConcaveCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftBodyConcaveCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSoftBodyConcaveCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftBodyConcaveCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyMaterialData {
    pub m_linearStiffness: f32,
    pub m_angularStiffness: f32,
    pub m_volumeStiffness: f32,
    pub m_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyNodeData {
    pub m_material: *mut SoftBodyMaterialData,
    pub m_position: btVector3FloatData,
    pub m_previousPosition: btVector3FloatData,
    pub m_velocity: btVector3FloatData,
    pub m_accumulatedForce: btVector3FloatData,
    pub m_normal: btVector3FloatData,
    pub m_inverseMass: f32,
    pub m_area: f32,
    pub m_attach: ::std::os::raw::c_int,
    pub m_pad: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyLinkData {
    pub m_material: *mut SoftBodyMaterialData,
    pub m_nodeIndices: [::std::os::raw::c_int; 2usize],
    pub m_restLength: f32,
    pub m_bbending: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyFaceData {
    pub m_normal: btVector3FloatData,
    pub m_material: *mut SoftBodyMaterialData,
    pub m_nodeIndices: [::std::os::raw::c_int; 3usize],
    pub m_restArea: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyTetraData {
    pub m_c0: [btVector3FloatData; 4usize],
    pub m_material: *mut SoftBodyMaterialData,
    pub m_nodeIndices: [::std::os::raw::c_int; 4usize],
    pub m_restVolume: f32,
    pub m_c1: f32,
    pub m_c2: f32,
    pub m_pad: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftRigidAnchorData {
    pub m_c0: btMatrix3x3FloatData,
    pub m_c1: btVector3FloatData,
    pub m_localFrame: btVector3FloatData,
    pub m_rigidBody: *mut btRigidBodyDoubleData,
    pub m_nodeIndex: ::std::os::raw::c_int,
    pub m_c2: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyConfigData {
    pub m_aeroModel: ::std::os::raw::c_int,
    pub m_baumgarte: f32,
    pub m_damping: f32,
    pub m_drag: f32,
    pub m_lift: f32,
    pub m_pressure: f32,
    pub m_volume: f32,
    pub m_dynamicFriction: f32,
    pub m_poseMatch: f32,
    pub m_rigidContactHardness: f32,
    pub m_kineticContactHardness: f32,
    pub m_softContactHardness: f32,
    pub m_anchorHardness: f32,
    pub m_softRigidClusterHardness: f32,
    pub m_softKineticClusterHardness: f32,
    pub m_softSoftClusterHardness: f32,
    pub m_softRigidClusterImpulseSplit: f32,
    pub m_softKineticClusterImpulseSplit: f32,
    pub m_softSoftClusterImpulseSplit: f32,
    pub m_maxVolume: f32,
    pub m_timeScale: f32,
    pub m_velocityIterations: ::std::os::raw::c_int,
    pub m_positionIterations: ::std::os::raw::c_int,
    pub m_driftIterations: ::std::os::raw::c_int,
    pub m_clusterIterations: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyPoseData {
    pub m_rot: btMatrix3x3FloatData,
    pub m_scale: btMatrix3x3FloatData,
    pub m_aqq: btMatrix3x3FloatData,
    pub m_com: btVector3FloatData,
    pub m_positions: *mut btVector3FloatData,
    pub m_weights: *mut f32,
    pub m_numPositions: ::std::os::raw::c_int,
    pub m_numWeigts: ::std::os::raw::c_int,
    pub m_bvolume: ::std::os::raw::c_int,
    pub m_bframe: ::std::os::raw::c_int,
    pub m_restVolume: f32,
    pub m_pad: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoftBodyClusterData {
    pub m_framexform: btTransformFloatData,
    pub m_locii: btMatrix3x3FloatData,
    pub m_invwi: btMatrix3x3FloatData,
    pub m_com: btVector3FloatData,
    pub m_vimpulses: [btVector3FloatData; 2usize],
    pub m_dimpulses: [btVector3FloatData; 2usize],
    pub m_lv: btVector3FloatData,
    pub m_av: btVector3FloatData,
    pub m_framerefs: *mut btVector3FloatData,
    pub m_nodeIndices: *mut ::std::os::raw::c_int,
    pub m_masses: *mut f32,
    pub m_numFrameRefs: ::std::os::raw::c_int,
    pub m_numNodes: ::std::os::raw::c_int,
    pub m_numMasses: ::std::os::raw::c_int,
    pub m_idmass: f32,
    pub m_imass: f32,
    pub m_nvimpulses: ::std::os::raw::c_int,
    pub m_ndimpulses: ::std::os::raw::c_int,
    pub m_ndamping: f32,
    pub m_ldamping: f32,
    pub m_adamping: f32,
    pub m_matching: f32,
    pub m_maxSelfCollisionImpulse: f32,
    pub m_selfCollisionImpulseFactor: f32,
    pub m_containsAnchor: ::std::os::raw::c_int,
    pub m_collide: ::std::os::raw::c_int,
    pub m_clusterIndex: ::std::os::raw::c_int,
}
pub const btSoftJointBodyType_BT_JOINT_SOFT_BODY_CLUSTER: btSoftJointBodyType = 1;
pub const btSoftJointBodyType_BT_JOINT_RIGID_BODY: btSoftJointBodyType = 2;
pub const btSoftJointBodyType_BT_JOINT_COLLISION_OBJECT: btSoftJointBodyType = 3;
pub type btSoftJointBodyType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyJointData {
    pub m_bodyA: *mut ::std::os::raw::c_void,
    pub m_bodyB: *mut ::std::os::raw::c_void,
    pub m_refs: [btVector3FloatData; 2usize],
    pub m_cfm: f32,
    pub m_erp: f32,
    pub m_split: f32,
    pub m_delete: ::std::os::raw::c_int,
    pub m_relPosition: [btVector3FloatData; 2usize],
    pub m_bodyAtype: ::std::os::raw::c_int,
    pub m_bodyBtype: ::std::os::raw::c_int,
    pub m_jointType: ::std::os::raw::c_int,
    pub m_pad: ::std::os::raw::c_int,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyFloatData {
    pub m_collisionObjectData: btCollisionObjectFloatData,
    pub m_pose: *mut SoftBodyPoseData,
    pub m_materials: *mut *mut SoftBodyMaterialData,
    pub m_nodes: *mut SoftBodyNodeData,
    pub m_links: *mut SoftBodyLinkData,
    pub m_faces: *mut SoftBodyFaceData,
    pub m_tetrahedra: *mut SoftBodyTetraData,
    pub m_anchors: *mut SoftRigidAnchorData,
    pub m_clusters: *mut SoftBodyClusterData,
    pub m_joints: *mut btSoftBodyJointData,
    pub m_numMaterials: ::std::os::raw::c_int,
    pub m_numNodes: ::std::os::raw::c_int,
    pub m_numLinks: ::std::os::raw::c_int,
    pub m_numFaces: ::std::os::raw::c_int,
    pub m_numTetrahedra: ::std::os::raw::c_int,
    pub m_numAnchors: ::std::os::raw::c_int,
    pub m_numClusters: ::std::os::raw::c_int,
    pub m_numJoints: ::std::os::raw::c_int,
    pub m_config: SoftBodyConfigData,
}
/// btGjkEpaSolver contributed under zlib by Nathanael Presson
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGjkEpaSolver2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGjkEpaSolver2_sResults {
    pub status: btGjkEpaSolver2_sResults_eStatus,
    pub __bindgen_padding_0: u64,
    pub witnesses: [btVector3; 2usize],
    pub normal: btVector3,
    pub distance: btScalar,
    pub __bindgen_padding_1: u64,
}
pub const btGjkEpaSolver2_sResults_eStatus_Separated: btGjkEpaSolver2_sResults_eStatus = 0;
pub const btGjkEpaSolver2_sResults_eStatus_Penetrating: btGjkEpaSolver2_sResults_eStatus = 1;
pub const btGjkEpaSolver2_sResults_eStatus_GJK_Failed: btGjkEpaSolver2_sResults_eStatus = 2;
pub const btGjkEpaSolver2_sResults_eStatus_EPA_Failed: btGjkEpaSolver2_sResults_eStatus = 3;
pub type btGjkEpaSolver2_sResults_eStatus = i32;
extern "C" {
    #[link_name = "\u{1}?StackSizeRequirement@btGjkEpaSolver2@@SAHXZ"]
    pub fn btGjkEpaSolver2_StackSizeRequirement() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?Distance@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@@Z"]
    pub fn btGjkEpaSolver2_Distance(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Penetration@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@_N@Z"]
    pub fn btGjkEpaSolver2_Penetration(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?SignedDistance@btGjkEpaSolver2@@SANAEBVbtVector3@@NPEBVbtConvexShape@@AEBVbtTransform@@AEAUsResults@1@@Z"]
    pub fn btGjkEpaSolver2_SignedDistance(
        position: *const btVector3,
        margin: btScalar,
        shape: *const btConvexShape,
        wtrs: *const btTransform,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?SignedDistance@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@@Z"]
    pub fn btGjkEpaSolver2_SignedDistance1(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> bool;
}
impl btGjkEpaSolver2 {
    #[inline]
    pub unsafe fn StackSizeRequirement() -> ::std::os::raw::c_int {
        btGjkEpaSolver2_StackSizeRequirement()
    }
    #[inline]
    pub unsafe fn Distance(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> bool {
        btGjkEpaSolver2_Distance(shape0, wtrs0, shape1, wtrs1, guess, results)
    }
    #[inline]
    pub unsafe fn Penetration(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
        usemargins: bool,
    ) -> bool {
        btGjkEpaSolver2_Penetration(shape0, wtrs0, shape1, wtrs1, guess, results, usemargins)
    }
    #[inline]
    pub unsafe fn SignedDistance(
        position: *const btVector3,
        margin: btScalar,
        shape: *const btConvexShape,
        wtrs: *const btTransform,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> btScalar {
        btGjkEpaSolver2_SignedDistance(position, margin, shape, wtrs, results)
    }
    #[inline]
    pub unsafe fn SignedDistance1(
        shape0: *const btConvexShape,
        wtrs0: *const btTransform,
        shape1: *const btConvexShape,
        wtrs1: *const btTransform,
        guess: *const btVector3,
        results: *mut btGjkEpaSolver2_sResults,
    ) -> bool {
        btGjkEpaSolver2_SignedDistance1(shape0, wtrs0, shape1, wtrs1, guess, results)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSparseSdf_IntFrac {
    pub b: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub f: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSparseSdf_Cell {
    pub d: *mut *mut *mut btScalar,
    pub c: [::std::os::raw::c_int; 3usize],
    pub puid: ::std::os::raw::c_int,
    pub hash: ::std::os::raw::c_uint,
    pub pclient: *const btCollisionShape,
    pub next: *mut btSparseSdf_Cell,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyWorldInfo {
    pub air_density: btScalar,
    pub water_density: btScalar,
    pub water_offset: btScalar,
    pub m_maxDisplacement: btScalar,
    pub water_normal: btVector3,
    pub m_broadphase: *mut btBroadphaseInterface,
    pub m_dispatcher: *mut btDispatcher,
    pub m_gravity: btVector3,
    pub m_sparsesdf: [u64; 8usize],
}
/// The btSoftBody is an class to simulate cloth and volumetric soft bodies.
/// There is two-way interaction between btSoftBody and btRigidBody/btCollisionObject.
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody {
    pub _base: btCollisionObject,
    pub m_collisionDisabledObjects: btAlignedObjectArray<*const btCollisionObject>,
    pub m_softBodySolver: *mut btSoftBodySolver,
    pub m_cfg: btSoftBody_Config,
    pub m_sst: btSoftBody_SolverState,
    pub m_pose: btSoftBody_Pose,
    pub m_tag: *mut ::std::os::raw::c_void,
    pub m_worldInfo: *mut btSoftBodyWorldInfo,
    pub m_notes: btSoftBody_tNoteArray,
    pub m_nodes: btSoftBody_tNodeArray,
    pub m_links: btSoftBody_tLinkArray,
    pub m_faces: btSoftBody_tFaceArray,
    pub m_tetras: btSoftBody_tTetraArray,
    pub m_anchors: btSoftBody_tAnchorArray,
    pub m_rcontacts: btSoftBody_tRContactArray,
    pub m_scontacts: btSoftBody_tSContactArray,
    pub m_joints: btSoftBody_tJointArray,
    pub m_materials: btSoftBody_tMaterialArray,
    pub m_timeacc: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_bounds: [btVector3; 2usize],
    pub m_bUpdateRtCst: bool,
    pub m_ndbvt: btDbvt,
    pub m_fdbvt: btDbvt,
    pub m_cdbvt: btDbvt,
    pub m_clusters: btSoftBody_tClusterArray,
    pub m_clusterConnectivity: btAlignedObjectArray<bool>,
    pub __bindgen_padding_1: u64,
    pub m_initialWorldTransform: btTransform,
    pub m_windVelocity: btVector3,
    pub m_restLengthScale: btScalar,
    pub m_userIndexMapping: btAlignedObjectArray<::std::os::raw::c_int>,
    pub __bindgen_padding_2: u64,
}
/// eAeroModel
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_eAeroModel {
    pub _address: u8,
}
pub const btSoftBody_eAeroModel___V_Point: btSoftBody_eAeroModel__ = 0;
/// Vertex normals are oriented toward velocity
pub const btSoftBody_eAeroModel___V_TwoSided: btSoftBody_eAeroModel__ = 1;
/// Vertex normals are flipped to match velocity
pub const btSoftBody_eAeroModel___V_TwoSidedLiftDrag: btSoftBody_eAeroModel__ = 2;
/// Vertex normals are flipped to match velocity and lift and drag forces are applied
pub const btSoftBody_eAeroModel___V_OneSided: btSoftBody_eAeroModel__ = 3;
/// Vertex normals are taken as it is
pub const btSoftBody_eAeroModel___F_TwoSided: btSoftBody_eAeroModel__ = 4;
/// Face normals are flipped to match velocity
pub const btSoftBody_eAeroModel___F_TwoSidedLiftDrag: btSoftBody_eAeroModel__ = 5;
/// Face normals are flipped to match velocity and lift and drag forces are applied
pub const btSoftBody_eAeroModel___F_OneSided: btSoftBody_eAeroModel__ = 6;
/// Face normals are taken as it is
pub const btSoftBody_eAeroModel___END: btSoftBody_eAeroModel__ = 7;
pub type btSoftBody_eAeroModel__ = i32;
/// eVSolver : velocities solvers
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_eVSolver {
    pub _address: u8,
}
pub const btSoftBody_eVSolver___Linear: btSoftBody_eVSolver__ = 0;
/// Linear solver
pub const btSoftBody_eVSolver___END: btSoftBody_eVSolver__ = 1;
pub type btSoftBody_eVSolver__ = i32;
/// ePSolver : positions solvers
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_ePSolver {
    pub _address: u8,
}
pub const btSoftBody_ePSolver___Linear: btSoftBody_ePSolver__ = 0;
/// Linear solver
pub const btSoftBody_ePSolver___Anchors: btSoftBody_ePSolver__ = 1;
/// Anchor solver
pub const btSoftBody_ePSolver___RContacts: btSoftBody_ePSolver__ = 2;
/// Rigid contacts solver
pub const btSoftBody_ePSolver___SContacts: btSoftBody_ePSolver__ = 3;
/// Soft contacts solver
pub const btSoftBody_ePSolver___END: btSoftBody_ePSolver__ = 4;
pub type btSoftBody_ePSolver__ = i32;
/// eSolverPresets
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_eSolverPresets {
    pub _address: u8,
}
pub const btSoftBody_eSolverPresets___Positions: btSoftBody_eSolverPresets__ = 0;
pub const btSoftBody_eSolverPresets___Velocities: btSoftBody_eSolverPresets__ = 1;
pub const btSoftBody_eSolverPresets___Default: btSoftBody_eSolverPresets__ = 0;
pub const btSoftBody_eSolverPresets___END: btSoftBody_eSolverPresets__ = 1;
pub type btSoftBody_eSolverPresets__ = i32;
/// eFeature
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_eFeature {
    pub _address: u8,
}
pub const btSoftBody_eFeature___None: btSoftBody_eFeature__ = 0;
pub const btSoftBody_eFeature___Node: btSoftBody_eFeature__ = 1;
pub const btSoftBody_eFeature___Link: btSoftBody_eFeature__ = 2;
pub const btSoftBody_eFeature___Face: btSoftBody_eFeature__ = 3;
pub const btSoftBody_eFeature___Tetra: btSoftBody_eFeature__ = 4;
pub const btSoftBody_eFeature___END: btSoftBody_eFeature__ = 5;
pub type btSoftBody_eFeature__ = i32;
pub type btSoftBody_tVSolverArray = btAlignedObjectArray<btSoftBody_eVSolver__>;
pub type btSoftBody_tPSolverArray = btAlignedObjectArray<btSoftBody_ePSolver__>;
/// fCollision
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_fCollision {
    pub _address: u8,
}
pub const btSoftBody_fCollision___RVSmask: btSoftBody_fCollision__ = 15;
/// Rigid versus soft mask
pub const btSoftBody_fCollision___SDF_RS: btSoftBody_fCollision__ = 1;
/// SDF based rigid vs soft
pub const btSoftBody_fCollision___CL_RS: btSoftBody_fCollision__ = 2;
/// Cluster vs convex rigid vs soft
pub const btSoftBody_fCollision___SVSmask: btSoftBody_fCollision__ = 48;
/// Rigid versus soft mask
pub const btSoftBody_fCollision___VF_SS: btSoftBody_fCollision__ = 16;
/// Vertex vs face soft vs soft handling
pub const btSoftBody_fCollision___CL_SS: btSoftBody_fCollision__ = 32;
/// Cluster vs cluster soft vs soft handling
pub const btSoftBody_fCollision___CL_SELF: btSoftBody_fCollision__ = 64;
/// Cluster soft body self collision
pub const btSoftBody_fCollision___Default: btSoftBody_fCollision__ = 1;
/// Cluster soft body self collision
pub const btSoftBody_fCollision___END: btSoftBody_fCollision__ = 2;
pub type btSoftBody_fCollision__ = i32;
/// fMaterial
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_fMaterial {
    pub _address: u8,
}
pub const btSoftBody_fMaterial___DebugDraw: btSoftBody_fMaterial__ = 1;
/// Enable debug draw
pub const btSoftBody_fMaterial___Default: btSoftBody_fMaterial__ = 1;
/// Enable debug draw
pub const btSoftBody_fMaterial___END: btSoftBody_fMaterial__ = 2;
pub type btSoftBody_fMaterial__ = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_sRayCast {
    pub body: *mut btSoftBody,
    /// soft body
    pub feature: btSoftBody_eFeature__,
    /// feature type
    pub index: ::std::os::raw::c_int,
    /// feature index
    pub fraction: btScalar,
}
#[repr(C)]
pub struct btSoftBody_ImplicitFn__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_ImplicitFn {
    pub vtable_: *const btSoftBody_ImplicitFn__bindgen_vtable,
}
pub type btSoftBody_tScalarArray = btAlignedObjectArray<btScalar>;
pub type btSoftBody_tVector3Array = btAlignedObjectArray<btVector3>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_sCti {
    pub m_colObj: *const btCollisionObject,
    pub __bindgen_padding_0: u64,
    pub m_normal: btVector3,
    pub m_offset: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_sMedium {
    pub m_velocity: btVector3,
    pub m_pressure: btScalar,
    pub m_density: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Element {
    pub m_tag: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Material {
    pub _base: btSoftBody_Element,
    pub m_kLST: btScalar,
    pub m_kAST: btScalar,
    pub m_kVST: btScalar,
    pub m_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Feature {
    pub _base: btSoftBody_Element,
    pub m_material: *mut btSoftBody_Material,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Node {
    pub _base: btSoftBody_Feature,
    pub m_x: btVector3,
    pub m_q: btVector3,
    pub m_v: btVector3,
    pub m_f: btVector3,
    pub m_n: btVector3,
    pub m_im: btScalar,
    pub m_area: btScalar,
    pub m_leaf: *mut btDbvtNode,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl btSoftBody_Node {
    #[inline]
    pub fn m_battach(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_battach(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_battach: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let m_battach: u32 = unsafe { ::std::mem::transmute(m_battach) };
            m_battach as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Link {
    pub _base: btSoftBody_Feature,
    pub m_c3: btVector3,
    pub m_n: [*mut btSoftBody_Node; 2usize],
    pub m_rl: btScalar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub m_c0: btScalar,
    pub m_c1: btScalar,
    pub m_c2: btScalar,
    pub __bindgen_padding_0: u64,
}
impl btSoftBody_Link {
    #[inline]
    pub fn m_bbending(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_bbending(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_bbending: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let m_bbending: u32 = unsafe { ::std::mem::transmute(m_bbending) };
            m_bbending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Face {
    pub _base: btSoftBody_Feature,
    pub m_n: [*mut btSoftBody_Node; 3usize],
    pub __bindgen_padding_0: u64,
    pub m_normal: btVector3,
    pub m_ra: btScalar,
    pub m_leaf: *mut btDbvtNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Tetra {
    pub _base: btSoftBody_Feature,
    pub m_n: [*mut btSoftBody_Node; 4usize],
    pub m_rv: btScalar,
    pub m_leaf: *mut btDbvtNode,
    pub m_c0: [btVector3; 4usize],
    pub m_c1: btScalar,
    pub m_c2: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_RContact {
    pub m_cti: btSoftBody_sCti,
    pub m_node: *mut btSoftBody_Node,
    pub __bindgen_padding_0: u64,
    pub m_c0: btMatrix3x3,
    pub m_c1: btVector3,
    pub m_c2: btScalar,
    pub m_c3: btScalar,
    pub m_c4: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_SContact {
    pub m_node: *mut btSoftBody_Node,
    pub m_face: *mut btSoftBody_Face,
    pub m_weights: btVector3,
    pub m_normal: btVector3,
    pub m_margin: btScalar,
    pub m_friction: btScalar,
    pub m_cfm: [btScalar; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Anchor {
    pub m_node: *mut btSoftBody_Node,
    pub __bindgen_padding_0: u64,
    pub m_local: btVector3,
    pub m_body: *mut btRigidBody,
    pub m_influence: btScalar,
    pub m_c0: btMatrix3x3,
    pub m_c1: btVector3,
    pub m_c2: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Note {
    pub _base: btSoftBody_Element,
    pub m_text: *const ::std::os::raw::c_char,
    pub m_offset: btVector3,
    pub m_rank: ::std::os::raw::c_int,
    pub m_nodes: [*mut btSoftBody_Node; 4usize],
    pub m_coords: [btScalar; 4usize],
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_Pose {
    pub m_bvolume: bool,
    pub m_bframe: bool,
    pub m_volume: btScalar,
    pub m_pos: btSoftBody_tVector3Array,
    pub m_wgh: btSoftBody_tScalarArray,
    pub m_com: btVector3,
    pub m_rot: btMatrix3x3,
    pub m_scl: btMatrix3x3,
    pub m_aqq: btMatrix3x3,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_Cluster {
    pub m_masses: btSoftBody_tScalarArray,
    pub m_nodes: btAlignedObjectArray<*mut btSoftBody_Node>,
    pub m_framerefs: btSoftBody_tVector3Array,
    pub m_framexform: btTransform,
    pub m_idmass: btScalar,
    pub m_imass: btScalar,
    pub m_locii: btMatrix3x3,
    pub m_invwi: btMatrix3x3,
    pub m_com: btVector3,
    pub m_vimpulses: [btVector3; 2usize],
    pub m_dimpulses: [btVector3; 2usize],
    pub m_nvimpulses: ::std::os::raw::c_int,
    pub m_ndimpulses: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_lv: btVector3,
    pub m_av: btVector3,
    pub m_leaf: *mut btDbvtNode,
    pub m_ndamping: btScalar,
    pub m_ldamping: btScalar,
    pub m_adamping: btScalar,
    pub m_matching: btScalar,
    pub m_maxSelfCollisionImpulse: btScalar,
    pub m_selfCollisionImpulseFactor: btScalar,
    pub m_containsAnchor: bool,
    pub m_collide: bool,
    pub m_clusterIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Impulse {
    pub m_velocity: btVector3,
    pub m_drift: btVector3,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 15usize],
}
impl btSoftBody_Impulse {
    #[inline]
    pub fn m_asVelocity(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_asVelocity(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn m_asDrift(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_asDrift(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_asVelocity: ::std::os::raw::c_int,
        m_asDrift: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let m_asVelocity: u32 = unsafe { ::std::mem::transmute(m_asVelocity) };
            m_asVelocity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let m_asDrift: u32 = unsafe { ::std::mem::transmute(m_asDrift) };
            m_asDrift as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Body {
    pub m_soft: *mut btSoftBody_Cluster,
    pub m_rigid: *mut btRigidBody,
    pub m_collisionObject: *const btCollisionObject,
}
#[repr(C)]
pub struct btSoftBody_Joint__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_Joint {
    pub vtable_: *const btSoftBody_Joint__bindgen_vtable,
    pub __bindgen_padding_0: u64,
    pub m_bodies: [btSoftBody_Body; 2usize],
    pub m_refs: [btVector3; 2usize],
    pub m_cfm: btScalar,
    pub m_erp: btScalar,
    pub m_split: btScalar,
    pub __bindgen_padding_1: u64,
    pub m_drift: btVector3,
    pub m_sdrift: btVector3,
    pub m_massmatrix: btMatrix3x3,
    pub m_delete: bool,
    pub __bindgen_padding_2: [u8; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Joint_eType {
    pub _address: u8,
}
pub const btSoftBody_Joint_eType___Linear: btSoftBody_Joint_eType__ = 0;
pub const btSoftBody_Joint_eType___Angular: btSoftBody_Joint_eType__ = 1;
pub const btSoftBody_Joint_eType___Contact: btSoftBody_Joint_eType__ = 2;
pub type btSoftBody_Joint_eType__ = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_Joint_Specs {
    pub erp: btScalar,
    pub cfm: btScalar,
    pub split: btScalar,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_LJoint {
    pub _base: btSoftBody_Joint,
    pub m_rpos: [btVector3; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_LJoint_Specs {
    pub _base: btSoftBody_Joint_Specs,
    pub __bindgen_padding_0: u64,
    pub position: btVector3,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_AJoint {
    pub _base: btSoftBody_Joint,
    pub m_axis: [btVector3; 2usize],
    pub m_icontrol: *mut btSoftBody_AJoint_IControl,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
pub struct btSoftBody_AJoint_IControl__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_AJoint_IControl {
    pub vtable_: *const btSoftBody_AJoint_IControl__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_AJoint_Specs {
    pub _base: btSoftBody_Joint_Specs,
    pub __bindgen_padding_0: u64,
    pub axis: btVector3,
    pub icontrol: *mut btSoftBody_AJoint_IControl,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_CJoint {
    pub _base: btSoftBody_Joint,
    pub m_life: ::std::os::raw::c_int,
    pub m_maxlife: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u64,
    pub m_rpos: [btVector3; 2usize],
    pub m_normal: btVector3,
    pub m_friction: btScalar,
    pub __bindgen_padding_1: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBody_Config {
    pub aeromodel: btSoftBody_eAeroModel__,
    pub kVCF: btScalar,
    pub kDP: btScalar,
    pub kDG: btScalar,
    pub kLF: btScalar,
    pub kPR: btScalar,
    pub kVC: btScalar,
    pub kDF: btScalar,
    pub kMT: btScalar,
    pub kCHR: btScalar,
    pub kKHR: btScalar,
    pub kSHR: btScalar,
    pub kAHR: btScalar,
    pub kSRHR_CL: btScalar,
    pub kSKHR_CL: btScalar,
    pub kSSHR_CL: btScalar,
    pub kSR_SPLT_CL: btScalar,
    pub kSK_SPLT_CL: btScalar,
    pub kSS_SPLT_CL: btScalar,
    pub maxvolume: btScalar,
    pub timescale: btScalar,
    pub viterations: ::std::os::raw::c_int,
    pub piterations: ::std::os::raw::c_int,
    pub diterations: ::std::os::raw::c_int,
    pub citerations: ::std::os::raw::c_int,
    pub collisions: ::std::os::raw::c_int,
    pub m_vsequence: btSoftBody_tVSolverArray,
    pub m_psequence: btSoftBody_tPSolverArray,
    pub m_dsequence: btSoftBody_tPSolverArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_SolverState {
    pub sdt: btScalar,
    pub isdt: btScalar,
    pub velmrg: btScalar,
    pub radmrg: btScalar,
    pub updmrg: btScalar,
}
/// RayFromToCaster takes a ray from, ray to (instead of direction!)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBody_RayFromToCaster {
    pub m_rayFrom: btVector3,
    pub m_rayTo: btVector3,
    pub m_rayNormalizedDirection: btVector3,
    pub m_mint: btScalar,
    pub m_face: *mut btSoftBody_Face,
    pub m_tests: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}?Process@RayFromToCaster@btSoftBody@@QEAAXPEBUbtDbvtNode@@@Z"]
    pub fn btSoftBody_RayFromToCaster_Process(
        this: *mut btSoftBody_RayFromToCaster,
        leaf: *const btDbvtNode,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayFromToTriangle@RayFromToCaster@btSoftBody@@SANAEBVbtVector3@@00000N@Z"]
    pub fn btSoftBody_RayFromToCaster_rayFromToTriangle(
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayNormalizedDirection: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        maxt: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??0RayFromToCaster@btSoftBody@@QEAA@AEBVbtVector3@@0N@Z"]
    pub fn btSoftBody_RayFromToCaster_RayFromToCaster(
        this: *mut btSoftBody_RayFromToCaster,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        mxt: btScalar,
    );
}
impl btSoftBody_RayFromToCaster {
    #[inline]
    pub unsafe fn Process(&mut self, leaf: *const btDbvtNode) {
        btSoftBody_RayFromToCaster_Process(self, leaf)
    }
    #[inline]
    pub unsafe fn rayFromToTriangle(
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayNormalizedDirection: *const btVector3,
        a: *const btVector3,
        b: *const btVector3,
        c: *const btVector3,
        maxt: btScalar,
    ) -> btScalar {
        btSoftBody_RayFromToCaster_rayFromToTriangle(
            rayFrom,
            rayTo,
            rayNormalizedDirection,
            a,
            b,
            c,
            maxt,
        )
    }
    #[inline]
    pub unsafe fn new(rayFrom: *const btVector3, rayTo: *const btVector3, mxt: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBody_RayFromToCaster_RayFromToCaster(&mut __bindgen_tmp, rayFrom, rayTo, mxt);
        __bindgen_tmp
    }
}
pub type btSoftBody_psolver_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut btSoftBody, arg2: btScalar, arg3: btScalar),
>;
pub type btSoftBody_vsolver_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut btSoftBody, arg2: btScalar)>;
pub type btSoftBody_tClusterArray = btAlignedObjectArray<*mut btSoftBody_Cluster>;
pub type btSoftBody_tNoteArray = btAlignedObjectArray<btSoftBody_Note>;
pub type btSoftBody_tNodeArray = btAlignedObjectArray<btSoftBody_Node>;
pub type btSoftBody_tLeafArray = btAlignedObjectArray<*mut btDbvtNode>;
pub type btSoftBody_tLinkArray = btAlignedObjectArray<btSoftBody_Link>;
pub type btSoftBody_tFaceArray = btAlignedObjectArray<btSoftBody_Face>;
pub type btSoftBody_tTetraArray = btAlignedObjectArray<btSoftBody_Tetra>;
pub type btSoftBody_tAnchorArray = btAlignedObjectArray<btSoftBody_Anchor>;
pub type btSoftBody_tRContactArray = btAlignedObjectArray<btSoftBody_RContact>;
pub type btSoftBody_tSContactArray = btAlignedObjectArray<btSoftBody_SContact>;
pub type btSoftBody_tMaterialArray = btAlignedObjectArray<*mut btSoftBody_Material>;
pub type btSoftBody_tJointArray = btAlignedObjectArray<*mut btSoftBody_Joint>;
pub type btSoftBody_tSoftBodyArray = btAlignedObjectArray<*mut btSoftBody>;
extern "C" {
    #[link_name = "\u{1}?initDefaults@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_initDefaults(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?checkLink@btSoftBody@@QEBA_NHH@Z"]
    pub fn btSoftBody_checkLink(
        this: *const btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?checkLink@btSoftBody@@QEBA_NPEBUNode@1@0@Z"]
    pub fn btSoftBody_checkLink1(
        this: *const btSoftBody,
        node0: *const btSoftBody_Node,
        node1: *const btSoftBody_Node,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?checkFace@btSoftBody@@QEBA_NHHH@Z"]
    pub fn btSoftBody_checkFace(
        this: *const btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?appendMaterial@btSoftBody@@QEAAPEAUMaterial@1@XZ"]
    pub fn btSoftBody_appendMaterial(this: *mut btSoftBody) -> *mut btSoftBody_Material;
}
extern "C" {
    #[link_name = "\u{1}?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@AEBVbtVector4@@PEAUNode@1@333@Z"]
    pub fn btSoftBody_appendNote(
        this: *mut btSoftBody,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        c: *const btVector4,
        n0: *mut btSoftBody_Node,
        n1: *mut btSoftBody_Node,
        n2: *mut btSoftBody_Node,
        n3: *mut btSoftBody_Node,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAUNode@1@@Z"]
    pub fn btSoftBody_appendNote1(
        this: *mut btSoftBody,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Node,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAULink@1@@Z"]
    pub fn btSoftBody_appendNote2(
        this: *mut btSoftBody,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Link,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAUFace@1@@Z"]
    pub fn btSoftBody_appendNote3(
        this: *mut btSoftBody,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Face,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendNode@btSoftBody@@QEAAXAEBVbtVector3@@N@Z"]
    pub fn btSoftBody_appendNode(this: *mut btSoftBody, x: *const btVector3, m: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?appendLink@btSoftBody@@QEAAXHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_appendLink(
        this: *mut btSoftBody,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendLink@btSoftBody@@QEAAXHHPEAUMaterial@1@_N@Z"]
    pub fn btSoftBody_appendLink1(
        this: *mut btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
        bcheckexist: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendLink@btSoftBody@@QEAAXPEAUNode@1@0PEAUMaterial@1@_N@Z"]
    pub fn btSoftBody_appendLink2(
        this: *mut btSoftBody,
        node0: *mut btSoftBody_Node,
        node1: *mut btSoftBody_Node,
        mat: *mut btSoftBody_Material,
        bcheckexist: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendFace@btSoftBody@@QEAAXHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_appendFace(
        this: *mut btSoftBody,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendFace@btSoftBody@@QEAAXHHHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_appendFace1(
        this: *mut btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendTetra@btSoftBody@@QEAAXHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_appendTetra(
        this: *mut btSoftBody,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendTetra@btSoftBody@@QEAAXHHHHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_appendTetra1(
        this: *mut btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
        node3: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendAnchor@btSoftBody@@QEAAXHPEAVbtRigidBody@@_NN@Z"]
    pub fn btSoftBody_appendAnchor(
        this: *mut btSoftBody,
        node: ::std::os::raw::c_int,
        body: *mut btRigidBody,
        disableCollisionBetweenLinkedBodies: bool,
        influence: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendAnchor@btSoftBody@@QEAAXHPEAVbtRigidBody@@AEBVbtVector3@@_NN@Z"]
    pub fn btSoftBody_appendAnchor1(
        this: *mut btSoftBody,
        node: ::std::os::raw::c_int,
        body: *mut btRigidBody,
        localPivot: *const btVector3,
        disableCollisionBetweenLinkedBodies: bool,
        influence: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@PEAUCluster@1@UBody@1@@Z"]
    pub fn btSoftBody_appendLinearJoint(
        this: *mut btSoftBody,
        specs: *const btSoftBody_LJoint_Specs,
        body0: *mut btSoftBody_Cluster,
        body1: btSoftBody_Body,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@UBody@1@@Z"]
    pub fn btSoftBody_appendLinearJoint1(
        this: *mut btSoftBody,
        specs: *const btSoftBody_LJoint_Specs,
        body: btSoftBody_Body,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@PEAV1@@Z"]
    pub fn btSoftBody_appendLinearJoint2(
        this: *mut btSoftBody,
        specs: *const btSoftBody_LJoint_Specs,
        body: *mut btSoftBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@PEAUCluster@1@UBody@1@@Z"]
    pub fn btSoftBody_appendAngularJoint(
        this: *mut btSoftBody,
        specs: *const btSoftBody_AJoint_Specs,
        body0: *mut btSoftBody_Cluster,
        body1: btSoftBody_Body,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@UBody@1@@Z"]
    pub fn btSoftBody_appendAngularJoint1(
        this: *mut btSoftBody,
        specs: *const btSoftBody_AJoint_Specs,
        body: btSoftBody_Body,
    );
}
extern "C" {
    #[link_name = "\u{1}?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@PEAV1@@Z"]
    pub fn btSoftBody_appendAngularJoint2(
        this: *mut btSoftBody,
        specs: *const btSoftBody_AJoint_Specs,
        body: *mut btSoftBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?addForce@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_addForce(this: *mut btSoftBody, force: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?addForce@btSoftBody@@QEAAXAEBVbtVector3@@H@Z"]
    pub fn btSoftBody_addForce1(
        this: *mut btSoftBody,
        force: *const btVector3,
        node: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addAeroForceToNode@btSoftBody@@QEAAXAEBVbtVector3@@H@Z"]
    pub fn btSoftBody_addAeroForceToNode(
        this: *mut btSoftBody,
        windVelocity: *const btVector3,
        nodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addAeroForceToFace@btSoftBody@@QEAAXAEBVbtVector3@@H@Z"]
    pub fn btSoftBody_addAeroForceToFace(
        this: *mut btSoftBody,
        windVelocity: *const btVector3,
        faceIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?addVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_addVelocity(this: *mut btSoftBody, velocity: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?setVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_setVelocity(this: *mut btSoftBody, velocity: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?addVelocity@btSoftBody@@QEAAXAEBVbtVector3@@H@Z"]
    pub fn btSoftBody_addVelocity1(
        this: *mut btSoftBody,
        velocity: *const btVector3,
        node: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMass@btSoftBody@@QEAAXHN@Z"]
    pub fn btSoftBody_setMass(this: *mut btSoftBody, node: ::std::os::raw::c_int, mass: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?getMass@btSoftBody@@QEBANH@Z"]
    pub fn btSoftBody_getMass(this: *const btSoftBody, node: ::std::os::raw::c_int) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getTotalMass@btSoftBody@@QEBANXZ"]
    pub fn btSoftBody_getTotalMass(this: *const btSoftBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setTotalMass@btSoftBody@@QEAAXN_N@Z"]
    pub fn btSoftBody_setTotalMass(this: *mut btSoftBody, mass: btScalar, fromfaces: bool);
}
extern "C" {
    #[link_name = "\u{1}?setTotalDensity@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_setTotalDensity(this: *mut btSoftBody, density: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setVolumeMass@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_setVolumeMass(this: *mut btSoftBody, mass: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setVolumeDensity@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_setVolumeDensity(this: *mut btSoftBody, density: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?transform@btSoftBody@@QEAAXAEBVbtTransform@@@Z"]
    pub fn btSoftBody_transform(this: *mut btSoftBody, trs: *const btTransform);
}
extern "C" {
    #[link_name = "\u{1}?translate@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_translate(this: *mut btSoftBody, trs: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?rotate@btSoftBody@@QEAAXAEBVbtQuaternion@@@Z"]
    pub fn btSoftBody_rotate(this: *mut btSoftBody, rot: *const btQuaternion);
}
extern "C" {
    #[link_name = "\u{1}?scale@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_scale(this: *mut btSoftBody, scl: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?getRestLengthScale@btSoftBody@@QEAANXZ"]
    pub fn btSoftBody_getRestLengthScale(this: *mut btSoftBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setRestLengthScale@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_setRestLengthScale(this: *mut btSoftBody, restLength: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setPose@btSoftBody@@QEAAX_N0@Z"]
    pub fn btSoftBody_setPose(this: *mut btSoftBody, bvolume: bool, bframe: bool);
}
extern "C" {
    #[link_name = "\u{1}?resetLinkRestLengths@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_resetLinkRestLengths(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?getVolume@btSoftBody@@QEBANXZ"]
    pub fn btSoftBody_getVolume(this: *const btSoftBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?clusterCount@btSoftBody@@QEBAHXZ"]
    pub fn btSoftBody_clusterCount(this: *const btSoftBody) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?clusterCom@btSoftBody@@SA?AVbtVector3@@PEBUCluster@1@@Z"]
    pub fn btSoftBody_clusterCom(cluster: *const btSoftBody_Cluster) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?clusterCom@btSoftBody@@QEBA?AVbtVector3@@H@Z"]
    pub fn btSoftBody_clusterCom1(
        this: *const btSoftBody,
        cluster: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?clusterVelocity@btSoftBody@@SA?AVbtVector3@@PEBUCluster@1@AEBV2@@Z"]
    pub fn btSoftBody_clusterVelocity(
        cluster: *const btSoftBody_Cluster,
        rpos: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?clusterVImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@1@Z"]
    pub fn btSoftBody_clusterVImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?clusterDImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@1@Z"]
    pub fn btSoftBody_clusterDImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?clusterImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@AEBUImpulse@1@@Z"]
    pub fn btSoftBody_clusterImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btSoftBody_Impulse,
    );
}
extern "C" {
    #[link_name = "\u{1}?clusterVAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z"]
    pub fn btSoftBody_clusterVAImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?clusterDAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z"]
    pub fn btSoftBody_clusterDAImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?clusterAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBUImpulse@1@@Z"]
    pub fn btSoftBody_clusterAImpulse(
        cluster: *mut btSoftBody_Cluster,
        impulse: *const btSoftBody_Impulse,
    );
}
extern "C" {
    #[link_name = "\u{1}?clusterDCImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z"]
    pub fn btSoftBody_clusterDCImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}?generateBendingConstraints@btSoftBody@@QEAAHHPEAUMaterial@1@@Z"]
    pub fn btSoftBody_generateBendingConstraints(
        this: *mut btSoftBody,
        distance: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?randomizeConstraints@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_randomizeConstraints(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?releaseCluster@btSoftBody@@QEAAXH@Z"]
    pub fn btSoftBody_releaseCluster(this: *mut btSoftBody, index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?releaseClusters@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_releaseClusters(this: *mut btSoftBody);
}
extern "C" {
    /// generateClusters with k=0 will create a convex cluster for each tetrahedron or triangle
    /// ///otherwise an approximation will be used (better performance)
    #[link_name = "\u{1}?generateClusters@btSoftBody@@QEAAHHH@Z"]
    pub fn btSoftBody_generateClusters(
        this: *mut btSoftBody,
        k: ::std::os::raw::c_int,
        maxiterations: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?refine@btSoftBody@@QEAAXPEAUImplicitFn@1@N_N@Z"]
    pub fn btSoftBody_refine(
        this: *mut btSoftBody,
        ifn: *mut btSoftBody_ImplicitFn,
        accurary: btScalar,
        cut: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?cutLink@btSoftBody@@QEAA_NHHN@Z"]
    pub fn btSoftBody_cutLink(
        this: *mut btSoftBody,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        position: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?cutLink@btSoftBody@@QEAA_NPEBUNode@1@0N@Z"]
    pub fn btSoftBody_cutLink1(
        this: *mut btSoftBody,
        node0: *const btSoftBody_Node,
        node1: *const btSoftBody_Node,
        position: btScalar,
    ) -> bool;
}
extern "C" {
    /// Ray casting using rayFrom and rayTo in worldspace, (not direction!)
    #[link_name = "\u{1}?rayTest@btSoftBody@@QEAA_NAEBVbtVector3@@0AEAUsRayCast@1@@Z"]
    pub fn btSoftBody_rayTest(
        this: *mut btSoftBody,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        results: *mut btSoftBody_sRayCast,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setSolver@btSoftBody@@QEAAXW4_@eSolverPresets@1@@Z"]
    pub fn btSoftBody_setSolver(this: *mut btSoftBody, preset: btSoftBody_eSolverPresets__);
}
extern "C" {
    #[link_name = "\u{1}?predictMotion@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_predictMotion(this: *mut btSoftBody, dt: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?solveConstraints@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_solveConstraints(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?staticSolve@btSoftBody@@QEAAXH@Z"]
    pub fn btSoftBody_staticSolve(this: *mut btSoftBody, iterations: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?solveCommonConstraints@btSoftBody@@SAXPEAPEAV1@HH@Z"]
    pub fn btSoftBody_solveCommonConstraints(
        bodies: *mut *mut btSoftBody,
        count: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveClusters@btSoftBody@@SAXAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@@Z"]
    pub fn btSoftBody_solveClusters(bodies: *const btAlignedObjectArray<*mut btSoftBody>);
}
extern "C" {
    #[link_name = "\u{1}?integrateMotion@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_integrateMotion(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?defaultCollisionHandler@btSoftBody@@QEAAXPEBUbtCollisionObjectWrapper@@@Z"]
    pub fn btSoftBody_defaultCollisionHandler(
        this: *mut btSoftBody,
        pcoWrap: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}?defaultCollisionHandler@btSoftBody@@QEAAXPEAV1@@Z"]
    pub fn btSoftBody_defaultCollisionHandler1(this: *mut btSoftBody, psb: *mut btSoftBody);
}
extern "C" {
    /// Set a wind velocity for interaction with the air.
    #[link_name = "\u{1}?setWindVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z"]
    pub fn btSoftBody_setWindVelocity(this: *mut btSoftBody, velocity: *const btVector3);
}
extern "C" {
    /// Return the wind velocity for interaction with the air.
    #[link_name = "\u{1}?getWindVelocity@btSoftBody@@QEAAAEBVbtVector3@@XZ"]
    pub fn btSoftBody_getWindVelocity(this: *mut btSoftBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?pointersToIndices@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_pointersToIndices(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?indicesToPointers@btSoftBody@@QEAAXPEBH@Z"]
    pub fn btSoftBody_indicesToPointers(this: *mut btSoftBody, map: *const ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btSoftBody@@QEBAHAEBVbtVector3@@0AEANAEAW4_@eFeature@1@AEAH_N@Z"]
    pub fn btSoftBody_rayTest1(
        this: *const btSoftBody,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        mint: *mut btScalar,
        feature: *mut btSoftBody_eFeature__,
        index: *mut ::std::os::raw::c_int,
        bcountonly: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?initializeFaceTree@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_initializeFaceTree(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?evaluateCom@btSoftBody@@QEBA?AVbtVector3@@XZ"]
    pub fn btSoftBody_evaluateCom(this: *const btSoftBody) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?checkContact@btSoftBody@@QEBA_NPEBUbtCollisionObjectWrapper@@AEBVbtVector3@@NAEAUsCti@1@@Z"]
    pub fn btSoftBody_checkContact(
        this: *const btSoftBody,
        colObjWrap: *const btCollisionObjectWrapper,
        x: *const btVector3,
        margin: btScalar,
        cti: *mut btSoftBody_sCti,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?updateNormals@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updateNormals(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updateBounds@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updateBounds(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updatePose@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updatePose(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updateConstants@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updateConstants(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updateLinkConstants@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updateLinkConstants(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updateArea@btSoftBody@@QEAAX_N@Z"]
    pub fn btSoftBody_updateArea(this: *mut btSoftBody, averageArea: bool);
}
extern "C" {
    #[link_name = "\u{1}?initializeClusters@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_initializeClusters(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?updateClusters@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_updateClusters(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?cleanupClusters@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_cleanupClusters(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?prepareClusters@btSoftBody@@QEAAXH@Z"]
    pub fn btSoftBody_prepareClusters(this: *mut btSoftBody, iterations: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?solveClusters@btSoftBody@@QEAAXN@Z"]
    pub fn btSoftBody_solveClusters1(this: *mut btSoftBody, sor: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?applyClusters@btSoftBody@@QEAAX_N@Z"]
    pub fn btSoftBody_applyClusters(this: *mut btSoftBody, drift: bool);
}
extern "C" {
    #[link_name = "\u{1}?dampClusters@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_dampClusters(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?applyForces@btSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_applyForces(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?PSolve_Anchors@btSoftBody@@SAXPEAV1@NN@Z"]
    pub fn btSoftBody_PSolve_Anchors(psb: *mut btSoftBody, kst: btScalar, ti: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?PSolve_RContacts@btSoftBody@@SAXPEAV1@NN@Z"]
    pub fn btSoftBody_PSolve_RContacts(psb: *mut btSoftBody, kst: btScalar, ti: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?PSolve_SContacts@btSoftBody@@SAXPEAV1@NN@Z"]
    pub fn btSoftBody_PSolve_SContacts(psb: *mut btSoftBody, arg1: btScalar, ti: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?PSolve_Links@btSoftBody@@SAXPEAV1@NN@Z"]
    pub fn btSoftBody_PSolve_Links(psb: *mut btSoftBody, kst: btScalar, ti: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?VSolve_Links@btSoftBody@@SAXPEAV1@N@Z"]
    pub fn btSoftBody_VSolve_Links(psb: *mut btSoftBody, kst: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?getSolver@btSoftBody@@SAP6AXPEAV1@NN@ZW4_@ePSolver@1@@Z"]
    pub fn btSoftBody_getSolver(solver: btSoftBody_ePSolver__) -> btSoftBody_psolver_t;
}
extern "C" {
    #[link_name = "\u{1}?getSolver@btSoftBody@@SAP6AXPEAV1@N@ZW4_@eVSolver@1@@Z"]
    pub fn btSoftBody_getSolver1(solver: btSoftBody_eVSolver__) -> btSoftBody_vsolver_t;
}
extern "C" {
    #[link_name = "\u{1}??0btSoftBody@@QEAA@PEAUbtSoftBodyWorldInfo@@HPEBVbtVector3@@PEBN@Z"]
    pub fn btSoftBody_btSoftBody(
        this: *mut btSoftBody,
        worldInfo: *mut btSoftBodyWorldInfo,
        node_count: ::std::os::raw::c_int,
        x: *const btVector3,
        m: *const btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSoftBody@@QEAA@PEAUbtSoftBodyWorldInfo@@@Z"]
    pub fn btSoftBody_btSoftBody1(this: *mut btSoftBody, worldInfo: *mut btSoftBodyWorldInfo);
}
impl btSoftBody {
    #[inline]
    pub unsafe fn initDefaults(&mut self) {
        btSoftBody_initDefaults(self)
    }
    #[inline]
    pub unsafe fn checkLink(
        &self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
    ) -> bool {
        btSoftBody_checkLink(self, node0, node1)
    }
    #[inline]
    pub unsafe fn checkLink1(
        &self,
        node0: *const btSoftBody_Node,
        node1: *const btSoftBody_Node,
    ) -> bool {
        btSoftBody_checkLink1(self, node0, node1)
    }
    #[inline]
    pub unsafe fn checkFace(
        &self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
    ) -> bool {
        btSoftBody_checkFace(self, node0, node1, node2)
    }
    #[inline]
    pub unsafe fn appendMaterial(&mut self) -> *mut btSoftBody_Material {
        btSoftBody_appendMaterial(self)
    }
    #[inline]
    pub unsafe fn appendNote(
        &mut self,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        c: *const btVector4,
        n0: *mut btSoftBody_Node,
        n1: *mut btSoftBody_Node,
        n2: *mut btSoftBody_Node,
        n3: *mut btSoftBody_Node,
    ) {
        btSoftBody_appendNote(self, text, o, c, n0, n1, n2, n3)
    }
    #[inline]
    pub unsafe fn appendNote1(
        &mut self,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Node,
    ) {
        btSoftBody_appendNote1(self, text, o, feature)
    }
    #[inline]
    pub unsafe fn appendNote2(
        &mut self,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Link,
    ) {
        btSoftBody_appendNote2(self, text, o, feature)
    }
    #[inline]
    pub unsafe fn appendNote3(
        &mut self,
        text: *const ::std::os::raw::c_char,
        o: *const btVector3,
        feature: *mut btSoftBody_Face,
    ) {
        btSoftBody_appendNote3(self, text, o, feature)
    }
    #[inline]
    pub unsafe fn appendNode(&mut self, x: *const btVector3, m: btScalar) {
        btSoftBody_appendNode(self, x, m)
    }
    #[inline]
    pub unsafe fn appendLink(
        &mut self,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) {
        btSoftBody_appendLink(self, model, mat)
    }
    #[inline]
    pub unsafe fn appendLink1(
        &mut self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
        bcheckexist: bool,
    ) {
        btSoftBody_appendLink1(self, node0, node1, mat, bcheckexist)
    }
    #[inline]
    pub unsafe fn appendLink2(
        &mut self,
        node0: *mut btSoftBody_Node,
        node1: *mut btSoftBody_Node,
        mat: *mut btSoftBody_Material,
        bcheckexist: bool,
    ) {
        btSoftBody_appendLink2(self, node0, node1, mat, bcheckexist)
    }
    #[inline]
    pub unsafe fn appendFace(
        &mut self,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) {
        btSoftBody_appendFace(self, model, mat)
    }
    #[inline]
    pub unsafe fn appendFace1(
        &mut self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) {
        btSoftBody_appendFace1(self, node0, node1, node2, mat)
    }
    #[inline]
    pub unsafe fn appendTetra(
        &mut self,
        model: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) {
        btSoftBody_appendTetra(self, model, mat)
    }
    #[inline]
    pub unsafe fn appendTetra1(
        &mut self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
        node3: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) {
        btSoftBody_appendTetra1(self, node0, node1, node2, node3, mat)
    }
    #[inline]
    pub unsafe fn appendAnchor(
        &mut self,
        node: ::std::os::raw::c_int,
        body: *mut btRigidBody,
        disableCollisionBetweenLinkedBodies: bool,
        influence: btScalar,
    ) {
        btSoftBody_appendAnchor(
            self,
            node,
            body,
            disableCollisionBetweenLinkedBodies,
            influence,
        )
    }
    #[inline]
    pub unsafe fn appendAnchor1(
        &mut self,
        node: ::std::os::raw::c_int,
        body: *mut btRigidBody,
        localPivot: *const btVector3,
        disableCollisionBetweenLinkedBodies: bool,
        influence: btScalar,
    ) {
        btSoftBody_appendAnchor1(
            self,
            node,
            body,
            localPivot,
            disableCollisionBetweenLinkedBodies,
            influence,
        )
    }
    #[inline]
    pub unsafe fn appendLinearJoint(
        &mut self,
        specs: *const btSoftBody_LJoint_Specs,
        body0: *mut btSoftBody_Cluster,
        body1: btSoftBody_Body,
    ) {
        btSoftBody_appendLinearJoint(self, specs, body0, body1)
    }
    #[inline]
    pub unsafe fn appendLinearJoint1(
        &mut self,
        specs: *const btSoftBody_LJoint_Specs,
        body: btSoftBody_Body,
    ) {
        btSoftBody_appendLinearJoint1(self, specs, body)
    }
    #[inline]
    pub unsafe fn appendLinearJoint2(
        &mut self,
        specs: *const btSoftBody_LJoint_Specs,
        body: *mut btSoftBody,
    ) {
        btSoftBody_appendLinearJoint2(self, specs, body)
    }
    #[inline]
    pub unsafe fn appendAngularJoint(
        &mut self,
        specs: *const btSoftBody_AJoint_Specs,
        body0: *mut btSoftBody_Cluster,
        body1: btSoftBody_Body,
    ) {
        btSoftBody_appendAngularJoint(self, specs, body0, body1)
    }
    #[inline]
    pub unsafe fn appendAngularJoint1(
        &mut self,
        specs: *const btSoftBody_AJoint_Specs,
        body: btSoftBody_Body,
    ) {
        btSoftBody_appendAngularJoint1(self, specs, body)
    }
    #[inline]
    pub unsafe fn appendAngularJoint2(
        &mut self,
        specs: *const btSoftBody_AJoint_Specs,
        body: *mut btSoftBody,
    ) {
        btSoftBody_appendAngularJoint2(self, specs, body)
    }
    #[inline]
    pub unsafe fn addForce(&mut self, force: *const btVector3) {
        btSoftBody_addForce(self, force)
    }
    #[inline]
    pub unsafe fn addForce1(&mut self, force: *const btVector3, node: ::std::os::raw::c_int) {
        btSoftBody_addForce1(self, force, node)
    }
    #[inline]
    pub unsafe fn addAeroForceToNode(
        &mut self,
        windVelocity: *const btVector3,
        nodeIndex: ::std::os::raw::c_int,
    ) {
        btSoftBody_addAeroForceToNode(self, windVelocity, nodeIndex)
    }
    #[inline]
    pub unsafe fn addAeroForceToFace(
        &mut self,
        windVelocity: *const btVector3,
        faceIndex: ::std::os::raw::c_int,
    ) {
        btSoftBody_addAeroForceToFace(self, windVelocity, faceIndex)
    }
    #[inline]
    pub unsafe fn addVelocity(&mut self, velocity: *const btVector3) {
        btSoftBody_addVelocity(self, velocity)
    }
    #[inline]
    pub unsafe fn setVelocity(&mut self, velocity: *const btVector3) {
        btSoftBody_setVelocity(self, velocity)
    }
    #[inline]
    pub unsafe fn addVelocity1(&mut self, velocity: *const btVector3, node: ::std::os::raw::c_int) {
        btSoftBody_addVelocity1(self, velocity, node)
    }
    #[inline]
    pub unsafe fn setMass(&mut self, node: ::std::os::raw::c_int, mass: btScalar) {
        btSoftBody_setMass(self, node, mass)
    }
    #[inline]
    pub unsafe fn getMass(&self, node: ::std::os::raw::c_int) -> btScalar {
        btSoftBody_getMass(self, node)
    }
    #[inline]
    pub unsafe fn getTotalMass(&self) -> btScalar {
        btSoftBody_getTotalMass(self)
    }
    #[inline]
    pub unsafe fn setTotalMass(&mut self, mass: btScalar, fromfaces: bool) {
        btSoftBody_setTotalMass(self, mass, fromfaces)
    }
    #[inline]
    pub unsafe fn setTotalDensity(&mut self, density: btScalar) {
        btSoftBody_setTotalDensity(self, density)
    }
    #[inline]
    pub unsafe fn setVolumeMass(&mut self, mass: btScalar) {
        btSoftBody_setVolumeMass(self, mass)
    }
    #[inline]
    pub unsafe fn setVolumeDensity(&mut self, density: btScalar) {
        btSoftBody_setVolumeDensity(self, density)
    }
    #[inline]
    pub unsafe fn transform(&mut self, trs: *const btTransform) {
        btSoftBody_transform(self, trs)
    }
    #[inline]
    pub unsafe fn translate(&mut self, trs: *const btVector3) {
        btSoftBody_translate(self, trs)
    }
    #[inline]
    pub unsafe fn rotate(&mut self, rot: *const btQuaternion) {
        btSoftBody_rotate(self, rot)
    }
    #[inline]
    pub unsafe fn scale(&mut self, scl: *const btVector3) {
        btSoftBody_scale(self, scl)
    }
    #[inline]
    pub unsafe fn getRestLengthScale(&mut self) -> btScalar {
        btSoftBody_getRestLengthScale(self)
    }
    #[inline]
    pub unsafe fn setRestLengthScale(&mut self, restLength: btScalar) {
        btSoftBody_setRestLengthScale(self, restLength)
    }
    #[inline]
    pub unsafe fn setPose(&mut self, bvolume: bool, bframe: bool) {
        btSoftBody_setPose(self, bvolume, bframe)
    }
    #[inline]
    pub unsafe fn resetLinkRestLengths(&mut self) {
        btSoftBody_resetLinkRestLengths(self)
    }
    #[inline]
    pub unsafe fn getVolume(&self) -> btScalar {
        btSoftBody_getVolume(self)
    }
    #[inline]
    pub unsafe fn clusterCount(&self) -> ::std::os::raw::c_int {
        btSoftBody_clusterCount(self)
    }
    #[inline]
    pub unsafe fn clusterCom(cluster: *const btSoftBody_Cluster) -> btVector3 {
        btSoftBody_clusterCom(cluster)
    }
    #[inline]
    pub unsafe fn clusterCom1(&self, cluster: ::std::os::raw::c_int) -> btVector3 {
        btSoftBody_clusterCom1(self, cluster)
    }
    #[inline]
    pub unsafe fn clusterVelocity(
        cluster: *const btSoftBody_Cluster,
        rpos: *const btVector3,
    ) -> btVector3 {
        btSoftBody_clusterVelocity(cluster, rpos)
    }
    #[inline]
    pub unsafe fn clusterVImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btVector3,
    ) {
        btSoftBody_clusterVImpulse(cluster, rpos, impulse)
    }
    #[inline]
    pub unsafe fn clusterDImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btVector3,
    ) {
        btSoftBody_clusterDImpulse(cluster, rpos, impulse)
    }
    #[inline]
    pub unsafe fn clusterImpulse(
        cluster: *mut btSoftBody_Cluster,
        rpos: *const btVector3,
        impulse: *const btSoftBody_Impulse,
    ) {
        btSoftBody_clusterImpulse(cluster, rpos, impulse)
    }
    #[inline]
    pub unsafe fn clusterVAImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3) {
        btSoftBody_clusterVAImpulse(cluster, impulse)
    }
    #[inline]
    pub unsafe fn clusterDAImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3) {
        btSoftBody_clusterDAImpulse(cluster, impulse)
    }
    #[inline]
    pub unsafe fn clusterAImpulse(
        cluster: *mut btSoftBody_Cluster,
        impulse: *const btSoftBody_Impulse,
    ) {
        btSoftBody_clusterAImpulse(cluster, impulse)
    }
    #[inline]
    pub unsafe fn clusterDCImpulse(cluster: *mut btSoftBody_Cluster, impulse: *const btVector3) {
        btSoftBody_clusterDCImpulse(cluster, impulse)
    }
    #[inline]
    pub unsafe fn generateBendingConstraints(
        &mut self,
        distance: ::std::os::raw::c_int,
        mat: *mut btSoftBody_Material,
    ) -> ::std::os::raw::c_int {
        btSoftBody_generateBendingConstraints(self, distance, mat)
    }
    #[inline]
    pub unsafe fn randomizeConstraints(&mut self) {
        btSoftBody_randomizeConstraints(self)
    }
    #[inline]
    pub unsafe fn releaseCluster(&mut self, index: ::std::os::raw::c_int) {
        btSoftBody_releaseCluster(self, index)
    }
    #[inline]
    pub unsafe fn releaseClusters(&mut self) {
        btSoftBody_releaseClusters(self)
    }
    #[inline]
    pub unsafe fn generateClusters(
        &mut self,
        k: ::std::os::raw::c_int,
        maxiterations: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btSoftBody_generateClusters(self, k, maxiterations)
    }
    #[inline]
    pub unsafe fn refine(
        &mut self,
        ifn: *mut btSoftBody_ImplicitFn,
        accurary: btScalar,
        cut: bool,
    ) {
        btSoftBody_refine(self, ifn, accurary, cut)
    }
    #[inline]
    pub unsafe fn cutLink(
        &mut self,
        node0: ::std::os::raw::c_int,
        node1: ::std::os::raw::c_int,
        position: btScalar,
    ) -> bool {
        btSoftBody_cutLink(self, node0, node1, position)
    }
    #[inline]
    pub unsafe fn cutLink1(
        &mut self,
        node0: *const btSoftBody_Node,
        node1: *const btSoftBody_Node,
        position: btScalar,
    ) -> bool {
        btSoftBody_cutLink1(self, node0, node1, position)
    }
    #[inline]
    pub unsafe fn rayTest(
        &mut self,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        results: *mut btSoftBody_sRayCast,
    ) -> bool {
        btSoftBody_rayTest(self, rayFrom, rayTo, results)
    }
    #[inline]
    pub unsafe fn setSolver(&mut self, preset: btSoftBody_eSolverPresets__) {
        btSoftBody_setSolver(self, preset)
    }
    #[inline]
    pub unsafe fn predictMotion(&mut self, dt: btScalar) {
        btSoftBody_predictMotion(self, dt)
    }
    #[inline]
    pub unsafe fn solveConstraints(&mut self) {
        btSoftBody_solveConstraints(self)
    }
    #[inline]
    pub unsafe fn staticSolve(&mut self, iterations: ::std::os::raw::c_int) {
        btSoftBody_staticSolve(self, iterations)
    }
    #[inline]
    pub unsafe fn solveCommonConstraints(
        bodies: *mut *mut btSoftBody,
        count: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
    ) {
        btSoftBody_solveCommonConstraints(bodies, count, iterations)
    }
    #[inline]
    pub unsafe fn solveClusters(bodies: *const btAlignedObjectArray<*mut btSoftBody>) {
        btSoftBody_solveClusters(bodies)
    }
    #[inline]
    pub unsafe fn integrateMotion(&mut self) {
        btSoftBody_integrateMotion(self)
    }
    #[inline]
    pub unsafe fn defaultCollisionHandler(&mut self, pcoWrap: *const btCollisionObjectWrapper) {
        btSoftBody_defaultCollisionHandler(self, pcoWrap)
    }
    #[inline]
    pub unsafe fn defaultCollisionHandler1(&mut self, psb: *mut btSoftBody) {
        btSoftBody_defaultCollisionHandler1(self, psb)
    }
    #[inline]
    pub unsafe fn setWindVelocity(&mut self, velocity: *const btVector3) {
        btSoftBody_setWindVelocity(self, velocity)
    }
    #[inline]
    pub unsafe fn getWindVelocity(&mut self) -> *const btVector3 {
        btSoftBody_getWindVelocity(self)
    }
    #[inline]
    pub unsafe fn pointersToIndices(&mut self) {
        btSoftBody_pointersToIndices(self)
    }
    #[inline]
    pub unsafe fn indicesToPointers(&mut self, map: *const ::std::os::raw::c_int) {
        btSoftBody_indicesToPointers(self, map)
    }
    #[inline]
    pub unsafe fn rayTest1(
        &self,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        mint: *mut btScalar,
        feature: *mut btSoftBody_eFeature__,
        index: *mut ::std::os::raw::c_int,
        bcountonly: bool,
    ) -> ::std::os::raw::c_int {
        btSoftBody_rayTest1(self, rayFrom, rayTo, mint, feature, index, bcountonly)
    }
    #[inline]
    pub unsafe fn initializeFaceTree(&mut self) {
        btSoftBody_initializeFaceTree(self)
    }
    #[inline]
    pub unsafe fn evaluateCom(&self) -> btVector3 {
        btSoftBody_evaluateCom(self)
    }
    #[inline]
    pub unsafe fn checkContact(
        &self,
        colObjWrap: *const btCollisionObjectWrapper,
        x: *const btVector3,
        margin: btScalar,
        cti: *mut btSoftBody_sCti,
    ) -> bool {
        btSoftBody_checkContact(self, colObjWrap, x, margin, cti)
    }
    #[inline]
    pub unsafe fn updateNormals(&mut self) {
        btSoftBody_updateNormals(self)
    }
    #[inline]
    pub unsafe fn updateBounds(&mut self) {
        btSoftBody_updateBounds(self)
    }
    #[inline]
    pub unsafe fn updatePose(&mut self) {
        btSoftBody_updatePose(self)
    }
    #[inline]
    pub unsafe fn updateConstants(&mut self) {
        btSoftBody_updateConstants(self)
    }
    #[inline]
    pub unsafe fn updateLinkConstants(&mut self) {
        btSoftBody_updateLinkConstants(self)
    }
    #[inline]
    pub unsafe fn updateArea(&mut self, averageArea: bool) {
        btSoftBody_updateArea(self, averageArea)
    }
    #[inline]
    pub unsafe fn initializeClusters(&mut self) {
        btSoftBody_initializeClusters(self)
    }
    #[inline]
    pub unsafe fn updateClusters(&mut self) {
        btSoftBody_updateClusters(self)
    }
    #[inline]
    pub unsafe fn cleanupClusters(&mut self) {
        btSoftBody_cleanupClusters(self)
    }
    #[inline]
    pub unsafe fn prepareClusters(&mut self, iterations: ::std::os::raw::c_int) {
        btSoftBody_prepareClusters(self, iterations)
    }
    #[inline]
    pub unsafe fn solveClusters1(&mut self, sor: btScalar) {
        btSoftBody_solveClusters1(self, sor)
    }
    #[inline]
    pub unsafe fn applyClusters(&mut self, drift: bool) {
        btSoftBody_applyClusters(self, drift)
    }
    #[inline]
    pub unsafe fn dampClusters(&mut self) {
        btSoftBody_dampClusters(self)
    }
    #[inline]
    pub unsafe fn applyForces(&mut self) {
        btSoftBody_applyForces(self)
    }
    #[inline]
    pub unsafe fn PSolve_Anchors(psb: *mut btSoftBody, kst: btScalar, ti: btScalar) {
        btSoftBody_PSolve_Anchors(psb, kst, ti)
    }
    #[inline]
    pub unsafe fn PSolve_RContacts(psb: *mut btSoftBody, kst: btScalar, ti: btScalar) {
        btSoftBody_PSolve_RContacts(psb, kst, ti)
    }
    #[inline]
    pub unsafe fn PSolve_SContacts(psb: *mut btSoftBody, arg1: btScalar, ti: btScalar) {
        btSoftBody_PSolve_SContacts(psb, arg1, ti)
    }
    #[inline]
    pub unsafe fn PSolve_Links(psb: *mut btSoftBody, kst: btScalar, ti: btScalar) {
        btSoftBody_PSolve_Links(psb, kst, ti)
    }
    #[inline]
    pub unsafe fn VSolve_Links(psb: *mut btSoftBody, kst: btScalar) {
        btSoftBody_VSolve_Links(psb, kst)
    }
    #[inline]
    pub unsafe fn getSolver(solver: btSoftBody_ePSolver__) -> btSoftBody_psolver_t {
        btSoftBody_getSolver(solver)
    }
    #[inline]
    pub unsafe fn getSolver1(solver: btSoftBody_eVSolver__) -> btSoftBody_vsolver_t {
        btSoftBody_getSolver1(solver)
    }
    #[inline]
    pub unsafe fn new(
        worldInfo: *mut btSoftBodyWorldInfo,
        node_count: ::std::os::raw::c_int,
        x: *const btVector3,
        m: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBody_btSoftBody(&mut __bindgen_tmp, worldInfo, node_count, x, m);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(worldInfo: *mut btSoftBodyWorldInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBody_btSoftBody1(&mut __bindgen_tmp, worldInfo);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?Prepare@Joint@btSoftBody@@UEAAXNH@Z"]
    pub fn btSoftBody_Joint_Prepare(
        this: *mut ::std::os::raw::c_void,
        dt: btScalar,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?Prepare@LJoint@btSoftBody@@UEAAXNH@Z"]
    pub fn btSoftBody_LJoint_Prepare(
        this: *mut ::std::os::raw::c_void,
        dt: btScalar,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?Solve@LJoint@btSoftBody@@UEAAXNN@Z"]
    pub fn btSoftBody_LJoint_Solve(this: *mut ::std::os::raw::c_void, dt: btScalar, sor: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?Terminate@LJoint@btSoftBody@@UEAAXN@Z"]
    pub fn btSoftBody_LJoint_Terminate(this: *mut ::std::os::raw::c_void, dt: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?Prepare@AJoint@btSoftBody@@UEAAXNH@Z"]
    pub fn btSoftBody_AJoint_Prepare(
        this: *mut ::std::os::raw::c_void,
        dt: btScalar,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?Solve@AJoint@btSoftBody@@UEAAXNN@Z"]
    pub fn btSoftBody_AJoint_Solve(this: *mut ::std::os::raw::c_void, dt: btScalar, sor: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?Terminate@AJoint@btSoftBody@@UEAAXN@Z"]
    pub fn btSoftBody_AJoint_Terminate(this: *mut ::std::os::raw::c_void, dt: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?Prepare@CJoint@btSoftBody@@UEAAXNH@Z"]
    pub fn btSoftBody_CJoint_Prepare(
        this: *mut ::std::os::raw::c_void,
        dt: btScalar,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?Solve@CJoint@btSoftBody@@UEAAXNN@Z"]
    pub fn btSoftBody_CJoint_Solve(this: *mut ::std::os::raw::c_void, dt: btScalar, sor: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?Terminate@CJoint@btSoftBody@@UEAAXN@Z"]
    pub fn btSoftBody_CJoint_Terminate(this: *mut ::std::os::raw::c_void, dt: btScalar);
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftBody@@QEAAXXZ"]
    pub fn btSoftBody_btSoftBody_destructor(this: *mut btSoftBody);
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btSoftBody@@UEBAHXZ"]
    pub fn btSoftBody_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btSoftBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btSoftBody_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyHelpers {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?Draw@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@H@Z"]
    pub fn btSoftBodyHelpers_Draw(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        drawflags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?DrawInfos@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@_N22@Z"]
    pub fn btSoftBodyHelpers_DrawInfos(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        masses: bool,
        areas: bool,
        stress: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?DrawNodeTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z"]
    pub fn btSoftBodyHelpers_DrawNodeTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?DrawFaceTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z"]
    pub fn btSoftBodyHelpers_DrawFaceTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?DrawClusterTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z"]
    pub fn btSoftBodyHelpers_DrawClusterTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?DrawFrame@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@@Z"]
    pub fn btSoftBodyHelpers_DrawFrame(psb: *mut btSoftBody, idraw: *mut btIDebugDraw);
}
extern "C" {
    #[link_name = "\u{1}?CreateRope@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@1HH@Z"]
    pub fn btSoftBodyHelpers_CreateRope(
        worldInfo: *mut btSoftBodyWorldInfo,
        from: *const btVector3,
        to: *const btVector3,
        res: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CreatePatch@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@111HHH_N@Z"]
    pub fn btSoftBodyHelpers_CreatePatch(
        worldInfo: *mut btSoftBodyWorldInfo,
        corner00: *const btVector3,
        corner10: *const btVector3,
        corner01: *const btVector3,
        corner11: *const btVector3,
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
        gendiags: bool,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CreatePatchUV@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@111HHH_NPEAM@Z"]
    pub fn btSoftBodyHelpers_CreatePatchUV(
        worldInfo: *mut btSoftBodyWorldInfo,
        corner00: *const btVector3,
        corner10: *const btVector3,
        corner01: *const btVector3,
        corner11: *const btVector3,
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
        gendiags: bool,
        tex_coords: *mut f32,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CalculateUV@btSoftBodyHelpers@@SAMHHHHH@Z"]
    pub fn btSoftBodyHelpers_CalculateUV(
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        ix: ::std::os::raw::c_int,
        iy: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}?CreateEllipsoid@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@1H@Z"]
    pub fn btSoftBodyHelpers_CreateEllipsoid(
        worldInfo: *mut btSoftBodyWorldInfo,
        center: *const btVector3,
        radius: *const btVector3,
        res: ::std::os::raw::c_int,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CreateFromTriMesh@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBNPEBHH_N@Z"]
    pub fn btSoftBodyHelpers_CreateFromTriMesh(
        worldInfo: *mut btSoftBodyWorldInfo,
        vertices: *const btScalar,
        triangles: *const ::std::os::raw::c_int,
        ntriangles: ::std::os::raw::c_int,
        randomizeConstraints: bool,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CreateFromConvexHull@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBVbtVector3@@H_N@Z"]
    pub fn btSoftBodyHelpers_CreateFromConvexHull(
        worldInfo: *mut btSoftBodyWorldInfo,
        vertices: *const btVector3,
        nvertices: ::std::os::raw::c_int,
        randomizeConstraints: bool,
    ) -> *mut btSoftBody;
}
extern "C" {
    #[link_name = "\u{1}?CreateFromTetGenData@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBD11_N22@Z"]
    pub fn btSoftBodyHelpers_CreateFromTetGenData(
        worldInfo: *mut btSoftBodyWorldInfo,
        ele: *const ::std::os::raw::c_char,
        face: *const ::std::os::raw::c_char,
        node: *const ::std::os::raw::c_char,
        bfacelinks: bool,
        btetralinks: bool,
        bfacesfromtetras: bool,
    ) -> *mut btSoftBody;
}
extern "C" {
    /// Sort the list of links to move link calculations that are dependent upon earlier
    /// /// ones as far as possible away from the calculation of those values
    /// /// This tends to make adjacent loop iterations not dependent upon one another,
    /// /// so out-of-order processors can execute instructions from multiple iterations at once
    #[link_name = "\u{1}?ReoptimizeLinkOrder@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@@Z"]
    pub fn btSoftBodyHelpers_ReoptimizeLinkOrder(psb: *mut btSoftBody);
}
impl btSoftBodyHelpers {
    #[inline]
    pub unsafe fn Draw(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        drawflags: ::std::os::raw::c_int,
    ) {
        btSoftBodyHelpers_Draw(psb, idraw, drawflags)
    }
    #[inline]
    pub unsafe fn DrawInfos(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        masses: bool,
        areas: bool,
        stress: bool,
    ) {
        btSoftBodyHelpers_DrawInfos(psb, idraw, masses, areas, stress)
    }
    #[inline]
    pub unsafe fn DrawNodeTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    ) {
        btSoftBodyHelpers_DrawNodeTree(psb, idraw, mindepth, maxdepth)
    }
    #[inline]
    pub unsafe fn DrawFaceTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    ) {
        btSoftBodyHelpers_DrawFaceTree(psb, idraw, mindepth, maxdepth)
    }
    #[inline]
    pub unsafe fn DrawClusterTree(
        psb: *mut btSoftBody,
        idraw: *mut btIDebugDraw,
        mindepth: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
    ) {
        btSoftBodyHelpers_DrawClusterTree(psb, idraw, mindepth, maxdepth)
    }
    #[inline]
    pub unsafe fn DrawFrame(psb: *mut btSoftBody, idraw: *mut btIDebugDraw) {
        btSoftBodyHelpers_DrawFrame(psb, idraw)
    }
    #[inline]
    pub unsafe fn CreateRope(
        worldInfo: *mut btSoftBodyWorldInfo,
        from: *const btVector3,
        to: *const btVector3,
        res: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreateRope(worldInfo, from, to, res, fixeds)
    }
    #[inline]
    pub unsafe fn CreatePatch(
        worldInfo: *mut btSoftBodyWorldInfo,
        corner00: *const btVector3,
        corner10: *const btVector3,
        corner01: *const btVector3,
        corner11: *const btVector3,
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
        gendiags: bool,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreatePatch(
            worldInfo, corner00, corner10, corner01, corner11, resx, resy, fixeds, gendiags,
        )
    }
    #[inline]
    pub unsafe fn CreatePatchUV(
        worldInfo: *mut btSoftBodyWorldInfo,
        corner00: *const btVector3,
        corner10: *const btVector3,
        corner01: *const btVector3,
        corner11: *const btVector3,
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        fixeds: ::std::os::raw::c_int,
        gendiags: bool,
        tex_coords: *mut f32,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreatePatchUV(
            worldInfo, corner00, corner10, corner01, corner11, resx, resy, fixeds, gendiags,
            tex_coords,
        )
    }
    #[inline]
    pub unsafe fn CalculateUV(
        resx: ::std::os::raw::c_int,
        resy: ::std::os::raw::c_int,
        ix: ::std::os::raw::c_int,
        iy: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> f32 {
        btSoftBodyHelpers_CalculateUV(resx, resy, ix, iy, id)
    }
    #[inline]
    pub unsafe fn CreateEllipsoid(
        worldInfo: *mut btSoftBodyWorldInfo,
        center: *const btVector3,
        radius: *const btVector3,
        res: ::std::os::raw::c_int,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreateEllipsoid(worldInfo, center, radius, res)
    }
    #[inline]
    pub unsafe fn CreateFromTriMesh(
        worldInfo: *mut btSoftBodyWorldInfo,
        vertices: *const btScalar,
        triangles: *const ::std::os::raw::c_int,
        ntriangles: ::std::os::raw::c_int,
        randomizeConstraints: bool,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreateFromTriMesh(
            worldInfo,
            vertices,
            triangles,
            ntriangles,
            randomizeConstraints,
        )
    }
    #[inline]
    pub unsafe fn CreateFromConvexHull(
        worldInfo: *mut btSoftBodyWorldInfo,
        vertices: *const btVector3,
        nvertices: ::std::os::raw::c_int,
        randomizeConstraints: bool,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreateFromConvexHull(worldInfo, vertices, nvertices, randomizeConstraints)
    }
    #[inline]
    pub unsafe fn CreateFromTetGenData(
        worldInfo: *mut btSoftBodyWorldInfo,
        ele: *const ::std::os::raw::c_char,
        face: *const ::std::os::raw::c_char,
        node: *const ::std::os::raw::c_char,
        bfacelinks: bool,
        btetralinks: bool,
        bfacesfromtetras: bool,
    ) -> *mut btSoftBody {
        btSoftBodyHelpers_CreateFromTetGenData(
            worldInfo,
            ele,
            face,
            node,
            bfacelinks,
            btetralinks,
            bfacesfromtetras,
        )
    }
    #[inline]
    pub unsafe fn ReoptimizeLinkOrder(psb: *mut btSoftBody) {
        btSoftBodyHelpers_ReoptimizeLinkOrder(psb)
    }
}
/// This class is used to compute the polar decomposition of a matrix. In
/// general, the polar decomposition factorizes a matrix, A, into two parts: a
/// unitary matrix (U) and a positive, semi-definite Hermitian matrix (H).
/// However, in this particular implementation the original matrix, A, is
/// required to be a square 3x3 matrix with real elements. This means that U will
/// be an orthogonal matrix and H with be a positive-definite, symmetric matrix.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPolarDecomposition {
    pub m_tolerance: btScalar,
    pub m_maxIterations: ::std::os::raw::c_uint,
}
extern "C" {
    /// Decomposes a matrix into orthogonal and symmetric, positive-definite
    /// parts. If the number of iterations returned by this function is equal to
    /// the maximum number of iterations, the algorithm has failed to converge.
    ///
    /// @param a - the original matrix
    /// @param u - the resulting orthogonal matrix
    /// @param h - the resulting symmetric matrix
    ///
    /// @return the number of iterations performed by the algorithm.
    #[link_name = "\u{1}?decompose@btPolarDecomposition@@QEBAIAEBVbtMatrix3x3@@AEAV2@1@Z"]
    pub fn btPolarDecomposition_decompose(
        this: *const btPolarDecomposition,
        a: *const btMatrix3x3,
        u: *mut btMatrix3x3,
        h: *mut btMatrix3x3,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Returns the maximum number of iterations that this algorithm will perform
    /// to achieve convergence.
    ///
    /// @return maximum number of iterations
    #[link_name = "\u{1}?maxIterations@btPolarDecomposition@@QEBAIXZ"]
    pub fn btPolarDecomposition_maxIterations(
        this: *const btPolarDecomposition,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Creates an instance with optional parameters.
    ///
    /// @param tolerance     - the tolerance used to determine convergence of the
    /// algorithm
    /// @param maxIterations - the maximum number of iterations used to achieve
    /// convergence
    #[link_name = "\u{1}??0btPolarDecomposition@@QEAA@NI@Z"]
    pub fn btPolarDecomposition_btPolarDecomposition(
        this: *mut btPolarDecomposition,
        tolerance: btScalar,
        maxIterations: ::std::os::raw::c_uint,
    );
}
impl btPolarDecomposition {
    #[inline]
    pub unsafe fn decompose(
        &self,
        a: *const btMatrix3x3,
        u: *mut btMatrix3x3,
        h: *mut btMatrix3x3,
    ) -> ::std::os::raw::c_uint {
        btPolarDecomposition_decompose(self, a, u, h)
    }
    #[inline]
    pub unsafe fn maxIterations(&self) -> ::std::os::raw::c_uint {
        btPolarDecomposition_maxIterations(self)
    }
    #[inline]
    pub unsafe fn new(tolerance: btScalar, maxIterations: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPolarDecomposition_btPolarDecomposition(&mut __bindgen_tmp, tolerance, maxIterations);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btSymMatrix<T> {
    pub store: btAlignedObjectArray<T>,
    pub dim: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyCollisionShape {
    pub _base: btConcaveShape,
    pub m_body: *mut btSoftBody,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftClusterCollisionShape {
    pub _base: btConvexInternalShape,
    pub m_cluster: *const btSoftBody_Cluster,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btEigen {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders_ClusterBase {
    pub erp: btScalar,
    pub idt: btScalar,
    pub m_margin: btScalar,
    pub friction: btScalar,
    pub threshold: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders_CollideCL_RS {
    pub _base: btSoftColliders_ClusterBase,
    pub psb: *mut btSoftBody,
    pub m_colObjWrap: *const btCollisionObjectWrapper,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders_CollideCL_SS {
    pub _base: btSoftColliders_ClusterBase,
    pub bodies: [*mut btSoftBody; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders_CollideSDF_RS {
    pub psb: *mut btSoftBody,
    pub m_colObj1Wrap: *const btCollisionObjectWrapper,
    pub m_rigidBody: *mut btRigidBody,
    pub dynmargin: btScalar,
    pub stamargin: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftColliders_CollideVF_SS {
    pub psb: [*mut btSoftBody; 2usize],
    pub mrg: btScalar,
}
#[repr(C)]
pub struct btCollisionConfiguration__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionConfiguration allows to configure Bullet collision detection
/// stack allocator size, default collision algorithms and persistent manifold pool size
/// @todo: describe the meaning
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionConfiguration {
    pub vtable_: *const btCollisionConfiguration__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDefaultCollisionConstructionInfo {
    pub m_persistentManifoldPool: *mut btPoolAllocator,
    pub m_collisionAlgorithmPool: *mut btPoolAllocator,
    pub m_defaultMaxPersistentManifoldPoolSize: ::std::os::raw::c_int,
    pub m_defaultMaxCollisionAlgorithmPoolSize: ::std::os::raw::c_int,
    pub m_customCollisionAlgorithmMaxElementSize: ::std::os::raw::c_int,
    pub m_useEpaPenetrationAlgorithm: ::std::os::raw::c_int,
}
/// btCollisionConfiguration allows to configure Bullet collision detection
/// stack allocator, pool memory allocators
/// @todo: describe the meaning
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultCollisionConfiguration {
    pub _base: btCollisionConfiguration,
    pub m_persistentManifoldPoolSize: ::std::os::raw::c_int,
    pub m_persistentManifoldPool: *mut btPoolAllocator,
    pub m_ownsPersistentManifoldPool: bool,
    pub m_collisionAlgorithmPool: *mut btPoolAllocator,
    pub m_ownsCollisionAlgorithmPool: bool,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub m_convexConvexCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_convexConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedConvexConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_compoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_compoundCompoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedCompoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_emptyCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereBoxCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_boxSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_boxBoxCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereTriangleCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_triangleSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_planeConvexCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_convexPlaneCF: *mut btCollisionAlgorithmCreateFunc,
}
extern "C" {
    /// Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
    /// ///By default, this feature is disabled for best performance.
    /// ///@param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
    /// ///@param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
    /// ///3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
    /// ///See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
    /// ///@todo we could add a per-object setting of those parameters, for level-of-detail collision detection.
    #[link_name = "\u{1}?setConvexConvexMultipointIterations@btDefaultCollisionConfiguration@@QEAAXHH@Z"]
    pub fn btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
        this: *mut btDefaultCollisionConfiguration,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setPlaneConvexMultipointIterations@btDefaultCollisionConfiguration@@QEAAXHH@Z"]
    pub fn btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
        this: *mut btDefaultCollisionConfiguration,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btDefaultCollisionConfiguration@@QEAA@AEBUbtDefaultCollisionConstructionInfo@@@Z"]
    pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
        this: *mut btDefaultCollisionConfiguration,
        constructionInfo: *const btDefaultCollisionConstructionInfo,
    );
}
impl btDefaultCollisionConfiguration {
    #[inline]
    pub unsafe fn setConvexConvexMultipointIterations(
        &mut self,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) {
        btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
            self,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        )
    }
    #[inline]
    pub unsafe fn setPlaneConvexMultipointIterations(
        &mut self,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) {
        btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
            self,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        )
    }
    #[inline]
    pub unsafe fn new(constructionInfo: *const btDefaultCollisionConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
            &mut __bindgen_tmp,
            constructionInfo,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtDefaultCollisionConfiguration@@QEAAXXZ"]
    pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_destructor(
        this: *mut btDefaultCollisionConfiguration,
    );
}
extern "C" {
    #[link_name = "\u{1}?getCollisionAlgorithmCreateFunc@btDefaultCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z"]
    pub fn btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
extern "C" {
    #[link_name = "\u{1}?getClosestPointsAlgorithmCreateFunc@btDefaultCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z"]
    pub fn btDefaultCollisionConfiguration_getClosestPointsAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
/// btSoftBodyRigidBodyCollisionConfiguration add softbody interaction on top of btDefaultCollisionConfiguration
#[repr(C)]
#[derive(Debug)]
pub struct btSoftBodyRigidBodyCollisionConfiguration {
    pub _base: btDefaultCollisionConfiguration,
    pub m_softSoftCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_softRigidConvexCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedSoftRigidConvexCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_softRigidConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedSoftRigidConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btSoftBodyRigidBodyCollisionConfiguration@@QEAA@AEBUbtDefaultCollisionConstructionInfo@@@Z"]
    pub fn btSoftBodyRigidBodyCollisionConfiguration_btSoftBodyRigidBodyCollisionConfiguration(
        this: *mut btSoftBodyRigidBodyCollisionConfiguration,
        constructionInfo: *const btDefaultCollisionConstructionInfo,
    );
}
impl btSoftBodyRigidBodyCollisionConfiguration {
    #[inline]
    pub unsafe fn new(constructionInfo: *const btDefaultCollisionConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftBodyRigidBodyCollisionConfiguration_btSoftBodyRigidBodyCollisionConfiguration(
            &mut __bindgen_tmp,
            constructionInfo,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftBodyRigidBodyCollisionConfiguration@@QEAAXXZ"]
    pub fn btSoftBodyRigidBodyCollisionConfiguration_btSoftBodyRigidBodyCollisionConfiguration_destructor(
        this: *mut btSoftBodyRigidBodyCollisionConfiguration,
    );
}
extern "C" {
    /// creation of soft-soft and soft-rigid, and otherwise fallback to base class implementation
    #[link_name = "\u{1}?getCollisionAlgorithmCreateFunc@btSoftBodyRigidBodyCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z"]
    pub fn btSoftBodyRigidBodyCollisionConfiguration_getCollisionAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiBodyInplaceSolverIslandCallback {
    _unused: [u8; 0],
}
/// The btMultiBodyDynamicsWorld adds Featherstone multi body dynamics to Bullet
/// This implementation is still preliminary/experimental.
#[repr(C)]
#[derive(Debug)]
pub struct btMultiBodyDynamicsWorld {
    pub _base: btDiscreteDynamicsWorld,
    pub m_multiBodies: btAlignedObjectArray<*mut btMultiBody>,
    pub m_multiBodyConstraints: btAlignedObjectArray<*mut btMultiBodyConstraint>,
    pub m_sortedMultiBodyConstraints: btAlignedObjectArray<*mut btMultiBodyConstraint>,
    pub m_multiBodyConstraintSolver: *mut btMultiBodyConstraintSolver,
    pub m_solverMultiBodyIslandCallback: *mut MultiBodyInplaceSolverIslandCallback,
    pub m_scratch_world_to_local: btAlignedObjectArray<btQuaternion>,
    pub m_scratch_local_origin: btAlignedObjectArray<btVector3>,
    pub m_scratch_world_to_local1: btAlignedObjectArray<btQuaternion>,
    pub m_scratch_local_origin1: btAlignedObjectArray<btVector3>,
    pub m_scratch_r: btAlignedObjectArray<btScalar>,
    pub m_scratch_v: btAlignedObjectArray<btVector3>,
    pub m_scratch_m: btAlignedObjectArray<btMatrix3x3>,
}
extern "C" {
    #[link_name = "\u{1}?forwardKinematics@btMultiBodyDynamicsWorld@@QEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_forwardKinematics(this: *mut btMultiBodyDynamicsWorld);
}
extern "C" {
    #[link_name = "\u{1}??0btMultiBodyDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtMultiBodyConstraintSolver@@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btMultiBodyDynamicsWorld_btMultiBodyDynamicsWorld(
        this: *mut btMultiBodyDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btMultiBodyConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btMultiBodyDynamicsWorld {
    #[inline]
    pub unsafe fn forwardKinematics(&mut self) {
        btMultiBodyDynamicsWorld_forwardKinematics(self)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btMultiBodyConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiBodyDynamicsWorld_btMultiBodyDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?calculateSimulationIslands@btMultiBodyDynamicsWorld@@MEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_calculateSimulationIslands(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?updateActivationState@btMultiBodyDynamicsWorld@@MEAAXN@Z"]
    pub fn btMultiBodyDynamicsWorld_updateActivationState(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveConstraints@btMultiBodyDynamicsWorld@@MEAAXAEAUbtContactSolverInfo@@@Z"]
    pub fn btMultiBodyDynamicsWorld_solveConstraints(
        this: *mut ::std::os::raw::c_void,
        solverInfo: *mut btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeMultiBodies@btMultiBodyDynamicsWorld@@MEAAXPEAVbtSerializer@@@Z"]
    pub fn btMultiBodyDynamicsWorld_serializeMultiBodies(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtMultiBodyDynamicsWorld@@QEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_btMultiBodyDynamicsWorld_destructor(
        this: *mut btMultiBodyDynamicsWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?addMultiBody@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBody@@HH@Z"]
    pub fn btMultiBodyDynamicsWorld_addMultiBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btMultiBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeMultiBody@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBody@@@Z"]
    pub fn btMultiBodyDynamicsWorld_removeMultiBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btMultiBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?addMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z"]
    pub fn btMultiBodyDynamicsWorld_addMultiBodyConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btMultiBodyConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z"]
    pub fn btMultiBodyDynamicsWorld_removeMultiBodyConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btMultiBodyConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?integrateTransforms@btMultiBodyDynamicsWorld@@UEAAXN@Z"]
    pub fn btMultiBodyDynamicsWorld_integrateTransforms(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?debugDrawMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z"]
    pub fn btMultiBodyDynamicsWorld_debugDrawMultiBodyConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btMultiBodyConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?clearForces@btMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?clearMultiBodyConstraintForces@btMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_clearMultiBodyConstraintForces(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?clearMultiBodyForces@btMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_clearMultiBodyForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?applyGravity@btMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btMultiBodyDynamicsWorld_applyGravity(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?serialize@btMultiBodyDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z"]
    pub fn btMultiBodyDynamicsWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
pub type btSoftBodyArray = btAlignedObjectArray<*mut btSoftBody>;
#[repr(C)]
#[derive(Debug)]
pub struct btSoftMultiBodyDynamicsWorld {
    pub _base: btMultiBodyDynamicsWorld,
    pub m_softBodies: btSoftBodyArray,
    pub m_drawFlags: ::std::os::raw::c_int,
    pub m_drawNodeTree: bool,
    pub m_drawFaceTree: bool,
    pub m_drawClusterTree: bool,
    pub __bindgen_padding_0: u64,
    pub m_sbi: btSoftBodyWorldInfo,
    /// Solver classes that encapsulate multiple soft bodies for solving
    pub m_softBodySolver: *mut btSoftBodySolver,
    pub m_ownsSolver: bool,
    pub __bindgen_padding_1: [u8; 7usize],
}
extern "C" {
    #[link_name = "\u{1}?solveSoftBodiesConstraints@btSoftMultiBodyDynamicsWorld@@IEAAXN@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_solveSoftBodiesConstraints(
        this: *mut btSoftMultiBodyDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeSoftBodies@btSoftMultiBodyDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_serializeSoftBodies(
        this: *mut btSoftMultiBodyDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?addSoftBody@btSoftMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@HH@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_addSoftBody(
        this: *mut btSoftMultiBodyDynamicsWorld,
        body: *mut btSoftBody,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeSoftBody@btSoftMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_removeSoftBody(
        this: *mut btSoftMultiBodyDynamicsWorld,
        body: *mut btSoftBody,
    );
}
extern "C" {
    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// /// This allows more customization.
    #[link_name = "\u{1}?rayTestSingle@btSoftMultiBodyDynamicsWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSoftMultiBodyDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtMultiBodyConstraintSolver@@PEAVbtCollisionConfiguration@@PEAVbtSoftBodySolver@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_btSoftMultiBodyDynamicsWorld(
        this: *mut btSoftMultiBodyDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btMultiBodyConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
        softBodySolver: *mut btSoftBodySolver,
    );
}
impl btSoftMultiBodyDynamicsWorld {
    #[inline]
    pub unsafe fn solveSoftBodiesConstraints(&mut self, timeStep: btScalar) {
        btSoftMultiBodyDynamicsWorld_solveSoftBodiesConstraints(self, timeStep)
    }
    #[inline]
    pub unsafe fn serializeSoftBodies(&mut self, serializer: *mut btSerializer) {
        btSoftMultiBodyDynamicsWorld_serializeSoftBodies(self, serializer)
    }
    #[inline]
    pub unsafe fn addSoftBody(
        &mut self,
        body: *mut btSoftBody,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) {
        btSoftMultiBodyDynamicsWorld_addSoftBody(
            self,
            body,
            collisionFilterGroup,
            collisionFilterMask,
        )
    }
    #[inline]
    pub unsafe fn removeSoftBody(&mut self, body: *mut btSoftBody) {
        btSoftMultiBodyDynamicsWorld_removeSoftBody(self, body)
    }
    #[inline]
    pub unsafe fn rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btSoftMultiBodyDynamicsWorld_rayTestSingle(
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btMultiBodyConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
        softBodySolver: *mut btSoftBodySolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftMultiBodyDynamicsWorld_btSoftMultiBodyDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
            softBodySolver,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?predictUnconstraintMotion@btSoftMultiBodyDynamicsWorld@@MEAAXN@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_predictUnconstraintMotion(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalSingleStepSimulation@btSoftMultiBodyDynamicsWorld@@MEAAXN@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_internalSingleStepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftMultiBodyDynamicsWorld@@QEAAXXZ"]
    pub fn btSoftMultiBodyDynamicsWorld_btSoftMultiBodyDynamicsWorld_destructor(
        this: *mut btSoftMultiBodyDynamicsWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btSoftMultiBodyDynamicsWorld@@UEAAXXZ"]
    pub fn btSoftMultiBodyDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btDiscreteDynamicsWorld::removeCollisionObject
    #[link_name = "\u{1}?removeCollisionObject@btSoftMultiBodyDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btSoftMultiBodyDynamicsWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?serialize@btSoftMultiBodyDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z"]
    pub fn btSoftMultiBodyDynamicsWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// btSoftRigidCollisionAlgorithm  provides collision detection between btSoftBody and btRigidBody
#[repr(C)]
#[derive(Debug)]
pub struct btSoftRigidCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
    /// for rigid versus soft (instead of soft versus rigid), we use this swapped boolean
    pub m_isSwapped: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftRigidCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btSoftRigidCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z"]
    pub fn btSoftRigidCollisionAlgorithm_btSoftRigidCollisionAlgorithm(
        this: *mut btSoftRigidCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    );
}
impl btSoftRigidCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
        isSwapped: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftRigidCollisionAlgorithm_btSoftRigidCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            col0,
            col1Wrap,
            isSwapped,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftRigidCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSoftRigidCollisionAlgorithm_btSoftRigidCollisionAlgorithm_destructor(
        this: *mut btSoftRigidCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSoftRigidCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftRigidCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSoftRigidCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftRigidCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftRigidDynamicsWorld {
    pub _base: btDiscreteDynamicsWorld,
    pub m_softBodies: btSoftBodyArray,
    pub m_drawFlags: ::std::os::raw::c_int,
    pub m_drawNodeTree: bool,
    pub m_drawFaceTree: bool,
    pub m_drawClusterTree: bool,
    pub __bindgen_padding_0: u64,
    pub m_sbi: btSoftBodyWorldInfo,
    /// Solver classes that encapsulate multiple soft bodies for solving
    pub m_softBodySolver: *mut btSoftBodySolver,
    pub m_ownsSolver: bool,
    pub __bindgen_padding_1: [u8; 7usize],
}
extern "C" {
    #[link_name = "\u{1}?solveSoftBodiesConstraints@btSoftRigidDynamicsWorld@@IEAAXN@Z"]
    pub fn btSoftRigidDynamicsWorld_solveSoftBodiesConstraints(
        this: *mut btSoftRigidDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?serializeSoftBodies@btSoftRigidDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z"]
    pub fn btSoftRigidDynamicsWorld_serializeSoftBodies(
        this: *mut btSoftRigidDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}?addSoftBody@btSoftRigidDynamicsWorld@@QEAAXPEAVbtSoftBody@@HH@Z"]
    pub fn btSoftRigidDynamicsWorld_addSoftBody(
        this: *mut btSoftRigidDynamicsWorld,
        body: *mut btSoftBody,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeSoftBody@btSoftRigidDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z"]
    pub fn btSoftRigidDynamicsWorld_removeSoftBody(
        this: *mut btSoftRigidDynamicsWorld,
        body: *mut btSoftBody,
    );
}
extern "C" {
    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// /// This allows more customization.
    #[link_name = "\u{1}?rayTestSingle@btSoftRigidDynamicsWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btSoftRigidDynamicsWorld_rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSoftRigidDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@PEAVbtSoftBodySolver@@@Z"]
    pub fn btSoftRigidDynamicsWorld_btSoftRigidDynamicsWorld(
        this: *mut btSoftRigidDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
        softBodySolver: *mut btSoftBodySolver,
    );
}
impl btSoftRigidDynamicsWorld {
    #[inline]
    pub unsafe fn solveSoftBodiesConstraints(&mut self, timeStep: btScalar) {
        btSoftRigidDynamicsWorld_solveSoftBodiesConstraints(self, timeStep)
    }
    #[inline]
    pub unsafe fn serializeSoftBodies(&mut self, serializer: *mut btSerializer) {
        btSoftRigidDynamicsWorld_serializeSoftBodies(self, serializer)
    }
    #[inline]
    pub unsafe fn addSoftBody(
        &mut self,
        body: *mut btSoftBody,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) {
        btSoftRigidDynamicsWorld_addSoftBody(self, body, collisionFilterGroup, collisionFilterMask)
    }
    #[inline]
    pub unsafe fn removeSoftBody(&mut self, body: *mut btSoftBody) {
        btSoftRigidDynamicsWorld_removeSoftBody(self, body)
    }
    #[inline]
    pub unsafe fn rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btSoftRigidDynamicsWorld_rayTestSingle(
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
        softBodySolver: *mut btSoftBodySolver,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftRigidDynamicsWorld_btSoftRigidDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
            softBodySolver,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?predictUnconstraintMotion@btSoftRigidDynamicsWorld@@MEAAXN@Z"]
    pub fn btSoftRigidDynamicsWorld_predictUnconstraintMotion(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?internalSingleStepSimulation@btSoftRigidDynamicsWorld@@MEAAXN@Z"]
    pub fn btSoftRigidDynamicsWorld_internalSingleStepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftRigidDynamicsWorld@@QEAAXXZ"]
    pub fn btSoftRigidDynamicsWorld_btSoftRigidDynamicsWorld_destructor(
        this: *mut btSoftRigidDynamicsWorld,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btSoftRigidDynamicsWorld@@UEAAXXZ"]
    pub fn btSoftRigidDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btDiscreteDynamicsWorld::removeCollisionObject
    #[link_name = "\u{1}?removeCollisionObject@btSoftRigidDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btSoftRigidDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btSoftRigidDynamicsWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z"]
    pub fn btSoftRigidDynamicsWorld_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?serialize@btSoftRigidDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z"]
    pub fn btSoftRigidDynamicsWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// collision detection between two btSoftBody shapes
#[repr(C)]
#[derive(Debug)]
pub struct btSoftSoftCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSoftSoftCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btSoftSoftCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z"]
    pub fn btSoftSoftCollisionAlgorithm_btSoftSoftCollisionAlgorithm(
        this: *mut btSoftSoftCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btSoftSoftCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSoftSoftCollisionAlgorithm_btSoftSoftCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSoftSoftCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftSoftCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSoftSoftCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSoftSoftCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtSoftSoftCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSoftSoftCollisionAlgorithm_btSoftSoftCollisionAlgorithm_destructor(
        this: *mut btSoftSoftCollisionAlgorithm,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPlane {
    pub normal: btVector3,
    pub dist: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvexH_HalfEdge {
    pub ea: ::std::os::raw::c_short,
    pub v: ::std::os::raw::c_uchar,
    pub p: ::std::os::raw::c_uchar,
}
/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
#[repr(C)]
#[derive(Debug)]
pub struct btConvexHullComputer {
    pub vertices: btAlignedObjectArray<btVector3>,
    pub edges: btAlignedObjectArray<btConvexHullComputer_Edge>,
    pub faces: btAlignedObjectArray<::std::os::raw::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexHullComputer_Edge {
    pub next: ::std::os::raw::c_int,
    pub reverse: ::std::os::raw::c_int,
    pub targetVertex: ::std::os::raw::c_int,
}
/// Rudimentary btCpuFeatureUtility for CPU features: only report the features that Bullet actually uses (SSE4/FMA3, NEON_HPFP)
/// We assume SSE2 in case BT_USE_SSE2 is defined in LinearMath/btScalar.h
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCpuFeatureUtility {
    pub _address: u8,
}
pub const btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_FMA3: btCpuFeatureUtility_btCpuFeature = 1;
pub const btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_SSE4_1: btCpuFeatureUtility_btCpuFeature = 2;
pub const btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_NEON_HPFP: btCpuFeatureUtility_btCpuFeature =
    4;
pub type btCpuFeatureUtility_btCpuFeature = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrahamVector3 {
    pub _base: btVector3,
    pub m_angle: btScalar,
    pub m_orgIndex: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAngleCompareFunc {
    pub m_anchor: btVector3,
}
/// The btPoolAllocator class allows to efficiently allocate a large pool of objects, instead of dynamically allocating them separately.
#[repr(C)]
#[derive(Debug)]
pub struct btPoolAllocator {
    pub m_elemSize: ::std::os::raw::c_int,
    pub m_maxElements: ::std::os::raw::c_int,
    pub m_freeCount: ::std::os::raw::c_int,
    pub m_firstFree: *mut ::std::os::raw::c_void,
    pub m_pool: *mut ::std::os::raw::c_uchar,
    pub m_mutex: btSpinMutex,
}
/// The btBlock class is an internal structure for the btStackAlloc memory allocator.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBlock {
    pub previous: *mut btBlock,
    pub address: *mut ::std::os::raw::c_uchar,
}
/// The StackAlloc class provides some fast stack-based memory allocator (LIFO last-in first-out)
#[repr(C)]
#[derive(Debug)]
pub struct btStackAlloc {
    pub data: *mut ::std::os::raw::c_uchar,
    pub totalsize: ::std::os::raw::c_uint,
    pub usedsize: ::std::os::raw::c_uint,
    pub current: *mut btBlock,
    pub ischild: bool,
}
/// The btSphereShape implements an implicit sphere, centered around a local origin with radius.
#[repr(C)]
#[derive(Debug)]
pub struct btSphereShape {
    pub _base: btConvexInternalShape,
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btSphereShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btSphereShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btSphereShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btSphereShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btSphereShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btSphereShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btSphereShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
/// The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
/// The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
/// The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShape {
    pub _base: btConvexInternalShape,
    pub m_upAxis: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}??0btCapsuleShape@@QEAA@NN@Z"]
    pub fn btCapsuleShape_btCapsuleShape(
        this: *mut btCapsuleShape,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShape {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShape_btCapsuleShape(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    /// CollisionShape Interface
    #[link_name = "\u{1}?calculateLocalInertia@btCapsuleShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btCapsuleShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    /// btConvexShape Interface
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btCapsuleShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btCapsuleShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btCapsuleShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btCapsuleShape@@UEBAHXZ"]
    pub fn btCapsuleShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btCapsuleShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btCapsuleShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// btCapsuleShapeX represents a capsule around the Z axis
/// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShapeX {
    pub _base: btCapsuleShape,
}
extern "C" {
    #[link_name = "\u{1}??0btCapsuleShapeX@@QEAA@NN@Z"]
    pub fn btCapsuleShapeX_btCapsuleShapeX(
        this: *mut btCapsuleShapeX,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShapeX {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShapeX_btCapsuleShapeX(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
/// btCapsuleShapeZ represents a capsule around the Z axis
/// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShapeZ {
    pub _base: btCapsuleShape,
}
extern "C" {
    #[link_name = "\u{1}??0btCapsuleShapeZ@@QEAA@NN@Z"]
    pub fn btCapsuleShapeZ_btCapsuleShapeZ(
        this: *mut btCapsuleShapeZ,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShapeZ {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShapeZ_btCapsuleShapeZ(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCapsuleShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upAxis: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis.
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShape {
    pub _base: btConvexInternalShape,
    pub m_upAxis: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
extern "C" {
    #[link_name = "\u{1}??0btCylinderShape@@QEAA@AEBVbtVector3@@@Z"]
    pub fn btCylinderShape_btCylinderShape(
        this: *mut btCylinderShape,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShape {
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShape_btCylinderShape(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btCylinderShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btCylinderShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btCylinderShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btCylinderShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btCylinderShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btCylinderShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btCylinderShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btCylinderShape@@UEBAHXZ"]
    pub fn btCylinderShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btCylinderShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btCylinderShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShapeX {
    pub _base: btCylinderShape,
}
extern "C" {
    #[link_name = "\u{1}??0btCylinderShapeX@@QEAA@AEBVbtVector3@@@Z"]
    pub fn btCylinderShapeX_btCylinderShapeX(
        this: *mut btCylinderShapeX,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShapeX {
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShapeX_btCylinderShapeX(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btCylinderShapeX@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btCylinderShapeX_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShapeX@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btCylinderShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShapeZ {
    pub _base: btCylinderShape,
}
extern "C" {
    #[link_name = "\u{1}??0btCylinderShapeZ@@QEAA@AEBVbtVector3@@@Z"]
    pub fn btCylinderShapeZ_btCylinderShapeZ(
        this: *mut btCylinderShapeZ,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShapeZ {
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShapeZ_btCylinderShapeZ(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btCylinderShapeZ@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btCylinderShapeZ_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShapeZ@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btCylinderShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCylinderShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upAxis: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis.
#[repr(C)]
#[derive(Debug)]
pub struct btConeShape {
    pub _base: btConvexInternalShape,
    pub m_sinAngle: btScalar,
    pub m_radius: btScalar,
    pub m_height: btScalar,
    pub m_coneIndices: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
extern "C" {
    /// choose upAxis index
    #[link_name = "\u{1}?setConeUpIndex@btConeShape@@QEAAXH@Z"]
    pub fn btConeShape_setConeUpIndex(this: *mut btConeShape, upIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}??0btConeShape@@QEAA@NN@Z"]
    pub fn btConeShape_btConeShape(this: *mut btConeShape, radius: btScalar, height: btScalar);
}
impl btConeShape {
    #[inline]
    pub unsafe fn setConeUpIndex(&mut self, upIndex: ::std::os::raw::c_int) {
        btConeShape_setConeUpIndex(self, upIndex)
    }
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShape_btConeShape(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConeShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConeShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btConeShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConeShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btConeShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btConeShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btConeShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConeShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btConeShape@@UEBAHXZ"]
    pub fn btConeShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btConeShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btConeShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// btConeShape implements a Cone shape, around the X axis
#[repr(C)]
#[derive(Debug)]
pub struct btConeShapeX {
    pub _base: btConeShape,
}
extern "C" {
    #[link_name = "\u{1}??0btConeShapeX@@QEAA@NN@Z"]
    pub fn btConeShapeX_btConeShapeX(this: *mut btConeShapeX, radius: btScalar, height: btScalar);
}
impl btConeShapeX {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShapeX_btConeShapeX(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
/// btConeShapeZ implements a Cone shape, around the Z axis
#[repr(C)]
#[derive(Debug)]
pub struct btConeShapeZ {
    pub _base: btConeShape,
}
extern "C" {
    #[link_name = "\u{1}??0btConeShapeZ@@QEAA@NN@Z"]
    pub fn btConeShapeZ_btConeShapeZ(this: *mut btConeShapeZ, radius: btScalar, height: btScalar);
}
impl btConeShapeZ {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShapeZ_btConeShapeZ(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upIndex: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btConvexHullShape implements an implicit convex hull of an array of vertices.
/// Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexHullShape {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_unscaledPoints: btAlignedObjectArray<btVector3>,
}
extern "C" {
    #[link_name = "\u{1}?addPoint@btConvexHullShape@@QEAAXAEBVbtVector3@@_N@Z"]
    pub fn btConvexHullShape_addPoint(
        this: *mut btConvexHullShape,
        point: *const btVector3,
        recalculateLocalAabb: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?optimizeConvexHull@btConvexHullShape@@QEAAXXZ"]
    pub fn btConvexHullShape_optimizeConvexHull(this: *mut btConvexHullShape);
}
extern "C" {
    /// this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
    /// ///It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
    /// ///btConvexHullShape make an internal copy of the points.
    #[link_name = "\u{1}??0btConvexHullShape@@QEAA@PEBNHH@Z"]
    pub fn btConvexHullShape_btConvexHullShape(
        this: *mut btConvexHullShape,
        points: *const btScalar,
        numPoints: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
impl btConvexHullShape {
    #[inline]
    pub unsafe fn addPoint(&mut self, point: *const btVector3, recalculateLocalAabb: bool) {
        btConvexHullShape_addPoint(self, point, recalculateLocalAabb)
    }
    #[inline]
    pub unsafe fn optimizeConvexHull(&mut self) {
        btConvexHullShape_optimizeConvexHull(self)
    }
    #[inline]
    pub unsafe fn new(
        points: *const btScalar,
        numPoints: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexHullShape_btConvexHullShape(&mut __bindgen_tmp, points, numPoints, stride);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConvexHullShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexHullShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btConvexHullShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexHullShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexHullShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?project@btConvexHullShape@@UEBAXAEBVbtTransform@@AEBVbtVector3@@AEAN2AEAV3@3@Z"]
    pub fn btConvexHullShape_project(
        this: *mut ::std::os::raw::c_void,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumVertices@btConvexHullShape@@UEBAHXZ"]
    pub fn btConvexHullShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getNumEdges@btConvexHullShape@@UEBAHXZ"]
    pub fn btConvexHullShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getEdge@btConvexHullShape@@UEBAXHAEAVbtVector3@@0@Z"]
    pub fn btConvexHullShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVertex@btConvexHullShape@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btConvexHullShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumPlanes@btConvexHullShape@@UEBAHXZ"]
    pub fn btConvexHullShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPlane@btConvexHullShape@@UEBAXAEAVbtVector3@@0H@Z"]
    pub fn btConvexHullShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?isInside@btConvexHullShape@@UEBA_NAEBVbtVector3@@N@Z"]
    pub fn btConvexHullShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {
    /// in case we receive negative scaling
    #[link_name = "\u{1}?setLocalScaling@btConvexHullShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvexHullShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btConvexHullShape@@UEBAHXZ"]
    pub fn btConvexHullShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btConvexHullShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btConvexHullShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexHullShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_unscaledPointsFloatPtr: *mut btVector3FloatData,
    pub m_unscaledPointsDoublePtr: *mut btVector3DoubleData,
    pub m_numUnscaledPoints: ::std::os::raw::c_int,
    pub m_padding3: [::std::os::raw::c_char; 4usize],
}
/// The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
/// It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
/// If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
/// Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleMesh {
    pub _base: btTriangleIndexVertexArray,
    pub m_4componentVertices: btAlignedObjectArray<btVector3>,
    pub m_3componentVertices: btAlignedObjectArray<btScalar>,
    pub m_32bitIndices: btAlignedObjectArray<::std::os::raw::c_uint>,
    pub m_16bitIndices: btAlignedObjectArray<::std::os::raw::c_ushort>,
    pub m_use32bitIndices: bool,
    pub m_use4componentVertices: bool,
    pub m_weldingThreshold: btScalar,
}
extern "C" {
    /// By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
    /// ///In general it is better to directly use btTriangleIndexVertexArray instead.
    #[link_name = "\u{1}?addTriangle@btTriangleMesh@@QEAAXAEBVbtVector3@@00_N@Z"]
    pub fn btTriangleMesh_addTriangle(
        this: *mut btTriangleMesh,
        vertex0: *const btVector3,
        vertex1: *const btVector3,
        vertex2: *const btVector3,
        removeDuplicateVertices: bool,
    );
}
extern "C" {
    /// Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices)
    #[link_name = "\u{1}?addTriangleIndices@btTriangleMesh@@QEAAXHHH@Z"]
    pub fn btTriangleMesh_addTriangleIndices(
        this: *mut btTriangleMesh,
        index1: ::std::os::raw::c_int,
        index2: ::std::os::raw::c_int,
        index3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumTriangles@btTriangleMesh@@QEBAHXZ"]
    pub fn btTriangleMesh_getNumTriangles(this: *const btTriangleMesh) -> ::std::os::raw::c_int;
}
extern "C" {
    /// findOrAddVertex is an internal method, use addTriangle instead
    #[link_name = "\u{1}?findOrAddVertex@btTriangleMesh@@QEAAHAEBVbtVector3@@_N@Z"]
    pub fn btTriangleMesh_findOrAddVertex(
        this: *mut btTriangleMesh,
        vertex: *const btVector3,
        removeDuplicateVertices: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// addIndex is an internal method, use addTriangle instead
    #[link_name = "\u{1}?addIndex@btTriangleMesh@@QEAAXH@Z"]
    pub fn btTriangleMesh_addIndex(this: *mut btTriangleMesh, index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}??0btTriangleMesh@@QEAA@_N0@Z"]
    pub fn btTriangleMesh_btTriangleMesh(
        this: *mut btTriangleMesh,
        use32bitIndices: bool,
        use4componentVertices: bool,
    );
}
impl btTriangleMesh {
    #[inline]
    pub unsafe fn addTriangle(
        &mut self,
        vertex0: *const btVector3,
        vertex1: *const btVector3,
        vertex2: *const btVector3,
        removeDuplicateVertices: bool,
    ) {
        btTriangleMesh_addTriangle(self, vertex0, vertex1, vertex2, removeDuplicateVertices)
    }
    #[inline]
    pub unsafe fn addTriangleIndices(
        &mut self,
        index1: ::std::os::raw::c_int,
        index2: ::std::os::raw::c_int,
        index3: ::std::os::raw::c_int,
    ) {
        btTriangleMesh_addTriangleIndices(self, index1, index2, index3)
    }
    #[inline]
    pub unsafe fn getNumTriangles(&self) -> ::std::os::raw::c_int {
        btTriangleMesh_getNumTriangles(self)
    }
    #[inline]
    pub unsafe fn findOrAddVertex(
        &mut self,
        vertex: *const btVector3,
        removeDuplicateVertices: bool,
    ) -> ::std::os::raw::c_int {
        btTriangleMesh_findOrAddVertex(self, vertex, removeDuplicateVertices)
    }
    #[inline]
    pub unsafe fn addIndex(&mut self, index: ::std::os::raw::c_int) {
        btTriangleMesh_addIndex(self, index)
    }
    #[inline]
    pub unsafe fn new(use32bitIndices: bool, use4componentVertices: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleMesh_btTriangleMesh(&mut __bindgen_tmp, use32bitIndices, use4componentVertices);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?preallocateVertices@btTriangleMesh@@UEAAXH@Z"]
    pub fn btTriangleMesh_preallocateVertices(
        this: *mut ::std::os::raw::c_void,
        numverts: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?preallocateIndices@btTriangleMesh@@UEAAXH@Z"]
    pub fn btTriangleMesh_preallocateIndices(
        this: *mut ::std::os::raw::c_void,
        numindices: ::std::os::raw::c_int,
    );
}
/// The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
/// A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexTriangleMeshShape {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_stridingMesh: *mut btStridingMeshInterface,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    /// ///and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
    /// ///by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
    /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    /// ///of the collision object by the principal transform. This method also computes the volume of the convex mesh.
    #[link_name = "\u{1}?calculatePrincipalAxisTransform@btConvexTriangleMeshShape@@QEBAXAEAVbtTransform@@AEAVbtVector3@@AEAN@Z"]
    pub fn btConvexTriangleMeshShape_calculatePrincipalAxisTransform(
        this: *const btConvexTriangleMeshShape,
        principal: *mut btTransform,
        inertia: *mut btVector3,
        volume: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConvexTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_N@Z"]
    pub fn btConvexTriangleMeshShape_btConvexTriangleMeshShape(
        this: *mut btConvexTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        calcAabb: bool,
    );
}
impl btConvexTriangleMeshShape {
    #[inline]
    pub unsafe fn calculatePrincipalAxisTransform(
        &self,
        principal: *mut btTransform,
        inertia: *mut btVector3,
        volume: *mut btScalar,
    ) {
        btConvexTriangleMeshShape_calculatePrincipalAxisTransform(self, principal, inertia, volume)
    }
    #[inline]
    pub unsafe fn new(meshInterface: *mut btStridingMeshInterface, calcAabb: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexTriangleMeshShape_btConvexTriangleMeshShape(
            &mut __bindgen_tmp,
            meshInterface,
            calcAabb,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btConvexTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexTriangleMeshShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btConvexTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexTriangleMeshShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btConvexTriangleMeshShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumVertices@btConvexTriangleMeshShape@@UEBAHXZ"]
    pub fn btConvexTriangleMeshShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getNumEdges@btConvexTriangleMeshShape@@UEBAHXZ"]
    pub fn btConvexTriangleMeshShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getEdge@btConvexTriangleMeshShape@@UEBAXHAEAVbtVector3@@0@Z"]
    pub fn btConvexTriangleMeshShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getVertex@btConvexTriangleMeshShape@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btConvexTriangleMeshShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getNumPlanes@btConvexTriangleMeshShape@@UEBAHXZ"]
    pub fn btConvexTriangleMeshShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPlane@btConvexTriangleMeshShape@@UEBAXAEAVbtVector3@@0H@Z"]
    pub fn btConvexTriangleMeshShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?isInside@btConvexTriangleMeshShape@@UEBA_NAEBVbtVector3@@N@Z"]
    pub fn btConvexTriangleMeshShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btConvexTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btConvexTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btConvexTriangleMeshShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btConvexTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
/// The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
/// Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling'
#[repr(C)]
#[derive(Debug)]
pub struct btScaledBvhTriangleMeshShape {
    pub _base: btConcaveShape,
    pub m_localScaling: btVector3,
    pub m_bvhTriMeshShape: *mut btBvhTriangleMeshShape,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}??0btScaledBvhTriangleMeshShape@@QEAA@PEAVbtBvhTriangleMeshShape@@AEBVbtVector3@@@Z"]
    pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
        this: *mut btScaledBvhTriangleMeshShape,
        childShape: *mut btBvhTriangleMeshShape,
        localScaling: *const btVector3,
    );
}
impl btScaledBvhTriangleMeshShape {
    #[inline]
    pub unsafe fn new(
        childShape: *mut btBvhTriangleMeshShape,
        localScaling: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
            &mut __bindgen_tmp,
            childShape,
            localScaling,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtScaledBvhTriangleMeshShape@@QEAAXXZ"]
    pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape_destructor(
        this: *mut btScaledBvhTriangleMeshShape,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btScaledBvhTriangleMeshShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btScaledBvhTriangleMeshShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btScaledBvhTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btScaledBvhTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btScaledBvhTriangleMeshShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btScaledBvhTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btScaledBvhTriangleMeshShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btScaledBvhTriangleMeshShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?processAllTriangles@btScaledBvhTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z"]
    pub fn btScaledBvhTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btScaledBvhTriangleMeshShape@@UEBAHXZ"]
    pub fn btScaledBvhTriangleMeshShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btScaledBvhTriangleMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btScaledBvhTriangleMeshShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btScaledTriangleMeshShapeData {
    pub m_trimeshShapeData: btTriangleMeshShapeData,
    pub m_localScaling: btVector3FloatData,
}
/// The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
/// It can be replaced by another shape during runtime, but the inertia tensor should be recomputed.
#[repr(C)]
#[derive(Debug)]
pub struct btEmptyShape {
    pub _base: btConcaveShape,
    pub m_localScaling: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btEmptyShape@@QEAA@XZ"]
    pub fn btEmptyShape_btEmptyShape(this: *mut btEmptyShape);
}
impl btEmptyShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btEmptyShape_btEmptyShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtEmptyShape@@QEAAXXZ"]
    pub fn btEmptyShape_btEmptyShape_destructor(this: *mut btEmptyShape);
}
extern "C" {
    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    #[link_name = "\u{1}?getAabb@btEmptyShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btEmptyShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btEmptyShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btEmptyShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
/// The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
/// It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius
#[repr(C)]
#[derive(Debug)]
pub struct btMultiSphereShape {
    pub _base: btConvexInternalAabbCachingShape,
    pub m_localPositionArray: btAlignedObjectArray<btVector3>,
    pub m_radiArray: btAlignedObjectArray<btScalar>,
}
extern "C" {
    #[link_name = "\u{1}??0btMultiSphereShape@@QEAA@PEBVbtVector3@@PEBNH@Z"]
    pub fn btMultiSphereShape_btMultiSphereShape(
        this: *mut btMultiSphereShape,
        positions: *const btVector3,
        radi: *const btScalar,
        numSpheres: ::std::os::raw::c_int,
    );
}
impl btMultiSphereShape {
    #[inline]
    pub unsafe fn new(
        positions: *const btVector3,
        radi: *const btScalar,
        numSpheres: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiSphereShape_btMultiSphereShape(&mut __bindgen_tmp, positions, radi, numSpheres);
        __bindgen_tmp
    }
}
extern "C" {
    /// CollisionShape Interface
    #[link_name = "\u{1}?calculateLocalInertia@btMultiSphereShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btMultiSphereShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    /// btConvexShape Interface
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btMultiSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btMultiSphereShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btMultiSphereShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btMultiSphereShape@@UEBAHXZ"]
    pub fn btMultiSphereShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btMultiSphereShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btMultiSphereShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPositionAndRadius {
    pub m_pos: btVector3FloatData,
    pub m_radius: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiSphereShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_localPositionArrayPtr: *mut btPositionAndRadius,
    pub m_localPositionArraySize: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
/// The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
/// Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it.
#[repr(C)]
#[derive(Debug)]
pub struct btUniformScalingShape {
    pub _base: btConvexShape,
    pub m_childConvexShape: *mut btConvexShape,
    pub m_uniformScalingFactor: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btUniformScalingShape@@QEAA@PEAVbtConvexShape@@N@Z"]
    pub fn btUniformScalingShape_btUniformScalingShape(
        this: *mut btUniformScalingShape,
        convexChildShape: *mut btConvexShape,
        uniformScalingFactor: btScalar,
    );
}
impl btUniformScalingShape {
    #[inline]
    pub unsafe fn new(
        convexChildShape: *mut btConvexShape,
        uniformScalingFactor: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btUniformScalingShape_btUniformScalingShape(
            &mut __bindgen_tmp,
            convexChildShape,
            uniformScalingFactor,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtUniformScalingShape@@QEAAXXZ"]
    pub fn btUniformScalingShape_btUniformScalingShape_destructor(this: *mut btUniformScalingShape);
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertexWithoutMargin@btUniformScalingShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btUniformScalingShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?localGetSupportingVertex@btUniformScalingShape@@UEBA?AVbtVector3@@AEBV2@@Z"]
    pub fn btUniformScalingShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?batchedUnitVectorGetSupportingVertexWithoutMargin@btUniformScalingShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z"]
    pub fn btUniformScalingShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLocalInertia@btUniformScalingShape@@UEBAXNAEAVbtVector3@@@Z"]
    pub fn btUniformScalingShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    #[link_name = "\u{1}?getAabb@btUniformScalingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btUniformScalingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabbSlow@btUniformScalingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z"]
    pub fn btUniformScalingShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setLocalScaling@btUniformScalingShape@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btUniformScalingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getLocalScaling@btUniformScalingShape@@UEBAAEBVbtVector3@@XZ"]
    pub fn btUniformScalingShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}?setMargin@btUniformScalingShape@@UEAAXN@Z"]
    pub fn btUniformScalingShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?getMargin@btUniformScalingShape@@UEBANXZ"]
    pub fn btUniformScalingShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getNumPreferredPenetrationDirections@btUniformScalingShape@@UEBAHXZ"]
    pub fn btUniformScalingShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?getPreferredPenetrationDirection@btUniformScalingShape@@UEBAXHAEAVbtVector3@@@Z"]
    pub fn btUniformScalingShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
/// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
/// Also provides the most basic sample for custom/user btCollisionAlgorithm
#[repr(C)]
#[derive(Debug)]
pub struct btSphereSphereCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSphereSphereCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
extern "C" {
    #[link_name = "\u{1}??0btSphereSphereCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z"]
    pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
        this: *mut btSphereSphereCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0Wrap: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btSphereSphereCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0Wrap: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            col0Wrap,
            col1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?processCollision@btSphereSphereCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereSphereCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTimeOfImpact@btSphereSphereCollisionAlgorithm@@UEAANPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z"]
    pub fn btSphereSphereCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}??_DbtSphereSphereCollisionAlgorithm@@QEAAXXZ"]
    pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm_destructor(
        this: *mut btSphereSphereCollisionAlgorithm,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSimpleBroadphaseProxy {
    pub _base: btBroadphaseProxy,
    pub m_nextFree: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 3usize],
}
/// The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
/// It is a brute force aabb culling broadphase based on O(n^2) aabb checks
#[repr(C)]
#[derive(Debug)]
pub struct btSimpleBroadphase {
    pub _base: btBroadphaseInterface,
    pub m_numHandles: ::std::os::raw::c_int,
    pub m_maxHandles: ::std::os::raw::c_int,
    pub m_LastHandleIndex: ::std::os::raw::c_int,
    pub m_pHandles: *mut btSimpleBroadphaseProxy,
    pub m_pHandlesRawPtr: *mut ::std::os::raw::c_void,
    pub m_firstFreeHandle: ::std::os::raw::c_int,
    pub m_pairCache: *mut btOverlappingPairCache,
    pub m_ownsPairCache: bool,
    pub m_invalidPair: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?validate@btSimpleBroadphase@@IEAAXXZ"]
    pub fn btSimpleBroadphase_validate(this: *mut btSimpleBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?aabbOverlap@btSimpleBroadphase@@SA_NPEAUbtSimpleBroadphaseProxy@@0@Z"]
    pub fn btSimpleBroadphase_aabbOverlap(
        proxy0: *mut btSimpleBroadphaseProxy,
        proxy1: *mut btSimpleBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?testAabbOverlap@btSimpleBroadphase@@QEAA_NPEAUbtBroadphaseProxy@@0@Z"]
    pub fn btSimpleBroadphase_testAabbOverlap(
        this: *mut btSimpleBroadphase,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0btSimpleBroadphase@@QEAA@HPEAVbtOverlappingPairCache@@@Z"]
    pub fn btSimpleBroadphase_btSimpleBroadphase(
        this: *mut btSimpleBroadphase,
        maxProxies: ::std::os::raw::c_int,
        overlappingPairCache: *mut btOverlappingPairCache,
    );
}
impl btSimpleBroadphase {
    #[inline]
    pub unsafe fn validate(&mut self) {
        btSimpleBroadphase_validate(self)
    }
    #[inline]
    pub unsafe fn aabbOverlap(
        proxy0: *mut btSimpleBroadphaseProxy,
        proxy1: *mut btSimpleBroadphaseProxy,
    ) -> bool {
        btSimpleBroadphase_aabbOverlap(proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn testAabbOverlap(
        &mut self,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool {
        btSimpleBroadphase_testAabbOverlap(self, proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn new(
        maxProxies: ::std::os::raw::c_int,
        overlappingPairCache: *mut btOverlappingPairCache,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleBroadphase_btSimpleBroadphase(&mut __bindgen_tmp, maxProxies, overlappingPairCache);
        __bindgen_tmp
    }
}
extern "C" {
    /// reset broadphase internal structures, to ensure determinism/reproducability
    #[link_name = "\u{1}?resetPool@btSimpleBroadphase@@MEAAXPEAVbtDispatcher@@@Z"]
    pub fn btSimpleBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DbtSimpleBroadphase@@QEAAXXZ"]
    pub fn btSimpleBroadphase_btSimpleBroadphase_destructor(this: *mut btSimpleBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?createProxy@btSimpleBroadphase@@UEAAPEAUbtBroadphaseProxy@@AEBVbtVector3@@0HPEAXHHPEAVbtDispatcher@@@Z"]
    pub fn btSimpleBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
        dispatcher: *mut btDispatcher,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@btSimpleBroadphase@@UEAAXPEAVbtDispatcher@@@Z"]
    pub fn btSimpleBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?destroyProxy@btSimpleBroadphase@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btSimpleBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAabb@btSimpleBroadphase@@UEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z"]
    pub fn btSimpleBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btSimpleBroadphase@@UEBAXPEAUbtBroadphaseProxy@@AEAVbtVector3@@1@Z"]
    pub fn btSimpleBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btSimpleBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseRayCallback@@00@Z"]
    pub fn btSimpleBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayCallback: *mut btBroadphaseRayCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?aabbTest@btSimpleBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseAabbCallback@@@Z"]
    pub fn btSimpleBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        callback: *mut btBroadphaseAabbCallback,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvtProxy {
    pub _base: btBroadphaseProxy,
    pub leaf: *mut btDbvtNode,
    pub links: [*mut btDbvtProxy; 2usize],
    pub stage: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
pub type btDbvtProxyArray = btAlignedObjectArray<*mut btDbvtProxy>;
/// The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
/// One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
/// This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3.
#[repr(C)]
#[derive(Debug)]
pub struct btDbvtBroadphase {
    pub _base: btBroadphaseInterface,
    pub m_sets: [btDbvt; 2usize],
    pub m_stageRoots: [*mut btDbvtProxy; 3usize],
    pub m_paircache: *mut btOverlappingPairCache,
    pub m_prediction: btScalar,
    pub m_stageCurrent: ::std::os::raw::c_int,
    pub m_fupdates: ::std::os::raw::c_int,
    pub m_dupdates: ::std::os::raw::c_int,
    pub m_cupdates: ::std::os::raw::c_int,
    pub m_newpairs: ::std::os::raw::c_int,
    pub m_fixedleft: ::std::os::raw::c_int,
    pub m_updates_call: ::std::os::raw::c_uint,
    pub m_updates_done: ::std::os::raw::c_uint,
    pub m_updates_ratio: btScalar,
    pub m_pid: ::std::os::raw::c_int,
    pub m_cid: ::std::os::raw::c_int,
    pub m_gid: ::std::os::raw::c_int,
    pub m_releasepaircache: bool,
    pub m_deferedcollide: bool,
    pub m_needcleanup: bool,
    pub m_rayTestStacks: btAlignedObjectArray<btAlignedObjectArray<*const btDbvtNode>>,
}
pub const btDbvtBroadphase_DYNAMIC_SET: btDbvtBroadphase__bindgen_ty_1 = 0;
pub const btDbvtBroadphase_FIXED_SET: btDbvtBroadphase__bindgen_ty_1 = 1;
pub const btDbvtBroadphase_STAGECOUNT: btDbvtBroadphase__bindgen_ty_1 = 2;
pub type btDbvtBroadphase__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}?collide@btDbvtBroadphase@@QEAAXPEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_collide(this: *mut btDbvtBroadphase, dispatcher: *mut btDispatcher);
}
extern "C" {
    #[link_name = "\u{1}?optimize@btDbvtBroadphase@@QEAAXXZ"]
    pub fn btDbvtBroadphase_optimize(this: *mut btDbvtBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?performDeferredRemoval@btDbvtBroadphase@@QEAAXPEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_performDeferredRemoval(
        this: *mut btDbvtBroadphase,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    /// this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    /// ///it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
    /// ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    /// ///http://code.google.com/p/bullet/issues/detail?id=223
    #[link_name = "\u{1}?setAabbForceUpdate@btDbvtBroadphase@@QEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_setAabbForceUpdate(
        this: *mut btDbvtBroadphase,
        absproxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        arg1: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?benchmark@btDbvtBroadphase@@SAXPEAVbtBroadphaseInterface@@@Z"]
    pub fn btDbvtBroadphase_benchmark(arg1: *mut btBroadphaseInterface);
}
extern "C" {
    #[link_name = "\u{1}??0btDbvtBroadphase@@QEAA@PEAVbtOverlappingPairCache@@@Z"]
    pub fn btDbvtBroadphase_btDbvtBroadphase(
        this: *mut btDbvtBroadphase,
        paircache: *mut btOverlappingPairCache,
    );
}
impl btDbvtBroadphase {
    #[inline]
    pub unsafe fn collide(&mut self, dispatcher: *mut btDispatcher) {
        btDbvtBroadphase_collide(self, dispatcher)
    }
    #[inline]
    pub unsafe fn optimize(&mut self) {
        btDbvtBroadphase_optimize(self)
    }
    #[inline]
    pub unsafe fn performDeferredRemoval(&mut self, dispatcher: *mut btDispatcher) {
        btDbvtBroadphase_performDeferredRemoval(self, dispatcher)
    }
    #[inline]
    pub unsafe fn setAabbForceUpdate(
        &mut self,
        absproxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        arg1: *mut btDispatcher,
    ) {
        btDbvtBroadphase_setAabbForceUpdate(self, absproxy, aabbMin, aabbMax, arg1)
    }
    #[inline]
    pub unsafe fn benchmark(arg1: *mut btBroadphaseInterface) {
        btDbvtBroadphase_benchmark(arg1)
    }
    #[inline]
    pub unsafe fn new(paircache: *mut btOverlappingPairCache) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvtBroadphase_btDbvtBroadphase(&mut __bindgen_tmp, paircache);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtDbvtBroadphase@@QEAAXXZ"]
    pub fn btDbvtBroadphase_btDbvtBroadphase_destructor(this: *mut btDbvtBroadphase);
}
extern "C" {
    #[link_name = "\u{1}?createProxy@btDbvtBroadphase@@UEAAPEAUbtBroadphaseProxy@@AEBVbtVector3@@0HPEAXHHPEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
        dispatcher: *mut btDispatcher,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}?destroyProxy@btDbvtBroadphase@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAabb@btDbvtBroadphase@@UEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?rayTest@btDbvtBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseRayCallback@@00@Z"]
    pub fn btDbvtBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayCallback: *mut btBroadphaseRayCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?aabbTest@btDbvtBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseAabbCallback@@@Z"]
    pub fn btDbvtBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        callback: *mut btBroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}?getAabb@btDbvtBroadphase@@UEBAXPEAUbtBroadphaseProxy@@AEAVbtVector3@@1@Z"]
    pub fn btDbvtBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateOverlappingPairs@btDbvtBroadphase@@UEAAXPEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairCache@btDbvtBroadphase@@UEAAPEAVbtOverlappingPairCache@@XZ"]
    pub fn btDbvtBroadphase_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}?getOverlappingPairCache@btDbvtBroadphase@@UEBAPEBVbtOverlappingPairCache@@XZ"]
    pub fn btDbvtBroadphase_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}?getBroadphaseAabb@btDbvtBroadphase@@UEBAXAEAVbtVector3@@0@Z"]
    pub fn btDbvtBroadphase_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?printStats@btDbvtBroadphase@@UEAAXXZ"]
    pub fn btDbvtBroadphase_printStats(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// reset broadphase internal structures, to ensure determinism/reproducability
    #[link_name = "\u{1}?resetPool@btDbvtBroadphase@@UEAAXPEAVbtDispatcher@@@Z"]
    pub fn btDbvtBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
/// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
/// It uses quantized integers to represent the begin and end points for each of the 3 axis.
/// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3Internal<BP_FP_INT_TYPE> {
    pub _base: btBroadphaseInterface,
    pub m_bpHandleMask: BP_FP_INT_TYPE,
    pub m_handleSentinel: BP_FP_INT_TYPE,
    pub __bindgen_padding_0: u64,
    pub m_worldAabbMin: btVector3,
    pub m_worldAabbMax: btVector3,
    pub m_quantize: btVector3,
    pub m_numHandles: BP_FP_INT_TYPE,
    pub m_maxHandles: BP_FP_INT_TYPE,
    pub m_pHandles: *mut btAxisSweep3Internal_Handle<BP_FP_INT_TYPE>,
    pub m_firstFreeHandle: BP_FP_INT_TYPE,
    pub m_pEdges: [*mut btAxisSweep3Internal_Edge<BP_FP_INT_TYPE>; 3usize],
    pub m_pEdgesRawPtr: [*mut ::std::os::raw::c_void; 3usize],
    pub m_pairCache: *mut btOverlappingPairCache,
    /// btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
    pub m_userPairCallback: *mut btOverlappingPairCallback,
    pub m_ownsPairCache: bool,
    pub m_invalidPair: ::std::os::raw::c_int,
    /// additional dynamic aabb structure, used to accelerate ray cast queries.
    /// ///can be disabled using a optional argument in the constructor
    pub m_raycastAccelerator: *mut btDbvtBroadphase,
    pub m_nullPairCache: *mut btOverlappingPairCache,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAxisSweep3Internal_Edge<BP_FP_INT_TYPE> {
    pub m_pos: BP_FP_INT_TYPE,
    pub m_handle: BP_FP_INT_TYPE,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3Internal_Handle<BP_FP_INT_TYPE> {
    pub _base: btBroadphaseProxy,
    pub m_minEdges: [BP_FP_INT_TYPE; 3usize],
    pub m_maxEdges: [BP_FP_INT_TYPE; 3usize],
    pub m_dbvtProxy: *mut btBroadphaseProxy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
/// The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
/// It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
/// For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance.
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3 {
    pub _base: btAxisSweep3Internal<::std::os::raw::c_ushort>,
}
extern "C" {
    #[link_name = "\u{1}??0btAxisSweep3@@QEAA@AEBVbtVector3@@0GPEAVbtOverlappingPairCache@@_N@Z"]
    pub fn btAxisSweep3_btAxisSweep3(
        this: *mut btAxisSweep3,
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_ushort,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    );
}
impl btAxisSweep3 {
    #[inline]
    pub unsafe fn new(
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_ushort,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btAxisSweep3_btAxisSweep3(
            &mut __bindgen_tmp,
            worldAabbMin,
            worldAabbMax,
            maxHandles,
            pairCache,
            disableRaycastAccelerator,
        );
        __bindgen_tmp
    }
}
/// The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
/// This comes at the cost of more memory per handle, and a bit slower performance.
/// It uses arrays rather then lists for storage of the 3 axis.
#[repr(C)]
#[derive(Debug)]
pub struct bt32BitAxisSweep3 {
    pub _base: btAxisSweep3Internal<::std::os::raw::c_uint>,
}
extern "C" {
    #[link_name = "\u{1}??0bt32BitAxisSweep3@@QEAA@AEBVbtVector3@@0IPEAVbtOverlappingPairCache@@_N@Z"]
    pub fn bt32BitAxisSweep3_bt32BitAxisSweep3(
        this: *mut bt32BitAxisSweep3,
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_uint,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    );
}
impl bt32BitAxisSweep3 {
    #[inline]
    pub unsafe fn new(
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_uint,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        bt32BitAxisSweep3_bt32BitAxisSweep3(
            &mut __bindgen_tmp,
            worldAabbMin,
            worldAabbMax,
            maxHandles,
            pairCache,
            disableRaycastAccelerator,
        );
        __bindgen_tmp
    }
}
/// The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultMotionState {
    pub _base: btMotionState,
    pub __bindgen_padding_0: u64,
    pub m_graphicsWorldTrans: btTransform,
    pub m_centerOfMassOffset: btTransform,
    pub m_startWorldTrans: btTransform,
    pub m_userPointer: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_1: u64,
}
/// The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
/// Please use btDiscreteDynamicsWorld instead
#[repr(C)]
#[derive(Debug)]
pub struct btSimpleDynamicsWorld {
    pub _base: btDynamicsWorld,
    pub m_constraintSolver: *mut btConstraintSolver,
    pub m_ownsConstraintSolver: bool,
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_gravity: btVector3,
}
extern "C" {
    #[link_name = "\u{1}?predictUnconstraintMotion@btSimpleDynamicsWorld@@IEAAXN@Z"]
    pub fn btSimpleDynamicsWorld_predictUnconstraintMotion(
        this: *mut btSimpleDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?integrateTransforms@btSimpleDynamicsWorld@@IEAAXN@Z"]
    pub fn btSimpleDynamicsWorld_integrateTransforms(
        this: *mut btSimpleDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    /// this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver
    #[link_name = "\u{1}??0btSimpleDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z"]
    pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld(
        this: *mut btSimpleDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btSimpleDynamicsWorld {
    #[inline]
    pub unsafe fn predictUnconstraintMotion(&mut self, timeStep: btScalar) {
        btSimpleDynamicsWorld_predictUnconstraintMotion(self, timeStep)
    }
    #[inline]
    pub unsafe fn integrateTransforms(&mut self, timeStep: btScalar) {
        btSimpleDynamicsWorld_integrateTransforms(self, timeStep)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleDynamicsWorld_btSimpleDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtSimpleDynamicsWorld@@QEAAXXZ"]
    pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld_destructor(this: *mut btSimpleDynamicsWorld);
}
extern "C" {
    /// maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead
    #[link_name = "\u{1}?stepSimulation@btSimpleDynamicsWorld@@UEAAHNHN@Z"]
    pub fn btSimpleDynamicsWorld_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setGravity@btSimpleDynamicsWorld@@UEAAXAEBVbtVector3@@@Z"]
    pub fn btSimpleDynamicsWorld_setGravity(
        this: *mut ::std::os::raw::c_void,
        gravity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getGravity@btSimpleDynamicsWorld@@UEBA?AVbtVector3@@XZ"]
    pub fn btSimpleDynamicsWorld_getGravity(this: *mut ::std::os::raw::c_void) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?addRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z"]
    pub fn btSimpleDynamicsWorld_addRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?addRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@HH@Z"]
    pub fn btSimpleDynamicsWorld_addRigidBody1(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z"]
    pub fn btSimpleDynamicsWorld_removeRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}?debugDrawWorld@btSimpleDynamicsWorld@@UEAAXXZ"]
    pub fn btSimpleDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?addAction@btSimpleDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btSimpleDynamicsWorld_addAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}?removeAction@btSimpleDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z"]
    pub fn btSimpleDynamicsWorld_removeAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {
    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
    #[link_name = "\u{1}?removeCollisionObject@btSimpleDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z"]
    pub fn btSimpleDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateAabbs@btSimpleDynamicsWorld@@UEAAXXZ"]
    pub fn btSimpleDynamicsWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?synchronizeMotionStates@btSimpleDynamicsWorld@@UEAAXXZ"]
    pub fn btSimpleDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?setConstraintSolver@btSimpleDynamicsWorld@@UEAAXPEAVbtConstraintSolver@@@Z"]
    pub fn btSimpleDynamicsWorld_setConstraintSolver(
        this: *mut ::std::os::raw::c_void,
        solver: *mut btConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}?getConstraintSolver@btSimpleDynamicsWorld@@UEAAPEAVbtConstraintSolver@@XZ"]
    pub fn btSimpleDynamicsWorld_getConstraintSolver(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConstraintSolver;
}
extern "C" {
    #[link_name = "\u{1}?clearForces@btSimpleDynamicsWorld@@UEAAXXZ"]
    pub fn btSimpleDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConstraintSetting {
    pub m_tau: btScalar,
    pub m_damping: btScalar,
    pub m_impulseClamp: btScalar,
}
pub const btPoint2PointFlags_BT_P2P_FLAGS_ERP: btPoint2PointFlags = 1;
pub const btPoint2PointFlags_BT_P2P_FLAGS_CFM: btPoint2PointFlags = 2;
pub type btPoint2PointFlags = i32;
/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
#[repr(C)]
pub struct btPoint2PointConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_erp: btScalar,
    pub m_cfm: btScalar,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
    pub m_setting: btConstraintSetting,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@btPoint2PointConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btPoint2PointConstraint_getInfo1NonVirtual(
        this: *mut btPoint2PointConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@btPoint2PointConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1@Z"]
    pub fn btPoint2PointConstraint_getInfo2NonVirtual(
        this: *mut btPoint2PointConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        body0_trans: *const btTransform,
        body1_trans: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@btPoint2PointConstraint@@QEAAXN@Z"]
    pub fn btPoint2PointConstraint_updateRHS(
        this: *mut btPoint2PointConstraint,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btPoint2PointConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@1@Z"]
    pub fn btPoint2PointConstraint_btPoint2PointConstraint(
        this: *mut btPoint2PointConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btPoint2PointConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtVector3@@@Z"]
    pub fn btPoint2PointConstraint_btPoint2PointConstraint1(
        this: *mut btPoint2PointConstraint,
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
    );
}
impl btPoint2PointConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btPoint2PointConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        body0_trans: *const btTransform,
        body1_trans: *const btTransform,
    ) {
        btPoint2PointConstraint_getInfo2NonVirtual(self, info, body0_trans, body1_trans)
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btPoint2PointConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPoint2PointConstraint_btPoint2PointConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(rbA: *mut btRigidBody, pivotInA: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPoint2PointConstraint_btPoint2PointConstraint1(&mut __bindgen_tmp, rbA, pivotInA);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?buildJacobian@btPoint2PointConstraint@@UEAAXXZ"]
    pub fn btPoint2PointConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btPoint2PointConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btPoint2PointConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btPoint2PointConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btPoint2PointConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@btPoint2PointConstraint@@UEAAXHNH@Z"]
    pub fn btPoint2PointConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@btPoint2PointConstraint@@UEBANHH@Z"]
    pub fn btPoint2PointConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btPoint2PointConstraint@@UEBAHXZ"]
    pub fn btPoint2PointConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btPoint2PointConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btPoint2PointConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_pivotInA: btVector3FloatData,
    pub m_pivotInB: btVector3FloatData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_pivotInA: btVector3DoubleData,
    pub m_pivotInB: btVector3DoubleData,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
/// this structure is not used, except for loading pre-2.82 .bullet files
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_pivotInA: btVector3DoubleData,
    pub m_pivotInB: btVector3DoubleData,
}
pub const btHingeFlags_BT_HINGE_FLAGS_CFM_STOP: btHingeFlags = 1;
pub const btHingeFlags_BT_HINGE_FLAGS_ERP_STOP: btHingeFlags = 2;
pub const btHingeFlags_BT_HINGE_FLAGS_CFM_NORM: btHingeFlags = 4;
pub const btHingeFlags_BT_HINGE_FLAGS_ERP_NORM: btHingeFlags = 8;
pub type btHingeFlags = i32;
/// hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// axis defines the orientation of the hinge axis
#[repr(C)]
pub struct btHingeConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_rbAFrame: btTransform,
    pub m_rbBFrame: btTransform,
    pub m_motorTargetVelocity: btScalar,
    pub m_maxMotorImpulse: btScalar,
    pub m_limit: btAngularLimit,
    pub m_kHinge: btScalar,
    pub m_accLimitImpulse: btScalar,
    pub m_hingeAngle: btScalar,
    pub m_referenceSign: btScalar,
    pub m_angularOnly: bool,
    pub m_enableAngularMotor: bool,
    pub m_useSolveConstraintObsolete: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_useReferenceFrameA: bool,
    pub m_accMotorImpulse: btScalar,
    pub m_flags: ::std::os::raw::c_int,
    pub m_normalCFM: btScalar,
    pub m_normalERP: btScalar,
    pub m_stopCFM: btScalar,
    pub m_stopERP: btScalar,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@btHingeConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btHingeConstraint_getInfo1NonVirtual(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z"]
    pub fn btHingeConstraint_getInfo2NonVirtual(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2Internal@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z"]
    pub fn btHingeConstraint_getInfo2Internal(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2InternalUsingFrameOffset@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z"]
    pub fn btHingeConstraint_getInfo2InternalUsingFrameOffset(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@btHingeConstraint@@QEAAXN@Z"]
    pub fn btHingeConstraint_updateRHS(this: *mut btHingeConstraint, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?setFrames@btHingeConstraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btHingeConstraint_setFrames(
        this: *mut btHingeConstraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMotorTarget@btHingeConstraint@@QEAAXAEBVbtQuaternion@@N@Z"]
    pub fn btHingeConstraint_setMotorTarget(
        this: *mut btHingeConstraint,
        qAinB: *const btQuaternion,
        dt: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMotorTarget@btHingeConstraint@@QEAAXNN@Z"]
    pub fn btHingeConstraint_setMotorTarget1(
        this: *mut btHingeConstraint,
        targetAngle: btScalar,
        dt: btScalar,
    );
}
extern "C" {
    /// The getHingeAngle gives the hinge angle in range [-PI,PI]
    #[link_name = "\u{1}?getHingeAngle@btHingeConstraint@@QEAANXZ"]
    pub fn btHingeConstraint_getHingeAngle(this: *mut btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?getHingeAngle@btHingeConstraint@@QEAANAEBVbtTransform@@0@Z"]
    pub fn btHingeConstraint_getHingeAngle1(
        this: *mut btHingeConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?testLimit@btHingeConstraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btHingeConstraint_testLimit(
        this: *mut btHingeConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@111_N@Z"]
    pub fn btHingeConstraint_btHingeConstraint(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtVector3@@1_N@Z"]
    pub fn btHingeConstraint_btHingeConstraint1(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z"]
    pub fn btHingeConstraint_btHingeConstraint2(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z"]
    pub fn btHingeConstraint_btHingeConstraint3(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
impl btHingeConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btHingeConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2NonVirtual(self, info, transA, transB, angVelA, angVelB)
    }
    #[inline]
    pub unsafe fn getInfo2Internal(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2Internal(self, info, transA, transB, angVelA, angVelB)
    }
    #[inline]
    pub unsafe fn getInfo2InternalUsingFrameOffset(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2InternalUsingFrameOffset(
            self, info, transA, transB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btHingeConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btHingeConstraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn setMotorTarget(&mut self, qAinB: *const btQuaternion, dt: btScalar) {
        btHingeConstraint_setMotorTarget(self, qAinB, dt)
    }
    #[inline]
    pub unsafe fn setMotorTarget1(&mut self, targetAngle: btScalar, dt: btScalar) {
        btHingeConstraint_setMotorTarget1(self, targetAngle, dt)
    }
    #[inline]
    pub unsafe fn getHingeAngle(&mut self) -> btScalar {
        btHingeConstraint_getHingeAngle(self)
    }
    #[inline]
    pub unsafe fn getHingeAngle1(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) -> btScalar {
        btHingeConstraint_getHingeAngle1(self, transA, transB)
    }
    #[inline]
    pub unsafe fn testLimit(&mut self, transA: *const btTransform, transB: *const btTransform) {
        btHingeConstraint_testLimit(self, transA, transB)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
            axisInA,
            axisInB,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint1(
            &mut __bindgen_tmp,
            rbA,
            pivotInA,
            axisInA,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint2(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            rbAFrame,
            rbBFrame,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint3(&mut __bindgen_tmp, rbA, rbAFrame, useReferenceFrameA);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?buildJacobian@btHingeConstraint@@UEAAXXZ"]
    pub fn btHingeConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btHingeConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btHingeConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btHingeConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btHingeConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@btHingeConstraint@@UEAAXHNH@Z"]
    pub fn btHingeConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@btHingeConstraint@@UEBANHH@Z"]
    pub fn btHingeConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btHingeConstraint@@UEBAHXZ"]
    pub fn btHingeConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btHingeConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btHingeConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f32,
    pub m_maxMotorImpulse: f32,
    pub m_lowerLimit: f32,
    pub m_upperLimit: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
}
/// The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account
#[repr(C)]
pub struct btHingeAccumulatedAngleConstraint {
    pub _base: btHingeConstraint,
    pub m_accumulatedAngle: btScalar,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?getAccumulatedHingeAngle@btHingeAccumulatedAngleConstraint@@QEAANXZ"]
    pub fn btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(
        this: *mut btHingeAccumulatedAngleConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setAccumulatedHingeAngle@btHingeAccumulatedAngleConstraint@@QEAAXN@Z"]
    pub fn btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(
        this: *mut btHingeAccumulatedAngleConstraint,
        accAngle: btScalar,
    );
}
impl btHingeAccumulatedAngleConstraint {
    #[inline]
    pub unsafe fn getAccumulatedHingeAngle(&mut self) -> btScalar {
        btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(self)
    }
    #[inline]
    pub unsafe fn setAccumulatedHingeAngle(&mut self, accAngle: btScalar) {
        btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(self, accAngle)
    }
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btHingeAccumulatedAngleConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btHingeAccumulatedAngleConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f32,
    pub m_maxMotorImpulse: f32,
    pub m_lowerLimit: f32,
    pub m_upperLimit: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f64,
    pub m_maxMotorImpulse: f64,
    pub m_lowerLimit: f64,
    pub m_upperLimit: f64,
    pub m_limitSoftness: f64,
    pub m_biasFactor: f64,
    pub m_relaxationFactor: f64,
    pub m_padding1: [::std::os::raw::c_char; 4usize],
}
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_CFM: btConeTwistFlags = 1;
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_ERP: btConeTwistFlags = 2;
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_ANG_CFM: btConeTwistFlags = 4;
pub type btConeTwistFlags = i32;
/// btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
#[repr(C)]
pub struct btConeTwistConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_rbAFrame: btTransform,
    pub m_rbBFrame: btTransform,
    pub m_limitSoftness: btScalar,
    pub m_biasFactor: btScalar,
    pub m_relaxationFactor: btScalar,
    pub m_damping: btScalar,
    pub m_swingSpan1: btScalar,
    pub m_swingSpan2: btScalar,
    pub m_twistSpan: btScalar,
    pub m_fixThresh: btScalar,
    pub m_swingAxis: btVector3,
    pub m_twistAxis: btVector3,
    pub m_kSwing: btScalar,
    pub m_kTwist: btScalar,
    pub m_twistLimitSign: btScalar,
    pub m_swingCorrection: btScalar,
    pub m_twistCorrection: btScalar,
    pub m_twistAngle: btScalar,
    pub m_accSwingLimitImpulse: btScalar,
    pub m_accTwistLimitImpulse: btScalar,
    pub m_angularOnly: bool,
    pub m_solveTwistLimit: bool,
    pub m_solveSwingLimit: bool,
    pub m_useSolveConstraintObsolete: bool,
    pub m_swingLimitRatio: btScalar,
    pub m_twistLimitRatio: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_twistAxisA: btVector3,
    pub m_bMotorEnabled: bool,
    pub m_bNormalizedMotorStrength: bool,
    pub __bindgen_padding_1: u64,
    pub m_qTarget: btQuaternion,
    pub m_maxMotorImpulse: btScalar,
    pub __bindgen_padding_2: u64,
    pub m_accMotorImpulse: btVector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_linCFM: btScalar,
    pub m_linERP: btScalar,
    pub m_angCFM: btScalar,
}
extern "C" {
    #[link_name = "\u{1}?init@btConeTwistConstraint@@IEAAXXZ"]
    pub fn btConeTwistConstraint_init(this: *mut btConeTwistConstraint);
}
extern "C" {
    #[link_name = "\u{1}?computeConeLimitInfo@btConeTwistConstraint@@IEAAXAEBVbtQuaternion@@AEANAEAVbtVector3@@1@Z"]
    pub fn btConeTwistConstraint_computeConeLimitInfo(
        this: *mut btConeTwistConstraint,
        qCone: *const btQuaternion,
        swingAngle: *mut btScalar,
        vSwingAxis: *mut btVector3,
        swingLimit: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?computeTwistLimitInfo@btConeTwistConstraint@@IEAAXAEBVbtQuaternion@@AEANAEAVbtVector3@@@Z"]
    pub fn btConeTwistConstraint_computeTwistLimitInfo(
        this: *mut btConeTwistConstraint,
        qTwist: *const btQuaternion,
        twistAngle: *mut btScalar,
        vTwistAxis: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?adjustSwingAxisToUseEllipseNormal@btConeTwistConstraint@@IEBAXAEAVbtVector3@@@Z"]
    pub fn btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(
        this: *const btConeTwistConstraint,
        vSwingAxis: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@btConeTwistConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btConeTwistConstraint_getInfo1NonVirtual(
        this: *mut btConeTwistConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@btConeTwistConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtMatrix3x3@@2@Z"]
    pub fn btConeTwistConstraint_getInfo2NonVirtual(
        this: *mut btConeTwistConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@btConeTwistConstraint@@QEAAXN@Z"]
    pub fn btConeTwistConstraint_updateRHS(this: *mut btConeTwistConstraint, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?calcAngleInfo@btConeTwistConstraint@@QEAAXXZ"]
    pub fn btConeTwistConstraint_calcAngleInfo(this: *mut btConeTwistConstraint);
}
extern "C" {
    #[link_name = "\u{1}?calcAngleInfo2@btConeTwistConstraint@@QEAAXAEBVbtTransform@@0AEBVbtMatrix3x3@@1@Z"]
    pub fn btConeTwistConstraint_calcAngleInfo2(
        this: *mut btConeTwistConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMotorTarget@btConeTwistConstraint@@QEAAXAEBVbtQuaternion@@@Z"]
    pub fn btConeTwistConstraint_setMotorTarget(
        this: *mut btConeTwistConstraint,
        q: *const btQuaternion,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMotorTargetInConstraintSpace@btConeTwistConstraint@@QEAAXAEBVbtQuaternion@@@Z"]
    pub fn btConeTwistConstraint_setMotorTargetInConstraintSpace(
        this: *mut btConeTwistConstraint,
        q: *const btQuaternion,
    );
}
extern "C" {
    #[link_name = "\u{1}?GetPointForAngle@btConeTwistConstraint@@QEBA?AVbtVector3@@NN@Z"]
    pub fn btConeTwistConstraint_GetPointForAngle(
        this: *const btConeTwistConstraint,
        fAngleInRadians: btScalar,
        fLength: btScalar,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}??0btConeTwistConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1@Z"]
    pub fn btConeTwistConstraint_btConeTwistConstraint(
        this: *mut btConeTwistConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btConeTwistConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@@Z"]
    pub fn btConeTwistConstraint_btConeTwistConstraint1(
        this: *mut btConeTwistConstraint,
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
    );
}
impl btConeTwistConstraint {
    #[inline]
    pub unsafe fn init(&mut self) {
        btConeTwistConstraint_init(self)
    }
    #[inline]
    pub unsafe fn computeConeLimitInfo(
        &mut self,
        qCone: *const btQuaternion,
        swingAngle: *mut btScalar,
        vSwingAxis: *mut btVector3,
        swingLimit: *mut btScalar,
    ) {
        btConeTwistConstraint_computeConeLimitInfo(self, qCone, swingAngle, vSwingAxis, swingLimit)
    }
    #[inline]
    pub unsafe fn computeTwistLimitInfo(
        &mut self,
        qTwist: *const btQuaternion,
        twistAngle: *mut btScalar,
        vTwistAxis: *mut btVector3,
    ) {
        btConeTwistConstraint_computeTwistLimitInfo(self, qTwist, twistAngle, vTwistAxis)
    }
    #[inline]
    pub unsafe fn adjustSwingAxisToUseEllipseNormal(&self, vSwingAxis: *mut btVector3) {
        btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(self, vSwingAxis)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btConeTwistConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    ) {
        btConeTwistConstraint_getInfo2NonVirtual(
            self,
            info,
            transA,
            transB,
            invInertiaWorldA,
            invInertiaWorldB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btConeTwistConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn calcAngleInfo(&mut self) {
        btConeTwistConstraint_calcAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calcAngleInfo2(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    ) {
        btConeTwistConstraint_calcAngleInfo2(
            self,
            transA,
            transB,
            invInertiaWorldA,
            invInertiaWorldB,
        )
    }
    #[inline]
    pub unsafe fn setMotorTarget(&mut self, q: *const btQuaternion) {
        btConeTwistConstraint_setMotorTarget(self, q)
    }
    #[inline]
    pub unsafe fn setMotorTargetInConstraintSpace(&mut self, q: *const btQuaternion) {
        btConeTwistConstraint_setMotorTargetInConstraintSpace(self, q)
    }
    #[inline]
    pub unsafe fn GetPointForAngle(
        &self,
        fAngleInRadians: btScalar,
        fLength: btScalar,
    ) -> btVector3 {
        btConeTwistConstraint_GetPointForAngle(self, fAngleInRadians, fLength)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeTwistConstraint_btConeTwistConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            rbAFrame,
            rbBFrame,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(rbA: *mut btRigidBody, rbAFrame: *const btTransform) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeTwistConstraint_btConeTwistConstraint1(&mut __bindgen_tmp, rbA, rbAFrame);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?buildJacobian@btConeTwistConstraint@@UEAAXXZ"]
    pub fn btConeTwistConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btConeTwistConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btConeTwistConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btConeTwistConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btConeTwistConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?solveConstraintObsolete@btConeTwistConstraint@@UEAAXAEAUbtSolverBody@@0N@Z"]
    pub fn btConeTwistConstraint_solveConstraintObsolete(
        this: *mut ::std::os::raw::c_void,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        timeStep: btScalar,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@btConeTwistConstraint@@UEAAXHNH@Z"]
    pub fn btConeTwistConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFrames@btConeTwistConstraint@@UEAAXAEBVbtTransform@@0@Z"]
    pub fn btConeTwistConstraint_setFrames(
        this: *mut ::std::os::raw::c_void,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@btConeTwistConstraint@@UEBANHH@Z"]
    pub fn btConeTwistConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btConeTwistConstraint@@UEBAHXZ"]
    pub fn btConeTwistConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btConeTwistConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btConeTwistConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeTwistConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_swingSpan1: f64,
    pub m_swingSpan2: f64,
    pub m_twistSpan: f64,
    pub m_limitSoftness: f64,
    pub m_biasFactor: f64,
    pub m_relaxationFactor: f64,
    pub m_damping: f64,
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeTwistConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_swingSpan1: f32,
    pub m_swingSpan2: f32,
    pub m_twistSpan: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
    pub m_damping: f32,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
/// ! Rotation Limit structure for generic joints
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRotationalLimitMotor {
    /// !< joint limit
    pub m_loLimit: btScalar,
    /// !< joint limit
    pub m_hiLimit: btScalar,
    /// !< target motor velocity
    pub m_targetVelocity: btScalar,
    /// !< max force on motor
    pub m_maxMotorForce: btScalar,
    /// !< max force on limit
    pub m_maxLimitForce: btScalar,
    /// !< Damping.
    pub m_damping: btScalar,
    pub m_limitSoftness: btScalar,
    /// !< Constraint force mixing factor
    pub m_normalCFM: btScalar,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: btScalar,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: btScalar,
    /// !< restitution factor
    pub m_bounce: btScalar,
    pub m_enableMotor: bool,
    /// ! temp_variables
    /// //!@{
    pub m_currentLimitError: btScalar,
    /// !  How much is violated this limit
    pub m_currentPosition: btScalar,
    /// !< 0=free, 1=at lo limit, 2=at hi limit
    pub m_currentLimit: ::std::os::raw::c_int,
    pub m_accumulatedImpulse: btScalar,
}
extern "C" {
    /// ! calculates  error
    /// /*!
    /// calculates m_currentLimit and m_currentLimitError.
    /// */
    #[link_name = "\u{1}?testLimitValue@btRotationalLimitMotor@@QEAAHN@Z"]
    pub fn btRotationalLimitMotor_testLimitValue(
        this: *mut btRotationalLimitMotor,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ! apply the correction impulses for two bodies
    #[link_name = "\u{1}?solveAngularLimits@btRotationalLimitMotor@@QEAANNAEAVbtVector3@@NPEAVbtRigidBody@@1@Z"]
    pub fn btRotationalLimitMotor_solveAngularLimits(
        this: *mut btRotationalLimitMotor,
        timeStep: btScalar,
        axis: *mut btVector3,
        jacDiagABInv: btScalar,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
    ) -> btScalar;
}
impl btRotationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: btScalar) -> ::std::os::raw::c_int {
        btRotationalLimitMotor_testLimitValue(self, test_value)
    }
    #[inline]
    pub unsafe fn solveAngularLimits(
        &mut self,
        timeStep: btScalar,
        axis: *mut btVector3,
        jacDiagABInv: btScalar,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
    ) -> btScalar {
        btRotationalLimitMotor_solveAngularLimits(self, timeStep, axis, jacDiagABInv, body0, body1)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTranslationalLimitMotor {
    /// !< the constraint lower limits
    pub m_lowerLimit: btVector3,
    /// !< the constraint upper limits
    pub m_upperLimit: btVector3,
    pub m_accumulatedImpulse: btVector3,
    /// !< Softness for linear limit
    pub m_limitSoftness: btScalar,
    /// !< Damping for linear limit
    pub m_damping: btScalar,
    pub m_restitution: btScalar,
    pub __bindgen_padding_0: u64,
    /// !< Constraint force mixing factor
    pub m_normalCFM: btVector3,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: btVector3,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: btVector3,
    /// !@}
    pub m_enableMotor: [bool; 3usize],
    pub __bindgen_padding_1: u64,
    /// !< target motor velocity
    pub m_targetVelocity: btVector3,
    /// !< max force on motor
    pub m_maxMotorForce: btVector3,
    pub m_currentLimitError: btVector3,
    /// !  How much is violated this limit
    pub m_currentLinearDiff: btVector3,
    /// !< 0=free, 1=at lower limit, 2=at upper limit
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_2: u32,
}
extern "C" {
    #[link_name = "\u{1}?testLimitValue@btTranslationalLimitMotor@@QEAAHHN@Z"]
    pub fn btTranslationalLimitMotor_testLimitValue(
        this: *mut btTranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?solveLinearAxis@btTranslationalLimitMotor@@QEAANNNAEAVbtRigidBody@@AEBVbtVector3@@01H11@Z"]
    pub fn btTranslationalLimitMotor_solveLinearAxis(
        this: *mut btTranslationalLimitMotor,
        timeStep: btScalar,
        jacDiagABInv: btScalar,
        body1: *mut btRigidBody,
        pointInA: *const btVector3,
        body2: *mut btRigidBody,
        pointInB: *const btVector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const btVector3,
        anchorPos: *const btVector3,
    ) -> btScalar;
}
impl btTranslationalLimitMotor {
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int {
        btTranslationalLimitMotor_testLimitValue(self, limitIndex, test_value)
    }
    #[inline]
    pub unsafe fn solveLinearAxis(
        &mut self,
        timeStep: btScalar,
        jacDiagABInv: btScalar,
        body1: *mut btRigidBody,
        pointInA: *const btVector3,
        body2: *mut btRigidBody,
        pointInB: *const btVector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const btVector3,
        anchorPos: *const btVector3,
    ) -> btScalar {
        btTranslationalLimitMotor_solveLinearAxis(
            self,
            timeStep,
            jacDiagABInv,
            body1,
            pointInA,
            body2,
            pointInB,
            limit_index,
            axis_normal_on_a,
            anchorPos,
        )
    }
}
pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_NORM: bt6DofFlags = 1;
pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_STOP: bt6DofFlags = 2;
pub const bt6DofFlags_BT_6DOF_FLAGS_ERP_STOP: bt6DofFlags = 4;
pub type bt6DofFlags = i32;
/// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// *!
/// btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
/// currently this limit supports rotational motors<br>
/// <ul>
/// <li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
/// At this moment translational motors are not supported. May be in the future. </li>
///
/// <li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
/// This is accessible through btGeneric6DofConstraint.getLimitMotor method,
/// This brings support for limit parameters and motors. </li>
///
/// <li> Angulars limits have these possible ranges:
/// <table border=1 >
/// <tr>
/// <td><b>AXIS</b></td>
/// <td><b>MIN ANGLE</b></td>
/// <td><b>MAX ANGLE</b></td>
/// </tr><tr>
/// <td>X</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr><tr>
/// <td>Y</td>
/// <td>-PI/2</td>
/// <td>PI/2</td>
/// </tr><tr>
/// <td>Z</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr>
/// </table>
/// </li>
/// </ul>
///
/// */
#[repr(C)]
pub struct btGeneric6DofConstraint {
    pub _base: btTypedConstraint,
    /// !< the constraint space w.r.t body A
    pub m_frameInA: btTransform,
    /// !< the constraint space w.r.t body B
    pub m_frameInB: btTransform,
    /// !< 3 orthogonal linear constraints
    pub m_jacLinear: [btJacobianEntry; 3usize],
    /// !< 3 orthogonal angular constraints
    pub m_jacAng: [btJacobianEntry; 3usize],
    /// ! Linear_Limit_parameters
    /// //!@{
    pub m_linearLimits: btTranslationalLimitMotor,
    /// ! hinge_parameters
    /// //!@{
    pub m_angularLimits: [btRotationalLimitMotor; 3usize],
    /// ! temporal variables
    /// //!@{
    pub m_timeStep: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_calculatedAxisAngleDiff: btVector3,
    pub m_calculatedAxis: [btVector3; 3usize],
    pub m_calculatedLinearDiff: btVector3,
    pub m_factA: btScalar,
    pub m_factB: btScalar,
    pub m_hasStaticBody: bool,
    pub __bindgen_padding_1: u64,
    pub m_AnchorPos: btVector3,
    pub m_useLinearReferenceFrameA: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_flags: ::std::os::raw::c_int,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
    pub __bindgen_padding_2: [u8; 7usize],
}
extern "C" {
    #[link_name = "\u{1}?setAngularLimits@btGeneric6DofConstraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z"]
    pub fn btGeneric6DofConstraint_setAngularLimits(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setLinearLimits@btGeneric6DofConstraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z"]
    pub fn btGeneric6DofConstraint_setLinearLimits(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?buildLinearJacobian@btGeneric6DofConstraint@@IEAAXAEAVbtJacobianEntry@@AEBVbtVector3@@11@Z"]
    pub fn btGeneric6DofConstraint_buildLinearJacobian(
        this: *mut btGeneric6DofConstraint,
        jacLinear: *mut btJacobianEntry,
        normalWorld: *const btVector3,
        pivotAInW: *const btVector3,
        pivotBInW: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?buildAngularJacobian@btGeneric6DofConstraint@@IEAAXAEAVbtJacobianEntry@@AEBVbtVector3@@@Z"]
    pub fn btGeneric6DofConstraint_buildAngularJacobian(
        this: *mut btGeneric6DofConstraint,
        jacAngular: *mut btJacobianEntry,
        jointAxisW: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateLinearInfo@btGeneric6DofConstraint@@IEAAXXZ"]
    pub fn btGeneric6DofConstraint_calculateLinearInfo(this: *mut btGeneric6DofConstraint);
}
extern "C" {
    /// ! calcs the euler angles between the two bodies.
    #[link_name = "\u{1}?calculateAngleInfo@btGeneric6DofConstraint@@IEAAXXZ"]
    pub fn btGeneric6DofConstraint_calculateAngleInfo(this: *mut btGeneric6DofConstraint);
}
extern "C" {
    /// ! Calcs global transform of the offsets
    /// /*!
    /// Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    /// \sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
    /// */
    #[link_name = "\u{1}?calculateTransforms@btGeneric6DofConstraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btGeneric6DofConstraint_calculateTransforms(
        this: *mut btGeneric6DofConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTransforms@btGeneric6DofConstraint@@QEAAXXZ"]
    pub fn btGeneric6DofConstraint_calculateTransforms1(this: *mut btGeneric6DofConstraint);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@btGeneric6DofConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofConstraint_getInfo1NonVirtual(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@btGeneric6DofConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@222@Z"]
    pub fn btGeneric6DofConstraint_getInfo2NonVirtual(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateRHS@btGeneric6DofConstraint@@QEAAXN@Z"]
    pub fn btGeneric6DofConstraint_updateRHS(
        this: *mut btGeneric6DofConstraint,
        timeStep: btScalar,
    );
}
extern "C" {
    /// ! Get the rotation axis in global coordinates
    /// /*!
    /// \pre btGeneric6DofConstraint.buildJacobian must be called previously.
    /// */
    #[link_name = "\u{1}?getAxis@btGeneric6DofConstraint@@QEBA?AVbtVector3@@H@Z"]
    pub fn btGeneric6DofConstraint_getAxis(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    /// ! Get the relative Euler angle
    /// /*!
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?getAngle@btGeneric6DofConstraint@@QEBANH@Z"]
    pub fn btGeneric6DofConstraint_getAngle(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    /// ! Get the relative position of the constraint pivot
    /// /*!
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?getRelativePivotPosition@btGeneric6DofConstraint@@QEBANH@Z"]
    pub fn btGeneric6DofConstraint_getRelativePivotPosition(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setFrames@btGeneric6DofConstraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btGeneric6DofConstraint_setFrames(
        this: *mut btGeneric6DofConstraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    /// ! Test angular limit.
    /// /*!
    /// Calculates angular correction and returns true if limit needs to be corrected.
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */
    #[link_name = "\u{1}?testAngularLimitMotor@btGeneric6DofConstraint@@QEAA_NH@Z"]
    pub fn btGeneric6DofConstraint_testAngularLimitMotor(
        this: *mut btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get_limit_motor_info2@btGeneric6DofConstraint@@QEAAHPEAVbtRotationalLimitMotor@@AEBVbtTransform@@1AEBVbtVector3@@222PEAUbtConstraintInfo2@btTypedConstraint@@HAEAV4@HH@Z"]
    pub fn btGeneric6DofConstraint_get_limit_motor_info2(
        this: *mut btGeneric6DofConstraint,
        limot: *mut btRotationalLimitMotor,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setAxis@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@0@Z"]
    pub fn btGeneric6DofConstraint_setAxis(
        this: *mut btGeneric6DofConstraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z"]
    pub fn btGeneric6DofConstraint_btGeneric6DofConstraint(
        this: *mut btGeneric6DofConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z"]
    pub fn btGeneric6DofConstraint_btGeneric6DofConstraint1(
        this: *mut btGeneric6DofConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    );
}
impl btGeneric6DofConstraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_setAngularLimits(
            self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_setLinearLimits(
            self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn buildLinearJacobian(
        &mut self,
        jacLinear: *mut btJacobianEntry,
        normalWorld: *const btVector3,
        pivotAInW: *const btVector3,
        pivotBInW: *const btVector3,
    ) {
        btGeneric6DofConstraint_buildLinearJacobian(
            self,
            jacLinear,
            normalWorld,
            pivotAInW,
            pivotBInW,
        )
    }
    #[inline]
    pub unsafe fn buildAngularJacobian(
        &mut self,
        jacAngular: *mut btJacobianEntry,
        jointAxisW: *const btVector3,
    ) {
        btGeneric6DofConstraint_buildAngularJacobian(self, jacAngular, jointAxisW)
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        btGeneric6DofConstraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        btGeneric6DofConstraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btGeneric6DofConstraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self) {
        btGeneric6DofConstraint_calculateTransforms1(self)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btGeneric6DofConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btGeneric6DofConstraint_getInfo2NonVirtual(
            self, info, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btGeneric6DofConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> btVector3 {
        btGeneric6DofConstraint_getAxis(self, axis_index)
    }
    #[inline]
    pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofConstraint_getAngle(self, axis_index)
    }
    #[inline]
    pub unsafe fn getRelativePivotPosition(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofConstraint_getRelativePivotPosition(self, axis_index)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btGeneric6DofConstraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) -> bool {
        btGeneric6DofConstraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut btRotationalLimitMotor,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_get_limit_motor_info2(
            self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
            rotational, rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btGeneric6DofConstraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofConstraint_btGeneric6DofConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofConstraint_btGeneric6DofConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    /// ! performs Jacobian calculation, and also calculates angle differences and axis
    #[link_name = "\u{1}?buildJacobian@btGeneric6DofConstraint@@UEAAXXZ"]
    pub fn btGeneric6DofConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btGeneric6DofConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btGeneric6DofConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?calcAnchorPos@btGeneric6DofConstraint@@UEAAXXZ"]
    pub fn btGeneric6DofConstraint_calcAnchorPos(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@btGeneric6DofConstraint@@UEAAXHNH@Z"]
    pub fn btGeneric6DofConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@btGeneric6DofConstraint@@UEBANHH@Z"]
    pub fn btGeneric6DofConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btGeneric6DofConstraint@@UEBAHXZ"]
    pub fn btGeneric6DofConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btGeneric6DofConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btGeneric6DofConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: btVector3FloatData,
    pub m_linearLowerLimit: btVector3FloatData,
    pub m_angularUpperLimit: btVector3FloatData,
    pub m_angularLowerLimit: btVector3FloatData,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: btVector3DoubleData,
    pub m_linearLowerLimit: btVector3DoubleData,
    pub m_angularUpperLimit: btVector3DoubleData,
    pub m_angularLowerLimit: btVector3DoubleData,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRLIN: btSliderFlags = 1;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRLIN: btSliderFlags = 2;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRANG: btSliderFlags = 4;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRANG: btSliderFlags = 8;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTLIN: btSliderFlags = 16;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTLIN: btSliderFlags = 32;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTANG: btSliderFlags = 64;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTANG: btSliderFlags = 128;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMLIN: btSliderFlags = 256;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMLIN: btSliderFlags = 512;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMANG: btSliderFlags = 1024;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMANG: btSliderFlags = 2048;
pub type btSliderFlags = i32;
#[repr(C)]
pub struct btSliderConstraint {
    pub _base: btTypedConstraint,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub __bindgen_padding_0: u64,
    pub m_frameInA: btTransform,
    pub m_frameInB: btTransform,
    pub m_useLinearReferenceFrameA: bool,
    pub m_lowerLinLimit: btScalar,
    pub m_upperLinLimit: btScalar,
    pub m_lowerAngLimit: btScalar,
    pub m_upperAngLimit: btScalar,
    pub m_softnessDirLin: btScalar,
    pub m_restitutionDirLin: btScalar,
    pub m_dampingDirLin: btScalar,
    pub m_cfmDirLin: btScalar,
    pub m_softnessDirAng: btScalar,
    pub m_restitutionDirAng: btScalar,
    pub m_dampingDirAng: btScalar,
    pub m_cfmDirAng: btScalar,
    pub m_softnessLimLin: btScalar,
    pub m_restitutionLimLin: btScalar,
    pub m_dampingLimLin: btScalar,
    pub m_cfmLimLin: btScalar,
    pub m_softnessLimAng: btScalar,
    pub m_restitutionLimAng: btScalar,
    pub m_dampingLimAng: btScalar,
    pub m_cfmLimAng: btScalar,
    pub m_softnessOrthoLin: btScalar,
    pub m_restitutionOrthoLin: btScalar,
    pub m_dampingOrthoLin: btScalar,
    pub m_cfmOrthoLin: btScalar,
    pub m_softnessOrthoAng: btScalar,
    pub m_restitutionOrthoAng: btScalar,
    pub m_dampingOrthoAng: btScalar,
    pub m_cfmOrthoAng: btScalar,
    pub m_solveLinLim: bool,
    pub m_solveAngLim: bool,
    pub m_flags: ::std::os::raw::c_int,
    pub m_jacLin: [btJacobianEntry; 3usize],
    pub m_jacLinDiagABInv: [btScalar; 3usize],
    pub __bindgen_padding_1: u64,
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_timeStep: btScalar,
    pub __bindgen_padding_2: u64,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_sliderAxis: btVector3,
    pub m_realPivotAInW: btVector3,
    pub m_realPivotBInW: btVector3,
    pub m_projPivotInW: btVector3,
    pub m_delta: btVector3,
    pub m_depth: btVector3,
    pub m_relPosA: btVector3,
    pub m_relPosB: btVector3,
    pub m_linPos: btScalar,
    pub m_angPos: btScalar,
    pub m_angDepth: btScalar,
    pub m_kAngle: btScalar,
    pub m_poweredLinMotor: bool,
    pub m_targetLinMotorVelocity: btScalar,
    pub m_maxLinMotorForce: btScalar,
    pub m_accumulatedLinMotorImpulse: btScalar,
    pub m_poweredAngMotor: bool,
    pub m_targetAngMotorVelocity: btScalar,
    pub m_maxAngMotorForce: btScalar,
    pub m_accumulatedAngMotorImpulse: btScalar,
}
extern "C" {
    #[link_name = "\u{1}?initParams@btSliderConstraint@@IEAAXXZ"]
    pub fn btSliderConstraint_initParams(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}?getInfo1NonVirtual@btSliderConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btSliderConstraint_getInfo1NonVirtual(
        this: *mut btSliderConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2NonVirtual@btSliderConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2NN@Z"]
    pub fn btSliderConstraint_getInfo2NonVirtual(
        this: *mut btSliderConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        rbAinvMass: btScalar,
        rbBinvMass: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTransforms@btSliderConstraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btSliderConstraint_calculateTransforms(
        this: *mut btSliderConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?testLinLimits@btSliderConstraint@@QEAAXXZ"]
    pub fn btSliderConstraint_testLinLimits(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}?testAngLimits@btSliderConstraint@@QEAAXXZ"]
    pub fn btSliderConstraint_testAngLimits(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}?getAncorInA@btSliderConstraint@@QEAA?AVbtVector3@@XZ"]
    pub fn btSliderConstraint_getAncorInA(this: *mut btSliderConstraint) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}?getAncorInB@btSliderConstraint@@QEAA?AVbtVector3@@XZ"]
    pub fn btSliderConstraint_getAncorInB(this: *mut btSliderConstraint) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}??0btSliderConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z"]
    pub fn btSliderConstraint_btSliderConstraint(
        this: *mut btSliderConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btSliderConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z"]
    pub fn btSliderConstraint_btSliderConstraint1(
        this: *mut btSliderConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
impl btSliderConstraint {
    #[inline]
    pub unsafe fn initParams(&mut self) {
        btSliderConstraint_initParams(self)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btSliderConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        rbAinvMass: btScalar,
        rbBinvMass: btScalar,
    ) {
        btSliderConstraint_getInfo2NonVirtual(
            self, info, transA, transB, linVelA, linVelB, rbAinvMass, rbBinvMass,
        )
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btSliderConstraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn testLinLimits(&mut self) {
        btSliderConstraint_testLinLimits(self)
    }
    #[inline]
    pub unsafe fn testAngLimits(&mut self) {
        btSliderConstraint_testAngLimits(self)
    }
    #[inline]
    pub unsafe fn getAncorInA(&mut self) -> btVector3 {
        btSliderConstraint_getAncorInA(self)
    }
    #[inline]
    pub unsafe fn getAncorInB(&mut self) -> btVector3 {
        btSliderConstraint_getAncorInB(self)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSliderConstraint_btSliderConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSliderConstraint_btSliderConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btSliderConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btSliderConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btSliderConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btSliderConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.
    #[link_name = "\u{1}?setParam@btSliderConstraint@@UEAAXHNH@Z"]
    pub fn btSliderConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// return the local value of parameter
    #[link_name = "\u{1}?getParam@btSliderConstraint@@UEBANHH@Z"]
    pub fn btSliderConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btSliderConstraint@@UEBAHXZ"]
    pub fn btSliderConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btSliderConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btSliderConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSliderConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: f32,
    pub m_linearLowerLimit: f32,
    pub m_angularUpperLimit: f32,
    pub m_angularLowerLimit: f32,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSliderConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: f64,
    pub m_linearLowerLimit: f64,
    pub m_angularUpperLimit: f64,
    pub m_angularLowerLimit: f64,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
/// DOF index used in enableSpring() and setStiffness() means:
/// 0 : translation X
/// 1 : translation Y
/// 2 : translation Z
/// 3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
/// 4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
/// 5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] )
#[repr(C)]
pub struct btGeneric6DofSpringConstraint {
    pub _base: btGeneric6DofConstraint,
    pub m_springEnabled: [bool; 6usize],
    pub m_equilibriumPoint: [btScalar; 6usize],
    pub m_springStiffness: [btScalar; 6usize],
    pub m_springDamping: [btScalar; 6usize],
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}?init@btGeneric6DofSpringConstraint@@IEAAXXZ"]
    pub fn btGeneric6DofSpringConstraint_init(this: *mut btGeneric6DofSpringConstraint);
}
extern "C" {
    #[link_name = "\u{1}?internalUpdateSprings@btGeneric6DofSpringConstraint@@IEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofSpringConstraint_internalUpdateSprings(
        this: *mut btGeneric6DofSpringConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?enableSpring@btGeneric6DofSpringConstraint@@QEAAXH_N@Z"]
    pub fn btGeneric6DofSpringConstraint_enableSpring(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStiffness@btGeneric6DofSpringConstraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpringConstraint_setStiffness(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setDamping@btGeneric6DofSpringConstraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpringConstraint_setDamping(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        damping: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXXZ"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint(
        this: *mut btGeneric6DofSpringConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXH@Z"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint1(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint2(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        val: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofSpringConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z"]
    pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
        this: *mut btGeneric6DofSpringConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofSpringConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z"]
    pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
        this: *mut btGeneric6DofSpringConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    );
}
impl btGeneric6DofSpringConstraint {
    #[inline]
    pub unsafe fn init(&mut self) {
        btGeneric6DofSpringConstraint_init(self)
    }
    #[inline]
    pub unsafe fn internalUpdateSprings(&mut self, info: *mut btTypedConstraint_btConstraintInfo2) {
        btGeneric6DofSpringConstraint_internalUpdateSprings(self, info)
    }
    #[inline]
    pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpringConstraint_enableSpring(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setStiffness(&mut self, index: ::std::os::raw::c_int, stiffness: btScalar) {
        btGeneric6DofSpringConstraint_setStiffness(self, index, stiffness)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, index: ::std::os::raw::c_int, damping: btScalar) {
        btGeneric6DofSpringConstraint_setDamping(self, index, damping)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint(&mut self) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint(self)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint1(self, index)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint2(&mut self, index: ::std::os::raw::c_int, val: btScalar) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint2(self, index, val)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?setAxis@btGeneric6DofSpringConstraint@@UEAAXAEBVbtVector3@@0@Z"]
    pub fn btGeneric6DofSpringConstraint_setAxis(
        this: *mut ::std::os::raw::c_void,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btGeneric6DofSpringConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofSpringConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btGeneric6DofSpringConstraint@@UEBAHXZ"]
    pub fn btGeneric6DofSpringConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btGeneric6DofSpringConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btGeneric6DofSpringConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpringConstraintData {
    pub m_6dofData: btGeneric6DofConstraintData,
    pub m_springEnabled: [::std::os::raw::c_int; 6usize],
    pub m_equilibriumPoint: [f32; 6usize],
    pub m_springStiffness: [f32; 6usize],
    pub m_springDamping: [f32; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpringConstraintDoubleData2 {
    pub m_6dofData: btGeneric6DofConstraintDoubleData2,
    pub m_springEnabled: [::std::os::raw::c_int; 6usize],
    pub m_equilibriumPoint: [f64; 6usize],
    pub m_springStiffness: [f64; 6usize],
    pub m_springDamping: [f64; 6usize],
}
/// Constraint similar to ODE Universal Joint
/// has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
/// and Y (axis 2)
/// Description from ODE manual :
/// "Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular.
/// In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal."
#[repr(C)]
pub struct btUniversalConstraint {
    pub _base: btGeneric6DofConstraint,
    pub m_anchor: btVector3,
    pub m_axis1: btVector3,
    pub m_axis2: btVector3,
}
extern "C" {
    #[link_name = "\u{1}?setAxis@btUniversalConstraint@@QEAAXAEBVbtVector3@@0@Z"]
    pub fn btUniversalConstraint_setAxis(
        this: *mut btUniversalConstraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btUniversalConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@11@Z"]
    pub fn btUniversalConstraint_btUniversalConstraint(
        this: *mut btUniversalConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *const btVector3,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
impl btUniversalConstraint {
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btUniversalConstraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *const btVector3,
        axis1: *const btVector3,
        axis2: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btUniversalConstraint_btUniversalConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            anchor,
            axis1,
            axis2,
        );
        __bindgen_tmp
    }
}
pub const RotateOrder_RO_XYZ: RotateOrder = 0;
pub const RotateOrder_RO_XZY: RotateOrder = 1;
pub const RotateOrder_RO_YXZ: RotateOrder = 2;
pub const RotateOrder_RO_YZX: RotateOrder = 3;
pub const RotateOrder_RO_ZXY: RotateOrder = 4;
pub const RotateOrder_RO_ZYX: RotateOrder = 5;
pub type RotateOrder = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRotationalLimitMotor2 {
    pub m_loLimit: btScalar,
    pub m_hiLimit: btScalar,
    pub m_bounce: btScalar,
    pub m_stopERP: btScalar,
    pub m_stopCFM: btScalar,
    pub m_motorERP: btScalar,
    pub m_motorCFM: btScalar,
    pub m_enableMotor: bool,
    pub m_targetVelocity: btScalar,
    pub m_maxMotorForce: btScalar,
    pub m_servoMotor: bool,
    pub m_servoTarget: btScalar,
    pub m_enableSpring: bool,
    pub m_springStiffness: btScalar,
    pub m_springStiffnessLimited: bool,
    pub m_springDamping: btScalar,
    pub m_springDampingLimited: bool,
    pub m_equilibriumPoint: btScalar,
    pub m_currentLimitError: btScalar,
    pub m_currentLimitErrorHi: btScalar,
    pub m_currentPosition: btScalar,
    pub m_currentLimit: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}?testLimitValue@btRotationalLimitMotor2@@QEAAXN@Z"]
    pub fn btRotationalLimitMotor2_testLimitValue(
        this: *mut btRotationalLimitMotor2,
        test_value: btScalar,
    );
}
impl btRotationalLimitMotor2 {
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: btScalar) {
        btRotationalLimitMotor2_testLimitValue(self, test_value)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTranslationalLimitMotor2 {
    pub m_lowerLimit: btVector3,
    pub m_upperLimit: btVector3,
    pub m_bounce: btVector3,
    pub m_stopERP: btVector3,
    pub m_stopCFM: btVector3,
    pub m_motorERP: btVector3,
    pub m_motorCFM: btVector3,
    pub m_enableMotor: [bool; 3usize],
    pub m_servoMotor: [bool; 3usize],
    pub m_enableSpring: [bool; 3usize],
    pub __bindgen_padding_0: [u64; 0usize],
    pub m_servoTarget: btVector3,
    pub m_springStiffness: btVector3,
    pub m_springStiffnessLimited: [bool; 3usize],
    pub __bindgen_padding_1: u64,
    pub m_springDamping: btVector3,
    pub m_springDampingLimited: [bool; 3usize],
    pub __bindgen_padding_2: u64,
    pub m_equilibriumPoint: btVector3,
    pub m_targetVelocity: btVector3,
    pub m_maxMotorForce: btVector3,
    pub m_currentLimitError: btVector3,
    pub m_currentLimitErrorHi: btVector3,
    pub m_currentLinearDiff: btVector3,
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
    pub __bindgen_padding_3: u32,
}
extern "C" {
    #[link_name = "\u{1}?testLimitValue@btTranslationalLimitMotor2@@QEAAXHN@Z"]
    pub fn btTranslationalLimitMotor2_testLimitValue(
        this: *mut btTranslationalLimitMotor2,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    );
}
impl btTranslationalLimitMotor2 {
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) {
        btTranslationalLimitMotor2_testLimitValue(self, limitIndex, test_value)
    }
}
pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_STOP2: bt6DofFlags2 = 1;
pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_STOP2: bt6DofFlags2 = 2;
pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_MOTO2: bt6DofFlags2 = 4;
pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_MOTO2: bt6DofFlags2 = 8;
pub type bt6DofFlags2 = i32;
#[repr(C)]
pub struct btGeneric6DofSpring2Constraint {
    pub _base: btTypedConstraint,
    pub m_frameInA: btTransform,
    pub m_frameInB: btTransform,
    pub m_jacLinear: [btJacobianEntry; 3usize],
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_linearLimits: btTranslationalLimitMotor2,
    pub m_angularLimits: [btRotationalLimitMotor2; 3usize],
    pub m_rotateOrder: RotateOrder,
    pub __bindgen_padding_0: u64,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_calculatedAxisAngleDiff: btVector3,
    pub m_calculatedAxis: [btVector3; 3usize],
    pub m_calculatedLinearDiff: btVector3,
    pub m_factA: btScalar,
    pub m_factB: btScalar,
    pub m_hasStaticBody: bool,
    pub m_flags: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u64,
}
extern "C" {
    #[link_name = "\u{1}?setAngularLimits@btGeneric6DofSpring2Constraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z"]
    pub fn btGeneric6DofSpring2Constraint_setAngularLimits(
        this: *mut btGeneric6DofSpring2Constraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?setLinearLimits@btGeneric6DofSpring2Constraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z"]
    pub fn btGeneric6DofSpring2Constraint_setLinearLimits(
        this: *mut btGeneric6DofSpring2Constraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?calculateLinearInfo@btGeneric6DofSpring2Constraint@@IEAAXXZ"]
    pub fn btGeneric6DofSpring2Constraint_calculateLinearInfo(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateAngleInfo@btGeneric6DofSpring2Constraint@@IEAAXXZ"]
    pub fn btGeneric6DofSpring2Constraint_calculateAngleInfo(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?testAngularLimitMotor@btGeneric6DofSpring2Constraint@@IEAAXH@Z"]
    pub fn btGeneric6DofSpring2Constraint_testAngularLimitMotor(
        this: *mut btGeneric6DofSpring2Constraint,
        axis_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateJacobi@btGeneric6DofSpring2Constraint@@IEAAXPEAVbtRotationalLimitMotor2@@AEBVbtTransform@@1PEAUbtConstraintInfo2@btTypedConstraint@@HAEAVbtVector3@@HH@Z"]
    pub fn btGeneric6DofSpring2Constraint_calculateJacobi(
        this: *mut btGeneric6DofSpring2Constraint,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        info: *mut btTypedConstraint_btConstraintInfo2,
        srow: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?get_limit_motor_info2@btGeneric6DofSpring2Constraint@@IEAAHPEAVbtRotationalLimitMotor2@@AEBVbtTransform@@1AEBVbtVector3@@222PEAUbtConstraintInfo2@btTypedConstraint@@HAEAV4@HH@Z"]
    pub fn btGeneric6DofSpring2Constraint_get_limit_motor_info2(
        this: *mut btGeneric6DofSpring2Constraint,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?calculateTransforms@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btGeneric6DofSpring2Constraint_calculateTransforms(
        this: *mut btGeneric6DofSpring2Constraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateTransforms@btGeneric6DofSpring2Constraint@@QEAAXXZ"]
    pub fn btGeneric6DofSpring2Constraint_calculateTransforms1(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setFrames@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtTransform@@0@Z"]
    pub fn btGeneric6DofSpring2Constraint_setFrames(
        this: *mut btGeneric6DofSpring2Constraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}?setAxis@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@0@Z"]
    pub fn btGeneric6DofSpring2Constraint_setAxis(
        this: *mut btGeneric6DofSpring2Constraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBounce@btGeneric6DofSpring2Constraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpring2Constraint_setBounce(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        bounce: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?enableMotor@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z"]
    pub fn btGeneric6DofSpring2Constraint_enableMotor(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setServo@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z"]
    pub fn btGeneric6DofSpring2Constraint_setServo(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setTargetVelocity@btGeneric6DofSpring2Constraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpring2Constraint_setTargetVelocity(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        velocity: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setServoTarget@btGeneric6DofSpring2Constraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpring2Constraint_setServoTarget(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        target: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?setMaxMotorForce@btGeneric6DofSpring2Constraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpring2Constraint_setMaxMotorForce(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        force: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?enableSpring@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z"]
    pub fn btGeneric6DofSpring2Constraint_enableSpring(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setStiffness@btGeneric6DofSpring2Constraint@@QEAAXHN_N@Z"]
    pub fn btGeneric6DofSpring2Constraint_setStiffness(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
        limitIfNeeded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setDamping@btGeneric6DofSpring2Constraint@@QEAAXHN_N@Z"]
    pub fn btGeneric6DofSpring2Constraint_setDamping(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        damping: btScalar,
        limitIfNeeded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXXZ"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXH@Z"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint1(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXHN@Z"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint2(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        val: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?btGetMatrixElem@btGeneric6DofSpring2Constraint@@SANAEBVbtMatrix3x3@@H@Z"]
    pub fn btGeneric6DofSpring2Constraint_btGetMatrixElem(
        mat: *const btMatrix3x3,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerXYZ@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerXYZ(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerXZY@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerXZY(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerYXZ@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerYXZ(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerYZX@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerYZX(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerZXY@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerZXY(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matrixToEulerZYX@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerZYX(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofSpring2Constraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1W4RotateOrder@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
        this: *mut btGeneric6DofSpring2Constraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}??0btGeneric6DofSpring2Constraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@W4RotateOrder@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
        this: *mut btGeneric6DofSpring2Constraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    );
}
impl btGeneric6DofSpring2Constraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_setAngularLimits(
            self, info, row_offset, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_setLinearLimits(
            self, info, row, transA, transB, linVelA, linVelB, angVelA, angVelB,
        )
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        btGeneric6DofSpring2Constraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        btGeneric6DofSpring2Constraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) {
        btGeneric6DofSpring2Constraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn calculateJacobi(
        &mut self,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        info: *mut btTypedConstraint_btConstraintInfo2,
        srow: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) {
        btGeneric6DofSpring2Constraint_calculateJacobi(
            self, limot, transA, transB, info, srow, ax1, rotational, rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_get_limit_motor_info2(
            self, limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, ax1,
            rotational, rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btGeneric6DofSpring2Constraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self) {
        btGeneric6DofSpring2Constraint_calculateTransforms1(self)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btGeneric6DofSpring2Constraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn setBounce(&mut self, index: ::std::os::raw::c_int, bounce: btScalar) {
        btGeneric6DofSpring2Constraint_setBounce(self, index, bounce)
    }
    #[inline]
    pub unsafe fn enableMotor(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_enableMotor(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setServo(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_setServo(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setTargetVelocity(&mut self, index: ::std::os::raw::c_int, velocity: btScalar) {
        btGeneric6DofSpring2Constraint_setTargetVelocity(self, index, velocity)
    }
    #[inline]
    pub unsafe fn setServoTarget(&mut self, index: ::std::os::raw::c_int, target: btScalar) {
        btGeneric6DofSpring2Constraint_setServoTarget(self, index, target)
    }
    #[inline]
    pub unsafe fn setMaxMotorForce(&mut self, index: ::std::os::raw::c_int, force: btScalar) {
        btGeneric6DofSpring2Constraint_setMaxMotorForce(self, index, force)
    }
    #[inline]
    pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_enableSpring(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setStiffness(
        &mut self,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
        limitIfNeeded: bool,
    ) {
        btGeneric6DofSpring2Constraint_setStiffness(self, index, stiffness, limitIfNeeded)
    }
    #[inline]
    pub unsafe fn setDamping(
        &mut self,
        index: ::std::os::raw::c_int,
        damping: btScalar,
        limitIfNeeded: bool,
    ) {
        btGeneric6DofSpring2Constraint_setDamping(self, index, damping, limitIfNeeded)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint(&mut self) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint(self)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint1(self, index)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint2(&mut self, index: ::std::os::raw::c_int, val: btScalar) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint2(self, index, val)
    }
    #[inline]
    pub unsafe fn btGetMatrixElem(
        mat: *const btMatrix3x3,
        index: ::std::os::raw::c_int,
    ) -> btScalar {
        btGeneric6DofSpring2Constraint_btGetMatrixElem(mat, index)
    }
    #[inline]
    pub unsafe fn matrixToEulerXYZ(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerXYZ(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerXZY(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerXZY(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerYXZ(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerYXZ(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerYZX(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerYZX(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerZXY(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerZXY(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerZYX(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerZYX(mat, xyz)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            rotOrder,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            rotOrder,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}?getInfo1@btGeneric6DofSpring2Constraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}?getInfo2@btGeneric6DofSpring2Constraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btGeneric6DofSpring2Constraint@@UEBAHXZ"]
    pub fn btGeneric6DofSpring2Constraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?serialize@btGeneric6DofSpring2Constraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btGeneric6DofSpring2Constraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?setParam@btGeneric6DofSpring2Constraint@@UEAAXHNH@Z"]
    pub fn btGeneric6DofSpring2Constraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getParam@btGeneric6DofSpring2Constraint@@UEBANHH@Z"]
    pub fn btGeneric6DofSpring2Constraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpring2ConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: btVector3FloatData,
    pub m_linearLowerLimit: btVector3FloatData,
    pub m_linearBounce: btVector3FloatData,
    pub m_linearStopERP: btVector3FloatData,
    pub m_linearStopCFM: btVector3FloatData,
    pub m_linearMotorERP: btVector3FloatData,
    pub m_linearMotorCFM: btVector3FloatData,
    pub m_linearTargetVelocity: btVector3FloatData,
    pub m_linearMaxMotorForce: btVector3FloatData,
    pub m_linearServoTarget: btVector3FloatData,
    pub m_linearSpringStiffness: btVector3FloatData,
    pub m_linearSpringDamping: btVector3FloatData,
    pub m_linearEquilibriumPoint: btVector3FloatData,
    pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_padding1: [::std::os::raw::c_char; 4usize],
    pub m_angularUpperLimit: btVector3FloatData,
    pub m_angularLowerLimit: btVector3FloatData,
    pub m_angularBounce: btVector3FloatData,
    pub m_angularStopERP: btVector3FloatData,
    pub m_angularStopCFM: btVector3FloatData,
    pub m_angularMotorERP: btVector3FloatData,
    pub m_angularMotorCFM: btVector3FloatData,
    pub m_angularTargetVelocity: btVector3FloatData,
    pub m_angularMaxMotorForce: btVector3FloatData,
    pub m_angularServoTarget: btVector3FloatData,
    pub m_angularSpringStiffness: btVector3FloatData,
    pub m_angularSpringDamping: btVector3FloatData,
    pub m_angularEquilibriumPoint: btVector3FloatData,
    pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_rotateOrder: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpring2ConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: btVector3DoubleData,
    pub m_linearLowerLimit: btVector3DoubleData,
    pub m_linearBounce: btVector3DoubleData,
    pub m_linearStopERP: btVector3DoubleData,
    pub m_linearStopCFM: btVector3DoubleData,
    pub m_linearMotorERP: btVector3DoubleData,
    pub m_linearMotorCFM: btVector3DoubleData,
    pub m_linearTargetVelocity: btVector3DoubleData,
    pub m_linearMaxMotorForce: btVector3DoubleData,
    pub m_linearServoTarget: btVector3DoubleData,
    pub m_linearSpringStiffness: btVector3DoubleData,
    pub m_linearSpringDamping: btVector3DoubleData,
    pub m_linearEquilibriumPoint: btVector3DoubleData,
    pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_padding1: [::std::os::raw::c_char; 4usize],
    pub m_angularUpperLimit: btVector3DoubleData,
    pub m_angularLowerLimit: btVector3DoubleData,
    pub m_angularBounce: btVector3DoubleData,
    pub m_angularStopERP: btVector3DoubleData,
    pub m_angularStopCFM: btVector3DoubleData,
    pub m_angularMotorERP: btVector3DoubleData,
    pub m_angularMotorCFM: btVector3DoubleData,
    pub m_angularTargetVelocity: btVector3DoubleData,
    pub m_angularMaxMotorForce: btVector3DoubleData,
    pub m_angularServoTarget: btVector3DoubleData,
    pub m_angularSpringStiffness: btVector3DoubleData,
    pub m_angularSpringDamping: btVector3DoubleData,
    pub m_angularEquilibriumPoint: btVector3DoubleData,
    pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_rotateOrder: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct btHinge2Constraint {
    pub _base: btGeneric6DofSpring2Constraint,
    pub m_anchor: btVector3,
    pub m_axis1: btVector3,
    pub m_axis2: btVector3,
}
extern "C" {
    #[link_name = "\u{1}??0btHinge2Constraint@@QEAA@AEAVbtRigidBody@@0AEAVbtVector3@@11@Z"]
    pub fn btHinge2Constraint_btHinge2Constraint(
        this: *mut btHinge2Constraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *mut btVector3,
        axis1: *mut btVector3,
        axis2: *mut btVector3,
    );
}
impl btHinge2Constraint {
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *mut btVector3,
        axis1: *mut btVector3,
        axis2: *mut btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHinge2Constraint_btHinge2Constraint(&mut __bindgen_tmp, rbA, rbB, anchor, axis1, axis2);
        __bindgen_tmp
    }
}
/// The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
/// See Bullet/Demos/ConstraintDemo for an example use.
#[repr(C)]
pub struct btGearConstraint {
    pub _base: btTypedConstraint,
    pub m_axisInA: btVector3,
    pub m_axisInB: btVector3,
    pub m_useFrameA: bool,
    pub m_ratio: btScalar,
}
extern "C" {
    #[link_name = "\u{1}??0btGearConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@1N@Z"]
    pub fn btGearConstraint_btGearConstraint(
        this: *mut btGearConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        ratio: btScalar,
    );
}
impl btGearConstraint {
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        ratio: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGearConstraint_btGearConstraint(&mut __bindgen_tmp, rbA, rbB, axisInA, axisInB, ratio);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtGearConstraint@@QEAAXXZ"]
    pub fn btGearConstraint_btGearConstraint_destructor(this: *mut btGearConstraint);
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getInfo1@btGearConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z"]
    pub fn btGearConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    /// internal method used by the constraint solver, don't use them directly
    #[link_name = "\u{1}?getInfo2@btGearConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z"]
    pub fn btGearConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}?calculateSerializeBufferSize@btGearConstraint@@UEBAHXZ"]
    pub fn btGearConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "\u{1}?serialize@btGearConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z"]
    pub fn btGearConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGearConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintFloatData,
    pub m_axisInA: btVector3FloatData,
    pub m_axisInB: btVector3FloatData,
    pub m_ratio: f32,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGearConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_axisInA: btVector3DoubleData,
    pub m_axisInB: btVector3DoubleData,
    pub m_ratio: f64,
}
#[repr(C)]
pub struct btFixedConstraint {
    pub _base: btGeneric6DofSpring2Constraint,
}
extern "C" {
    #[link_name = "\u{1}??0btFixedConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1@Z"]
    pub fn btFixedConstraint_btFixedConstraint(
        this: *mut btFixedConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
    );
}
impl btFixedConstraint {
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btFixedConstraint_btFixedConstraint(&mut __bindgen_tmp, rbA, rbB, frameInA, frameInB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtFixedConstraint@@QEAAXXZ"]
    pub fn btFixedConstraint_btFixedConstraint_destructor(this: *mut btFixedConstraint);
}
#[repr(C)]
pub struct btVehicleRaycaster__bindgen_vtable(::std::os::raw::c_void);
/// btVehicleRaycaster is provides interface for between vehicle simulation and raycasting
#[repr(C)]
#[derive(Debug)]
pub struct btVehicleRaycaster {
    pub vtable_: *const btVehicleRaycaster__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVehicleRaycaster_btVehicleRaycasterResult {
    pub m_hitPointInWorld: btVector3,
    pub m_hitNormalInWorld: btVector3,
    pub m_distFraction: btScalar,
    pub __bindgen_padding_0: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfoConstructionInfo {
    pub m_chassisConnectionCS: btVector3,
    pub m_wheelDirectionCS: btVector3,
    pub m_wheelAxleCS: btVector3,
    pub m_suspensionRestLength: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_wheelRadius: btScalar,
    pub m_suspensionStiffness: btScalar,
    pub m_wheelsDampingCompression: btScalar,
    pub m_wheelsDampingRelaxation: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_maxSuspensionForce: btScalar,
    pub m_bIsFrontWheel: bool,
    pub __bindgen_padding_0: [u8; 15usize],
}
/// btWheelInfo contains information per wheel about friction and suspension.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfo {
    pub m_raycastInfo: btWheelInfo_RaycastInfo,
    pub m_worldTransform: btTransform,
    pub m_chassisConnectionPointCS: btVector3,
    pub m_wheelDirectionCS: btVector3,
    pub m_wheelAxleCS: btVector3,
    pub m_suspensionRestLength1: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_wheelsRadius: btScalar,
    pub m_suspensionStiffness: btScalar,
    pub m_wheelsDampingCompression: btScalar,
    pub m_wheelsDampingRelaxation: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_steering: btScalar,
    pub m_rotation: btScalar,
    pub m_deltaRotation: btScalar,
    pub m_rollInfluence: btScalar,
    pub m_maxSuspensionForce: btScalar,
    pub m_engineForce: btScalar,
    pub m_brake: btScalar,
    pub m_bIsFrontWheel: bool,
    pub m_clientInfo: *mut ::std::os::raw::c_void,
    pub m_clippedInvContactDotSuspension: btScalar,
    pub m_suspensionRelativeVelocity: btScalar,
    pub m_wheelsSuspensionForce: btScalar,
    pub m_skidInfo: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfo_RaycastInfo {
    pub m_contactNormalWS: btVector3,
    pub m_contactPointWS: btVector3,
    pub m_suspensionLength: btScalar,
    pub __bindgen_padding_0: u64,
    pub m_hardPointWS: btVector3,
    pub m_wheelDirectionWS: btVector3,
    pub m_wheelAxleWS: btVector3,
    pub m_isInContact: bool,
    pub m_groundObject: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[link_name = "\u{1}?getSuspensionRestLength@btWheelInfo@@QEBANXZ"]
    pub fn btWheelInfo_getSuspensionRestLength(this: *const btWheelInfo) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?updateWheel@btWheelInfo@@QEAAXAEBVbtRigidBody@@AEAURaycastInfo@1@@Z"]
    pub fn btWheelInfo_updateWheel(
        this: *mut btWheelInfo,
        chassis: *const btRigidBody,
        raycastInfo: *mut btWheelInfo_RaycastInfo,
    );
}
impl btWheelInfo {
    #[inline]
    pub unsafe fn getSuspensionRestLength(&self) -> btScalar {
        btWheelInfo_getSuspensionRestLength(self)
    }
    #[inline]
    pub unsafe fn updateWheel(
        &mut self,
        chassis: *const btRigidBody,
        raycastInfo: *mut btWheelInfo_RaycastInfo,
    ) {
        btWheelInfo_updateWheel(self, chassis, raycastInfo)
    }
}
/// rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
#[repr(C)]
#[derive(Debug)]
pub struct btRaycastVehicle {
    pub _base: btActionInterface,
    pub m_forwardWS: btAlignedObjectArray<btVector3>,
    pub m_axle: btAlignedObjectArray<btVector3>,
    pub m_forwardImpulse: btAlignedObjectArray<btScalar>,
    pub m_sideImpulse: btAlignedObjectArray<btScalar>,
    /// backwards compatibility
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_vehicleRaycaster: *mut btVehicleRaycaster,
    pub m_pitchControl: btScalar,
    pub m_steeringValue: btScalar,
    pub m_currentVehicleSpeedKmHour: btScalar,
    pub m_chassisBody: *mut btRigidBody,
    pub m_indexRightAxis: ::std::os::raw::c_int,
    pub m_indexUpAxis: ::std::os::raw::c_int,
    pub m_indexForwardAxis: ::std::os::raw::c_int,
    pub m_wheelInfo: btAlignedObjectArray<btWheelInfo>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRaycastVehicle_btVehicleTuning {
    pub m_suspensionStiffness: btScalar,
    pub m_suspensionCompression: btScalar,
    pub m_suspensionDamping: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_maxSuspensionForce: btScalar,
}
extern "C" {
    #[link_name = "\u{1}?getChassisWorldTransform@btRaycastVehicle@@QEBAAEBVbtTransform@@XZ"]
    pub fn btRaycastVehicle_getChassisWorldTransform(
        this: *const btRaycastVehicle,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}?rayCast@btRaycastVehicle@@QEAANAEAUbtWheelInfo@@@Z"]
    pub fn btRaycastVehicle_rayCast(
        this: *mut btRaycastVehicle,
        wheel: *mut btWheelInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?resetSuspension@btRaycastVehicle@@QEAAXXZ"]
    pub fn btRaycastVehicle_resetSuspension(this: *mut btRaycastVehicle);
}
extern "C" {
    #[link_name = "\u{1}?getSteeringValue@btRaycastVehicle@@QEBANH@Z"]
    pub fn btRaycastVehicle_getSteeringValue(
        this: *const btRaycastVehicle,
        wheel: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}?setSteeringValue@btRaycastVehicle@@QEAAXNH@Z"]
    pub fn btRaycastVehicle_setSteeringValue(
        this: *mut btRaycastVehicle,
        steering: btScalar,
        wheel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?applyEngineForce@btRaycastVehicle@@QEAAXNH@Z"]
    pub fn btRaycastVehicle_applyEngineForce(
        this: *mut btRaycastVehicle,
        force: btScalar,
        wheel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?getWheelTransformWS@btRaycastVehicle@@QEBAAEBVbtTransform@@H@Z"]
    pub fn btRaycastVehicle_getWheelTransformWS(
        this: *const btRaycastVehicle,
        wheelIndex: ::std::os::raw::c_int,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}?updateWheelTransform@btRaycastVehicle@@QEAAXH_N@Z"]
    pub fn btRaycastVehicle_updateWheelTransform(
        this: *mut btRaycastVehicle,
        wheelIndex: ::std::os::raw::c_int,
        interpolatedTransform: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?addWheel@btRaycastVehicle@@QEAAAEAUbtWheelInfo@@AEBVbtVector3@@00NNAEBVbtVehicleTuning@1@_N@Z"]
    pub fn btRaycastVehicle_addWheel(
        this: *mut btRaycastVehicle,
        connectionPointCS0: *const btVector3,
        wheelDirectionCS0: *const btVector3,
        wheelAxleCS: *const btVector3,
        suspensionRestLength: btScalar,
        wheelRadius: btScalar,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        isFrontWheel: bool,
    ) -> *mut btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}?getWheelInfo@btRaycastVehicle@@QEBAAEBUbtWheelInfo@@H@Z"]
    pub fn btRaycastVehicle_getWheelInfo(
        this: *const btRaycastVehicle,
        index: ::std::os::raw::c_int,
    ) -> *const btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}?getWheelInfo@btRaycastVehicle@@QEAAAEAUbtWheelInfo@@H@Z"]
    pub fn btRaycastVehicle_getWheelInfo1(
        this: *mut btRaycastVehicle,
        index: ::std::os::raw::c_int,
    ) -> *mut btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}?updateWheelTransformsWS@btRaycastVehicle@@QEAAXAEAUbtWheelInfo@@_N@Z"]
    pub fn btRaycastVehicle_updateWheelTransformsWS(
        this: *mut btRaycastVehicle,
        wheel: *mut btWheelInfo,
        interpolatedTransform: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?setBrake@btRaycastVehicle@@QEAAXNH@Z"]
    pub fn btRaycastVehicle_setBrake(
        this: *mut btRaycastVehicle,
        brake: btScalar,
        wheelIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateSuspension@btRaycastVehicle@@QEAAXN@Z"]
    pub fn btRaycastVehicle_updateSuspension(this: *mut btRaycastVehicle, deltaTime: btScalar);
}
extern "C" {
    #[link_name = "\u{1}??0btRaycastVehicle@@QEAA@AEBVbtVehicleTuning@0@PEAVbtRigidBody@@PEAUbtVehicleRaycaster@@@Z"]
    pub fn btRaycastVehicle_btRaycastVehicle(
        this: *mut btRaycastVehicle,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        chassis: *mut btRigidBody,
        raycaster: *mut btVehicleRaycaster,
    );
}
impl btRaycastVehicle {
    #[inline]
    pub unsafe fn getChassisWorldTransform(&self) -> *const btTransform {
        btRaycastVehicle_getChassisWorldTransform(self)
    }
    #[inline]
    pub unsafe fn rayCast(&mut self, wheel: *mut btWheelInfo) -> btScalar {
        btRaycastVehicle_rayCast(self, wheel)
    }
    #[inline]
    pub unsafe fn resetSuspension(&mut self) {
        btRaycastVehicle_resetSuspension(self)
    }
    #[inline]
    pub unsafe fn getSteeringValue(&self, wheel: ::std::os::raw::c_int) -> btScalar {
        btRaycastVehicle_getSteeringValue(self, wheel)
    }
    #[inline]
    pub unsafe fn setSteeringValue(&mut self, steering: btScalar, wheel: ::std::os::raw::c_int) {
        btRaycastVehicle_setSteeringValue(self, steering, wheel)
    }
    #[inline]
    pub unsafe fn applyEngineForce(&mut self, force: btScalar, wheel: ::std::os::raw::c_int) {
        btRaycastVehicle_applyEngineForce(self, force, wheel)
    }
    #[inline]
    pub unsafe fn getWheelTransformWS(
        &self,
        wheelIndex: ::std::os::raw::c_int,
    ) -> *const btTransform {
        btRaycastVehicle_getWheelTransformWS(self, wheelIndex)
    }
    #[inline]
    pub unsafe fn updateWheelTransform(
        &mut self,
        wheelIndex: ::std::os::raw::c_int,
        interpolatedTransform: bool,
    ) {
        btRaycastVehicle_updateWheelTransform(self, wheelIndex, interpolatedTransform)
    }
    #[inline]
    pub unsafe fn addWheel(
        &mut self,
        connectionPointCS0: *const btVector3,
        wheelDirectionCS0: *const btVector3,
        wheelAxleCS: *const btVector3,
        suspensionRestLength: btScalar,
        wheelRadius: btScalar,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        isFrontWheel: bool,
    ) -> *mut btWheelInfo {
        btRaycastVehicle_addWheel(
            self,
            connectionPointCS0,
            wheelDirectionCS0,
            wheelAxleCS,
            suspensionRestLength,
            wheelRadius,
            tuning,
            isFrontWheel,
        )
    }
    #[inline]
    pub unsafe fn getWheelInfo(&self, index: ::std::os::raw::c_int) -> *const btWheelInfo {
        btRaycastVehicle_getWheelInfo(self, index)
    }
    #[inline]
    pub unsafe fn getWheelInfo1(&mut self, index: ::std::os::raw::c_int) -> *mut btWheelInfo {
        btRaycastVehicle_getWheelInfo1(self, index)
    }
    #[inline]
    pub unsafe fn updateWheelTransformsWS(
        &mut self,
        wheel: *mut btWheelInfo,
        interpolatedTransform: bool,
    ) {
        btRaycastVehicle_updateWheelTransformsWS(self, wheel, interpolatedTransform)
    }
    #[inline]
    pub unsafe fn setBrake(&mut self, brake: btScalar, wheelIndex: ::std::os::raw::c_int) {
        btRaycastVehicle_setBrake(self, brake, wheelIndex)
    }
    #[inline]
    pub unsafe fn updateSuspension(&mut self, deltaTime: btScalar) {
        btRaycastVehicle_updateSuspension(self, deltaTime)
    }
    #[inline]
    pub unsafe fn new(
        tuning: *const btRaycastVehicle_btVehicleTuning,
        chassis: *mut btRigidBody,
        raycaster: *mut btVehicleRaycaster,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRaycastVehicle_btRaycastVehicle(&mut __bindgen_tmp, tuning, chassis, raycaster);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DbtRaycastVehicle@@QEAAXXZ"]
    pub fn btRaycastVehicle_btRaycastVehicle_destructor(this: *mut btRaycastVehicle);
}
extern "C" {
    /// btActionInterface interface
    #[link_name = "\u{1}?debugDraw@btRaycastVehicle@@UEAAXPEAVbtIDebugDraw@@@Z"]
    pub fn btRaycastVehicle_debugDraw(
        this: *mut ::std::os::raw::c_void,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}?updateVehicle@btRaycastVehicle@@UEAAXN@Z"]
    pub fn btRaycastVehicle_updateVehicle(this: *mut ::std::os::raw::c_void, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}?updateFriction@btRaycastVehicle@@UEAAXN@Z"]
    pub fn btRaycastVehicle_updateFriction(this: *mut ::std::os::raw::c_void, timeStep: btScalar);
}
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultVehicleRaycaster {
    pub _base: btVehicleRaycaster,
    pub m_dynamicsWorld: *mut btDynamicsWorld,
}
extern "C" {
    #[link_name = "\u{1}?castRay@btDefaultVehicleRaycaster@@UEAAPEAXAEBVbtVector3@@0AEAUbtVehicleRaycasterResult@btVehicleRaycaster@@@Z"]
    pub fn btDefaultVehicleRaycaster_castRay(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        result: *mut btVehicleRaycaster_btVehicleRaycasterResult,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyDoubleData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSdfCollisionShapeInternalData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btClockData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHullTriangle {
    pub _address: u8,
}
